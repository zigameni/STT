 da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je dobro, da je do na jednostava način, nego smo prvo reklji, ja došao, e onda i cada tražimo maksimu, druga stvar je stavili smo one operator, ono, ono funkciju, ni operator, miš mošte napraviti kao operator u nekom višim programom s kom jeziku, ali nećemo da preklapam operator, i to ćemo realizovati kao funkciju, ako nekada na ispitu dobijete da napišete bkr i algorita, a treba da napišete i taj operator za poradži, ono smo tu funkciju za poradži, nemojte da ostavite samo ono što imate na predkonom slajdu, to nije dovojno, jer ne postoji standardna operacija poradženja dve dvojke, to ne postoji, morate da kažete kako se onda to poradi, morate sa strane da napišete kada ćete, tu imati vrednost tru, kada ćete imati vrednost false, što smo reklji, postavimo da ja želim da uđem, a onda ovdje mi provjerim koliko ko ima vrednost i uzem maksimalnu koju sam ubećao za jedan, nakon toga idem i poradim se sa svim svojim susedima, ako je došao neki sused ne želi da uđi u kritičnu sekciju, super, smem da ga preskočim, ako želi da uđi u kritičnu sekciju, ja mogu da preskočim tog suseda, ako je sused došao posle mene, ili ako je došao isto vremeno kad ja, ali ja imam manji index, u ostalim snučajima ja moram da čekam tog suseda i tako dok ne preskočim sve susede koji ima, traženje maksimum je ovde bilo aproksimativno razlog zašto se desila proksimacija, pa možda smo isto vremeno si krenuli ovde da čačkamo i da pokušvamo da izračunavamo tu našu urednost, ali ovde algoritm kaže nema problema, ako su neki proces i krenuli to da radi isto vremeno, pustit ćemo ono koji ima manji index, nikakav problem, zbog toga ovo ovde nije baš strogo tiketa algoritm, ali dovojno liči na njeka, kažem, ovo smo morali da, miši morali, tako su smislili ovaj algoritm, znači postoji drugi algoritm, imate čitavu knjigu sa synchronizacijonim algoritmima koji ne koriste uslogi operativnog sistema, mi smo ovde za sada prošli nekoliko tih algoritama koji treba da nam omoguće ovakvu synchronizaciju. Ove aproksimativni algoritmi daju dosta često dobre rezultate, oni zahtevaju podatke iz predskodne iteracije i nakon n iteracije on je obično dolaze do neku sledećeg stanja koja nešto malo bolj običnu su, takvi ovaj ovde algoritm je jedan takav algoritm. Ovim smo videli da može da se napravi nešto što dovojno liči na tiki algoritm, a da nemo ni jednu specijalnu istrukciju. Ono što sada hoćemo da vidimo je jedan algoritm koji treba da smanji ono buđinje koji tiki algoritma, uvećali našu promenjivo nekst i rekli smo koga godovo da zanima nekvirne sada u promenjivo nekst i nekvidi dok le smo došli, da vidi taj neko il može da nastavi dalje sa svojim radom ili ne može da nastavi dalje sa svojim radom. Morali smo sve da probudimo. To je malo naporno, jer zahteva dosta tog reživskog vremena, a samo jedan će moći da nastavi dalje sa svojim izvršavanjem. I onda su ljudi rekli, hajde da promo da naparimo neki malo drugačij algoritm. Taj malo drugačij algoritm je Andersenova algoritm koji ću mi ovde razmatrati. Opet ovaj ovde algoritm koristi jedan na niz. Samo što će u tom nizu biti ne jedna promenjiva na kojoj neko čeka, nego će biti više promenjivih na kojima neko čeka. Koliko ima ovih elementa niza, onoliku, koliko ima različnih proces. Ali neće svaki proces čekati na svojoj promenjivi, da tako kažem, nego će svaki proces čekati na narednoj promenjivi. Ovde će uvijeti na početku vrednostru i šta radi proces? Oddođe ovde, kaže, ja ću čekati na ovaj ovde promenjivi, dok neko baš beni ne javi možeš danje, a ja ću onda uposlaviti da se čeka, da neko drugi treba da čeka na ovaj promenjivi. I kad dođe sveći, sveći će čekati na ovaj narednoj promenjivi, sveći će čekati na ovaj ovde narednoj promenjivi. Znači, mi želimo sada, ono što smo imali, ono periodičnost, ono što smo imali kod sticket algoritma, da pustimo sledećek. Ali tamo smo uvećavali jednu promenjivu samo. Ovde ne želimo jednu promenjivu da uvećavamo, nego želimo da imamo čitav nijestih promenjivih i jedan će čekati na ovaj promenjivi, naredni će čekati na naredne promenjivi, naredni će čekati na naredne promenjivi i kako se onda to realizuje. Ja dođem i pitam, gde ja treba da čekam i dobijem, neko mi kaže, ti čekasš o ovde, a onda ćemo opet i skoristimo specialnu instrukciju. Ovde su ona druga grana, gde želimo i dalje da zadržimo specialnu instrukcije, ali ne želimo da si čekaju na istoj promenjivi, jer je to zamorno. Svaki put kad se desi promena, te promenje svi moraju da provjere jako samo jedan može dalje. Ovde želimo da kada se desi promena, neke promenjive, samo jedan može da nastavi dalje. Ok, aajno ponovno, što sam odradio? Ja čekam na ovaj ovde promenjivi kad dobijem po toj promenjivi mogućem zda radim i ja krenem da radim. Kada završim, ja ću dođem i narednu promenjivu da uvećem i da kažem, Kada sam naredni, smeš da krenes da radiš. Ovo ovde, ha, znači moram da jem negde tru i false. Znači, ja kada dobijem ovde vrednost tru, ajde ovde za sada, ne znam šta se nalazi, ja ću da radi. Kad završi s poslom, ja ću na tu promenju da postajem false, a onom prvom narednom ću reći, e, ti možeš da radiš. Odemo i narednom kažemo, ti možeš da radiš. Naredni, odem radi, mi smo završili naš posao, kad završi on kaže false, ja više ne radim, a prvom narednom dajem, sada ti možeš da krenes da radiš. Ovo je radi, radi, kad završi, si imam se, kaže tru, on kaže, ja završio s poslom, ok, šta taj radi, taj ovom narednom treba da postavi tru, a sebi treba kaže da postavi vrednost false. Znači, ovde trenutno nikon ne čeka, ima veze, što nikon ne čeka. Kad neku dođe, on će reći, ja ću sada čekam na ovoj promenji, ali ću ja morati, on je broj, da pomerim za jedno mesto u napredku, ni kaže, gdje ja to treba da čekam, na kojoj lokacija to treba da čekam, ja ću vidjeti dobiti vrednost tru i odmah mogu da nastajim dalje, kad završim posao, ja ću staviti koji cvd false, a na prvo narednom mesto, ja ću staviti tru. Ovo ovde je jedan niz, a ovo ovde rešenje se zastniva na korišćenju jedne nizovske promenjive. Ja uzmem vrednost, čekam na svom elementu niza, kad završim, ja pustim prvog narednog. Ovo je algoritm, je veoma koristan algoritm i dosta često ćemo ga primenjivati, na primjer kocemafora, ili kojdu monitora. A kojdu ovdje rešenja šta mi radimo u suštini kocemafora? Imamo niz semafora na kojima neko može da čeka, ako želimo da dobijemo FIFA algoritm, a semafori nisu pošteni, šta mi je odradimo? A mi uznamo, na kome semaforo ja treba da čekam, samo vrlo kratko operaciju, to je inkrementiranja, te promenjive napravim, i onda kažem, ja čekam na datom semaforu, na prvom semaforu čekam, a kad dobijem dozvolu, ja sam bio jedan jedini koji čekam. Znači koliko god da je nepošteno neki semafor, ili monitor, ako postoji jedan jedini koji je zablokirano, on će raditi po FIFA principu. Znači koliko god da je nepošteno, ako postoji samo jedan, ta jedan je next. Nemak o drugi koj može doći kao sledeći. I ajde se vratimo sada na naš algoritm, da vidimo ovo ode sada što sam ispričao, kako može formalno da se zapiše. My Slot je na komesto ja trebam da čekam, to je moja lokalna promenjiva, je ova globalna promenjiva Slot po modulo n plus 1 i uveći Slot za 1. U suštini ovde pročitam Slot i uvećem za 1. Mogu da iskoristim isto ono istrukciju koju sam imao kod tiki talogoritma, to je ona i fetch.net. Dodaj mi jedan, daj mi star uvrednost, a ja ću za ovo ovde moje Slot da izračunam da je to po modulo n. To je sada meni već sasim svedno, zato što sigram sa lokalnim promenjima. Kad sigram s lokalnim promenjima, nema synchronizacije. Vradim sve sledeći.