 Način i predstavljena među koda u compilerina. U nekom vrlo jednostavnom compileru bilo bi zamislila da se iz semantičkih akcija ugrađenih u parser neposredno generiše kod. Međutim, realni compiler i to nikada ne rade nego koriste jedan ili više oblika među koda engleski intermediate representation u transformaciji u laznog programu u finalnih mašinski kod. Postoje više prednosti da se u koristi među kod u odnosu na variantu da se direktno generiše mašinski kod. Prednji kraj kompajlera, to je sintaksno-semantičke analizatori generatori među koda su mašinski, nezavisni compiler se lako pilagodžava novima šini izmenom zadnje kraja kompajlera generatora mašinskog koda iz među koda. Ako prednji kraj vi kompajlera zarazite jezike generišu isti među kod moguće za cilnu mašinu napraviti samo jedan generator koda za sve jezike. Optimizacije moguće sproboditi na među kodu čime se pravi mašinski nezavistan optimizator. U ovom lekciju se gleda ćemo nekoliko načina predstavljena među koda. Lekcija je uglavnom zasnovana na Dragonbook Aho Set u ULMAN knjizi i govorit ćemo na konceptualnom nivou i zostavit ćemo razne implementacijone detađe. Neki od načina su sintaksno-stablo ili aciklički graf. Vide ćemo dava graf može da se koristi da se identifikuju i eliminišu ponavljanja usled zajedničkih podizvraza, zatim postfiksna notacija, troadresni kod, graf toka kontrole na nivou bazičnih glokova i tz. statička forma jedinstvene dodela, odnosno statič singla Simon form, skraćeno SSI form. Što se tiče predstavljena među koda putem sintaksno-kstabla odnosno acikličko grafa, možemo odmah sagledati na primeru slika govori kao hiljadu reći, znači ode je namerno izabran jedan iskaz dodele, gde se promenjivoj a dodeljuje ovaj izraz koji opet namerno izabrano ima dva identična podizvraza b puta minus c koji se sabilaju. Ako predstavimo izraz sintaksnim stablom, u listovima stablabiće imena promenjivi, a u unutrašnji čvorovima stablabiće operatori. Operatori su način operaciju izrazu, takođe i dodela promenjivoj a je operator koji upravu korenu stabl. Isti izraz ako predstavimo grafom, u stablu vidimo da svaki čvore ima više jednog roditelja, odnosno praksno svaki ima tačno jednog akorenu nema roditelja, dok u acikličkom grafu, čvor stabla potencimala može da ima više od jednog roditelja, ovde vidimo da je uočena činjenica da se pod izraz b puta minus c ponavlja i onda ovaj čvor koji predstavlja taj pod izraz, čvor množenja je iskorišćen i kao levi, sin i kao desni sin ovoga čora koji reprezentuje sabiranje, tako da to kasnije om učava videte ćemo ugenerisanju koda da se samo jednom računa izrazu i onda da se taj pod izraz u potrebi tamo gde go treba u konkretnom slučaju dva put. Ako želimo da sagledamo kako možemo semanitićim akcijama izgenerisati stablo, odnosno graf ovdje je dati jedan jednostavan primer, graf gramatike koja sa nekoliko smena opisuje jedan ovakav izka z dodele i neke izraze, znači prva smena opisuje da je i d tačka jedna koja znači terminali koji opisuju operator dodele e opisuje izraze i onda imamo nekoliko smena za izraze, opošto je gramatika konceptu, ovdje vidimo da je osmislena, znači mora bi se dalje razrađivati naravno za konkroto pasiranja, opošto ovo samo koncept znači izraze i su e plus e, e puta e minus e i e u zagrati, dovoljno da ovoj naš primer reprezentuje i semanitića akcija vidimo da su, imamo dve vrste semanitićih akcija make node i make leaf, akcija make leaf ima tri argumenta, xypsalon set konstruiše čvor listi syntaxnog stabla, pri čemu nasljednja tribut x o značava tip čora a nasljednja tribut y nime promenjive koja je predstavlja na tim čorom ili pointer u tabeli simbola gde se nalazi ta promenja o sintetizovanja tribut c je pokazivačna konstruišanja čvor, znači on je u suštini izlaskat semanitića analiza aktiviratu akciju, znači stvara se čvor i dobija se pokazivačna novo konstruišanja čvor, dosta slična akcija make node za unutrašnja čvorove, ona ima 4 argumenta abcd, konstruiše unutrašnja čvor syntaxnog stabla, nasljednji tribut a o značava koja je operacija reča, a nasljednje tribut i bc su pokazivači na čvorove naslednike, sintetizovanja tribut e pokazivačna konstruišanja čvor, znači kredo staba se konstruiše od na kavrho, tako da onda već imamo naslednike ovoga čora. Esad u samoj gramatici, znači svaki neterminal što se tiče neterminala e koji predstavlja izraz ili delove izraza, ima jedan sintetizovanja tribut koji predstavlja pokazivačna deo sintetizovog stabla koji govori izrazu e, a neterminal s ima sintetizovanja tribut koji predstavlja pokazivačna kompletno syntaxnog stabla, terminal id koji predstavlja ime promenjive, znači ima tribut koji u stvari to ime ili pokazivačna tebolu simbolja gde se nalazi ta promenjiva. Gramatika, da se vratimo na nju, može da se koristi za konstrukciju stabla i za konstrukciju grafa, u čemu je jedina razlika, ako želim da konstruišamo acikrički graf, onda kada god pozovemo akciju make node, potrebno je da se u okviru tog poziva ispitaju parametriz koji imamo, pozvali ato sovi nasleđeni atributi ABC, i da se oni keširaju za već napravljene čvorove, ja sad ako imamo novi poziv i utvrdimo da smo već napravili čvorsa potpuno istim ulaznim parametrim ABC, onda ne treba da pravimo novi čvor, nego treba da vratimo pokazivač za već napravljeni čvor i onda ćemo u stvari dobiti o ustrukturu acikričko graf. Što se tiče konkretne implementacije, naslu struktura podataka za reprezentaciju syntaxak stabla odnosno grafa, ovo ili može biti dinamička, gde naravno dinamička alociramo zapise i koristimo, znači pokazivače memorijske, tako da realizujemo negrane stabla odnosno grafa, u obi čeina al tako struktura za reprezentaciju stabala ili alternativno može se, ako želim da izmegno u dinamičku alokaciju iz nekih razloga to je u danasnje vreme relativno retko, ali mohuće alocirati vektor u memoriji i onda da zapis su pojedini elementi tog vektora, znači kad god nam treba novi zapis, pamptimo index dok le smo iskolistili i novi zapis uvećavamo, znači index iskorišćenih i vraćamo taj poslednji, da kažem index i naravno u mestopokazivača onda bi grane grafa bila reprezentovanje indexima, da se nalaze, znači odgovarajući zapisi, sinova je stabla odnosno grafa, naravno pošto da ima dve vrste zapise, da ima dve komponente, to je listo, drugima, tri komponente to je unutrešnji čvor, mi prosto možemo, svaki ima tri komponente pa list, kod listovanje koristimo u jednu komponentu. Predstavljenje među kod naputnjem postfiksna notacija, opet na primeru ovog istog izraza, postfiksna notacija je, evo ovde data u ovoj drugoj lini, znači u postfiksnoj notaciji uvek prvo idu operandi pa onda ide aritmetička operacija, u genal postfiksna notacija pogodnene za izvršavanje na stek masini, kako se ovakav jedan izrad izvršava, pa tako što, znači prosto ga procesiramo sleva na desno svaki put, kada naidže operand, znači, znači, uvek prvo menjiva, radimo puš na neka varitmetički stek, znači, ovaj tri biš na stek, je sada ako naidze operator operacija, ako je unarni operator, znači, skidamo svrha steka jedan element, uradimo operaciju i rezultat operacije ponovostavimo na stek, ponovog kada ođe sledeći, recimo, ovaj binarni operator moženje, oskinuliby smo dva operanda sa steka izvršili operaciju i stavili rezultat na stek i tako, znači se vrlo lako procesira ceo izraza i to je u slišti niosno vrada stek masine, naravno, ovaj koncept postfiksne notaci je vrlo razraditi jer mikrojava virtualna masina koji mi koristimo u kursu i u projektu, kao i prava java virtualna masina je u stvari vrsta stek masine upravo radi na ovom konceptu. Ako želim da sagledamo kako semantiškim akcijamo u gramatici dobiti postfiksnu notaciju, to je vrlo lako, akcije, znači opet imamo sličnu gramatiku kao malo často smo razmatrali koja opisuje ove iskaze, dodale i izraze kao primer i dovoljno je u ovim smenama koje predstavljio izraze staviti akcije koje reprezentuje u operatora na sam kraj smene, jer onda će se prvo emitovat i operandi pa onda tek operacija i naravno ovde imamo ID, reprezentuje razno operanda, ovde su sam uvedene ovve ABC koliko se pojavlja u primeru i isto se tu emituju, čim se iskoristi neki operand odmah se emituje odgovarajuća akcija koja ga reprezentuje na izlasu. Naravno, ako imamo syntax na stavla, želim da konertom u postfiksnu notaciju, onda treba prosto obići to stavlo u post-order obilasku. Znači prvo se uvek onda obradelevi desti naslij čora pa onda na kraju sam čora. Sledaći način predstavima među koda je putem troadresno koda. To je jedan oblik koda koji do nekle poseća na, ajde da kažemo, mašinski kod i to za neku troadresno mašinu, ali abstrahovanju u smislu da ne mora da se vodi računa o konkretnim lokacijama promenjivim i konkretnim nadčinima adresiranja koji inače postoje u realnim proceselima. Ovdje je nabraja oblici i vrste iskaza koja tipično postoje u jednom troadresnom kodu. Osobno je izkazi ovaj oblik X, i adnako Y opc, gde se znači vrši nekabinarna operacija nad operandima Y-ceta rezultati da je u X. Aron ako pitanju u unarno operacije, onda je jedan od operana da je izostavljena, a to može biti u unara negacija, logička negacija, razna šiftovanja, pomeranja i razne konverzije.
 Zatim, narebe kopiranja, znači, direkno x jednako y, znači, renaz tipsilno se dodeljuje x, bez uslovni skok, go to l, može se na nivou tro adresno koda znači, lokacije skoka simbolički reprezentovati ovim oznakama, la belama, pa će kasnije generator koda naravno dodeliti konkretnu lokaciju, znači simboličkoj oznaci. Zatim, uslovni skok ovih i if x relacijon operator y go to l, relacijon operatori su oni u običajani razni jednakosti, nejednakosti i tako dalje, i skok se znači izvršava ako je određena relacija nad operantima zadovoljeno, ako ne, izvršavanje se nastavlja sekvencija. Zatim, sledači oblik na aradbe među koda ova tačka 6 odnosi se na pozive funcija, imamo tri vrste na aradbe koje reprezentuju poziv, prvo priprema parametara, tipično kad se neki poziv vrši procedure p koja ima nekih n parametara, imali bi smo n pripremnih naredbi gde param x1, znači jo se priprema x1 kao vrednost, prvog stvarnog parametra param x2, znači drugog stvarnog parametra, tako dalje param xn, zatim ide znači sama naredba, dosto slično kao u mašinskom jaziku, znači naredba poziva procedure p, pričam u dodatni argument nam govori koliko parametra ima da ne bih od nekih ugnežda ni poziv, znači bi bilo jedno značno da se može odrediti kolikovi param naredbi odgovara kojoj je ovoj naredbi poziva, znači ovo je nije broj parametara i konačno u telu poziva na kraju prosto treba da postoji naredba return koja ili može da ima znači vrednost y na koja je to funcija, koja je vraća neku vrednost ili samo return na koja je u pitanju procedura koja ne vraća vrednost, zatim tačka 7, indexne varijante dodela znači i k se je jednako y na d ili x od d je jednako y, praktično to znači da se izvrši nekakva adresna aritmetika da je početna lokacija y i da se onda sabere adrese y sa i i dobije se znači u riska lokacija odakle se vrši čitanje vrednosti koja se dodeljao je x, obrnuta naredba je znači da se vrednost y pisuje na lokaciju x plus i adres, zatim imamo varijante naredbi koja odgovaraju operaciji s pokazivačima, znači vrednost ili samo kao u ceu, u x je jednako adresa od y, u znači da x je jednako y dereferencirano i dereferencirano x je jednako y, znači ova prva naredba znači da imamo neku vrednost y, da uzimamo njenu adresu i da tu adresu pisujemo u x, znači x je neki pointer na neku vrednost, znači to je isto ceoska terminologia, postoje tako zvane l vrednosti i r vrednosti, treba da nas asocira r i l na poziciji u naredbi dodale, znači l vrednost je ono što se pojavljuje z leve strane naredbe dodala, znači nama treba atresa da bih smo mogli nekde upisati ili tako odredišno vrednost, a r vrednost je ono što se pojavljuje z desne strane naredbe dodala, znači dovoljna nam je vrednost, ovo drugo je isto kao u ceosnači ako y suštini neka adresa, pokazivača neku lokaciji, onda zvedice y nju stvari da preko adrese y pročitamo sadreže lokacije i upisemo u x, i konačno ova treća varijanta ako x neki pokazivač i želim na to mesto gde pokazuje x da upisemo neku vrednost y, i to su soliko osnovnih varijanti tih troadresnih naredbi može da se pokrije jedan osnovni troadresni među kod. Ako sad bismo za ona i isti izraz koji imao, nači a jednako b puta minus c plus b puta minus c, sećemo sa drane da smo dopijali ovako syntax na stabilovno acikrički graf, možemo na bazi tih da kažem predstava, znači stabilovno grafa da dobijemo troadresni među kod, u svojoj osnovi bismo numerisali čvorove stabla, tako što krenemo od korena pa numerišemo redom, čvor či su uvek biramo kao sledeći broj čvor, či su svi roditelji već numerisani, i onda kad dobijemo određenu sekvencu brojeva idemo suprotno što znači da ćemo u sluštini naredbe generišemo od listova stablaka korenu. Tako da ako na taj način postupimo i pri tome čvorovima dodelimo ove temporari promenjive t i, nači recimo vrednost ovog dela izraza kaze u potrebi unarni minus nad c, ćemo upisati u t i 1, nači preg čovom čvoru to poved može to i da se napiše t i 1, smo dodelili privranu promenju u t i 1, zatim ovom ovde dvore čvoru smo dodelili privranu promenju u t i 2, i sad kad krenemo od listova korenu u zupotrebu privranu promenju i koji reprezentuju vrednosti u pojedinim čvorovima stablama. Za ovo stablo dobijemo ovakav, trodresni medju kod, a za ovaj acikrički graf dobijemo još jednostavni, kao što vidimo medju kod samanje, naredbi zato što je prosto iskorišnjena činjenica da se ovo i izraz koji je jednom izračunat b puta minus c, to je ovo t2, ovdaj vidimo u t5 t2 plus t2, znači ne računamo ga zaista dva puta kao ovde, nego ga iskoristimo, znači već izračunati medju rezultat. Trodresni medju kod može vlako da se izgeneriša koje potrebno, direktno semanitikima akcijama izgramatike, tako što se prosto ubaci generisanje, znači trodresnih naredbi u svakoj smeni, znači ove i gore smeni je generisanje ove direktne dodale u ovim smenama, gde su izrazi je generisanje, odgovarići trodresnih naredbi sa binanim operacijama, u četvrtu i smeni je generisanje trodresne naredbe sa unarnom operacijom, parmetri naredbe su naravno operacija, operandi i dodala. I možemo da vidimo, pošto smo se dosadu glavnom, kao primer navodili isključivo izraze, ovdje možemo da vidimo i na primeru jedne naredbe kontrole toka, nači konkretno vile, petlje kako generisati trodresnih kod za njuhova, šemacka slika prikazuje usuštini šta želimo da postignamo pri generisanju koda, na početku petlje generisamo simboličku labelu s.bigin koja služi da se vratimo u sredneće iteracije na računanja koda za uslovni izrad z petlje, koji ispituje uslov ostanka u petlje i to je e-code. Ako gledamo gramatiku imamo jednu smenu, s je menja sa vile, e reprezentuje i u suštini iz njega se generisat izrad za prover uslov ostanka u petlje, pa onda s predstavlja kod koji je telo petlje, obradom procesiranjem s je generisati telo petlje i to je kompletna gramaticka smena, a znači njenim procesiranjem prvo što treba, znači prva akcija namerno ubačena ispred ovoga e da izgeneriša ovu labelu, znači ovada akcija genl se odnosi na to da se u među kodu izgeneriša s.bigin labela, znači obradom e to ne treba, znači semantičke obradivati u ovj smeni nego kako se bude prepoznavala svene znači generisaće se ovaj e.kod, znači trol adresni kod za računanje izraza, znači gen pet akcija generisat ovaj uslovni if u među kodu, znači koji treba da ispita rezultat izraza e to je ovo e.place, dalje je jednak nuli i ako ovo jeste treba da izveši skok, izlaz izvan petlje, znači ta izlaz izvan petlje će biti reprezentovan nekom s after labelom, zatim kad se bude procesirala ovaj neterminal s, on biće izgenerisano telo petlje i zatim kada prođe to generisanja tela petljeva gen 4, akcija služite izgeneriše u trol adresnom kodu bez uslovan skok na sledeći traciju odnosno na u sbgin labelu da bi se raču na ovaj tako uslov, ostanko u petlji za sledeći traciju i konačno ima još jedna gen l, akcija koja generisat u stvari mes to odnosno poziciju ove s after labele koji smo iskoristili ovom uslovnom skoku, tako da znači sa u kupno 4 semantičke akcije mogući izgenerisati sve što je potrebno od trol adresnom kodu za obradu oveva l petlje. Kad razmatranostrukture je v podatak za implementaciju i representaciju trol adresni naredbi u programu varijante su tako zvone četvoreke odnosno zapise sa četri polja, gde se o perandi predstavljaju pokazivačeva na tabelu simbola, zatim tako zvone trojke u tim zapisima izostavljanoj polje za rezultat nego praktično koristimo redni proj naredbe kad nam treba ukasnio i nekom zapisu među rezultat vodređene naredbe. Tako zvone indirektne trojke, vide ćemo znači da problem sa trojkama je što nije lako izmeniti redosled u sekvenci naredbe ako želim da dve naredbe zamene mesto, to nije lako obraditi jako kod representant trojkama i zato kod indirektne trojke se koristuje još jedan nivo indirekcije, osa ćemo to sve videti na jednom konkretnom primjeru naš rani primjer među koda koji je trojkada, koji bio dobijeno basionog syntaxnog stabla ima uklupno 5 trojkada naredbi, ako ga representujemo četvorkama, to su zapisi sa 4 komponente prva komponenta je operacija, druga komponenta je prvi argument, naravno uklupitanju u naranopiracije drugi argument nekoristimo i konačno u četvorkama se eksplicitno representuje i rezultat trojkada naredbe Kod trojki, zostavljamo polje rezultata eksplicitiva
 Ovrcitno nego ovoj index odnosno adresa samog zapisa nam u stvari služi i kao oznaka za rezultat, tako da recimo ako druga ova troadresna naredba koristila, tako među rezultati generisano u prvoj troadresnoj naredu i mi ovde znači koristimo adresu prve troadresnoj naredu odnosno odresu 0 kao jedan od operanada. E sad kažem pošto tu nije lako zameniti zašto bi se menja o redosled nekih vršlaneka pretumbacija ovog redosledam troadresnih naredu a to može da bude rezultat optimizacije, optimizator može da zaključi da treba da izmeni redosled da recimo približi korišćenje rezultata njegovom generisanju da bi manje optređivo procesarske registrii, tako dađi, znači postoje potreba nekada se preraspodeliti naredu u sekvenci i onda je pogodna forma ove tako zvane indirektne trojike, znači ova komponenta predstavlja ovu trojiku kao iranije, ali uvodimo još jedan dodatan vektor, ova i vektor određuje redosled naredbi, tako da ovde u ovom konkretnom primjeru vidimo da prva naredba u sekvencije koja ima adresu 14 u ovom drugom vektor ili index, kako uvod volimo to da ovde iše kao neki vektor, posuto indexi, znači ovo je, dokažem, index naredbe kako ona originogenerisana, a ovaj drugi vektor daju stvari redosled tih naredbi kako će ga kasnije recimo generator kod uze tu ovdje. Tako da preraspođi redjivanje naredbi u ovaj varianti traži samo ažuriranja ovog vektora, znači samo bih smo promenili redosled ovde, ovde ne bi ništa morali da menjamo, za razlik od ovoga kad bih ovde promenili, znači, redosled neki naredu i morali bih smo da jurimo povim poljima gde se naredbe korist. Naredbe recimo trojadresno koda u kompajeru se nikad ne razmatreju kao prosta sekvenca, nego se obično pravi ova struktura podataka koja se zove graftoka kontrole na nivu oznovni blokova i evo, sad ćemo definisati tu strukturu podataka, znači prvo, oznovni blok je skup iskaza međukoda koji se izvašavaju sekvenci bez grananja, izvuzem krajnjeg iskaza u bloku koji može biti uznovni ili bez uznovni skok. I u sekvenci, znači, naredbi međukoda ovim algoritmom identifikujemo te osnovne blokove, znači, prvo se odrede vođe, to je prvi iskazi osnovni blokova, to je ili prvi iskaz u programu ili iskaz koji predstavlja odredi što je neko uslovnog ili bez uslovnog skoka, ili iskaz koji neposredno slijedi bez uslovni ili uslovni skok. Esad jedno kada odredimo vođe, ispracelišemo cao ostatak koda, tako što svakom vođe ći pridružimo iskaze koji ga slijede do prvog slijedja dećeg vođe, isključujući naravno tog u sljedećeg vođu ili do kraja programu. Esad jednom kada ispracelišemo sekuvenci na osnovne blokove, nad njima dodatno možemo uspostaviti medjus o relacije, tako što znači, cao program predstavimo u vidu grafa, čvorovi grafa su osnovni blokove koje smo identifikovali, a onda grane uvodimo na sljedeće način, poslijećim pravima od bloka B1, postoji li entisona grana ka bloku B2, ako B2 neposredno slijedi B1 u nekoj izvršniji sekvenci, odnosno ako postoji uslovni ili bez uslovni skoka od poslednji iskaz, kada B1 kagođi B2 ili B2 neposredno slijedi B1 u međukodu, a B1 nema na kraju bez uslovni skoka, način kontrola se ili sekvenci, ali prenosi se jednog bloka na drugi ili nekim eksplicitnim skokom. Evo sve će biti jasnije na primeru, znači ako izvornom kodu vidimo neki konstrukt, da kažem iz više progranskoj jezika, tu vajl petlju i neke dodatne naredbe izračunavanja vrednosti nekoga izraza, koji u više progranskoj jeziku mogu biti kompleksni izrazi, to će na nivu troadresno koda sve da se svede na troadresne naredbe, a ova dual petlja će se svesti na uslovni go-2. I ovo je seklence od 12 troadresnih naredbi koja odgovarat ovom fragmentu koda. Zatim odredimo osnovne blokove, tako što vidimo da je početa programa iskaz i jedanje prvi vođa, a zatim vidimo da u sekvenciju imamo skok na 3, tako da iskas 3 predstavlja isto vođu, i prvi osnovni blokove obuhvata iskaze 1 i 2, do ovog vođa ali petlj nećemo govključiti, a od 3 do 12, pošto je sve seklence unidljšanje, samo naredba 12 je skok, predstavlja imamo uklupno 2 bloka i sada je ovo još bloka, među njima, znači uspostavimo ove grane, vidimo da od naredba 2 k naredba 3 imamo sekvencijno izvršavanje i takođe, značimo ove uspostavlja iskog koji predstavlja ovu povratnu granu za ovaj drugi osnovni blok, i na taj način smo dobili graf toka kontrole na nivou osnovni blokove, to je bitna struktura podataka koji prakčno svaki kompajder koristi i sve obrade koje se rade unutar jednog osnovnog bloka za usel lokalna obrad, recimo lokalna optimizacija ili lokalno generisanje koda gleda isključivo, granice jednog osnovnog bloka, a globalne optimizacije su kada se gleda ceo graf toka kontrole. Sledaći način predstavlja na među kode statička forma jedinstvena dodele odnosno engleski statik single assignment form SSA, u programu koji u SSA formi svakoj dodele i promenjive daje se jedinstveno ime i sve upotrebe te promenjive koje koriste vrednoste dodele se preimenu da reflektuje u dodele ime, znači to je neka neformala definicija, kod sekuencija je vrlo lako izvesti, znači vidimo da ovde imamo dve dodele promenjivo i v, naravno to programmernika tako ne bi pisa u sekuencija, li je moguću dobiti kao rezultatne kogenerisanja, među kode napazi višek programu, znači moramo sva koji dodele i dodele i jedinstveno ime, znači x, y čak i ne moramo da indeksiramo, ali znači v promenjive u v, znači prvu dodele ubeležavamo sa v0, a drugu dodelu znači vršimo to preimenovanje da ne bi smo imali istoj promenjivaj dve dodele, tako da drugo će biti v1 i ovde, naravno, da koristimo vrednost prvu, pišemo v0, ovde gde koristimo drugu vrednost pišemo v1 i sve delu je vrlo jednostavno, međutim, komplikacije nastaju kada imamo grananja u kodu, recimo posmatrem ove relativno jednostavno fragment, da je napazi nekog if, ifa, znači u den delu imamo dodelu xu jednu, u lz delu dodelu xu drugu i onda iz a ifa imamo dodelu xa y. Naravno, koja će tačno vrednost biti dodele na y, dal i 5 ili 3, zavisi od toka izvršavanja programa, znači statički kompajer ne može da kaže, znači šta će biti ovde, znači rekom senarizvršavanja programa može biti dodele na vrednost 5, u drugom senarizvršavanja programa može biti dodele na vrednost 3, tako da, znači lako je preimenovati prvi xu x0, drugi xu x1, ali ovde onda ne možemo reći da li piszemo y jednako x0 ili y jednako x1 i tu dilemu rešavanu tako zvanim phi funkcijalna, znači napišemo da je u stvari uvodimo novu dodelu xu x2 kao rezultat phi funkcije koja ima argumente ovih mogućih vrednosti x, znači x0 x1 i onda u stvari y udodeljujemo vrednost x2. E sad štaova phi funkcija tačno znači, vrednost phi funkcija jednako x0 ako kontrola u poslednji pazični blok ulazi iz den dele ifa, odnosno vrednost phi funkcija jednako x1 ako kontrola ulazi kroz els deo gornje gif. Znači u opštom slučaju vrednost funkcije phi koja ima je n argumentata u osnovnom bloku b sa n blokova prethodnika u grafu, znači kontrole toka i ti prethodnici su p1, p2 do pn redom, znači vrednost ove phi funkcije iznosi vi ako toki zvršavanja prenosi kontrolu programa sa, znači i tog prethodnika na blok b to je ust definicija phi funkcija. Znači phi funkcija ima tačno toliko argovina tako koliko poslatrani blok ima ulazni gran. Evo jedan dodatni primjer sa tim phi funkcija, znači ako u izvornom kodu na višnjeprogramstvog jezdjiku recimo imamo ovakavneki fragant sa vajvopetljom, onda moguće prevesti tu vajvopetlju na nivo među koda, znači to adresno bu među kodu imamo uslušniti na dva mesta ispitivanja ovog ustvara iz vlasku smetavode je malo zamrljano, listo je ovo i od manje od već je do jednako x, pardon, ovo je edit, ono su je malo pomereno onda ovo. Znači prvo je ustvar izpitivanje negacije da lošte treba da uđemo u petlju, znači ako ustvara nije ispunjeno da ćemo odmah iskočiti iz atela petlja, a naravno ako uđemo u petlju na kraju svakih tracija imamo ispitivanje u sluva ostanka u petlji. Ovo nije u ssa formi, ovo jeste u ssa formi, znači da bi bilo u ssa formi moramo praktično preimenovati sve dodela, vidimo da tu postoji ova jotu suštini, više dodela jot tako da imamo jot nula, ova početna, zatim jot jedanje ovo jot u petlji, ovaj blok koji reprezentuje telo petlje u njega možemo stići ili tako što ulazimo da kažem u prvu iteraciju ili što se vraćamo na sledeći iteraciju, znači ima dva predhodnika, tako da nam je tu potrebna jedna fi funcija, koja znači ima, kao što vidimo argumenti ili jot nula, ili ovaj jot dva ispredhodne iteracije i značinjen rezultat fi funcije ćemo beležiti si od jedan, i ta jot jedan se koristio ovom izrezu da bi se izračilo jot dva. Takođe, imamo i kad izrađemo iz petlje, znači ovo je finalni blok ima dva predhodnika, jedan predhodnik je ovaj direktan, znači kad preskačemo izvašavanje petlja, drugi predhodnik je naravno ako ovde prođemo, ako smo ušli u petlju i u sledeći iteracije više nije zadovjeni, tako da nam je tu potrebna jedna fi funcija na baziji znači jot nula i ovoga jot dva koji se generišu petlju, tako da ovo je znači finalna varianta koda sa. Malo formalnije znači kada definicija kad je programu u obliku ssa, znači moraju biti zadovoljene dva uslova, prvo je da svaka promenjiva posleduje tačno jednu dodelu uvrednosti, a drugo da dodela promenjivo i dominira svim u potrebama te promenjive, pojem dominacije se definiše za grafove, znači...
 u grafu tokakontrolnevolj u iskaza ne može se od uraznog čora doći do čora upotrebe promenjive, a da se ne prođe kroz čvor dodele, to je promenjivo i to znači da čvor dodele dominira čvorom upotrebe, znači ne može biti zaobića. Naravno, ostaje malo nejasna semantika te phi funkcije kako generisati kod kako izvršavati u runtime. I sva sreća, phi funkcija nije nešto što je ostaje u runtimeu, nego to je jedna formalizacija koja nama samo služi. Znači tipično mi ssa formu generisamo popotrebi tipično za nek zvršavanja nekih optimizacija prevedemo kod u ssa formu, a zatim pošto izvršimo optimizaciju i dobijemo finalni optimizovan i kod, mi ustvari vraćamo natrag iz ssa formu u ovaj međukod koji nema te phi funkcije i na taj način ih se onda otarasimo. Esat kako se vrši to vraćanje iz ssa formu nazad u običen međukod, pa najiva način, odnosno najednostan je varianta je da, znači phi funkcije sa n argomenatu bloku p treba zameniti sa n običnih dodela po jednom na kraju svakog bloka preethodnika bloku x u grafu. Znači to je vrlo jednostan način kako je li mi nišamo phi funkciju znači sa tih n dodela koje preselimo u te. Znači na kraje bloko, na krajeve blokova preethodnika, međutim ovim se nekada dobije nej efikasan kod sa suvišnim dodelama, ali znači postoje dodatne optimizacije koje mi sada nećemo razmatrati da se vidi koje o ti dodela su stvarno neopodna koje nisu. I jevo jedan završni primer koji je malo kompletni, kako tipičo takav jedan zadatak može da glasi da je zadato na nivou izvono kode ili češće. Recimo kad bi došao zadatak na ispitu najčešće bi već bio zadatu formi o kto adresno među koda. Naravno u tom troadresno među kodu prvo treba identifikovati osnune blokove. Ovde, znači vođa prvi iskac među kode ve je jednako G1. Zatim vođa je takođe ovaj iskac koji ima, koji odredište skoka vidimo da ima označenje lobelom, znači if. I takođe, ovaj iskac koji sledi if, rekli smo, iskac koji nepotretno sledi bez usluhnilu u slunisku ok isto voća. Tako da, ovaj sada imamo sekvenciju iskac za sve do ovoga krajnje. Tako da u suštini imamo tri osnovna bloka, prvi osnovni blokobukvata, prve tri naredve, drugi osnovni blok je sam, if, sam za sebe, i treći osnovni blokobukvata sve ove naredve od ovoga, t4 jednako do ovoga govtu, l1 za ključ. Esat ovde je predstavljeno znači na nivou grafa toka kontrole vidimo da, znači, označeno s vim ovin granama pokrivene s ove variante d, šta, da kažem se kontrola prenosi. I konačno ako još treba da uvedemo ssformu, nakradno, naravno vidimo da je gde god postoje, znači, ulazni, recimo, ifu se koristi v. I pošto ovaj blok b2 ima ulazil tako ili od gore ili iz ovoga govtu, ovo v može biti ili ovo v1 dodela ili ova dodela v3. Znači, ovdje žuriranje v, tako da nam je potrebno ovdje jedna phi funkcija. I, eto, uz uvođenje tf i funkcije i dodeljivanje indexa, da kažem, tim radnim promenivamo, da bi se tačno označilo koja dodela se gde koristi, dobijamo, znači, finalni graf toka na nivu osnovni blok, ovo pričamo u samim blokovima, znači, ssa formom. Ssa forma, znači, je pogodna za neke analize tokapodataka i u suštini, olakšava neke vrste optimizacija koje su zasunan analizi tokapodataka. Mi u ovom kursu ne pričamo o tim optimizacijama, ali ja sam dao koja je slušao testiranje softwarea, tamo sam dao primariadne takve analize, kada se računaju deulanci za onu jednu tehniku testiranja zastovanale na peloj kuti, metodatoka podataka. Ssa forma ima neke svoje mane, znači, što je u suštini ogrnečana skalarne vrednost, ono se ono nije lako tretirati elemente niza pojedinačno i takođe videli smo pri konvertovanju, znači, znači, znači, znači, se sa u običen među kod, znači nije lako dobiti optimalan kod.
