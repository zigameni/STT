 Ok. Odmečno. Dakle, tema današnjih clasa je AS-algoritm i dakle, ovaj je, kao što sam reka, sljedeći algoritm za inkripsiju podata, kako im se balimo. Danas ćemo da pričemo o tome, kako je uopšta došlo do razvoja AS-algoritma, zašto nam je on bio potreban. Pričećemo naravno i o detaljima funkcionisanja, dakle, kako konceptuo almo funkcionis je algoritm, koji su neki detalji zapravo i pričećemo takođe i o implementacijonima aspektima algoritma. I na kraju, kao i prošli put, dakle što smo videli za des algoritm, vidjet ćemo neku pojednostavljenu verziu algoritma, odnosno, SAS algoritm, kako bi smo prosto mogli da prođemo i kroz primere, kroz ovaj algoritm, zato što naravno, kao i kod desa, dakle, radimo nad nekom većim količinom podataka, a tonom nije naravčito korisno, kada koćemo da odrodimo neki zadatak i da se malo bliža upognamo sa algoritm. Takođe, naravno, AS će biti tema sledeće alaboratorijske vežbe, dakle, na zlično način kao što je to bio desa ovaj put. Okej, zašto uopšte nastav o AS-algoritm? Dakle, to je još jedan algoritm, koji radi enkrypsiju nad nekim blokom podataka i on je nastavu da bi prosto zamenio desa algoritm u komercijelnim aplikacijom. Razlog zašto je bilo potrebno da zameni desa algoritm, je u tome što desa algoritm se na kraju, dakle, prosto, nakon određenoj broja godina od kada je napravljen i usposteljen, dakle, pokazaju kao netuliko više siguran algoritm, a zbog čega pa, dakle, osim samog dizajna algoritma, koja je nešto što obezbeđuje, dakle, po uzdanosti sigurnost algoritma. I videli ste prošlet put, dakle, desa po svom dizajnu sodreži određene funkcionalnosti i delove algoritma, kojima obezbeđuju sigurnost i kojiga i čine dobrijim algoritmom. Međutim, vam toga, dakle, ona na ostavu čega procenujemo koliko je neki algoritm siguran, su tako, odživ po datcij nad kojem radi, odospo pre svega knjuča, odospo veličina knjuča koja se koje sti. Zadošto, na kraju, dakle, kuliko god konceptuvalno imali dober algoritm, koji po fazama i segmentima dobro funkcioniše, naravno bitno je obezbediti se od brute force napada, a u koliko prosto imate neki knjuč, koji se prosto sastoji od nekema manje poličine podata, kao odnosno na manju i širini, time se olakšava brute force napada i onda, naravno, tako algoritm nije do. Pošto desa, dakle, u ono efektivnu dužinu ključa je 56 bita, jasno je da taj algoritm već neku vreme praktično nije primendljivu pomercilnim aplikacijama, nije naročito siguran, izbog toga se pojavila potreba da se on zameni nekim sigurnim algoritmom. I to je upravo AS. Ostavni gradivni element i AS-a su dakle blok vodataka, koji je neka 120 osmobitni del same poroke koje se šifruje, odnosno, da je šifruje, i takođe, naravno, ključ, koji može biti u neke tri variante naši rini od 128 bita, 192 ili 256 bita, u zaviznosti je toga koja verzija AS se uziva. Prošli put, kad se pričali, dakle, uopšteno, o blokovskim algoritmama, pominjaliste i faistel strukturu i generalno, dakle, da se algoritmi projektu i dakle, mogu biti u skladbu sa faistel strukturom ili ne. I u tom nekom smislu AS ne koristi faistel strukturu, i jedna od implikacija toga je da prosto ne možemo koristiti identično algoritam, recimo, za šifrovanje i dešifrovanje, i nešto bliža otome, ćemo pričati kasnim. U principu, svaki algoritm ima neke svoje ostavne gradivne elemente, a to je istovremeno i pojedinačna iteracija algoritma, dakle, to je neki iteratimi procesim, svaku iteraciji sa obovljaju neke operacije. I to su ovde, dakle, substitucija, odnosno, zamena, permutacija, zatim, neka matematicka operacija nad konačnim poljem. I na kraju kombinacija sa ključom. I u principu, dakle, substitucija i permutacija, videli ste su neki gradivni elementi, koji doprinose sigurnošću, sigurnosti algoritma. E sad samo AS algoritm je, naravno, na neki način, ali tako prvo se pojavila potreba da on posloje, i onda se pojavila i neki konkurs, na kome je on prosto izabran, odnosno, implementacija konkretna, koja mi danas koristimo je izabrana kao noviji algoritm. I ono što je i bila potreba, je da to bude neki algoritm koji se da radi nad blokom podataka i koji je simetričan algoritm, dakle, koji će konceptuvolno dofuncioniše i da ima istu namenu kao što ima desa algoritm. Da prosto ima neku veću količinu podataka na tvojima radi, što se ogleda u veličini bloka i u veličini ključa. Da je sigurno, naravno, zato što smo želili da zamenimo desa algoritm, ali takođe da radi i brz. E sad, a mi u ovom momentu nećemo previše diskutovati o povašanjima desa algoritmo, ovo pa mi ćemo nešto više pričati na svedajčem času ili na nekom od svežjih časova. Ali ono što bih ja u ovom momentu rekla, je da ono momenta kada je ustanavljeno da desa algoritm više nije siguran, prvi, naravno, korake bio da se des nekako iskoristi, tako da se poveća njegova sigurnosta. I jedna od načina da se to uradi, je da se sama algoritm ponovi dva puta ili veći broj puta. I sad jasno da je prvi fora koji biste napravili, povrnovili algoritm dva puta. Međutim za takav algoritm, postoji jedan specifican napad, okome ćemo pričati i zbog toga on nije praktično primetis. Tako da prva sledeća stvar koja mogla da se uradi, je da su postavi triple desa algoritm, odnosno da se sam algoritm ponovi tri puta, time se postiže sigurnost, međutim ono što je problem je naravno brzina, zato što ovoj algoritm naravno radi spor. E, zbog toga, dakle, pojem da je bila napraviti siguran algoritm, ali tako da bude brži od triple desa. O triple desu ćemo također više pričati i kasnije u togugurse. I naravno, cilje ne napraviti algoritm, koji će sutra ponovobiti zamjenje, nego koji će prosto imati neki životni vek. A opet to se također odljeda pre svega u... ...resursima mašina i onim brute force napadima, o kojima sam pričala, pošto naravno, sa većom moći iz računavanja, koje računare imaju, je otako povećava se naravno i brzina, kojem se mogu brute force-ovati, usmog kapacitetima, otako povećava se i brzina, kojima se mogu brute force-ovati ključe. Što stvlice sami kritarijoma, naravno, sigurnost, efikasnost, ono što smo veći pomenuli, sama implementacija, što softverska, što harberska, također naravno, mogućnosti različitih optimizacija, racimo optimizacija, odnosno, potencija za instruction-level paralelizm, što im je zapravo mogućeno maksimalne iskorišćenje procesora. Također fleksibilno samog algoritma, to znači da kada se napravi neki algoritm, dakle koliko lako se on može unapređevać. Naravno, kasne, ćemo pričati o tome, kako izgleda algoritm šiprovanja, ali ono što je bitno posebno za algoritm, koji ne poštuje faistam strukturu i kod koji ćemo efektivno morati da definišemo i algoritm desiprovanja, je kolike su sličnosti između ta dva algoritma, dakle, dali definišemo u potporosti različite algoritme ili su oni nekako povezani i koliko je kompleksan, jedan, odnosno drugi algoritm. Sigurost, dakle, takođe se posmetra i kroz aspetra zličitih napada, te dakle, osim, brute force napada analiziraju se i potencijalni neki specificni napad i na samo implementaciju i na sam design algoritma. Tako da, to smo sve neke aspeci, koji su naravno posmetrani, odnosno kriterijumi, koji su postojili, prilikom izbora algoritma i dakle usvojena implementacija ASO, na koji ćemo je vidati na danošnjim času. Videli smo već u ubodu da postoji nekoliko varianti ASO algoritma pre svega uzavisnosti od veličine ključa. Te, dakle, kao što vidite, veličina ključa može biti 128, bito 192 ili 256 bita. Osim, u bitima, dakle, ovi podaci, dakle, što blog što ključavi, takođe se izrožavaju i u baitovima i u rečima, gde je reč veličina četiri baite mi ćemo danas često uokšte proleziti kroz termina reč zbog samestrukture bloka, što ćete vidati i kasnije, kad opređemo konkretno na detalj algoritma. A blok je uvek iste veličina, bez obzira na verziju samog algoritma, tako da je on četiri reči, odostno, 128 bita. Broj rundi se razlikuje, koje se rade i to je 10, 12 ili 14 rundi. U svakoj rundi koristiji se neki ključ i teracije, koji je ponovod 128 bita, odostno, četiri reči. E sada, zbog sigurnosti algoritma, svat će put, dakle, u teracijama se koriste različiti ključegi, koji su dobijaju nekako na osnovu polaznog ključa, procesom koji se zove ekspanzija. Videćemo, kasnije, kako ekspanzija točno funkcioniša, ali, dakle, ekspandoveni, odnosno, prošireni ključ je takođe varira po svoj veličini, dakle, on varira od 44 reči, preko 52 do 63 i zapravo njegove veličina zavisi od ukupnog broja i teracije u samom algoritmu, zato što, naravno, dakle, na osnovu tog ekspandovenja, kao što rekok, formiramo ključeve pojedinačne, koje ćemo koristiti u svakoj teraciji. Tako da, jasno što više i teracije imamo, već je nam ekspandoveni ključ i treb. Ok. Dobro, u principu, u svakom trenutku posmatramo neki blok podataka, dakle, ono poruci nekoj koji inicijalno imamo, podelimo tu poruku i u svakom trenutku posmatramo taj blok podataka kao neke četiri grupi od četiti.
 i to nam predstavlja neko stanje, da će sva kao ovo grupa od 4 byte, za nas predstavljati jednu reču i taj neki blog podateka mi ćemo predstavljati po kolonama. Tako da jedna kolona zapravo će nam biti ta jedna celina, odnosno jedna reč. I to ćemo otvore otvore posmatrati baš kao neku matricu. Expandovan i ključ, također na početku imamo neku inicijalni ključ, tako koji istopredstavljamo u formi ovoj matrične, a nakon toga procesom ekspansije prosto proširujemo taj ključ na onoliko matrajca, koliko nam je potrebno u zaviznosti od toga koliko iteracija ima. Mi ćemo dakle danas na času bez umanjenja obštosti pričati u ovaj osnovnoj verzi algoritmu, odnosno 128, zapravo koji je najmanja varianta algoritma da tako kažem, odnosno ima ove ključe 128 bita. I to je prosto zato što sve ove verzi algoritma funkcionišu na potkuno isti način, jedinošnoj, prosto imaju više iteracija, dakle nema potreba da sada pričamo o tome, nego prosto učimo otvorni koncept algoritma pa ćemo se zbog toga vezati za ovu osnovnu variantu. Dobro, dakle kada smo ustanovali, kako posmetramu blok, u odnosno kroz ovo jedno stanje, ili tako elemenete koje posmetramo kao nekom matricu od četiri kolone, gde svakog kolona neka reč od četiri bita. Sada svakog to stanje prolazi kroz neke iteracije, videli smo ima deset iteracija, od kojih dakle devet iteracije su kompletne i obukvata ju neke četiri operacije, dok je poslednja operacija nekompletna i im nojne dosta je jedna operacija. Te četiri operacije smo već pomenuli na početku i to su substitucija, dakle koja se radi na nivog bajtova, zatim šiftovanje, šift row, z.o. permutacija vrednosti u okviru svake vrste stanja, zatim mix-colons operacija koja podrozumeva nekom noženje matrica i aritmetiku u galo-up polju, što ako se svećete pričali smo na prvom času od nas vam pominili da će nam biti potrebna. I poslednja operacija je operacija kombinovanja sa ključom add-round key, dakle operacija koja je jedina, zapravo, kombinove blok podatak sa ključom iteracije. Sada, hajde da vidimo kako izbija da struktura našega algoritma, pa ćemo na toj strukturu joj vjasniti, dakle nakon ugrubo kako funkcioniše sam algorit. Dakle, na početku imamo jedan blok podataka od 128 bita, to je ovo što vidimo na ulazu. I to je nam je neče plain text. Taj plain text o 128 bita prekcevićemo kojoj jednu matricu i to je upravo ono stanje koje smo videli malo pre 4 kolone, u kojoj, dakle svaka kolona se sastoje 4 byte, odnosno predstavlja jednu reč. To stanje prolesi kroz inicijelnu transformaciju i dakle, inicijelna transformacija podrozumeva ovo operaciju edround key i to je dakle prva operacija dodatna, dakle van svake pojedinočne rune za koji smo videli kako izgleda struktura, odnosno tkojih operacija se sastoji, jer je to i jedina operacija koja prosto radi sa samim ključem, malo kastim ćemo ispričati zašta potrebno da ona budete. Tu se zapravo radi o kombinovanju vrednosti bloka podataka i ključa koji je dakle dostavljen u prvoj iteraciji. Nakon toga, ovaj ovo stanje koje prošlo tu inicijelnu transformaciju ulazi u rund. U prvoj rundi imamo definisane one četiri operacije koje smo malo prevideli, to su operacije substitucije, šiftovanje kolona, odnosno permutacija, operacija VxColms i ponoboj al tako kombinovanje sa ključem, z tim da sada, kao što možete videti na ovoj levoj strani, to kombinovanje sa ključem radimo nad drugom verziom ključem. I tako dalje, al tako prolazimo pro sve svedeće faze da bi nakon poslednje faze prosto dobili finalno stanje, što zapravo prekravlja šifrovani tekst. Poslednja faza, kao što vidite i kao što smo malo prerekli, razlakuje se u odnosno na predhodne runde al tako, po tome što nema operaciju VxColms, izbog toga je al tako ima prosto tri operacije definisane u toj rundi. E, kao što malo prereklu, svakove do ovih rundi koristite drugu verzi u ključ. To je jako bitno, zato što to takođe doprinosi sigurnosti algoritma, dakle ne koristite uvek identičan ključ, a to se upravo postižio onom operacijom tih expansioni, al tako odnosno proširivanjem ključa, ono liku puta koliko vam to treba na osnovu početnog zadatog ključa. Tako da zapravo u svakoj operaciji, vi imate i al tako, odnosno svakoj rundi, imate kao input potpuno novi ključ dobijen od predhodnog nekim transformacijama. Dobro, preneko što prezamo na proces deshifrovanja, isto s ove slike, samo bih kratko prokomentari salo. Da preumlasko u prvu rund, imamo ovu kombinovanje sa ključem, ili o tako. Razlog zašto ta operacija stoje tu je jer je to prosto jedina operacija koja, dakle, će iskombinovat i sam ključ sa blokom podataka i ukoliko ja ne bi smo imali na ovo mestu, mi bi smo na početku procesirali sam blok podataka i tako bi nam izlas, odnosno dok ne dođemo zapravo doga operacija koja radi sa ključom u oferu prve rundem, mi bi smo i stučivo manipulisali samim blokom podataka. Na ovim navčinim tima što iskombinovamo ključ, unosimo, dakle, dodatno, odnosno doprinosimo dodatnost i gurnosti samog algoritma, zato što se prve 3 operacije prve runde ne baziraju i stučivo na bloku podataka, već prosto imaju dodatno neku transformacije. Ok, što se tiče algoritmo deshiprovanja, koji je ovdje takođe možemo da vidimo, vidimo datke da pošto ne poštuemo faistal strukturom i zabrvo moramo definisati taj algorit. To znači u glavnom je odako krenemo u nazad i prosto sprovodimo korakje u nazad je odako. Tako do podpornosti kako smo imali operacije, primenjujemo u suprotnom redosledu, vidite da smo imali ship probe, sad imamo inverzno operacije i tako dalje pozicijono odgovaraju. Svaku od ovih pojedinočnog operacija ne možemo primeniti baš tako kako je, već za svaku moramo definisati inverzno operaciju. I tako da, imamo inverzno operaciju, šiftovanje, inverzno operaciju, substitucije, round, ki ćemo dobro isto inverzno, ali to ćemo prokventari se di kasnije, i inverzno operaciju x-caus. I kao što vidite, grupisanje je napravljena, takođe identično kao što je to bila situacija koji je šifrovanja, tako da smo, i ako smo krenali u nazad, dakle nismo obugotili ove poslini operacije na isti način, kao što je to slučaj koji šifrovanja gledano u nazad, tako da smo ponovno izdvojili e-round ki na početek, i onda naravne četiri faze uzeli u prvu rundu i tako do kraja, dakle poslini faze nam ponovno ima tri operacije. Naravno, ključede, primenujemo u obrnutom poretku, pošto je tako proces radimo u nas, znači je šifrovanog teksta dobijemo na kraju plain teksta. Ok, idemo dalje. Kao nam izgleda svaka pojedinačna runda, dakle odnosno šta nam zapravo znače sve ove operacije koje ratim? Imamo neko inicijom o stanjem, i dakle videli smo taj state je tamo nika matric, međutim kad da bi smo ga prektavili ovako, dakle ono što zapravo, vičino operacije kako radimo, mi radimo na nivou pojedinačnim byte-ov, tako da svako polje ovde koje vidite, predstavlja, dakle jedno jedinicu odnosno 1 byte, odnosno jedno polje matrice da tako kaše. I na početku imamo substituciju svako pojedinačnog byte kroz neku matricu, preslikaovanja. Ta matrica je običan sbox, funkcioniše, vrlo slično kao što je to v slučaj kod testa, odnosno princip mu je sličano detaljima koji se malo razlikujemo klasnije. Nakon substitucija imamo operaciju šiftovanja i cilj da operacije shift rows ja da malo izmešla zapravo pojedinačne byte-ove i elemente koje se nalaze tu u matrici. Nakon toga imamo operaciju mix-callonsku, a opet na neki način kombinuje elemente same matrice sa nekim dodatnikom kojeficientima. I poslanja operacija koji primenujemo je operacija kombinovanja s kluča literacije i to je add-round key, odnosno običano operacije xor koje dakle radi ponovno naravno nivou svakog byte, odnosno svaki element dove matrice stanja kombinove sa nekim elementom ključa i dobili smo finalno stanje nakon primene rota. Dobro, sad ćemo praktično vidjeti kako izgleda je u kako izgleda dakle svaka od ovih pojedinočnih operacija. Kad diskutujemo o pojedinočnim operacijama, dakle pričućemo odmoh i kako izgledaju reverznje operacije, zato što naravno za svaku operaciju potrebno nam je da definišemo i kako će izgledati reverznja operacija, prosto zbog toga da bi smo na taj način definisali i algoritm deshidzvanja. Idemo dalje, ovo sam u glavnom već izpričala. Dakle, prva naša faza je substitucija byte. Substitucija naravno funkcioniše kao prosta zamena, gde imamo neki sbox, i to nam je ovde jedna neka matlica presvekavanja, 16x16 byte-o, i ona data se drži permutacije svih mogućih 256 bitnih vrednosti byte-o. Dakle, za bilo koju vrednost koja se može naći, al tako u tojem bloku podataka, prosto je...
 Dakle, neka druga vrednostu koja ona može biti presleka na spok toga imamo permutaciju svih mogućih vrednosti. Hajde da je vidimo na primeru, dakle, kako to izgledam. Dakle, imamo ovak u jedan S-box, to nam je ovo dole desno. I to nam prestavio, dakle, jednu matricu svih mogućih preslekave. E, sada dakle, kao što vidite, to je jedna matrica 16 x 16. Zbog toga, što se dakle za selekciju vrste koristi jedna hexa cipra, tako da imamo 16 mogućih cipara. I za selekciju kolone, tako da imamo 16 kolone. U preseku nalazi se neka vrednost koji ćemo pročitati i koristiti za zanje. U lejavom delu vidimo kako sušnjenski funkcioniše zanjena kroz S-boxa. To je da identifikujemo jedan element naše bloka i odakor. I na osmom u njega odredimo vrstu i kolonu. O tako, u čim preseku ćemo dobiti element koji menjamo i odakor. Odnosno čitamo vrednost koja menjamo ove trenutni podatak iz bloka podataka. Kako identifikujemo xa, kako identifikujemo xa? x uzimamo kao prvu polovinu tog bajta koji čitamo. I sada, na primjeru, je ovo dakle ako čitamo vrednost e a iz ovoga elementa naše matice. Dakle, uzimamo prvu polovinu, to je prva hexa cifra. I to nam je e. Selektujemo vrstu e. Nakon toga uzimamo drugu hexa cifru, to nam je cifra a i time selektujemo kolon. U preseku dobijemo neko vrednost, to je vrednost 8.7 hexadecimovom zapisu. I to je upravo vrednost koja menjamo ove naš plain text ili u bilo koja fazija odakvo izlazi iz predhodnji iteracije. I kao što vidite, 8.7 na određenu odgovareću poziciju ubacujemo u ovo naše stanje, koja će i biti stanje nakon primjene ove fazije. Nakon što smo uzeli i zamene li svaki element ovog našeg stanja, mi smo dobili od ove matice koju vidite levo ako je bilo preoperacije substitucija, vidite ovu matricu koja je desno, dakle stanje nakon substitucija. Svaki naredni element, dakle dobijemo na potpuno identična način. Uzmijemo prvu hexa cifru selektuvanu vrstu, drugu hexa cifru selektuvanu kolonu, uzmijemo presek i zamene. To nam je operacija substitucija. Već, vidite možete također, hajde odmah lepo da prokomentarišimo kako bi smo radili reversno operacijom i to nam je, dakle, operacija substitucije inversna koju koristimo pri lekom desni provođ. Dakle, to je sad kao da imete upravo ov matricu sa desne strane, sa ovim lokom podataka i hoćete sad u dovolg 8.7 da dobijete ovaj tekst koji se nalazi u levoj matrici, koji je postoje o tako preznači ovo ea. Znači, reversni S-box koji biste koristili tako za ovo preslikavanje u nazad, biste dobili tako što biste sad za pravog upreseku vrste 8.7 i kolonu 7. Čiteli ovo vrednosti o tako ea koje vam nje inicijalno bila u ovom levom eltakopolju, koje ste imali da flepre samne substitucije kod šitela. Dakle, na taj način bi se formiralo reversni S-box i prosto sam proces deshifrovanja se radi na potpuno identično način. O tako, znači, ponovu selektojete vrsto selektoj u tako ono i uzmete preslikavanje. M.g. jedin od etle ne biste koristili identično ove S-box, već taj reversni S-box koji zapravo koristimo ko deshifrovanja, a on biti revoluo 8.7 da preslika u ea i svaki narodni element na identična način. Ok. Slednico faza, shift rows. Dakle radi šiftovanje odnosno zapravo zaslužno za permutaciju. Prva faza nam je radila neku zamena. Tako druga faza radi permutaciju. Videli ste prosto prošli put, kad ste diskutovali i ko dvesta, dakle, jako bitno da imamo i jedno i druge gradi vne elementa. Dobre, na koji način funkcioniša shift rows? Pa, on, sada posmatra odnosno uzima iz ove naše matrice stanja svaki red i shiftu je za različit broj pozit. Prvi red oste nepromenjen. Drugi red, ili ako biste brojali od tako od nula, da ovo je 0, 1, 2, 3, drugi red, kružno pomera za 1 byte u levo, pa sledaći red za 2 byte u levo, pa sledaći red za 3 byte u levo. Dakle, svaku vrstu pomera za još po 1 byte u levo. Hajde se da vidimo na primeru, kako to je izgleda i da onda prodiskutojemo zašto baš tako radimo pomeranje. Dakle, našto možete videti gore na ovom veštačkom primeru ko ilustruje algoritm, je da imamo prvu vrstu absolutno nepromenjenu, odnosno 0 vrstu, absolutno nepromenjenu. Zatim, sledaći u vrstu, jer tako ispadne ovoj prvi element i onda ođe skroz pozadi, a ovih su pomere za jednu pozicu u levo, to je zato što shiftovanje radimo kružno, ovako zadržamo sve elementi. Sledaće vrsta pomere na za još jednu pozicu, tako da su nam dva elementa ispala i pomerevo sedesno. I poslednji, naravno, sada pomeremo za 3 pozici. I ako vidite kako to izgleda u našem finalnom stanju na ovom primeru, dakle koji je nakon one substitucije došao, vidite da prve vrste nepromenjena, druga, shiftovanja kružno za jednu pozicu, zatim, sledaće za još jedno i treće za još jedno. Zašto smo baš ovako radila? Ako pogledate malo, kako su izgledali naše reći? Pre ove operacije, recimo prva reća, dakle prva kolona, 8,7, ec, 4a i 8c. Gde se sada naleza elementi te reća? 8,7 ostaje, dakle, u okviru prve reća. Ec je završilo u poslanju reća, četvrti. 4a je završilo u treće reći, a 8c je završilo u drugo reći. Dakle, ono što je cilj ove operacije, to je da pojedinočne baitove iz svake reći raštrka u različite reći, dakle da zapravo ni jedna dva baita, koja su s originalno nalazila, dakle, u istoj reći, ne ostanu u okviru i daptične reće. I na taj način smo maksimalno tako raštrka u li pojedinočne baitove po ove matice. Kako bi ih izgledalo o operacije deshifrovanja, pa prosto inverzno jednostavno ju je rekonstrujiti za dje lako, ako smo ove imali pomeranje u levo, reverzno operacije bi išlo u desnoj ovako. Znači ponovno, nullta vrsta se nek pomera, sledeće vrste se pomero u desno za jednu poziciju, sledeće za dve pozicije i poslednje za tri pozicije i time zapravo rekonstrujšete, dakle od ove matice koji imate kao krajnju, rekonstrujšete ono koje bila prepočetka same operacije. Slednje faza je faza Mix Columns koja radi noženje dve matice, od kojih je jedna matrice upravo ovo naše stanje, a druga matrice predstavlja neku matricu kojeficijet. Jovo noženje matrice zapravo se radi u galo apolju, sa nekom ostavom 2 na 8 korišanjem od gvarićeg nesvodljivog polina. I, dakle, uva je nesvodljiv polina, malo kasnije ćemo se vraditi na njega, hajde da vidimo kako to izgleda na konkretnom primer. Takne, u ovom noženje neke dve matrice od kojih je prva matrice kojeficijet. Primjer za tako jedno matricu možete baš ovde vidjeti. Ovi kojeficijenti nisu nikako nasumično odabreni i nešto kasnije ćemo bo pričati u samom izboru kojeficijet. To je dakle sada parametr našeg algorita. I tu matricu množimo ovom matricom, jel tako koja predstavlja naše stanje bloka. Sa znamo kako množimo matrice. Znači uzimamo vrstu isprve matrice, odnosno je je matrice kojeficijenata. I množimo jel tako sa kolonom naše matrice stanja, sabiramo odgovara i će projespode i na taj način dobijemo jel tako po finalnu pozitiju, baš ovu koju akip pokazuje. Dobro, zašto baš ovoj redosved nemajte da zaboravite, da ću to se često greši, šta se množi koja je matricom, koja je matrica prva, a koja je druga u tom proizbudu, zato što je ov tako svaku od ovih reći posmatramo kao celinu, a reć u ovom ovde stanju je upravo kolona, nije vrsta, zbog toga prvo ide matrica koja je feficijenata i onda su onam noži sa matricom stanja. Dobro, dakle treba da iznožimo ove svarije i da vidimo kako ćemo da dobijemo našu rezultu i ću matrici. Kako se radi sad to množenje? E pa to množenje nije klasično množenje. I ako dakle, naravno, možemo krenuti od atle i znamo kako bi smo formirali one prvi element ovak u našu rezultu i ću matrici, već smo reki, uzmemo nulltu vrstu ili prvu vrstu matrici koficijenata i pomožimo se prvom reći naše matrice stanje. Što znači? 8, 7 hexadecimolno množimo dvojkor, 6e množimo trojkor, 4, 6 množimo jedinicom i a6 množimo jedinicom. Sve to saberemo i dobijemo ove neki finalni rezultat, 4, 7. Bđutim, kako ćemo da dobijemo taj rezultat? Ove operacije koje vidimo nisu obično množenje i svarije. Viša razloga bostoji za to. Izbog toga u principu koćemo da vidimo kako funkcionišu zapravo ove operacije i to ćemo uraditi na ovom konkretenom primjer. Prvo stvar koji mohmo da pomnožimo je ove 8, 7 koje množimo sa 2. Operacije množenja za nas nije karakteristića operacija množenja, već predstavlja operaciju šitovanja. Operaciju šitovanja da bi prosto ove operacije bila što efikasnije. Množenje se dvojkom znate da prejde
 prestavlja šiftovanje u levo za jednu poziciju. Tako da kada prestavimo broje 8.7 koja heksadecimo mozapisano u binarne reprezentaciji, to izgleda baš ova, 1.000, 0.1.1.1, nadam se da se nisam zabrajela, pomrezi se za jednu poziciju u levo, naravno prva jedinica ispadne, a na poslanju poziciju se upisuje 0. I to prestavlja tako proizvod, odnosnu šiftovanje za jednu poziciju. Mjegi taj možda, što se dodatno radi, postoji jedna operacija uslovnog ksora. I dakle, ta operacija zavisji upravo od onog nesvodljivog polinoma, za koji smo rekli na početku da se koristi u ovom galo apođu. I ova operacija uslovnog ksora vrednošlji koja se dobija na osnovu tog nesvodljivog polinoma, zavisji upravo od toga da li smo imali prekoračenje, odnosno da li nam je ispala ova jedinica vodeća prilikom šiftovanja u levo. Ukoliko jeste, primenjujemo tu operaciju, ukoliko nije, neprimenjemo. Kako formiramo vrednost kojem ksoru jemo, ono što smo dobili kao rezultat ovog šiftovanja? Pa upravo na osnovu nesvodljivog polinoma. Sve ćete se da kada smo pričali u konošnim poljima na prvom času, pričali smo tome kako konvertujemo neki polinom u odgovarajuću binarno reprezentaciju. I to radimo tako što, dakle, ovom slučaju, pošte se radi o modulo 2, znači imamo kojeficiente koje stoja u spodinačne članove polinoma. I ukoliko, dakle, imamo neki član polinoma, to znači da njegom kojeficient 1, a ukoliko ne imamo te članove polinoma, to znači da je kojeficient 0. Što znači kada bi smo ove polinom x na 8, plus x na 4, plus x na 3, plus x plus 1, konvertovali u neku binarno reprezentaciju, nije bi smo na svaku i ove pozici da imamo član stavljeli jedinice, i tu bi smo imali od ako 1, 0, pošto ne imamo x na 7, pa 0, opet pošto ne imamo x na 6, pa ponovno 0, pa zatim 1, zato što imamo x na 4, pa 1, pa 0, za x na kvadrat, pa 1 i 1 za x i za 1. Esan, pošto jedakle, osnovu ga lua polja 2 na 8 i nama treba i osmobitne vrednosti, nama ove članke koji su odnosili na x na 8 i ne treba, zato što nam zapravo treba ostate k prideljenju sa ovim polinomom, tako da ćemo do odlocima jedinicu koje se odnosila tako na 2 na x na 8, i samim tim ćemo ostati samo ove ostate koje od članova x na 7, pa do 1, što znači 0, 0, 0, 1, 1, 0, 1, 1. I to je vrednost koji go sorujemo rezultat ovog šitovanja, koji smo imali malo prema. Kad ak soravamo ove dve vrednosti, dobijemo rezultate, otak u 3, 0, 1, 0, 1, 0, 1, i to je rezultat množenja ove dve vrednosti u ga lua polju za osnovu 2 na 8 po ovom nespodljivom polino. Dobro, slednjih vrednost, odnosno slednjih otak u poličnik, odnosno među proizvod, je 6e puta 0, 3. Kako sad to dobijemo? Dakle, ponevo nemo klasično množenje, ako nego razlažemo na među delove, koje ponevo, dakle, svodimo na ovo što smo videli malo prema. To znači, 6t puta 3 možemo predstaviti kao 6t puta 2 i plus još jedno 6e, odvada. 6t puta 2 znamo sada kako smo dobro. Dakle, to nam je operacija šistovanja u levo za jednu posiciju. Stim tako da predstavimo u binarnom zapis u ovo 6t, vidimo da ono ne počinje jedinicom, počinje 0. Što znači, kad ošiftujemo za jednu posiciju u levo, nama ništa nije nam ispala ova jedinica, nismo imali prekoračenje. Vidimo, dakle, rezultujiće vrednost koji dobijemo, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 Ovo vrednošći u 6e i dobijemo prezultat. Kada se radi operacija do davanja vrednosti, nikada nemao ovaj uslovnik sor, dakle, isključivo u slučaju da se radi operacija množenja, odnosno šiktovanja. I ovo je naš rezultat ovog množenja. 46 x 1, trivialno to je isto, tako kao ja, 6 x 1, to je također trivialno. I na kraju kada smo doplji ove među rezultate, sve što treba da uratimo je da ih sberemo, a videli smo da sebiranje ovde k violentnu operaciju XOR, tako da primenimo operaciju XOR na ova četiri među rezultata i finalni rezultat koji dobijemo je vrednost 4,7. I to upišemo u ono našu rezultujiću tabelu, odnosno u stanje, nakon primene ove operacije, u onom prvo polje. Ovo biste, odnosno, bismo naravno, uradili za svako, je otako polje, one matice. Dobro, dali je jasno, ovo da li možda ima neke pitanje ili za bilo šta do sada? Ok, ja se nadam da je jasno. Možda možda dalje. Kao što reku, ove kojeficienti nisu izbreni bilo kako. I ono što primećujete za prvo, prilikom ovog ovdje množenja, od tako da, kolikčina operacija koji ćemo sprodestiti, kolikčina ovojkšiftovanja, pred svega, zavisio toga koji su kojeficienti izbreni. I ako imamo kojeficient 2 ili kojeficient 3, ja svojde radimo ni kojeficienta 1, tako koje smo videli, radimo maksimalno jedno šitovenje. A ako imamo, recimo, množenje sa 4, radimo 2 šitovenje. Dakle, uz avisnosti od toga, koliko je veliki, konkreten kojeficient koji mi možemo, mi imamo prosto razlačit broj operacija. U skladu sa tim prosto da bi ovo operacija bilo što effikasnije implementirana, kojeficiente se biraju kao tipično male vrednosti. M.in, ono što implikacije toga, jedna naravno, prilikom operacije deshifrovanja, morate izbreti reverzne kojeficiente, tako odnosno, inverzne kojeficiente, na osnovu kojećete ovo kao proces koji je reversibilon prosto moći da deshifrovate konkretno porub. E, u koliko biramo male kojeficiente, prilikom operacije šifrovanja, to tipično znači da ćemo morati da uzamo veći kojeficiente, prilikom operacije deshifrovanja. I to naravno znači da je takva operacija manje effikasna usločajno šifrovanje. Tako da ovdje da bi se optimizovala operacije šifrovanje, to je uračeno prosto na račun deshifrovanje i izbog toga je deshifrovanje manje effikasna operacija. Međutim, da bi se rešio taj problem prosto u razlačitim algoritmu, odnosno za ovaj algoritm, ali za razlačite upotrebe, da se neki modovi funkcionisanja, u tom ćemo više pričati, neki sledeći put. Dakle, i da modovi funkcionisanja tipično predstavaju nešto što vam mogućeva da koristite odgovarići algoritm na način koji je vama pogodi. I postoje modovi funkcionisanja, na ostavu kojih možete da uzimete manje poličina podataka, tako je prilagođavate prosto algoritm, tako da ne morate algoritmu davati istučiv ovakav input kako ono čekvoje. Blok o 128 bit, ključ tako vi tako, već nekako prilagođavate algoritmi. Isto tako, dakle modovi mogu omogućiti i da u procesu dešifrovanja ne koristite operaciju dešifrovanja. Dakle, nema isključivo operacije dešifrovanja, već se takođe koristite algoritm za inkrediciju. To je dakle za neke modove funkcionisane. Ovo što se na taj način postiže, je da koristite za takođe ovaj efikas na algoritm, dakle, ovu efikas na operaciju mixkalenskoj radi sa malim kojeficientima i na taj način imate efikasni algoritm. Međutim, naravno, to nije uvek slučaj, znači, ovaj algoritm se može koristiti kao dakle, ovaj algoritm koji definišamo za dešifrovanje. Međutim, dakle, tipično postoje i modove funkcionisanja koji prosto uzmo baš ovaj algoritm za šifrovanje pa njega prilagode tako da se koristi za dešifrovanje. Dobro, osim toga, naravno, ovik koficienti su takođe raspoređeni na odgovareći način, tako da zapravo same ove operacije radja maksimalno mešanje, videli ste tamlo da su oni raspoređeni nekako po diagonalama. Dakle, baš tako da prosto kada radite ovom noženja, zapravo oni utiču na različite baitove, različiti freći na taj način ima najviše mešanje. Dok. Stajacija operacija, odnosno poslanja operacije koji imamo, imamo je operacija kombinovanje ključova i to je običan sor. Dakle, imamo prosto jedan blok podatak o 128 bita, imamo ključ i ta racija koja je takođe makrica o 128 bita i prosto se radi k sor ove dve vrednosti, dakle, svako polje matrice sa odgovarećim polje matrice tog ključa. Dakle, jako jednostavna operacija, inverzna operacija je potpuno identična. Dakle, znate da ukoliko k soru jete a sa nekim b i dobijete neki rezultat c i ponovog soru jete to c sa istim tim b, vi ćete zapravo dobiti ono početno a. Dakle, operacija je potpuno identična. Izbog toga, dakle, ne mora se našto posebno dizajni reč.
 Kako ćemo ovezbejiti sigurnost ove operacije? Tako što nećemo svaki put koristiti identičnog ljuča. I tome nam upravo služi operacije ekspanzije ključa, koja zapravu razvija po 4 neki ključ, veličine al tako 128 bita u nizu od 44 reči. Tako da zapravo u svaku iteraciji koristimo potpuno novi ključ od 4 reči. Kako se dobiraju te reči? Ako podledate dakle, ako zapravo vidimo da ova jedna matrita se predstavlja kao neke 4 reči inicijalno koristi su ove početni ključ. Reči su V0, V1, V2 i V3. Svaka četvrta reč prolazi kroz neku transformaciju i ta transformacija je definista na ovom nekom g funkciju. Ta g funkcija ima neke parke, vidat ćemo ih kasnije. Iste g funkcije, dakle ona se primenja na ovom četvrta reči, oveako, predstavlja tu transformiseno četvrtu rečku, kada se kombinuje sa ovoj prvom reči, mi zapravo dobijemo prvu reč sledaći ključ. I tako, to je nam je nakle V5. V5 dobijemo na osnovu V4 i V1, dakle uvek na osnovu predhodne reči, i reči koje je napomjeroj za 4 u odnosu na tu. Znači, od V5 za 4 je pomeraj, od tako V1. Kad kažem kombinuju do to, dakle, znači primenjemo izključivu ksoru operaciju i to je sve. V6 se dobija ksoruvanjemu V5 i od tako neko je na 4 pomerej od V6, to je V2, a V7 se dobija na osnovu V6 i V3. I tako, dakle smo formirali sljedeći ključ, a onda nastavljamo i u svakom sledaću iteraciju, uzimamo svaku četvrtu rečnih, či sada V7, trasvormišemo je primjerom g funkcija, primjerom g funkcija, tako, i nadalje opet pravimo sljedeću matricu, odnosno sljedeći ključ koji će se koristiti u narednoj prvom. Dakle, sve do kraja. Ove g funkcija, dakle, je dizajerem tako da bude odporna na napade, dakle na neke poznate napade, i u principu ona naravno zbog toga takođe sadrži neki algoritm zamene i neki algoritm permutacije, gde permutacije, dakle, predstavlja neku kružno pomeranje u levo za 1 byte, dakle, fiksno za 1 byte, predstavlja ponavu neku zamenu, što znači da ponavu imamo neku matricu preslekavanja, što su praktično esbogsivi, i predstavlja dodatno, dakle, treća fase, nekak sor operacija sa nekom konstantom. Tako konstanta je definisana kao parametralgoritma za svaku iteraciju pojedinačno i prosto se čpračita, tako, tako, konstanta iteracije, i izkombinoje se, odnosno, primjeni sa operacijom, sorry, na taj način smo dobili izlazi zove g funkcija. I onda, odako, videli smo kako tako izlaz dalje koristima. Već smo videli, da je kako se desiniše algoritm deshiprovanja, međutim, postoji još nešto, dakle, drugi način za algoritm deshiprovanja, a to je prosto ekvivalentena i nverzna šifra. Dakle, malo modifikovan algoritm deshiprovanja, odnosno, ono što smo videli, kada smo na početku, negde časet pričali o tome kako izgleda konceptuolnu algoritm šifrovanja i deshiprovanja. Dakle, po čemu se razlikuju, po čemu se razlikuju ove operacije, pa, dakle, ponevo imamo za svaku od koji nočnih operacije u rundama definisano inverzno operacijun, međutim, ono što je različno i to ovde u odnosno na onaj algoritm, jedne sa operacije, ne nalaze u istom redosledu. Odnosno, dakle, kod ono prvoj algoritmo deshiprovanja koji smo videli, mi smo samo korake primenjivali u suprotnom poretku. A ovde primenjujemo korake u identičnom poretku, kao što to radimo pod šifrovanja, samo što, dakle, naravno, primenjomo inverzne operacije. Kniučeve, takođe, naravno, primenjujemo u obrnutom poretku, dakle, prvo, uzimamo poslednji kniuč i onda idemo do prvog kniuča koji smo imali na početku. Poslednje se pitanje, zašto nam je sve jedno, sve jedno, kojem poretku mu zimamo ove operacije? I dal'i nam je sve jedno i dal'i ove operacije zapravo možemo primeniti, dakle, prvo, recimo, substituciju, pa onda šiftovanje i prvo šiftovanje, pa onda substituciju. Očegledno možemo je odakon, a razlog zašto možemo, recimo, za baš te dve operacije, je zbog toga što, svaka, na primjero, zbog toga što ove substitucije, kao što ste videli, radi na nivou ako jedinočnih baitila. Odnosno svaki bait, menjamo nekim drugim baitom. I sad, dal'i ćemo mi prvo da uzmemo, pa da promenimo redosled stih baitova u okviru ove shift rows, inverzne operacije, ili pa ćemo onda da se provedamo substituciju odnosno zameno, ili ćemo prvo da napravimo zameno, pa onda da promesamo te vrednosti, potpuno je sve jedno, to neće uticati na samu zameno. Zato što se zamena nikako ne radi na osnovu pozicije, već isključivo na osnovu vrednosti i radi nad tom količinom podataka, što je 1 bait, što će svakako ostati identično i neće se pomješati sa drugim vrednostima samo operacijom shift rows. Tako da smo što sličali da je operacija mir. Što sličali operacije inverse mixed columns i add round key, koji će moguće zameniti redosa, da njih je tako trivialno kao da je predhodan da je operacija, izbog toga svaki ključ koji se koristi u operaciji add round key mora proći kroz neku transformaciju koja će tako ključ pripremiti dakle za upotreb. Mi nećemo raditi detalje sada ove operacije, li je to čisto da znate da je moguće napraviti i ovo inverse equivalentnu šifru i na ta način zapravo definisati dva različita algoritma za šifrovenje koje prosto premenjuje ove operacije u drugom ponetku. Što sliči implementacijonih aspekata, dakle, efekstno se implementire na osmobitnom procesur i na 32-bitnom, je prosto to što možemo prilagoditi velicinu podatakanat koje bi se radi obrada, je tako ovih blokovog podataka, što znači kao što ste videli, praklično svakva operacija velo jednostavno radi nad pojedinočnim byte-ovima, ali takođe možemo predfinisati svakog pojedinočnu fazu tako da raditi nad rečima koje su dužine 32-bite i tako prilagoditi 32-bitnom procesur. Dobro. I sad ćemo dakle vidati, u sveri možda, posle pauze, ukretko dakle, kako bi izgledao jedan timer zadatka koji dakle ilustruje AS algoritmu u ove svoje ostavne formi, a onda ćemo nakon toga preći na skraćenu, odnosno skaliranu verziju, AS, kako bićemo prosto mogli da obradimo više ovih operacija, da to ne bude da ne eksplodira u smislu ove količine podataka nad kojem radimo obradu. Da imate možda neke pitanje za sam algoritm, dakle, prenego što odamo na pauzu i prenego što pređemo na neki primer. Da imate nepa pitanje? Dobro. Ako nemajte pitanja, onda idemo na pauzu. Dobro. Adlično. E, dobro, stigli smo do zadatka koji će ilustrovat i AS. Sad, naravno, dakle, absolutno jasno da u ovom roh zadatka nećemo raditi celokupni algoritm, zato što dakle, on ima dosta interaciju, videli smo raditi nad većom količinom podataka, sveto, naravno, nije ni potrebno, nije ni izbodljivo da u ovom formi radimo. Tako da u operu ovog zadatka, dakle, imamo stanje, dakle, blok podataka, to je avo što vidimo kao prvom matricu, pre poslednje iteracije za pravo AS algoritm. Zatim, imamo ključ, naravno, koji su koristili u iteraciji i imamo S-box koji ćemo koristiti prilikom substitucija. Dakle, onda samo vidimo kako izgleda poslednja iteracija, to je ona iteracija koja nije vam ikskalan iz operaciju, i ćemo više ilustrovatika da budemo radili S-i s u sljedešljim zadacima. Dakle, već, nam je pripremljim ključ, tako da takođe naradimo ni ekspanzije ključe. Dobro, ajde da vidimo, dakle, šta prvo radimo? Prva operacija koja je zprobodimo je substitucija. I ovdak u svaki od ovih pojedinačnih baitova menjamo odgovarajućim baitom koji se nalazi u tabele. Iako smo recli, dakle, da posmetramo reči po kolonama, po što smo već pomijali da substituciju radimo na nivou pojedinačnih baitova, onda, naravno, nije bitno kako idete, o tako za substituciju samo da idete po kolonama ili po vrstama. Tako, dakle, jedimo 1 po 1 element, 2a, dakle, uzimamo prvog eksta cifru, identifikujemo vrstu, i uzimamo drugog eksta cifru, identifikujemo kolon, tako da je to e5. Ono što možete primetiti je da u ovom konkretnom zadatku imamo parcijalni sbox, dakle nijam dati ceo, sbox nije potreban pa da ne bi trošio prostor na ovom slajdu. Dobro, zatim uzimamo sledeću vrednost, u ovom slučaju 39, ogosno 39 zapravo, trojku ili tako i trojku uzimamo za selekciju vrste, 9 za selekciju kolona i to je vrednost 1, 2. I tako, nastavimo, tako, zanmenimo celog kupno stanu. Dobro, sledeća, dakle ovom nam je tabela, odnosno naša stanja na...
 i tako primene substitucija. Prva reč gledate obovezno po kolonama za reči, gledam u po kolonama, tako je ulaz u sledeću operaciji. Prva reč gledam u po kolonama je E5, 6, 5, 3F7, 3 i tako daje. Zašto ovo na pominjem svaki put, to je da kada dobijete u zadatku, recimo da vam piše vrednost bloka ili ključa i po ređanom je način u tekstku prosto, ka vam piše sad u ovom konkretnom slučaju recimo E5, 6, 5, 3F7, 3, 1, 2 i 1C i tako daje. Morate da znate da prva četiri baita ređete u kolonu a ne u vrstu, dakle nemojte se prevarite, podporno ćete pograšno uroditi zadatak i onda sve probane. Dobro, što stiče druge operacije, dakle to je šiftovanje i tu idemo po vrstama. Prva vrsta koja je selektova na ovde, ne menja su uopšta, znači ona ostaje istat tako. Druga vrsta menja se tako, tako što prosto rotiram za jednu poziciju u levo. Ka pa što vidite, 65 dođe na poskodnju poziciju, sve ostale vrednosti pomere se za jednu poziciju u levo. Sledaće vrste se pomere za dve pozicije, znači i 3F i 17, odnosno 1, 7, se pomeraju u kada ju na drugu stranu i od ako, a 4, 3 i 3C se pomeraju levo. U poslodnju vrsti, dakle isto, radi u pomeranje za ali sad za 3 pozicije i vidite kako je izgleda o finalnom stanje. Dakle, još jednom bajtu vi se iz svake reči, dakle iz svake kolone maksimalno nešaju, tako da nakon primjena ove operacije pripadaju s različitim rečim u finalnom stanje. I poslodnja operacija je još e-d-roundki. Dakle, da ćemo uraviti obično ksorovanje matrice stanja koji smo dobeli nakon primjene, a šiftovanja i ključa iteracije koji smo videli i rezultujića matrice je upravo dakle rezultat šifrovanja, odnosno poslednje iteracije našeg algorita. Dobro. Dakle, u omtenu odkusmo završili sa jednim primjerom AS-a, završili smo dakle sa upoznavanjem, generomu sa strukturom AS-a. Prodiskutovali smo, ja ću sada, dakle, prepositi reč Akiu i on će, dakle, objasniti po čemu s AS-a i s algoritm razliku je od ovog veliko ga s algoritma i odraditi nekoliko zadataka, kako smo inustrovali ataku, kako to izgleda i dodatno, dakle, da vidite šta se od vas očekuje i na labua, naravno i na holo-crium. Ala, majo. Dobro. Da li se čujemo opšte? Ajde, presega. Pema se. Dobro, super, super. Ala. Ništa, dakle, nastavljamo dalje. Kao što smo prošli nedelje videli na nekom onom universitetu, praktično je napravljeno ova pojednostavljena verziya prošli nedelje učili sd-algoritmo, ove nedelje učimo sas-algoritma, koja služi bukvalno u te edukacijone svrhe, da vi lakše schvatite ceo princip funkcionisani ovog glavnog des, odnosno AS-algoritmo, kroz neki jednostavnije primjer, jer kao što vidite i kao što smo prošli nedelje i detaljno pričali, prosto struktura samog s-simplified algoritma koja god sad verzije je identična kao struktura konkretnog tog originalnog algoritma, samo smanja da radi sa manjom količinom podataka i sama struktura nekako sužena da ima manji tako da pojednostavljeni AS ima veličinu bloka od 16 bita, odnosno 2 byte i veličinu ključa od takođe 16 bita, odnosno 2 byte i sve svedeno na 2 iteracije. Pri čemu te 2 iteracije odgovaraju praktično ovoj prvoj iteraciji u AS-algoritmu, odnosno poslednjoj iteraciji u AS-algoritmu koja je nedostaja ona mix-columns funkcija u celoj rundi, i na početku i ovdje imamo add round ki zbog svega što je maja već spomenula u AS, sve te stvari koja smo čuli za AS važi ovde za s-i, dakle prosto imamo 2 runde i veličinu bloka od 16 bita, međutim ovdje je stanje takođe matrica sa 2 reda i 2 kolone, takva da jednopolje matrice nam sada nije byte, nego nibil odnosno 4 bita same matrice da bi smo prosto ovih 16 bitu opšte mogli nekako matrično da predstavimo. Tako da tu se prvo razlikuje ta predstava stanja, dakle matrice dosta manja što zavisi konkretno od veličine podataka, a naravno jednopolje, onda matrice je četvrtina ukupnog broja bita za veličinu bloka i za veličinu ključ. Tako da jedne i druga matrica i za ključ i za blok su 2 x 2 i svako polje je veličine od 4 bita. Naravno sve ove operacije sada u samom s-i algoritmo odgovaraju operacijama AS algoritmo, pri čemu su one modifikowane da rade sa četvorobitnim vrednostima koje su tog našeg stanja, poljate naše matrice. Tako da e-round-ki je identična operacija kao i ko da je s algoritmo, prosto ksorujemo celo matricu ključa i teracije sa celo matricom trenutnog stanja, a kod substitucije i ovih ostavljih operacija, prosto one su malo modifikone da rade na nivou četvorobitnih vrednosti. Konkretno substitucija dakle sada na drugačiji način selectu je red i kolonu kod oni has boxova, a to ćemo vidjeti u konkretnom zadatku, jer prosto ona sada menja kao jednopolje matrice, jednu četvorobitnu veličino, odnosno jedan nibel nekim drugim, a ne jedan byte nekim drugim. Tako da prosto na drugačiji način selectu imaju vrstu i kolonu, jer sad u svakom polju imamo samo 4 bita. Što se tiče operacije šiftovanja, ona se u suštini ovde svodi na šiftovanje samo jednog reda u levo, tako da se operacije zove shift row, dakle u jednini, jer prosto kako je matrica dva puta dva, ona i prvi, odnosno, nulti red ostaje tu gde jeste, kao i kod aj sa algoritma, a ona i drugi, odnosno, da kažem, prvi red u matrici se šiftoje za jednopolje levo, što su suštini svodi na samo zamenu ta dva polja. Mix column operacija je identično u suštini kao kod aj sa algoritmom, s tim što su oni kojeficienti, one matrice, sa kojem množimo naše stanje malo drugačiji, i sam ona i nesvodljiv polidom je takođi prilagođen da radi sa podacima veličine 16, odnosno 4 bita u slučaju, polja i add round ki smo već pro komentarisali. Naravno, deshifrovanja istu kada kao kod aj sa algoritmo može da se radi u inverznom redosledu, sa inverznim operacijama, i to sada već možete da svatite kako bi se za ovaj modifikovanem operaciji napravili inverzno operacije, dakle majete već detaljno ispričala. Dakle, kao što reko, svaka runde se sastoji s 4 operacijama u ovu substituciju, koja prosto od svakog nibla kroz S-box do, doprim, odnosno, menja taj nibl, nekim drugim nibla, tako što prosto od ta 4 bita selektuje red S-boxa sa leva 2 bita, a kolonu sa desna 2 bita. Dakle, isto kako kod aj sa prosto podelimo nekako bite u samom našem polju matrice na 2 dela, i onda ona leva polovina nam selektuje vrstu, a desna polovina nam selektuje kolonu. Kod aj sa smo dakle, to pod tom poljom dobili neki hexa cip, preovo dobijemo neke dvobitne vrednosti pa prosto tim dvobitnih vrednostima selektujemo kolonu, u preseku se i vrstu, i u preseku se nalazi ono čime menjamo to polje koje smo iskoristili za selekciju S-boxa. Kažem, shift row se svodi samo na zamenu mesta za ova dva polja u našem stanju, jer samo se taj red shiftuje u levo, a mix column operacija se svodi na množenje ove neke matrice, kod koje vidite da imamo na glavno i diagonali kečevena, sporedno i diagonali četvorki, opet nekako odabran i kojeficienti da maksimalno izmeste i utiču na sva ova stanja u našem, sva ova polja u našem stanju, i naravno tu matricu opet nožimo redom sa kolonama, odnosno sa svakim od ova dva byte u stanji. Aritmetika se radi u ovom slučaju nad poljem g2 na četvrti po modulu x na četvrti plus x plus 1, videli smo kako bi smo ovo predstavili u nekom binarnom formatu, a u deteljnom zadatku ćemo konkretno videti kako i ovo sve videte, ziročunam, ali u suštini sve ona pravila koja ste pričali sa majom koja su vezana za ovu aritmetiku na dojem konačnim galoa poljem važe i ovde što se tiče onih šiftovanja i onog ksorovanja za zamenu noženja i sabirenja. I add round key, dakle, tu ništa specijalno se nemenja, da se ksorojemo odgovarajuće, polja odnosno odgovarajuće delove ovog našeg stanja sa ključem za tujtira i teraciju. I kao što reka u druge
 Runda je istakao i poslednja Runda u AS-u, prosto ne dostaje operacija mix column opet zbog onog deshifrovanja. Da bi sve mogli do nast. Što se tiče samog ključa, kao i kod AS-a i ovde ključ mora da prođe kroz onu ekspanziju, odnosno da se od samog ključa generiše jedan niz nekih u ovom ključe u bajtova, ne reći, koje koristimo onda kao delove tog niza, koristimo u odgovarajućim iteracijama u našem algoritmu. Tako da i ovde to generisanje ključa, ta ekspanzija počinio tako što prosto kopiramo u taj neki naš veliki niz, u prva dva bajta, prva dva bajta baš naše ključe i opet popunjavajući sve ovo po kolonama. Dakle, to vam još jednom napominjemu. Stvarno svaki put na kolofijumu dobar deo studenata pograši u statu. Dakle, po kolonama ta dva bajta popunimo, svaki od ovih niblova i to nam predstavlja najprvi ključ koji ćemo dodam u prvoj e-droundki operacij. A onda na identičan način kao i kod AS algoritma prosto nekako utiče, svi ovi delove ključeva utiču na ginerisanje ostatka ključeva pri čemu nekde imamo samo neko ksorovanja nekde, prek sorovanja jedan od tih delova koji utiču na ginerisanje nekog drugog dela ključa mora da prođe kroz onu je funkciju. Ovde, dakle, pošto imamo dve same kolone, odnosno dve neke grupe u ovom stanju, ovde je pravilo da prosto za svaku grupu, za svaku kolonu nekog novog ključa, zna svaku kolonu ovom nekom velikom nizu, na nju utiču predhodne dve, tako što se one ksoru i tako da za ovo v2 prosto v0 i v1 će u nekom trenutku da se ksoru. Međutim za ove sve vrednosti koje da kažemo imaju ovaj neki parni index, odnosno za prvu kolonu svakom pod ključu ako ih ovako već podelimo, prenego što ova predhodna kolona ključa koja smo malo predobili, u ovom slučaju v1, se ksoru je sa onom koje se nalazi za dva mesta i za to je v0, prenego što to uvradi mora da prođe kroz ovu neku funkciju g. I sad o toj funkciji ste istodeteljno pričali s majom, pa evo samo ukrat koji ovde da prokomentarišemo našta se to svodi. Pa svodi se na prosto tri neke operacije, dakle prva operacija, sad dakle imamo ovaj neki byte koji se sastoji iz dva nibla, pa ga ovako predstavljamo u vrsti. Dakle, ovo n0, n1 je vezano za, na primer, ovu v1 koji nam je ulaz u g operaciju. Prvo zamenimo mesta tim dvema četvorobitnim veličinama i dobijemo neko n1 i n0 ako smo ih već ovako označili. Onda svaki od tih niblova prolazi kroz 1s box, čima dobijemo neke dve nove vrednosti, i onda se sve to sabira, odnosno, ksoruje sa opet nekom konstantom iteracije, koja opet predefini sa algoritmo i postoje način i kako se ona generiša, ustuštini ovdje će ovak da budu vrednosti 80 i 30, odnosno 30 i 80. I kada prođe sve kroz t3 operacije, odnosno, ovaj jedna kolona kroz t3 operacije, dobijemo izlaz i same funkcije g koja onda ulazi na ulaz ovog našeg ksora i na taj način dobijemo uvek prvu kolonu svakog podključa, svakog od ova dva podključa, a drugu kolonu prosto dobijemo tako što pretpodnu kolonu, a to je v2 u slučaju v3 i onu kolonu koji se nalazi dva mesta u nazada, to je v1, samo ksorujemo i dobijemo neki rezultat. Dobro, il ima na ovom trenutku pitanja, dakle, da je nešto možda ostalo nejasno još i za es algoritma, kada sam možda ovdje zbrz ovo je sa es algoritmo ili možemo da pređemo na konkretan zadatak. Dobro. Ovo je klasični jedan kolokvimski zadatak koji kaže da treba originalnu poruku koje ovde data u hexaciprama a1 0 c i koristeći ključ 1f29 da provučemo tu poruku kroz ceo es-es algoritam i damo sve među rezultate svih operacije, i, naravno, konačnu šifrovanu poruku. Detalje operacija su dati u nastavku i, naravno, te detalje uvek dajemo i na kolokvimu, dakle, ne morate napomnedućete, napr. ovaj es-box. Tako da detalje operacija su uvek isti, ovaj jedan jedin es-box se koristi i pri ekspanziji ključa i u onim rundama sama mes-i s algoritmu. Imao koje eficjente za mix column sa operaciju, imamo ove konstante koje se koriste, opet, prigenerisanju samog ključa. I sad, čisto da biste postupno videli od prilike kako sve to izgleda, ja ću pokušati, zaduše, sa mišan i pejntom da uradim ovaj zadatak. Dakle, evo, prekuceli smo ovde, odnosno, prekopirala sam ovdje u pejnt zadatak, tako da, ono što prvo možemo da uradimo, jeste da od ovog ključa 1F29 krenemo sa ekspanzijom ključa, sa ginerisanjem ključeva za prvu i za drugo iteraciju. Naravno, ove ključe ćemo koristiti ovoj 1F29 operaciji, ali prosto na početku, svakako, čim krenemo ovu poruku da propuštamo kroz algoritmu, nekod minutku će nam trebati tih pod ključavi, tako da možemo njihoj odma na početku da ginerišemo, da završimo koje se ovo sati. Dakle, ono što prvo treba da uradimo, dakle, ovaj sad kao neka moja matrica, neću je ojivičiti sa ove strane da ne gubim vreme, jeste da prestavimo ovaj ključ kao stanje samo GSI s algoritma, odnosno da ga predstavimo matrično. I tu još jednom naglašavamo i maja i ja da se sada ove vrednosti koji su ovde tekstolno date lepo sa levanu desno smještaju po kolonama ove matrice. Dakle, ova hekca cifra, jedan nibul, odnosno jedna četvorobitna veličina, ide u gornji leviu ga naše matrice, onda ispod nje u istoj koloni ide cifra F. Onda cifra 2 ide u prvu vrstu i drugu kolonu ove matrice, a ispod nje u istoj koloni ide ova cifra D. Dakle, to još jednom napominjemo, to negde sebi crvenom chemijskom zapišite da ne zaboravite i na labu svakako, a i na kolokvim. Dobro. Šta smo rekli? Pa rekli smo da sada da bi smo dobili ovaj neki ključ koji se koristi u prvoj iteracija koji ovo je označimo kao neki K0, dakle ključ koji se koristi pre prve iteracije. Onda prosto je potrebno da za ovu kolonu nekako, predhodne dve ksorujemo, a ovo kolonu opet dobijemo tako što predhodne dve ksorujemo, pri čemu rekli smo ovo prvu kolonu dobijemo ksoruvanjem predhodne dve, ali prenego što ih ksorujemo, ovu drugu kolonu predhodnog ključa, dakle jednu pomerenu u levu, odnosno na kolonu koji upravo želimo da generišemo, treba da provučemo kroz onu funkciju G. Dakle, povrsti prosto sad ove cifre možemo da nekako napišemo ovako, dakle 29, odnosno 29 u heksa ciframa, taj byte treba prosto da provučemo kroz funkciju G, to je cela ova kolona. Dakle, rekli smo funkcija G se sasto iz nekoliko manjih pod funkcija. Prvo, što se deshava, jeste da se cifre, odnosno heksa cifra, odnosno ti niblavi, treba da zamene mesta, tako da od 29 dobijemo 9.2. Onda druga iteracija u ovog G funkcija, odnosno druga pod funkcija, druga operacija, zame novih cifara koristeći ovaj ovde S-box. I sad rekli smo prosto S-box, biramo vrstu i kolonu S-boxu, u zavisnosti od leva dva i desna dva bita svake cifre. Dakle, zamena se za razliku da je sa ovde vršina nivou tih heksa cifara, odnosno tih čatvrobitnih vrednosti, a ne celog bita. Tako da uzimamo i redom menjamo prvo levu cifru, a onda i desnu cifru zaserno. Pa zapišemo ovu 9 u binarnom formatu, dakle 1, 0, 0, 1, podelimo na dva dela i kažemo ovoj levi deo nam selektuje vrstu u ovoj tabeli, dakle ako ovu označimo sa nula, ova sledeća je 1, ova sledeća je 2, ova sledeća je 3, 1, 0 nam je zapravo dvojka, tako da time selektujemo drugu vrstu. Drugi deo, ove naše 9, je predstavljenu u binarnom formatu, glasi 0, 1, tako da ovde praktično selektujemo prvu kolon.
 šta je čime selektuje. Tako da u presjuku sad ove druge vrste i prve kolone nam se nalazi cipra kojom menjamo ovu našu cifru 9-ku i to je kao što ovdje vidimo u S-boxu heksa cipra sa vrednošću 2. Na isti način i ovu dvojku možemo da predstavimo u binarnom formatu, to je 0 0 1 0, podelimo na dva dela, 0 0 leva nam selektuje vrstu, a 1 0 nam selektuje kolonu i u preseku nalazimo cifru kojom menjamo ovu dvojku, u pitanju je heksa cifra a. Dobro i treća operacija o ovim funkciji G je ste ksorovanje sa konstantom iteracije, a konstanta u slučaju generisanja baš ovoj prvog podključe jeste 80. Tako da ovo dva A ksorujemo sa 80 i znamo da A kada ksorojemo, odostno bilo šta kada ksorujemo sa 0 dobijemo bilo šta, to nešto, a dvojku kada ksorujemo sa 0, a ako mislim, evo imamo 0, ovebebebebebez ovebebez ove kjece i dvojku ovde, možete u glavi da izračunate lako da je opetu pitanju heksa cifra. I videte ćete kada budete već bali ove zadatke, nekako ćete sve brže brže ksorovatim. Ove vrednosti i generomu kad budemo prolazili kroz kursi steći ćete tu našu omiljenu veštvinu, naponjeko ksorovanje z tih heksa cifara napomnetu glavi. Dobro, time smo dobili šta, pa dobili smo izlaz izgje funkciji, naravno ne upisujemo to ovde odmah u kolonu k1, nego sad rekli smo ove izlaz izgje funkcije ksorujemo sa kolonom koja se nalazi za dva mesta i za kolone koju upravo generišemo. Tako da a a i 1f kada se ksoruju, opet možemo da videmo tu neka pravila tipa a, bilo šta kada se ksoruje sa f, prosto se svi biti udarece neka inverzija, pa sve nule postaju u keče i sve keče postaju nule, tako da od a što je 1, 0, 1, 0 dobijemo peticu što je 0, 1, 0, 1, a ovo a kada ksorujemo sa onim kecom, očigledno dobijemo heksa cifru b. Tako da b5 nam je ono što nam je prva kolona u našem stanju ključa k1, dakle ključa za prvu iteraciju. Ovo drugu kolonu dobijemo na lakši način, tako što sada predhodne dve kolone samo ksorujemo, a to su b5 i 2, 9, 5 i 9, a je da, znači b5 i 2, 9, 5 i 9 kada se ksoruje dobijemo c, a b2 kada ksorujemo dobijemo d, tj. Ako sam nevaram, ako sam pogrešio, značite sami da ksorujete ove vrednosti. Dakle, to što smo dobili je odma kolona, druga kolona ovog ključa za prvu iteraciju. Sad na identiča način bi smo dobili ključ za drugu iteraciju, tako što prost opet ovo provućemo kroz funkciju g, ksorujemo sa ovim i dobijemo ovo kolonu, a onda tu kolonu i predhodnu kolonu samo ksorujemo bez ikakve funkcija g i dobili bi smo ovu kolonu. I sad ja ću se vratiti za sekun na slajdove, samo da vidim, da li ovo tačne jeste i kažemo ovde nakon svih istih ovih operacija dobili bi smo i ključ k2 koji je predstavljen sljedećem stanjem, dakle 47db koji se koristi u drugoj iteraciji. Dobro, dalje ovoj trenutku ima nekih bitanja što se tiče generalnu SI-sa algoritma, ali ajde, odradili smo ovu ekspansiju, pa da li vam je sve ovo ovde kristalno jasno? Dobra, dobra. Sada kada smo dobili ključeve k0, k1 i k2, onda prosto možemo sada ovu originalnu poruku da prvučemo kroz sve one operacije koje su definisane SI-sa algoritmo i dobijemo neku šifrovanu poruku. I rekli smo prenego što uđemo uopšte u prvu rundu ovoj originalnu poruku a1,0,c. Preba opet da prikažemo u nekom matričnom formatu, onim našim stanjem. Tako da opet ovde po kolonama popunjavamo sve, idemo a, pa 1, pa 0,c u drugoj koloni. I prenego što uđemo u prvu rundu treba prosto ovo stanje da ksorujemo sa onim našim početnim inicijalnim ključom, dakle to je ona inicijalna operacija e-round-kija koja ide pre prve iteracije samog algoritma. Ovo ksorujemo sa 1f29 i dobijemo rezultat, tako što prosto na svakoj pozici ksorujemo odgovarajuće pozicije iz ove dve matrice. Pa a i 1 će nam dati očigledno b, f i 1 će samo da je liminišljenog kjeca na kraju ovog ove cifre f, pa ćemo dobiti cifru e, 2 i 0 je dvojka, a c i 9, mislim da sam negdo to imao, možda nisam, c i 9 će dati onu peticu. Dobro, i time smo dobili izlaz iz prve e-round-kija operacija, to nam je sad ulaz u prvu rundu samog naše algoritma koji se stoji, koji se sastoji iz nekolik operacija, to su ona i nibl substitution, shift row, mix column i još jednog e-round-kija koji sada dodaje ove i ovde ključ koji smo izginericali, tako da ovo sada ovde, prolazi prvo kroz ona i nibl substitution koji funkcioniša na isti način kao i u ovom delu za generisanje podključava za iteraciju. Prosto, sada se stavlja, da se stavlja, kako se stavlja sight, kako se stavlja, kako se stavlja, kako se stavlja sight, kako se stavlja, kako se stavlja, kako se stavlja, kako se stavlja sight, substitution koji funkcioniša na isti način kao i u ovom delu za generisanje podključava za iteraciju. Prosto, svaki nibl, svaku četvorobitnu vrednost, odnosno svaku heksacifru, zasevno menjamo ovom našem S-boxu, tako što je binarno prikažemo, leva polovina utiče na izbor brste, a desna polovina utiče odnosno selektu je kolon u ovom S-boxu. I sad 1, 0, 0, 1 konkretno smo već videli, ili nismo. 1, 0, 1, 1 je ovu stvar. Dakle, cipra B nama je 1, 0, 1, 1, Odelimo na dva dela, levi deo 1, 0 selektu vrstu, Evo je ta vrsta, desni deo 1, 1 selektu kolonu, tako da u preseku imamo trojku, odnosno heksacifru B menjamo heksacifrom 3. Dobro, sad dakle, generalno nije bitno kojim redom ćemo da menjamo ove cifre, možemo sad uzmamo dvojku, možemo E, Dakle, idemo po klonama, po vrstav, možemo i peticu, rekli smo da to u potpunosti nezavisno, jer se zame na vršina nivou jedne heksacifre, a i selektovanje opet na nivou jedne heksacifre. Dakle, da možemo da uzmamo ovo dvojku, a ne 0, 0, 1, 0, njusmo već, videli da se menja heksacifrom A. Heksacifra E predstavljena sa 1, 1, 1, 0, se menja heksacifrom F Iheksacifra 5 je binarno prikazana 0, 1, 0, 1, dakle, selektujemo i prvu vrstu i prvu kolonu, u čijem preseku se nalazi cifra 1. I tim smo završili prvu operaciju našoj prvoj iteraciji samog algoritma, dakle, odradili smo Nibal Substitution, dakle, ovo je bio NSD. Sada od ovoga, ovo nam ulazi na shift rov operaciju, koja reklismo svodi se prosto na samo zamenu donjek dela samog našeg stanja, odnosno na zamenu ovih heksacifara, tako da gore nam ostaje ovo 3A, jer reklismo taj 0-ti red shiftuje za 0 bita u levo, ovaj prvi red shiftuje za 1, ne bitnego, za jedno mesto, za jednu poziciju u levo, tako da praktično našta se to svodi, je se da jedinica dođe ovde, AF dođe ovde sa desne strane, tako da za sada imamo stanje 3,1, AF. Dobro. Treća operacija koja se ovde desava, jestem X kolomna operacija koja sada treba da pomnoži ovu matricu koja eficijena, dakle 1,4,4,1, sa ovim našim stanjem, odnosno sa svakom kolonom zasebnu ili generalno sa celim stanjem sve.
 I rekli smo, ajde sad malo ovo da povećam, dakle 1,4,4,1 sa 3,1af, rekli smo da se ova matrica mora naći sa leve strane ovog znaka zamnoženja, nikako sa desne strane, ako bi mogli matrici tako da se pomnoži, jer prosto dobićete pograšan rezultat, to je jedna stvar, druga stvar, jeste, kako se to množi da se pocetimo, pa svako ovo polje našeg stanja se dobije, tako što se vrsta u kojem se to polje nalazi iz prve matrice i kolona u kojem se to polje nalazi iz druge matrice, nekako međusobno pomnože odnosno, odgovarajući članu i gledani sadestna levoj, odgovorajući odosgo na dole, se pomnože i sve se to sabere. Tako da ovo ovdje cifru ćemo dobiti, tako što pomnožimo 1 sa 3, gledamo množenje ove vrste i ove kolone, i to sve saberemo sa pomnožkom 4 i keca. Naravno, množenje kao i kuda se se ovde svodi na neko šiftovanje u levo, kada se množi sa dvojkom za jednom mesto, kada se množi sa četvorkom za dva mesta, a sabiranje se svodi na samo ksorovanje tih nekih vrednosti. Naravno, ovde 1 x 3 očigledno 3 i 1 x 4 očigledno 4, 3 plus 4 je, kada ksorovamo te dve vrednosti očiglednom 7, tako da ovde nismo imali imno mnogo muke i već će ovo naše polje našeg stanja da bude sedmica. Dakle, reakli smo, kad možimo s jedinicom, ništa se ne dešava čak i ovde, a sabiranje se svodi na ksorooperaciju, ako predstavimo ova dva broja u binarnom formatu, vidjet ćemo da izlos koji dobijemo je 0, 3 jedinice, što je heksacifra sedmica. Dobro. Ništa, idemo da dobijemo ovu drugopolje našeg stanja, da bi smo dobili ovo polje, množimo drugu vrstu sa 1 kolonom, odnosno 4 sa 3 i to sabiramo sa 1 puta 1. Dobro. E sad, ovom noženje četvork je sa trojkom se u suštini svodi našta, pa na dva shift, dve shift operacije u levo, pri čemu sve vreme moramo da vodimo raču na onom ne svodljivom polinomu koji je činimi se x na 4 plus x plus 1, odnosno binarno zapisan, sad esno na levo 1 pa 1, pa x na kvadrat nemamo, to je 0, pa x na 3 nemamo, to je 0, x na četvrti imamo, to je 1, ali pošto sve radimo sa četvorobitnim vrednostima, taj kjec nam u suštini. Ne treba on služi samo da maskiramo drugog kjeca, koji će ispasti iz shiftovanja kada bi trebalo da koristimo ksorovanja sa ovim ovdje ne svodljivim ključom. Taku polinomu, tako da ovo u trojku treba dva mesta u levo da rotiramu, odnosno shiftamo. Tako da kada predstavimo samu cifru u binarnom formatu imamo 0, 0, 1, 1, jednom kada pomerimo sve u levo, sve ve strane, s desne strane će nam doći 0, sve ve strane nam ova nula ispada. Pošto ta nula koja je ispala je baš nula, nije kjec, rekli smo u tom slučaju sad ne radimo nikak po dodatno ksorovanje dobijene vrednosti sa ovim ne svodljivim polinomom, već to radimo samo u koliko nam prišiftovanju ispadne kjec sa leve strane. Dobro, jednom smo šiftovali ovo vrednost, treba da šiftamo još jednom. Tako, ove desne strane nam dolazi nula, sa leve strane nam ispada takođe nula, tako da ni u ovom slučaju ne radimo nikakvo ksorovanje sa ne svodljivim polinomom, i vidimo da smo dobili praktično vrednost 12, što jest, kada se četvorka i trojka pomnožerje sve i dalje u nivo ovog modula odnosno kada to predstajimo hek sa cifrem, u pitanju je hek sa cifra c. Kada hek sa cifru c, sberemo sa rezultatom koji dobijamo kada kjec pomnožimo sa kjecama, to je baš kjec, kao zbir ova dva dobijamo kao što vidite cifru d. Dakle, 1, 1, 0, 1, tako da nam je d rezultat ove ovde operacije. I na isti način bi smo dobili i ovo ovde polje i ovo ovde polje, dakle, za ovo ovde polje bi smo pomnožili prvu vrstu i drugu kolonu, odnosno 1 x a plus 4 x f. 1 x a je baš a, a 4 x f opet treba ovo f za šiftujemo za dva mesta u levo. Dobro, prvi put kad šiftujemo to u levo, s desne strane nam dolazi nula, a sada nam ispada ove kjec, tako da sad treba ovo da ksorojemo sa ovim nesvodljivim poljinovom, koji smo upravo predstavili binarnim ciframa, to je 0, 0, 1, 1, i rezultat je, s desne, na levo čitano 1, 0, 1, 1. Ovo je pomnožena cifra f trenutno sa dvojkom i sada još jednom treba da pomnožimo sa dvojkom, da bi to efektivno bila praktično pomnoženo sa četvorkom, tako da opet leva cifra nam ispada, s desne strane dolazi f, pošto je cifra koja ispada i zopsega opet kjec, ponov ove rezultat treba da ksorojemo sa nesvodljivim poljinovom i dobijemo rezultat 1, 0, 0, 1, što je cifra, 9. Tako da četri puta f u ovoj aritmetici po modulu sa ovim ovdje nesvodljivim poljinovom je 9, i a i 9 kada saberemo, dakle, imamo 1, 0, 1, 0, 1 i dobijemo 0, 0, 1, 1 i u pitanju je cifra 3. I na isti način bi smo dobili i ovde pomnožili bi smo četri 1 sa af, pa je to to ostavljam vama da odratite. U stuštini, to kada uradimo, dobijemo ovaj rezultat stanja i sada kao poslednja operacija naše prve runde jeste da dodamo na to stanje ključ prve iteracije koje smo dobili, to je kaj 1, a već smo pokazali u Paint u kako se radi ova operacija, pa ne bih vas zadržava i radženjem ovaj operacije, tako da praktično ovde sada ovaj izlaz sorujemo sa ključem ka 1 i dobijemo neki rezultat. I taj rezultat je ulaz u drugu iteraciju i rekli smo jedina razlika između prvi i drugi iteracije, to tašto sada ovde nema nihako operaciju koja meša one kolone, dakle mi s kolom operacija nam ovde fali nedoste, tako da ovdje imamo samo opet one nibble substitution, to je prostu zamena ovih heksacifara pomoću ovog gasboxa, onda shift rovo operaciju koja samo pomera ovaj donji red za jedno mestu levo, odnosno menja polja ovih heksacifara, menja im mesta i na kraju opet add round ki operacija odnosno ovo stanje se sabira odnosno ksoruje sa ključem kada ako je smo takođu dobili rjonom generisanju ključa odnosno ekspanziji ključa i dobijemo napokon ovu poruku i još jednom molim vas, dakle sada kad vas pitamo šta je konkretno šifrovani tekst, pa šifrovani tekst se čita po kolonama, dakle 8, 9, D, D u heksadecimalnom formatu je rezultat. Dobro, dali imate neko pitanje za bilo šta što smo danas radili na čas, dali vam i ovo sve bilo jasno? Dakle, isto kao i za des algoritm. Na samoj laboratorijskoj vežbi vam dolazi i AS i SAS algoritm što se tiče AS algoritma, tu opet možete da iskoristite simulator koji ste nadam se već preuzeli u stvari sa predmetnog sajta, da malo provežbate sam AS algoritm, naravno, taj simulator imati na samoj labor veseb i onda se sve svodi na nekih nizpitanja o tome šta u kom koraku je rezultat ovog AS algoritma i po neko teorisko pitanje. Dakle, ja si smerja već video od prilike kako taj labor funkcioniše, a onda drugi deo tog laba jeste jedan SI zadatak da vi ručno na papiru bez simulatora, naravno treba da rešite, odnosno da prođete kruz ceo SI sa algoritm, zadati blok podata kako se šifruje i zadati ključ koji koristite za početni ključ. Lab će biti zavisi koji ste smer, ali dakle, u torak sad prvi narednji utorak je lab za IR prvi lab, dakle da se radi des algoritm, a onda naredne meda ljajide AS-i smer,
 imaju drugi i treći lab u istom danu, a onda nedelja nakon te, opet IR-smer ima drugi i treći lab. Dakle, na zmenu, idu IR-SI, IR-SI. I rekli smo ove i lab koji se tiče IS-algoritma i lab koji se tiče RS-side if-helman-algoritama koje ste radi u i na predavanju, imate u istom terminu. S obzirom da se te lab vežbe iz iskustva znamo da se radi dosta kraće od ove des lab vežbe, al opet u se celoj ovi situaciji smo želili da prosto skratimo sve to za jednu lab vežbu, za jedan cel terve. Dakle, na zmenu, idu labovi, a u svakom trenutku, vi svakako možete na sajtu katedre, dakle, rti, tačka je tev, tačka RS, da vidite raspored po predmetima u laboratorijama i moćete tamo i da vidite tačan datum kada je lab vežba za koji predmet. Za zasvitu podata, kak konkretno veći sve unati u sistem, pa možete tamo da vidite ako zaborajte. Dobro, ali imajuš neko pitanje? RS-a je utorak za dve nederlje. Dakle, nije sledeće, sledeće nederlje i dRTI, onda za praktično nekih desetak 12 dana. 12 dana je RS-a, dvijek helman i IS, sve odjedno. Mislim, naravno, testovi su odvojni, tako da vi opet možete da radite samo jedan test u koliko želite, ali u istom terminu se rade objeb. A onda nakon te nederlje ide RTI i onda nakon te nederlje opet CIC-CAC-SI pa RTI i du nadok na delabova. U tome smo već pričali prošle nederlje. Veš neko pitanje za kraj? Dobro, ovim bi smo onda završili današnji čas, sledaće nederlje ćemo raditi nešto novo. Dakle, videli smo ovaj nekim odovi funkcionisani, spominjamo ovdje, 3.5-10 algoritm pa ćemo se malo dotiči tih tema, a do tada vežbajte za lab koji ima lab utorak, pa se vidimo nekom drugom prilikom. Pozdrav od mene, a pozdrav ti od maje.
