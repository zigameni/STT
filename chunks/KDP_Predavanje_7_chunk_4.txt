 tako da ćemo i to koristiti kada budemo a rešavali naš problem. Naše psihronizacijone probleme. Šta smo mi beše sad da radili? Rešavali smo problem proizvodnje semafora a i onda smo videli da postoji ovo ovde tehnika koja dosta često može da se primeni, to je tehnika prostadživanja u sluva ili na engelskom kako se zove passing the condition. Onaj što budi, ono me k'o treba da se probudi a poret toga što šalje signal, a menja stanje. A tako da se odradi posao koji bi treba da bude odrađen u onog tributka kada se taj neko probudi. U ovo je ovdje implementacija, kada taj neko ko treba da se probudi, treba da se probudi, dođe na red da se probudi, u suštini taj neko ne treba da radi ništa ili skoro ništa, jer je kompletan taj posao odradilo onaj ko budi nekok. A ako nam je uslo napromenjiva, koju koristimo, FIFA, ako je uslo napromenja FIFA, u tom slučaju je i monitor, odnosno semafor koji budemo pravili koristići ovdje monitor, takođe garantovano realizovan po FIFA rednosledu. Ok, i to je bilo to što se pravinja semafora tiče. Ajde da vidimo da ponemo još jednom šta sone metode. Rekli smo da je o metodu signal. Wait. Queue. Empty. Porad tih, imamo još neke metode, koji ćemo sada krenuti da koristi. Ajde, imamo metodu, malo če se mi je spomeno, wait. Samo što ko je metoda wait, imamo još jedan argument, koji kaže, ako liku iznosi prioritet datok zahtjeva, znači ako mi želimo da uredimo po kom rednosledu će se neko buditi, mi možemo da stavimo, koliko iznosi prioritet, tog neko ko treba da se proboti. Ako imamo metodu, da postajemo prioritet, imamo ovde dola i metodu da dohvatimo prioritet koja je tu sa najvećim prioritetom. Samo da vas ne zbunim. Ona je koja ima najmanji broj, najmanju rank vrednost, ima najveći prioritet. Znači manja vrednost, veći prioritet. Dobro, mi ovo ovde možemo da iskoristimo, znači da bi smo mogli da napravimo fifo rednosled. Ovo ovde metodu wait koja prijma neki argument, možemo da iskoristimo, ako treba da garantujemo fifo rednosled. Svi imaju ovo ovde metodu min rank i wait sa argumentom. Odgovor je, nemaju, u javi nemamo ovako nešto. Postoje me to da wait koji ima argument, ali ta argument je nešto drugo. Ta argument je koliko vremena. Ja maksimalno čekam da me neko probudi. Či u nema nikako je veze sa prioritetom, manja vrednost, veći vrednost veći prioritet, manja vrednost, manji prijuritet, prijelikom buđenja. Nema nikako veze tamo wait sa argumentom. Znači koliko maksimalno dugo ja želim da čekam, dok legoce nedesi to što ja želim da se desi, to da me neko probudi. Podpunno različite stvari, ali izgleda slično ima argument koje celo broj. Tako da kad glijete, konkretan programski jezik, ga vjernite da vidite šta znači metoda wait. Metoda wait u javi, ako stavite vrednost nula, u suštini znači bez konacu dugo čekaju odnosno, dok se ne pojavi, neko ko ćete probuditi, ko će probuditi datunit, dotle treba da se ček. Jedan to je jedna milisekunda, a ako stavim nula, to je bez konacu. Šta smo reki još da postoji? Postoji, ovo ovde metoda signal all. Ali ovo ovde metoda ima jedino smisla kod monitora koji imaju disciplinu signal and continue. Preostale dve metode imaju smisla iko discipline signal and continue iko discipline signal and wait. Ovo ovde se može koristiti isa c, isa v, ovo ovde samo kod discipline signal and continue. Razlog zašto je još jednom povrnem signal and continue, a ne može ko signal and wait kad kažemo signal, mi garantujemo koja je prvi naredni. Kad kažemo signal all, pa ne možemo garantujemo koja je prvi naredni, ne ima prvog narednog, svi su naredni. I sada krećemo da resvamo naše synchronizacione probleme. Imo nekoliko synchronizacionih problema koje želimo da razrišimo i možemo da krenemo jedan po jedan. Znači ta danas treba da resvimo nekoliko synchronizacionih problema, to je prezvojđar Potrošac. A posled toga imamo čitavac pisac i vidat ćemo da ali ćemo stići da uradimo problem koji se zove berberin koji spava. Ajde da krenemo da odkucamo resvenje za taj naš problem. Da vidimo šta mi je ovde, u stvari treba da imamo odpromenivih. Imojmo jedan monitor i izbaciću ove sve uslu nepromenive, nego samo ono što znamo da imamo u monitoru. Pravimo monitor pa stavljamo ovdje ključno reču monitor imamo niz promenivih u kojima nešto želimo da smestamo imamo tri promenive i jedna kaže size koliko ima nečega i jedna kaže gde nešto treba da se upisuje, to je front i imamo rear promenivah koja kaže odakle treba nešto da se čita. Treba da smistimo koliko u uslu nih promenivih nam je potrebno da bi smo mogli da resvimo ove synchronizacijone problem. Možda može jedna, možda može više. Zavisi da imamo mogućnost uopšte da koristimo više promenivih, jer ako može jedna, ako samo jednu, imamo mora jedna, nema šta drugo. Na primer u programskom jaziku java do verzi 5, poslova je jedina i jedina uslu na promeniva. Dis ne bilo više. A poslo se to promenilo pa su onda one napravili da može biti ipak više. Jer su ukapirali, ljudi baš neznam da programiraju konkurentno, ajde mi da imamo olaksamo da kad oni nađu u neko resenji, u nekoj knjizi, mogu jednostavno da ga trasliraju na programski jaziku java, da ne moraju da razmišljaju, da ne naprove deadlock. Ili da ne naproju neku bezviznu situaciju koja može da se vesije, kojimo samo jednostavno promedi. Dobro, šta je monitor? Klasav? Šta radi ta klasav? Treba da sakrije ubacivanje i izbacivanje objekta iz ovogo ovde našeg buffera. Dobro. Znači ona to treba da sakrije. Šta treba da napišimo metodu put, metodu get i treba da napišimo konstruktor. To je ovde što je stavljeno na kraju iznočil ovih zagradica, beće manje. Treba da inicializujemo ovo je ovde naš objekat. Ok, ajde to sa duradimo i objedimo nekako. Šta treba duradimo je ponovlo a treba da obezbidimo da nekog smije da ubaci nešto u buffer. Saču ja da krenemo da pisem if pa ćemo da vidite ili to treba if ili nešto. Kaj da ja smemem do ubaci if size, jednako i jednako n, ja tad moram da čekamo. Poslice uvidite ili to treba if ili while. Šta ja treba da kažemo ovde? Ajde treba da stajemo dve promenime. Posluštini, pošto znaate već radili ste sa semoforima, možemo da krenemo da radimo na sličan način. To je full, to su dva uslova, soundditian, full empty. Ako size jednako n, ako size jednako n nema mesta u bufferu, ja moram da čekam. Znači ja ću čekati dok se nešto ne oslobodi empty. Wait. Da ćete koristiti oznaku empty.wait ili wait nad empty sasinije sve jedne. Ja ću pisati jošto malo primerenije tim objekti orijenti sa nimi. A, prislupima stavit ću empty.wait. Čekam. Ok, kad ne neko probudi, šta ja radimo onda da ubacimo objekat u buffer to je data od front i jednako t front i jednako ovo je c like front plus 1 pomodulo n, to li koji ima elementa u našem bufferu size plus plus imamo jedan element više i treba da probodimo nekog sa druge strane.