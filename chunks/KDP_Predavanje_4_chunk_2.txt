 da učini beći ne treba jer ja imam ova dva pokazivača meni treba pokazivač, current, gde ja čekam i next, gde će biti sledeći tako da ovo o ovde strukturo ja ustvarim mogu da ubacim u svaki proces koji nekakog čeka znači videte, ovo o ovde ne mora da bude unutaraliste sačuvano nego će svako imati svoj ovde current i next current i next ovo ovde current i next su lokalne promenjive po jedinih procesa to je promenjiva procesa na privir p1 ovo ovde je lokalna promenjiva procesa p2 ovo ovde su lokalne promenjive procesa p3 i šta smo mi uspali da napravimo? mi imamo ovde listu ovo i ne treba nakraja imamo listu, samo što nam je ta lista malo rasturena po memori kako izgleda ovo ovde lista relativno jednostavno je ta lista imamo svaki element svaka nit, ima pokazivač na tekući element i pokazivač na nearredni element šta radimo? čekamo na tekućem elementu kada završimo, puštamo naaredni element imamo jedan globali pokazivač to je last last nam kaže šta se tu nalazi na kraju da je sad jada probam da napišem ovo ovde kao algoritm šta treba dodredimo? jednako neko nju treba da naprajem naš element na koji me čekamo ovde samo što sam napisao ovo ovde dođe šta treba dodredimo? karant karant je jednako last a last je jednako next šta dalje treba da radim? alate na karant na tom polju tu koji ja svarno vredno shoći da pročitamo onda skat sam sačekao to odredim taj svoj posao i šta radim na kraju a treba da kažem next i da sam svoj posao karant.s i next.s da pustim tog sledećeg da kažem da je to jednako true i ovaj naš algoritm čitav cel ha algoritm ovaj je osukrenili da ljudi koriste tek početkom 21. veka može da algoritm nastavio rani ali su oni tek značeno krenili da koriste ovo negde od 2005. godine kada je ovo implementirano u verzi jave 5 a java 5 koristi cel ha algoritm u pozadini a ovdje je taj algoritm šta ovdje stoj? a next je jednako nju? ja radim nešto loko u suštini ja prvem promenimo koju nikon dedira ako delivo toga nema i ovaj ovdje je delo pošto sam ja jedini ja mogu da popet izbacim ove vitičeste zakrte i sad je pitanje ovo za await to nije nikak problem await nad karantom to će biti while current not karant.ovo ovdje s skip to je isto jednostavno čijedini problem je kako da odradim ove ovde dve stvari karant je jednako last i last je jednako neksta dači dali ova dva pokazivača mogu da prevežem nekako jednom jedinom instrukcijo? postoje takve instrukcije koje će nešto ovako odraditi i videćemo kako izgledaju te instrukcije instrukcije su šta sam reko get and set da imi staru vrednost postavi na novog rešta šta sam reko sad get and set instrukcija šta radi get and set instrukcija dohvatimi staru vrednost to je get to je ovo što ćemo mi da postavimo da karant je jednako last and set last je jednako next tako da mi ovo ovde mi smo mogli da zamenimo jednom tom specijalnom instrukcijem da imamo da je karant jednako get and set dohvatim staru vrednost last i postavi last na next to je pod uslovom da imamo jednu ovakvu instrukciju da li postoje baš ovačva instrukcija svuda pitanje u javi postoj napravili su kad su rešavali ove atomski operacije razrešili su jednu ovakvu operaciju najčešće neće postojati ovako složenisto ovakva instrukcija nego će postojati jedna vrlo jednostavna instrukcija to je instrukcija svop za meni neka dva a vi možete da smislite kako ovaj ovde algoritm može da se realizuje koristiti najubičniju svop instrukciju treba da se postihne fk ali da to malo drugačije napišta či to je vaš sad posto da vi nekako smislite kako koristiti či neku drugu instrukciju šta sam rekao svop instrukcija koja za meni a i b svop a i b šta ona radi t je jednako a ok, a je jednako b b je jednako t ovdje odradi taj svop i sad videte da možete to nekako da... te ne vraćate nigde te je lokalna promenjiva tog tu, to bi bio lokalni registar b našeg procesora na primer način nešto što se ne vidi što ne ostavlja nikakav rezultat mi je da smistite da možete realizovati koristiti tako nešto ajde se vratimo na kod ovde su malo... kao što su malo čas spomenuo malo drugačije označeni pokazivači a, način current to je ovo ovde što se zove null što se zove previous tail je ovaj posledni element a node je next ovno kako sam ja malo čas to nazvo, način ovako su oni nazvali pa je onda to prepisenu tako iz tradicionalnih razlogađa meni bilo lakso, onako dobjašnja na primeru što smo rektili node a da je node je taj prvi naredni na kome treba koji mi krjeramo, način node je jednakotru krjerali smo tu promenimo koji će biti dostępna to s ovde pravi na hipu sa nekomožda kaže čegaj, a kako to ja nju mogu da naparim kad nemam synchronizaciju a možete da pogledate knih ovnu knjigu, konkurentno distribuirano programiranje tamo imate moguću da vidite, a kako se ovo reciklira da nemoram, ja možda svaki put da kreiram ovu promenjuvu next nego da ja to možda mogu da recikliram da punim neki pull i da to posle mogu da koristim ako nema napraviću da se ovo što bi pravi o ponovu pa da troši vreme karmicu kolektoru što ne bi napravili da se to reciklira privius je jednako tail privius je ona i nakome ja čekam to je moj current tail je oneg poslanji element tail je jednako node, ta dva treba da se odrade atomski, način vidite, nemam uzništini lista ovde ne postoji kao struktura lista je ovde rasparčana svaki proces će imati šta je moj element i šta je naredni element na taj način je obezveđeno da postoji lista kao struktura ali lista kao samonosnit će struktura koja postoji kao takva odegda u memori gde imamo tekući i naredni i da se to olo boža lepo pratiti, ne postoji ona je isetskana i svaku ima po jednu parče date, liste ovde je uzito da samo mi čekamo kontra usluvu, način ja sam čekao na tru, tako se ne postovi a ovde je da je locked uzleta vrednost da je zakričana kako je postavljeno da ovde funkcioniše tail je jednako false a ovde je napravljeno da prvi može da krjene da radi, kajom ovde je uzleta kontra logika u odnusu na primer koji sam ima oče crto primer sam crto o sony moznak da vama bilo ovakši da pratite kako su kreg, landini, hager, ten napravili ovde je CLH algoritm teško mi je da pamitim ovdje imena pa sam zapam ti da je to CLH u suštini ako uzmeti da gleda te knjige pisat će da je to CLH algoritm