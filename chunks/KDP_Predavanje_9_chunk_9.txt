 U smetrskim procesu smo reklili, imamo graf neki. Imojmo naše procese gde imamo odrećen broj ulaznih i odrećen broj izlaznih kanala i nekako treba da povežemo sve to, neko će sve to da poveše ko neko. Prepuštamo nekome da taj neko odreće. So za nas. Ono što sada hoćemo da radimo je u sestini već prelazimo na drugu stvar. Kojimo mu u konkurenci, u distribuiranom programpiranju. Prelazimo na nešto što se naziva klijen server. Klijent uputi server u zahtev, server odradi odgovor i vrati nazad odgovor. Imaćemo server koji će određivati posao, imaćemo klijent koji će slati zahtev što treba da se radi. Ono što smo pretkudno imali, su bili filtrski proces. Inači povezali smo veći broj procesa da nam odradi posao. Sada to nećemo raditi koji se naziva klijen server. Kaj koji ćemo imati klijent u puti zahtev serveru, server treba dobro odradi posao i da vrati nazad. Alocas koji se prospilitiravano se je ideja bila, hajde da povezemo veći broj. Takvi procesa tako da naša obroda može da se obrvi, možda brši. Sada ne želimo to, želimo da neko drugi tamo na nekom drugom, možda boljim bržem racunaru odradi neki posao za nas. I sada hoćemo da vidimo kako se pravi takva komunikacija. Server će imati svoje sanduče, odnosno svoj kanal, preko koga može da radi im zahteva, znači znači radi ćeri kvest i radi ćeri plaj. Kome odgovara? Šta radi? Ko su svari koji neko mora da nam kaši? Poči da nam kaši, kad server dobio poruk, od kod zna od koga je dobio poruk, on ima jedan kanal preko kog nešto gleda. Ko znači? Značimo, kot kljen server architetu, a imati potrebu. A onaj što upućuje zahte mora da kaže, ja sam taj-taj potrebno da mi se odradi sledaći posao. Šta sam sad rekao? Kada se upućuje zahteva, je dovoljno da se kaže, evo ti vrednosti odradi posao. Šta ja želim da dobijem nas do odgogora? Moram ja da se predstavim. Če nije da bilo ko dobije odvorno pitanje koje sam ja prosledio, i meni bitno da ja dobijem odvorno, da su prosledi. Moram da kažem koje je pitanje i moram da se predstavim na neki način. To ćemo raditi koristići da se u kumulijaciji šalje i ovaj ovde client ID. Javi, odnosno u višim programskim jezicima, je to nekako realizovanu kroz sokete. Kada mi kažemo da želim da ospostavimo okoneksiju s onom drugom stranom, TCPIP, odnosno sokete će formirati nov kanal, gdje ćemo imati dve krajnje tatke. Ona je ko prima poruku i ona je ko šalje poruku će biti na svojoj IP adresi i svom portu i na ta i način ćemo mi moći da tačno znamo, sa kim komuniciramo. Tačno znamo šta je IP adresa i porca, one druge strane i mi sa tom tamo stranom komuniciramo. Nećemo morati mi u samu poruku onda da ugradžimo. Kosa sam ja? Oveć ugradženo sam protuku će to verat, ugraditi za nas. Dobro, način da smo rekli, imaćemo klijen server, klijen će morati da se predstavi. Server kada osvali odgovor, to ćemo će da radi, tako što će da izvucemo šta reply kanal ako postoji ili tako što će morati na osmog klijenta idea da iskopa nekako izliste klijenata njegov komunikacijoni kanal i u taj komunikacijoni kanal da uplaci poruku. V svakom sluči klijen će imati svoje poštansko samnočno sluči u svoj kanal preko kojom dobija zakti i svaki klijen će morati da ima kanal preko kojom će dobiti odgovor. I kako onda izgada server? Ima jednu jednog operaciju koju treba da obatni. Server-ski procesiv. Se najčešće izvršavaju u jednoj bezkonečnoj petlji. Znači server šta radi? Primi zaachtim, odradi zaachtim poštani odgovor. Primi zaachtim, odradi zaachtim poštani odgovor. I kod jednog servera izgleda ovako. Receive. I šta tu imamo sada? Klijen taj bi. Moram da se pretstavim, kaže, ja sam taj taj, meni treba da se vrati nazad odgovor. I onda su ovo ovde ti argumenti šta treba da se rati. Server-odradi posao koji treba dodradi na osnovu tih vrednosti kojemu je neko prosledio, ali i na osnovu svoj internog stanja. Odradi neki posao i onda dobije rezultat i onda šta kaže? Ono me ko se predstavio kao klijen taj bi, evo odgovora. Vi ćemo ovde to da napravimo ovako, tako šta nekone nam se predstavio, a to može da bude ujavi direktno kroz taj i komunikacijuni kanala koji će onda biti bi direkcijuni, gdje će se uzraštini dinamicki formirati to s kim mi treba da komuniciramo. Znači, dal ćemo mi ovako statički ili ćemo dinamicki to komunicicima. Napravimo, to će zavisiti od konkretnog jezika. U svakom slučaju, onaj, ko treba da radi obradu, to je server, mora da dobije identitikator u svojega kome treba odgovor da se vrati. To je veoma bitno, dal se to izlači. Samo komunikacijunog kanala, takošto protokol to odradio za nas u posadini ili tako što je ovaj mora directno da se predstavi, zavisite od konkretnog jezika. Ali u svakom slučaju server mora da dobije informaciju o tome, s kim priča. I ovo bila priča za server koji ima jednu jedinu peraciju. Kako izgleda klijentski proces? Klijent, serveru kaže odradim i to i to. I onda od servera očekuje da dobije odgovor. Ovo što smo mi ovdje napravili? I nešto je s to već počinje da liči na monitor. Malo če smo videli da komunikacijunog kanala sam po sebi može da zaliči na semafor. A ono što smo mi ovde krenuli da radimo sa ovom klijent, server, architetur. Je da pravimo nešto što se naziva aktivni monitor. Ovde je aktivni monitor koji ima jednu jedinu operaciju koja ne blokira ića. A ono što ćemo mi raditi na naradi casu, vidite ćemo kako izgledaju aktivni monitor sa više operacija, a kako oni mogu da se realizuju, način kako da se napravi sve to u pozadini, da oni funkcionišu, da možemo da razmenjimo porukje, da mogu dodrde neki posao za nas, da možemo dodobiljimo odgor, a da se ne zablokiraju. Ovi naši aktivni monitor. Šta imaju? Imaju jedno postavsko sanduče, preko, odnosno, jedan komunikacijunikan, preko kog dobijaju za akteve. Šta treba da radi? Imaju jednu nit koju treba da radi, to što treba da radi. I treba da nam šalju nekako odgogor. Ovo ovde je, da kažemo, servererjska strana aplikacije koja ima jednu i jedinu nit. Javi ćete vidjeti da to ne mora tako da se realizujete, tamo možemo dinamičke napravo niti i tamo se obrda u suštini radi malo drugačija. Manje više izgleda isto. Primi za aktev samo što ovo ovde, ovaj drugi deo poslav, neće raditi u datoje niti, nego taj posao ubacite u neki pool niti i onda neka nit iz poola niti uzme, izbazena niti uzme taj posao, odradi posao i prosledi odgog. Kažem, serveri izgledaju obječno tako. I ako ste nekada konfigurisali neki server, tamo ste mogli da kašete, koliko niti želite da obslužuju za akteve. Primi ako ste podešavali web server ili aplikativi server ili server base podataka, tamo vas pita obječno visor da kogu go koristite, ako liko niti želite da stavite, možete stavite jednu-jedinu nit, to će raditi, možda će biti sporia ako imate veći broj, a i izgara, možda i neće. To zavisio toga kako je obrada koja treba da se oboblja. A ono što će u mi razrađivati kroz ovaj aktivni monitor, odnosno kroz sve o taj koncept je nešto što se zove event3 na arhitektura, gde će u mi moći da naprimu sistem koji reaguje na dogadje, koji će sve to obradivati u jednoj biti. Ostat ćemo kažem razmatrati, naravne nedelje je klijent server arhitektura, koristiti aktivne monitore, koji će imati jednu nit, ali će imati veći broj operacija koji za klijenta mogu da budu bakljereći. Ka sam sad reka, mogu biti bakljereći. Kako izgledaju klijenti u klijent server arhitekturi, možete stvini uvijek izgleda.