 Dobro, evo sad se snimamo, sam mi recite, da li vidite moj ekran trenutno, odnosno sadržaj sam je prezentaciju o ovom sluču. Vidimo, vidimo. Dakle, kašto rekoh danas imamo nekoliko tema i prvo ćemo da je pričamo šta je to triple des algoritm, zašto ono opšte nastao i zašto opšte nismo mogli da iskoristimo double des algoritm kao tu neku varijantu samog des algoritma. Malo smo pričeli na predkonim času imamo na koog ugrubo šta je taj triple des double des algoritm, to je prosto više iteracija istog des algoritma koje funkcionišno na neki konkreta način, pa prosto nekako u glavinam je prvo pitanje zašto double des algoritm nije bio moguć za korišsini, odnosno zašto je nepraknicam. A kada zavišimo sa tom temom oko triple desa, onda ćemo napokon da suvedemo u modele funkcionisanja da vidimo šta su to modele funkcionisanja, kako nam oni pomažu da prilagodimo konkretan skup podataka i konkretan algoritm koji koristimo, bilo koje je aplikacija, bilo sam algoritam nekog streamovskog tipa ili nekog blokovskog tipa, dakle prosto da nekako u kombinujemo sve ono što imamo na raspolaganju za ono što nam je dato kao neki c. I u okviru tih moduva funkcionisanja mi ćemo se danas baviti moduva funkcionisanja koja vidite ovdje na slajdu, to je nekih šest trenutno moduva funkcionisanja, ECB, CBC, CFB i OFB, onda Ctr i na kraju CC mod funkcionisanja, za one koji su slušali predmet i prošli godina, ovo je nov mod funkcionisanja koji nismo učili predtkoni godina, tako da ovo nešto što svakako nemate na starim prezentacijama, ali nemate niju knjizi, tako da u suštini ovo što danas budemo videli ovde će vam biti prakatično jedini materiali koje vam mi nudimo, naravno internet postovi pa ako nešto nije jasno možete tamo da pretražite, ali trudi ćemo se da vam detenno objasnimo taj mod funkcionisanja, so obzirom da on čak je kompleksni od predhodnjih, ne samo što je nov nego i kompleksni, i tu smo pripremili neku simulaciju tog konkretnog moda funkcionisanja, pa ćemo sve biti tosta jasnika da prođemo i kroz taj simulator, i taj simulator ćemo zadnju sa prezentacijom i s nimcima, sa časa da okacimo kasnije nam u. Sledaće nedelje nam ostaje još jedan mod funkcionisanja koji ćemo ovde da dodamo, i na kraju pregled i modova funkcionisanja koje nismo ovde spomenuli, ali svakako postoje, čisto da vidite da je postoji dosta i prosto da vidimo i neku njihovu potrebu i primenu i neku njihovi ideju bez ulaženja u neke detalje, tako da ideje da sledaće nedelje to doveršimo prenego što pređemo na nov oblast, tako da imamo dosta tih modova funkcionisanja i sam ovaj triple des, tako da treba da se ovjasni, tako da haj da da krenemo odma sa samim gratifom. Dakle triple des algoritm je algoritm koji je nastao zbog prosto sve većih napada, brute force napada na sam des algoritm. Prosto des algoritm pričali smo kada smo ga radili da njegova veličina ključa, odnosno, ekaktivni ključ od 56 bita koji se koristi nije bio dovoljan da se spreče sami brute force napada i u nekom trenutku. Naravno, on je bio dovoljan dok technologia nije napredovala do temere kada je 56 bita prosto bilo premalo bita da se spreči brute force napada ispog toga smo pričali da je prosto postojala potreba da se des algoritm zameni nekim drugim algoritm. I od atle nastala ona ideja o isu bio, ona i ceo konkurs, is je nešto što je danas zamenilo stari des algoritm. Međutim, prenego što je is design Iran, nekako, s obzirom da je design samo algoritma dosta kompleksni od iskorišćenja nekog, odnosno, design nekog novog algoritma, prosto kompleksni proces od iskorišćenja nekog starog algoritma na neki drugi način, odnosno da pokušamo da poboljšamo neki starija algoritma i da ga iskoristimo. Prvo što se pojavilo kao neka ideja za zamenu starog des algoritma, jeste da se des algoritam u napredi, tako što će on više struko da se primeni na neki konkretan način. Dakle prosto to je bilo prvobitna ideja, jer to prosto onda ne zahteva nikak u dodatnu realizaciji nekog novog algoritma i osmišljavanje same ideja nekog novog algoritma, nego koristimo već postojići algoritam na način koji će nam obezbediti da oni brute force napadi više ne budu toliko uspašnje. Dakle ideja je nekako da iskoristimo algoritam, tako da prosto nekako efektivno povećamo ona i ključ koji se koristi za des algoritam na neki veći broj bitak koji će biti takav da su ti brute force napadi on je mogućeni. I prvo ono što se razmatralo je bio taj double des algoritam i vidjet ćemo već na sljedećem slajdu kako on izgleda. Ali odma da kažemo, dakle prosto i ako je on na prvi pogleda vidjet ćemo detaljno obezbeđivao bolju zaštitu des algoritma, i da se nekako efektivno imao taj neki veći ključ koji se koristi. Opet sigurnost nije bila zadovoljavajuća odnosno svela se na sigurnost samog des algoritma jer se prosto u nekom trenutku osmislju taj specifican meeting the middle napad koji najveoma jedan specifica način napada sam algoritam, tako da ga svodi na brute force napad na sam des algoritam. I tog razloga taj double des i vrlo brzo otpav ka opcija u napređenja samog des algoritma i od atle se javila potreba za triple des algoritm koji prevaziš ove meet and middle napad i obezbedio da sam des algoritm bude dovoljno nekako siguran da te brute force napade omogući da se odbrani od njih. Tako da, hajde prvo da vidimo zašto opšte double des algoritam nije mogo da se iskoristi zašto on nije bio praktičan i primeniv prenego što pređemo na sam triple des prenego što vidimo kako izgleda triple des algoritam i kako je praktično njegova sigurnost. Dakle sam double des algoritam možemo da vidimo njenu njegovu šemu na slici sa desne strane za enkrypciju i dekrypciju. Idea je da plain text koji ovde označen slovom p prođe kroz dva des algoritma koji su označeni ovim nekim boxom sa slovom e sa dva različita ključa k1 i k2. Na taj način, ono što možemo nekako da pretpostavimo, jeste da od ovog plain texta do cipher texta naš plain text kako prolazi kroz dva ova enkrypcijona des algoritma i koristi dva različita ključa. Ključa praktično nekako dovodi do toga da je odnosno svodi se na to da je kao na ovim plain textom primenjen jedan veći neki des algoritm či je ključ neka kombinacija ova dva algoritma odnosno neka kao konkatenacija, pa efektivno smo povećali samu veličinu ključa sa 56 na 112 bita, jer prosto dva puta smo prošli kroz sam algoritm, odnosno kada posmatramo sa strane dekripsije prosto ponovotreba kroz dva neka dekripsijona algoritma da prođemo, tako što koristimo ove ključeve u uprotnom redesledu. Tako da ovde nekako na prvi pogled Brutforce napad bi zahteva od nas da isprobamo sve moguće kombinacije za k1 i k2 i onda u nekom trenutku da dođemo do plain texta, a da bi smo isprobali sve moguće kombinacije za k1 i k2 kažem prosto nam treba neki 112 bitni podatak. I na ta i način prosto nekako su ljudi pomisli li ok, ovo je dovoljno sigurno, jer sad Brutforce napad više nije tolka pretnja pove algoritme, jer 112 bita je sasvim dovoljno da spreči taj Brutforce napad za tadašnje mogućnosti računara. Međutim ovde se sama ideje ovog algoritma prosto dovodi do jednog specificnu, do mogućnosti jednog specificnu napada koji mi ovde nazivamo myth in the middle napada. Koja je ideja tog napada? Dakle ideja opet nekako Brutforce technikom doći do same poruke, ali ne isprobavajući sve moguće kombinacije za k1 i k2, jer bi to značilo da imamo 112 bita, pa sve moguće vrednosti za tih 112 bita što nam nije zgodno. Već treba da nekako podelimo ovu celu šemu na dva dela i da zasebno svaki ovaj enkrypcioni algoritam napadnemo Brutforce napadom sa jedne strane. Odnosno ako pogledamo nekako šemacke kako možemo da prikažemo ovu poruku, vidimo da se poruka c, odnosno cypher text dobija kao primenje na prvoj enkrypcija sa ključem k1 nad p1.
 tajim tekstom, pa nad celim tim enkryptovanim blokom primanimo ključ k2 i opet izvršimo neko šifrovanje desom i tako dobijemo ovaj sajfer tekst. U pogledam ovu sredinu vidimo i označimo sx, vidimo da nju možemo po ovom zapisu da je zapišemo na dva različita načina. Dakle, x sa jedne strane može da se dobije, tako što nad samim plain tekstom izvršimo šifrovanje koristit ći ključ k1, dakle to je taj neki među rezultat od plain tekst do sajfer teksta, ili sa druge strane ako za sajfer tekst dovedemo na ulaz algoritma sa ključem k2, opet ćemo doći do tog nekog među rezultata koja označavam o sx. Tako da rezultat prve enkrypci plain teksta može da se zapiše ovako, a može da se zapiše ovako. I onda se ceo, meet and the middle napad svodi, tako što prosto isprobamo sve mogućnosti za k1 i provlačeći ovaj neki plain tekst, isprobamo sve mogućnosti zasebno za k2, provlačeći ovaj sajfer tekst i nekak upoređućite vrednosti. Tako da bi smo prosto izvršili ovaj napad, nama je potreban jedan par pozna tih plain tekstova, sajfer tekstova, tako da ovaj napad je, dakle tip napada je samo prosto poznavanje i plain i sajfer tekst. Kada imamo taj poznat par plain teksta i sajfer teksta, mi prosto možemo brute force napadom sa svim mogućim ključevima za k1 na dovim plain tekstom da dobimo sve moguće vrednosti za x, a sa druge strane ponovno koristeći sajfer tekst koji nam je isto poznat isprobavajući brute force napadom sve vrednosti za k2, ali koristeći dekripsijun i algoritm ponovno da dobijemo sve svih 2 na 56 mogućih vrednosti za x. I ono što praktično samo treba da uradimo kada dobijemo te vrednosti, ja evo mogu i da nacetam, Dakle dobijemo sve moguće vrednosti za x prvim načinom, odnosno isprobavajući brute force napad na one prvi način i sve vrednosti za x isprobavajući brute force napad na drugi način, ono što prosto možemo ovde sad da uradimo jeste da sortiramo na neki način obeta bele i da tražimo poklapanje u nekoj čeli ove tabeli u nekoj čeli ove tabeli. Ako nađemo poklapanje, to tačno znači da je to to neko x i da za baš tu neku kombinaciju ključeva k1 i k2 smo mi od cipher tekste sa ključem k2 dobili to x, a od plain tekste sa ključem k1 dobili isto to x, što znači da ovej poznat plain tekste i ovej cipher tekste koji nam je takođe poznat za baš ove dve kombinacije ključeva čekao taj među rezultat da ima to x. I na taj način smo prosto opet nekom vrstom brute force napada svodeći ovaj nekakog algoritam na neka dva dela došli do konkretnih ključeva, jer iako je efektivni ključ bio nekih 112 bita, prosto mi smo ovom nekom podelom se sveli na dva brute force napada koja napadaju ključ od 56 bita, što reklismo da je sasvim dovoljno da brute force napada može vrlo brzu da se izvrši, tako da na taj način smo došli do oba ključa. I to je nešto što se zove prosto meet in the middle napada. Dobro, da li sto ovo razumnevi? Ano smo da imate pitanje. Može pitanje? Može. I ovo to znači da ovaj triple desk onima sigurnost na njim u ovo dva ključa, a ne tri. Tako je, tako je. Aha, ok, ala. Ništa. Da, ovo je još neko pitanje. Dobro. I očigledno jasno nam je dovoj double desk ne može da funkcioniše kao zamena za desk algorita, jer prosto i ako ima efektivno veći ključ od nekaj 112 bit, tako možemo da to zamislimo prosto i da imamo met in the middle napada, mi možemo sej al algoritm da svedemo na dva neka desk algoritma ko napadamo zasebno i onda dolazimo do oba ključa koji se koriste u double desk algoritma. I u datle nastala ideja o triple desk algoritmu, gde se sada koriste tri šifrovanja, jer sada praktično, ako bi smo pokušali taj napad, onda to ne bi smo uspeli kao što je kolega sada i rekao, imamo sada tri neka bloka koja šifrojemo od plain texta do cipher texta i sada ovdje imamo neka dva među rezultata xipsila. Ako bi smo preko x'a pokušali da brute force napadom dođemo do ključeva, s jedne strane bi smo brute force napadom napali jedan ključ od 56 bita, ali sa druge strane imamo opet neku kombinaciju dva ključa, či efektivno vredno su 112 bita, tako da praktično brute force napad sa desne strane u ovom slučaju ne bi uspio, jer prosto 112 bita je dovoljno za one mogućavanje brute force napada na danasnjom računarima. Sa druge strane, ako bi smo pokušali da se dovedemo na rezultati xipsila, no opet s jedne strane bi smo imali brute force napad sa samo 56 bita za ključ, a sa druge strane opet nekako moramo kroz 112 bita. Da prođemo čime je opet ove brute force napad sa leve strane one mogućen, tako da meet in the middle ovde ne funkcioniše. Tako da ono što moramo da uradimo, je sti da moramo da koristimo 3 shiprovanja i odatle nastoj triple des, i onam je za sada je skroz dovoljno dobar da može da se koristi, dovoljno praktično da može da se primenjuje, uširemo opsiju aplikacije, videćemo, kastnije i radićemo neke konkretne technologie každu su PGPS, majem da se koristi baš algoritm, dakle prosto i danas je upotreb. Ali ono što se postavlja, kao pitanje je, jeste dali su nam stvarno potrebna tri različita ključa, odnosno, dali je potrebno da imamo ključka 1 sa jedne strane, pa k2 na drugom, enkrypcionom algoritmu, pa k3 na trećem enkrypcionom algoritmu. Pa neka istraživanja su napravljena, ali bi možda neka kombinacija ključeva k1, k2, pa opet k1 omogucila neke druge napade i postoje naznak je da postoje neki napad i na triple desk sa dva ključa, ali prosto nijedano tih napada za sada, koliko ja znam, nije bio praktično primenji, tako da za sada triple desk može da se koristi sa ovom kombinacijom od dva ključeva, onda prosto manju količino informacije moramo da pamitimo. Na strani slanja i prijema, dakle za 56 bita manje, jer imamo dva različne ključa, koje koristimo u kombinaciji prvi, drugi prvi, ali prosto da izbegnemo tu neku mogućnostu tog napada koju još uvek nekako nije dokazan, postoji kombinacija, odnosno variacija na temu da se triple desk koristi sa tri potponosti različita ključa, k1, k2 i k3, i onda smo sasvim sigurni da nikun je može nekim novim specialnim napadom da nas napade. Ono što se dodatno, ovde stavlja kao, odnosno što se dodatno dostavlja kao ideja o algoritmo, odnosno kako se koriste ovi blokoi, s obzirom da koristimo desk algoritm tri puta, postoji se pitanje, da ali uvek koristimo enkripsijun i algoritm za desk, ili možemo nekada i dekripsijun i algoritm za desk, da koristimo i koja je ideja i zašto je neka kombinacija ovih enkripsijunih, dekripsijunih algoritama bolja, zašto neka lošija. Ono kako se koristi triple desk, danas u glavnom, jeste sa ovom EDE sekvencom, dakle, da je prvi blok, sad nije bitno da su 2 ili 3 ključa, odnosno da je ovde na kraju k3 ili k1, da je se prvo i ovi blok, odnosno sam plain text provlači kroz enkripsijun algoritm sa k1, pa se taj među rezultat provlači kroz dekripsijun i algoritm sa ključem k2, i naravno ovde se njišta praktično ne deshifro, koristimo totalno drugi ključ, dakle, enkripsijun i dekripsijun, algoritm sećete sučili, smo su veoma slični, jedno i drugo stvari rade neko šifrovanje, pakost se koristi isti ključ, značimo, stvarno do deshifrovanje, ovde kad koristimo neki potpuno drugi ključ sa dekripsijunim algoritm, bukvalno dobijamo efekat nekošifrovanja, tako da ne postoji neka konceptualna razlika, da ćemo koristiti e ili d u nekom trenutkom, međutim, zbog kompatibilnosti sa starim aplikacijama, koji su koristili single desh algoritm, dakle samo jedan algoritm, koristi se ova kombinacija e.d.e. Jer, hajde naprimer da koristimo dva ključa, pa da pokažemo to, ako koristimo e.d.e. kombinaciju i ključeve po redosledu k1, k2, pa ok...
 k1 onda prosto možemo da koristimo i ovaj triple des tamo gde smo nekada koristili single des tako što ćemo reći da ovaj ključ k2 jednak ključu k1. Dakle prosto da su sva tri ključa ista i da u slučaj da imamo k3 da i k3 jednak k1 jer ono što sada dobijamo kada ncryptujemo nešto sva ključem k1 i decryptom isto to nešto sa ključem k2 jeste baš to nešto što nam je došli i na uloz ovdje jer prosto šifrovali smo plain text dobili neko x i sasmo desifrovali to x sa istim ključem pa dobijemo naravno nazat plain text i onda ono što nam efektivno ostaje jeste jedan ncryptjoni algoritm za plain text sa jednim ključem kojoj nazivamo k1 odakle se dobija i tako smo prosto triple des algoritm sveli na single des algoritm tako da prosto aplikacije koji su koristila single des i dalje mogu da se koriste s ovim ovom ovde varijantom pa imamo tu backward compatabilnost dobra dalje ovo jasno dalje vam je jasna ideja triple desa i dalje vam je jasno prosto kako on funkcioniše zašto postojova edd se krenca i zašto onaj mitin domidul napad više ovdje nije mogući dobra ako jasno idemo dalje dakle ovo je prosto bilo neka kratka priča neki uvodu triple des algoritm ko ga zanima u knjizi možete znađete neke napade koji su koji su sprovedeni na triple des algoritmom nakle te naznake za napade koje mogu da postoje pa ko ga zanima može tamo da se informiše više o mogućnostima napada na taj algoritm i zašto je prosto nekad bolje koristiti prenevo triple desa u svakom slučaju to je bilo neki uvoda sada do kraja prosto i ovog časa i sledaček časa ćemo raditi temo odove funkcionisanja i kažem ima ih dosta i vidjet ćete ima dosta ovde nekih šema tako da prosto koncentrišite se sada maksimalno da biste uspeli nekako da pohvatate kako sve ovu funkcioniše, ja siguran sam da nećete uspeti da zapamtite kako izgledaju sve ove šeme već ćete da morati sami da prođete još jednom kroz sve to svakako ali prosto se trudite da pohvatate kako one funkcionišu jer ako razumete kako one funkcionišu, vrlo lako ćete moći u glavi nekako da skicirate sami sebitu šemu koju koristi konkretan mod funkcionišu. Često znaju da se pomiješaju modove, po prosto ako ih razumete, mi se nemojte da učite napam, to je prosto pojem tako i želim da postim. Šta su opšte modove funkcionisanje i čemu oni sluše? Dobro, mi kada smo pričeli o blok algoritmima, rekli smo da oni, z razliku do nich stream algoritama, šifruju blokove neke fiksne veličine, dakle kako celete blokove. Na primer des, on šifruje blokove 64 bita, nekim ključem od 56 bita, onda a s neki drugi veličini ima i tako dalje, ali prosto cel blok se od jednom šifruje. S obzirom da nekako poruk je u glavnom nisu tih veličina, u generomlu praksi prosto ko lječina podata kako je žalite da pošaljete, i možda da bude i manja od ovog veličina bloka, na primer za des, a koristimo, želim da koristimo des, a možda da bude i znatno veća od ove veličine bloka koji koristi des. A na primeri imamo neki algoritm koji moramo da koristimo, dakle imamo koji ličinu podataka koja je nebitno hiljado nekih bitova, koristimo prosto algoritm koji ne radi sa blokom od hiljado bita, nego s nekim manjem blokom, prosto nekako moramo da iskoristimo ove algoritme u praksi, da ih u kombinojmo na taj način, tako da prosto može, da je, ta algoritm može da se prilagodi našoj poruc i odnosno da se prilagodi veličini naše poruke koji ušalja. I generalno postoji nekoliko rešenja konkretno za des algoritm koji su definisani u ovom nekomansi standardu u 83. godine, ali danas postoji gomil o nekih tih modova funkcionisanja koji omogućavaju da bilo koji simetrični blok algoritm, dakle i des, ali i as i triple des koji smo malo prevideli, nekako iskoriste, tako da za bilo koju količinu podataka koja šaljemo, mi to nekako kombinojmo na način koji odgovara, to je naše aplikacije, dakle prosto modova funkcionisanja nekako s jedne strane omogućavaju da se proizvojna kolečina informacija šalje sa algoritmima koji rade sa manjom kolečinom informacija, a sa druge strane da prilagode prosto taj algoritm koji imamo našoj namenu, odnosno prosto aplikaciji koji u koju koristimo to, koje nam je potrebno to neko šifro. Nje videte, postoji blok i stream modovi, nakle neki koji prilaguđavaju same blok algoritme, blok, odnosno blok modovi, blok algoritmima, ovi stream modovi nekako imitiraju stream algoritma, ali opet koristeći blokovski algoritm, jer u nekim slučavima imamo tok podataka ali nemo njiha na algoritm koji radi sa tokom podataka, nego nam je dat algoritm koji radi sa blokovima podataka, pa kažem potrebno to nekako prilagoditi, naprim. ovaj des prilagoditi, tom našem toku podataka koji nam nadolasi. Tako da prosto modovi funkcionisanja nam služe da nekako prilagodimo i poruku i seve naše te algoritme koji imamo, o nome što nam je potrebno u našu aplikaće. I prvi mod funkcionisanja koji ćemo da spomenemo, spomenemo jest to je elektronik codebookbook odnosno skračeno ECB mod funkcionisanja koji je jednostavan i to ono prvo što nam se nekako nameće, kada razmišljamo o tome kako sada iskoristiti neki enkripsion i algoritm, naprim. des, naprim. koji radi sa 64 bita bloka, u koliko imamo poruku koja dosta duže od 64 bita. I stvarno, ono što nam prvo pada na pamet, je se da podelimo tu našu poruku na blokove od 64 bita. Tako da imamo nekih u proizvoljnom slučaju n, u opstu slučaju n blokove od 64 bita, jer znamo da naš naprim. des algoritm, ali kažemo, ovde može da spoj bilošta i is, des i triple des. Da prosto naš naprim. des algoritm, znamo da on radi sa blokovimo 64 bita, pa njemu prosto na ulazu ne možemo da dostavimo ništa manjen i ništa viša od 64 bita. Tako da prosto delimo poruku na blokove od 64 bita i svaki blok nezavisno šifruemo koristit ći, naravno, isti ključi, isti algoritm svaki put, da dobijamo blokove šifrovane poruke koje na kraju konkateniramo i na taj način dobijamo jednu veliku šifrovanu poruku. Naravno, postavlja se pitanje šta se dešao u koliku sama poruku nije deliva nekako sa 64 bita, pa prosto to je uredu. Dakle, ovaj poslini blok će efektivno da ima manje, da kažem, bita koje stvarno se drža informacije o poruci, ali možemo ostatak samog bloka da dopunimo nekim proizvalnim. Podacima koji za poruku ne znači ništa, da odnosno da imamo neki padding, tako da prosto dopunimo i ta ideo poruk je do 64 bita, da bi on mogao da se iskoristi u koristući konkretan blok algoritm koji je trenutno upotrebio ovom slučaju, kažem, sve primjera ćemo nekako raditi sa des algoritm. Tako da, eto, prosto poruka se deli u nezavisne blokove koji su odgovareviće veličine za blok, u zavisnosti od bloka algoritma koji koristimo i svaki se šifro je zasebno koristeći isti ključ i dobijemo zasebne blokove šifrovanoj teksta koji se na kraju kongateniraju, dobijemo šifrovanu poruku. Samo ime Codebook je nastalo od cele ideje ovog algoritma, gde je prosto nekako bilo koji šestetvorobitni podatak mijenjamo u neki drugi šestetvorobitni podatak, ponošto možemo da uradimo praktično jeste da imamo neki šifrarnik, dakle neki kao Codebook, gde imamo za svaki mogući ključ prosto i za svakom moguću vrednost ovog ulaznog plaint teksta izlazni cyfer tekst koji se dobija u kombinaciji tog ključa i te poruki. Mislim, naravno, to nije nikakva efika smo uraditi, ali prosto od atle ideje, dakle prosto šif, kao neki šifrarnik se iz ovog enkripsijunog algoritma kaže, koristimo je ključ i ovaj plaint tekst, dobro dobijemo ovaj cyfer tekst, isto je neke tabele i od atle nastalo ime samog moda funkcionisani. Naravno, dekripsija, jasno je...
 da je vrlo slična enkrypci, dakle prosto uzimamo blokove cifr teksta, opet od odgovarajuće veličine, okoliko je cela poruka cifr teksta veća od veličina, koja se koristi za konkretan algoritm i svaki zasemno provlačimo kroz dekrypcioni algoritm, naravno koristeći isti ključ da bi smo nazododobili odgovarajuće plain text blokove, koje opet konkateniramo i to nam je poruka, naravno izbacimo na i neki peding, i to sad uzavisnosti šta je poruka možemo da zaključimo, dalje bilo ovde neke dopune na kraju ili nije. Tako da pojnita priča jeste da se svaki blok cifru je nezavisno odnosu na ostale blokove, i ono što do čega to dovodi do jedne konkretne manje, jeste da ukoliko je sad ova naša poruka dovoljno velika, i ukoliko se neki delovi same poruke, okoliko postoji pattern u nekoj poruci, i pa se neki delovi poruke ponavljaju, mi ćemo i u samom izlaznom tekstu, šifronom tekstu da imamo patterne koji se ponavlja, jer uveki isti plain text šifremu uveku isti sajfer tekst, jer koristim uveki isti ključ. Tako da praktično ukoliko je naša poruka dovoljno velika, i ukoliko imamo te neki ponavljajuće delove, onda neka kryptoanaliza na dovolj poruku može da se izvaši, tako da je glavna upotreba, ovo galgoritma ne zasiguran prenos neke veće poruke, nego zasiguran prenos nekih pojedinačnih vrednosti, dakle do neka dva, tri bloka možda same poruke. Tako da se ono u glavnom koristi za slanje nekih ključeva, dakle bilo kakve poruke koje su neke manje veličine. Ovdje kaže, ako se radi grafičkim elementima, onda možemo prosto da provalimo taj neki pattern, pa da prosto, ili neke druge poruke koje se malo menje, po imamo neko ponavljenje, prosto možemo da izdošimo kryptoanalizu i da zaključimo od kog plain tekste nastav taj neki sajfer tekst, tako da je glavna upotreba da se šalje nekoliko blokova podata, kak da prosto ponavljenje ne može ni da se dostigne, čak i da postoji nekakog poruka tolko mala da kryptoanaliza nekako nije moguć. Tako da se u glavnom koristi za šifrovanje ključa, za neko dalje šifrovanje, za neki drugi algorit. S druge strane, kada pogledamo kako bi smo mogli da ispravimo to ponavljenje nekih patterna iz plain tekstu, koje se kasnije javlja i u sajfer tekstu, jeste ideja da nekako svi plain tekstuvi koji su se predkodno šifrovali na neki način utiču na ne samo sajfer tekst koji se dobija u to iteraciji, nego i na sve dalje sajfer tekstuve koje imamo. Tako da od atle nastali ideja o sajfer block chaining modu funkcionisani, odnosno skračeno CBC, gde se poruka ponavodeli u blokove, ali se ti blokove šifruju nekako povezano. Odnosno nekako kada imamo izlaz i samo galgoritma i to je naprim. neki blok šifrovanjih podataka, taj blok nadalje koristimo i u sledećem šifrovanju sledećeg bloka. Tako što prosto šifrovanji blok ksoru jemo sa sledećim blokom ulaznih podataka, dakle za sledećim blokom plain teksta i onda tako nešto nam dolazi na ulaz samo genkripsijonog algoritma, tako da praktično ono što se dođe i na izlazu je zavisilo ne samo od bloka plain teksta, u toj neku iteraciji nego i od predhodnog plain teksta, odnosno sajfer teksta, koji je zavisio plain teksta u opštom slučaju od svih predhodnih plain tekstu blokova, koji su se koristili u to koog glančanog šifrovanja. Tako da prosto ideje je kažem da na ulazne dolazi direktno plain tekst, nego neka kombinacija plain teksta i predhodnog bloka sajfer teksta. Što dovodi do pitanja šta ćemo sa prvim blokom, pa za prvi blok spostoji neka inicijalna vrednost, neka početna vrednost koja se ksoruje sa prvim blokom, pa na ulaz dolazi taksorova na vrednosti, naravno ta inicijalna vrednost postoji da bi se započeo postupak i da bi sve ovo u svakvite raci zgedalo isto i naravno ta inicijalna vrednost je taj na vrednosti, potrebno je da nju znaju i o neko šalje poruku, i o neko primu poruku da bi započeli šifrovanje odnosno. Deja šifrovanja tako da se ona u glavnom opet nekako nekim sigurnim kanalima prenosi do strane prima oca, naprimer koristeći baš ove predhodni ECB mod funkcionisane, jer ta inicijalna vrednost je veličina u suštini jednog blok, tako da možemo da iskoristimo ECB mod funkcionisane. Dobro, što se tiče dekripsije, dakle stvari je neka koreverzna, prosto imamo opet ove blokove šifrovanog teksta i prosto onda svaki šifrovani tekst prolačimo kroz dekripsijon i algoritam koristeći konkretan ključ i ono što dobijemo na izlaz u sobzirom deksor operacija invers na sama posebi, ksoru jemo sa ili inicijalnom vrednošću u slučaju prvog bloka ili sa predhodnom vrednošću šifrovanog bloka koje smo upravo nekako podelili od šifrovanje porukje i na taj način kao izlaz te ksor operacije, na izlaz u ksor operacije dobijemo blok plane teksta i onda prosto opet ovo se konkateniramo i dobijemo poruku. I sada kao što vidite, prosto dva ista bloka plane teksta sigurno, odnosno, slučaju neće dati dva ista bloka cyfer teksta, jer sad nezavisi vredno cyfer teksta samo od bloka plane teksta, nego blok cyfer teksta zavisi i od konkretnog bloka plane teksta i od svih predhodnih blokova plane tekstova, tako da prosto ponavljanje u poruci neće biti tako lako očljiva, jer neće postojati u opštom slučaju nikakva povezanost između ponavljanje u plane tekstu i ponavljanje u cyfer tekstu, tako da kryptoanaliza je ovde nekako dosta složena. Istog razloga prosto upotreba ovog cyfer blok chaininga je tako da se u glavnom koristi za šifrovanje te neke veće količine podatak, ka baš ono zašta ECB nismo smeli da koristimo ili za autentikaciju, oto ćemo da vidimo kada budemo radi ljevoj poslednji mod funkcionisanja za danas, prosto on se oslanja na cevoj blok, na cevoj mod funkcionisanja i koristi se baš da za autentikaciju u okviru tog nekog moda funkcionisanja. Tažem, pošto svaki blok zavisi od svih ostelih blokova, svaka promeno poruci utiče na promenu svim blokovima, pa s jedne strane imamo dobar ona efekta tlavina, s druge strane ponavljanje je teže. Uočeti jedino što je dodatno potrebno jeste da ona početna inicijalna vrednost bude tajna i da prosto je znaju i posiljalac i primac. Dobro, da li imate neko pitanje u ovom trenutku? Moš da pitanje? Zašto njegi bio tu inicijalna vrednost, na primer dobiljaj tako što njegi inkripto bi imamo prvo paro koji? Kako može? Prvo bi imamo prvi blok. Pa recimo, inicijalno vrednost da dobijemo tako što bi inkripto bi prvi blok. Pa do stvari, ti mi ne bi moralo da se šalj, onda... Aha, mislite da imamo ove prvi blok da je na izlazu inicijalna vrednost, kada ona dolazi na ulaz pravog prvog bloka, odnosno drugog bloka li šta, već? Pa dobro, da li? Pa dobro, mislim, praktično ono što dobijate, jestli sličan efekat nadalj, ali jedino što će ovi prvi blok, ako je uvek isti, uvek će se šifrovati u isti ciphertext, ja to jedino je tu razlika. Pa ako vam je taj prvi blok, baš neki, neki, da kažem, obrazac u samoj poruci, nešto što vam je uvek isto, onda će to u suštini uvek u isti ciphertext da se šifro, i onda ako nekod dohvati mnogo parova plaintextova i ciphertextova, svati će da vi tu nemate nikakvu kombinaciju sinicilnom vrednošće, ali u suštini nadalje postupak isti, nadalje efekat isti. A sad zašto se to ne koristi ovde, pa odku znam nekoj smisli, ove mod funkcionisani odluči da to bude ovako. Verovatno da bi prosto ovaj početnji deo vek bio isti, zbog implementaciju. Našto. Da, da ima jaima našto doda. Da, u principu, na ovaj načinu bezbeđujemo uniformnost između svih iteracija, takođu dobro je baš ovo što je vjake rekao, dobro je kombinovat i samu poruku sa još nekom dodatnom informacijom, tako da praktično inkripsije ne zavisio same poruke ukoliko je to moguću. To je, ovo inicijalna vrednost je praktično nešto slično kao što imamo kod do nich parametra algoritma, a koje moguće promeniti te parametra. I to je neka dolet na vrednost koje se prosto šalje i koje taj na vrednost. A pošto se, dakle, šalje istim kanalima, kao što je to slučaj sa samim ključem, dakle, na taj način prosto računamo na to da ćemo na sigura način distribuirati tu vrednosti samim tim, dakle to nije...
 i neki poseban problem. Posebno zbog toga što se režiti troškovi samih slanja nešto ne povećava jer se ipak radi o jednoj vrednosti koja je na određenoj fixnoj širini vezanoj za sam parametar enkrypcionog algoritme. Jasno, hvala. Nemaj na čemu. Nista, imali osnjako pitanje. Kaj je uvijednog uvijednog? To nema. Ako nema pitanja, majoćemo na pauzu, onda sada podanastimo dalje? Mislim da je sada dobra vrema je da krenemo na pauzu, zato što se narodni mode funkcionisani je dosta naslanje u jedan i na drugi tako da je možda ovo dobro mesto da naprojimo pauzu i vidimo se za 15 minuta. Može, može. Vidimo se za 15 minuta. Super, hvala. Dakle, do sada smo videli neka dva mode funkcionisanja koja su u principu tretirala neku količinu podataka koji su šifrujili, dakle odnosno, da je šifrujili kao praktično neki nizblokova. Gde je dakle taj nizblokova, naravno, u napred morao biti dostupan ili dakle ceoniz, dakle celo poruka ili delovi, ali u principu podatke smo dobijali kao blokove na ulasu. I jedina razvika, odnosno, dakle najveća razvika zapravo između ta dva moda funkcionisanja je bilo dakle, dali koristimo rezultati sprethodne iteracije za sledeću iteraciju, odnosno, dali praktično su nam potmuno nezavisne iteracije ili dakle nisu. Među o tim, sledeće dva mlode funkcionisanja koje ćemo videti, radi druga čije buk toga što same podatke koji dolaze i koji si šifruju. Dakle, samim algoritmom za šifrovanje, tretera prosto kao tok bitova. Tako da ovdi ćemo zapravo imati mogućnost da vidimo upravo mod funkcionisanja kao nešto što prilagođava algoritm koji je naminjen prosto jednom tipu ulaznih podataka za nešto drugo što nama treba u okviru sama aplikacija. Dakle, recimo, ako je priroda problema takvoj da imete neke podatke koji dolaze prosto u manjim količinama ili jednostavno recimo ne dolaze istom brzinom. To će značiti da prosto možete uzeti neka dva pristupa, a to je ili da baferoete podatke sve dok ne bodete imali onu količinu podataka koja može biti input neku blokovskog algoritma ili da prosto dakle koristite te podatke kao neki tok podataka, odnosno kao neki stream podatak. U tom slučaju, ako prosto koristite podatke kao neki stream, naravno možete koristiti neki streamovski algoritm, ali ukuliko želite da koristite blokovski algoritm, onda naravno takav stream podataka morate da prilagodite ulazu u blokovski algoritm koji koristite. Te tako našla dva naredna moda funkcionisanja koje ćemo videti, upravo to i rade. Odnosno uzimaju neki tok podataka i praktično, dakle, uz avisosti je toga koliko je to konkretno podataka, dostavaju to samom algoritmu koji poslana neki nakon radijegripsiju, odnosno dekripsiju i detalji samih modova ćemo vidati malčice kasti. Što stiče, količine bitova koji da mogu biti uzeti da tako kažemo od strane algoritmo u pojedinočnoj iteraciji, dakle, taj broj je promenljiv i dakle može biti 1, 8 bita, 64 bita, u principu, dakle, postoji više varianti, u skladu se tim postoje i različite variante ovog moda i to za samu logiku funkcionisanja šifrovanja od osnodesnjifrovanja i nije to likovitno, što ćemo moći da vidimo na sljedećem slajdu kada vidimo, dakle, kako zapravo izgleda šema za ovaj mod funkcionisanja. Odlično. Najlakša zapravo objasniti kako funkcioniša ove algoritma preko same šeme. Tako da, ono što, dakle, po čega krećemo, kao i se preskudimo algoritma, je, dakle, proces ekripsije i to je ove u gornjih deo šeme koji možemo da vidimo. Dakle, naša poruka pristeže u nekom, nekim grupicama od s bita i to je ove delo koji vidite kao neke plain text koji je opet označen kao neki boxič, praktično p1, p2 do pn i tako dalje. Mjodim, dakle, ne mora to biti sada, dakle, ta grupa bita, opet je nešto što vareira pre svega odnosno to koliko vam je podataka i kojem brazinomom podaciji tako da, kao što smo videli, to s je prosto neki promenjni parametr i možete uzimati i 1 po 1 bit ili veću grupu bita, dakle, to nije toliko bitna za samo u logiku funkcionisanja algoritma. Mjodim, ono što je samim tim jasno, jer da mi zapravo ne možemo uzeti tih s bita i samo ih ubatiti u algoritm za enkrypciju i iskoristiti output kao što smo to videli u prethodnim modele. Razlog je zato što algoritm koji koristimo za enkrypciju je jedan blockovski algoritm koji, dakle, kao parametra algoritma ima tačnom broj bita koji očekuje kao input ka ulezni podatak i ne možemo, dakle, to menjati i nije nam ovdje cilj da menjamo sam algoritm koji radi enkrypciju, već da ga prosto koristimo kao jedan black box, koji mi prosto dostavimo ulezne podatke i dokvotimo ono što se nalazi na izvosu. Zbog toga, ovo je jedan primjer prosto moda funkcionisanja, gde ćemo mi sam proces enkrypcije da radimo nad nekim uleznim podacima, a onda ćemo, dakle, tako enkryptovene ulezne podatke da koristimo dalje za kombinovanje sa samim plain textom. Tako da zapravo ovde plain text kao takav, dakle, direktivno ne ulazi u sam algoritm za enkrypciju, već prosto se na neki način kombinoje sa enkryptovanim nekim dodatnim podacim. I ako sad ne ispratimo kako izgleda ova šema, vidićemo da u okviru prve iteracije imamo, dakle, ponevo neke ulezne podatke, to je neka inicijalna vrednost koja je smeštena u nekom registru. Ta inicijalna vrednost, dakle, mora biti na onoj širini koju prosto podrazumeva dati enkrypcijoni algoritm za ulaz, odnosno kao blok podatak nad kojim se prosto radi neka enkrypcija. Tako da to nam je ta neka inicijalna vrednost koja je prosto upisana u neki registru. Dodatno, naravno, mora se koristiti neki pjuč, kao na predzadata vrednost i, naravno, ovde se nalazi neki od algoritama za enkrypciju koji je blokovski algoritm, des, ais ili neki drugi algoritm. Ono što je, naravno, rezultat je, dakle, ponavno, neki blok šifrovanih podataka, međutim, za prvu iteracijav, dakle, to isključivo blok šifrovanje ove inicijalne vrednosti, al dakle, zadatim pjučem koji se na neki način dalje koristi. Pošto, dakle, upravo i to je neku iteraciji ni imamo samo s bitom. Jasno je, dakle, da nećemo cijel izlozi iz ovog enkrypcijeno algoritmo moći da iskoristimo. Već pošto, radimo kombinovanje zapravo sa tim, sa tih s bita, da što je, dakle, nešto slično što smo videli kada smo generalno pričali u paradigmi racimo streamovskih algoritama, a to je da nekako predprocesiramo sam pjuč, pa ga u kombinovamo sa samom porokom, dakle, nešto slično se i ovde dešava. Mi ćemo zapravo od tih koliko god bite da smo dobili kao produkt enkrypcija, što, naravno, da, kako bih se zavisli od samog algoritma, dohvatiti s bita. O tako kao što vidite, imamo selekciju prvih s bita i to će biti vrednost koji ćemo mi zapravo iskoristiti za direktno kombinovanje sa plain textom i to će biti i rezultat, dakle, odnosno prvih s bita šifrovanog teksta. Nadalje, naravno, dakle, koristimo feedback iz prve iteracije i razvuk zaštu to radimo, od, pravo da kažem, zapravo da taj feedback koristimo, tako što go je dodajemo u shift register i tako da, zapravo, ovu inicijalnu vrednost koji smo imali iz prve iteracije koje se nalazila, dakle, u tom registru, shiftujemo za ona i broj pozicija, koliko nam, dakle, treba sada slobodnih pozicija za ovih s bita, dakle, za ovu konkretnu, šifrovanu vrednost iz prve iteracije. Tako da mi taj shift register pomerimo, njemu se nalazilo ova inicijalna vrednost i ubacimo tih novih s bita. Kada ne bi smo koristili feedback iz prve iteracije, naravno, u shift registeru bi smo onda uvek imali identičnu vrednost, a samim tim, naravno, i rezultat inkripsije bi bio potpuno identično, ako bi smo jasno koristili isti ključ, što, dakle, jeste obde situacije, zato što prosto nešto njemu novi vrednosti ključa za inkripsiju svakog bloka. Gjena Ramun, dakle, svećete se da kada smo pričali i u razlikama za blokoske algoritme iz Trimovski, rekli smo da je ko od Trimovski prosto dolazi do izražu, ja to stalno menje ključa, dok od blokosih algoritama jasno možemo koristiti isti ključ. Ok, dakle, shiftujemo ovo, inkriptujemo.
 i produkt koji dobijemo je odakon identično način procesiramo kao prvo iteracija, to znači ponovos selektuemo prvih s bita, sada kombinuemo sa naravnih s bita play texta i dobijemo novih s bita šifrovane poroke. I tako do kraja sve dok nam pristiže zapravo taj stream naše poruke, odnosno playing texta, s po s bita, odakon i na kraju imamo formiranu kompletnu šifrovano porovo. Jasno, da svakih ovih s bita da možemo dalje slati, sve to spojeno, tako pretavlja u potpunosti šifrovan cel stream talk. Kao što vidite, imamo ovoj feedback i sama dekripcija izgleda, dakle, vrlo slično. Jako pogledamo sada ovaj don i deo naše šeme, ono što ćemo primetiti je da je ovaj gorni deo, da tako kažemo, odnosno, pretproncaciranje samih podataka absolutno identično. Pogledajte, na primar, za prvu iteraciju. Dakle, ponovno radimo učitavanje i al tako inicijalne vrednosti i zatim, enkripciju te inicijalne vrednosti korišćenjem, naravno, identičnom blokovskog algoritma. I nakon toga, ponovno selekciju s bita. Međutim da bi smo dobili s bita playing texta, da s tih s bita selektovanih kao izlozi i zenkripsionog algoritma moramo sada kombinovatiti onih s bita šiprovanje port. I naravno, pošto ksor je, dakle, operacija koja je simetrična, prosto rezultat će biti s bita playing texta. Ono što bih sam udovala, premojmo što pogledam, koje pitanje je i odvorem na njega, je da, dakle, ono što možete primediti je da je gornjide o šeme absolutno identičan šemi za inkripsiju. To znači da sada takođe sve naradne iteracije prosto ovi šiprovanih s bita. Šaljemu ponovno i al tako u registar za naradnu iteraciju. U tom šift registru pomeramo prethodnu vrednost da je spozicija, dodajemo tih s bita i ponovno inkriptujemo celo taj registar i tako da. Sve, dakle, što se razlikuje, je jeste došto prosto finalni produk svake iteracije, dobijemo sada kao ksor, dakle, ovih pripremljenih podataka i šiprovanih vrednosti, odnosno šiprovanih s bita. I to je jasno naravno, zato što je to ono što se prosto mora razlikovati poštu na mi ovdje ciju da dobijemo plain text. Međutim, sam gornjideo je potpuno identičan i ono što možete primediti je da ovde, pri likom dekripsije, ni u jednom trenutku ne koristimo sam algoritm za dekripsiju. Već ponovno koristimo blokovski algoritm enkripsije. Zašto kako, dakle, da malo prudiskutvamo prosto ovdje ovde deon, razlu prvo zašto koristimo ponovno algoritm za enkripsiju je upravo taj što mi zapravo nikada nismo enkriptovali zaista plain text. Dakle, da jasno engriptovali plain text pri likom enkripsije podataka, dakle, gornju šemi, jasno da bi inverzan proces tome bio dekripsija šifrovanih podataka kako bi smo došli do plain text. Međete mi to nije ono što smo mi radi. Dakle, mi smo enkriptovali neke pomoćene vrednosti, a onda smo te vrednosti koristili u operaciji XOR sa konkretnim podacima koji nam jesu bitini i koje šifrovani. To će zapravo značiti da mi, naravno, da bi smo mogli da je skoristimo ponovodakle, tu simetrečnost same operacije XORa, na ulas moramo dovesti pomoćene podatke u istu formi, kako smo ih koristili i pri likom enkripsije, a to znači ne smo naravno raditi nikakvu drugu operaciju poput dekriptovanja, već ćemo ponovodakla od istih ulasnih podataka, enkriptijom doći do istih izlasnih podataka koje ćemo zatim iskoristiti u operacijih XORa kako bi smo dobili plain text kada kombinojimo to sa operacijom šifrovanja. Druga je stvar dobra koji ćemo prosto, koje dobro mesto zapravo ovo da prodiskutvemo. Ješto recimo dakle kod des algoritma, dakle ne možete vidati neku posebno veliku razliku u odnisu na to, da li smo pri likom deshifrovanja koristili samo algoritm enkripsije ili dekripsije. Ali recimo, ako posmatrate ove blokovski algoritm kao is algoritm, onda dakle znači zapravo ove še me naravčite dolazite do izražeje i ako se sećete kada smo pričali o razlikamo u procesu između šifrovanja i deshifrovanja rekli smo upravo da algoritam za deshifrovanje kod ASa je kompleksni u odnosu na proces šifrovanja i rezultat dakle dominantno na ona operacija Mix-Caunt, kog koja prosto imamo drugarčije koje picijente i zbog toga dekripsija traje duž. Epo kao što vidite, ove za samo dekriptovanje podatak nama uokšta nije potrebar samo algoritm dekripsije u datom blokovskom algoritmu, reći koristimo isti onej efikas na algoritama in triptije. Tako da ukoliko je dakle se ovdje kao blokovski algoritam koristi baš AS, dakle prosto nikde ne imamo tu negativnu stranu na sporijeg algoritma koji se koristi za dekriptiju. Ok, inac za pitanja je dobro također da se ukličite pa da pitate dakle baš kada je nešto aktualno, zato što onda možemo i odmom da obratimo važno pitanje znači dali i 2 i o 2 imaju jednak broj bita. Samo da vidim šta je i 2. Aha, dakle ove gore deo i kao ulaznik podataku u ekripsijonim algoritm je dakle veličina tog podatka koji se nalazi na ulazu i direktno određena ekripsijonim algoritm kao i veličina izlaznog podatka. Dakle to je nešto što je vezano za sam algoritm koji su ovde koristi. Ja sad retimo koji desa, dakle imali smo jedan blok koji se nalazi na ulazu, koji je dakle neki plain text, šta goda da se šitruje i koji je 64 bita i izlazi naravno enkriptovan i blok podataka, dakle identične širine. I to je dakle slučaj kod algoritama koje smo videli, ali kovo prosto posmetrate kao neki black box, dakle i radi so bilo koom nekom blokovskom algoritmo, prosto imate na ulazu neki blok podataka i on mora biti ona širine kako to algoritm zahteva, a također na izlazu dobijete šifrovani blok podataka koji će biti ona širine koju također algoritm određu. Dakle, konkretno, za oga algoritmu koja mi je smo radili, je ste takap slučaju, ali u opštena slučaju, dakle to je nešto što definiša sama algoritma. Odnosvakom slučaju, dakle selektujemo one broj bita od ste šifrovane vrednosti koje je namo zapravo potreba. Ok, ili manjeke pitanje možda vezemo za same šeme i za način funcjonisanja. Ok, dobro, dakle pozitivna strana ovog algoritma i načina funcjonisanja je, dakle slična, ono što smo videli i kod CBC, a to je da koristimo prosto rezultati spredkodne iteracije i u naravnim iteracijama, tako da prosto dakle ova e-kriptovanja nisu nezavisna i na taj način povećevamo sigurnost. Sa druge strane, naravno, pošto se dakle radi o tome da vi prosto šifruete neku kolečinu podataka, pa ih šaljete nekada. Prilikom slanja samog, dakle može doći, naravno, do invertovanja određenih bita same poroke i samim tim dok ustoji zapravo greška u samoj poruci koja se šalje, a pošli su ona koristi u svedećime o tako iteracijama, odnosno, dakle, prosto i ta vrednost koja se propagira na taj način, naravno, sama neka greška koja se može javiti u prenosu, ima impacta i na svedeće iteracije. Ok. Dobro, znači, ovo je bio cfb algoritm. Propostođam da se nisu među vremeno pojavila neka pitanja na ovak, pa ću preći na ofa bio algoritm koji je beoma sličan, dakle, ponečemo se razlikaju odnosno na cfb, i naravno, ako u bilo, o komitrem notku imate neko pitanje, dakle, slobo da su pjučite i postavite to pitanje. Ja bih u ovom momentu, dakle, odmah prešlo na šemu, pa ću usput pričati, dakle, sve ove stvari, ali lakše, kad prosto posmatramo šemu i onda možemo da uparimo je, dakle, logiku funkcionisanja moda sa timet, dakle, samo šemu i vidimo kako to izgleda. Tako, ovaj algoritm je veoma sličan kao cfb i takođe, dakle, je to jedan streamovski algoritm, gde ponovno dakle, imamo neku poličinu podataka potencijalno manjima, tako koja tu dolezi. Ove algoritm, generalno, izuzeta mnogo i liči, dakle, na algoritm koji smo videli malo pre. Jedino što praktično, ono što je glavna razlika samog algoritma, je što postoji ovo neko predprocesiranje kao mogućnost, onostno, govorni deo svaki od ovećšema, koja se nekako, koja nekako nezavisna i može se izračunati nekako u napredi. To je prosto ovej deo koji vidite, dakle, kao sam prozor. Inače, dakle, što ste prosto ostatka tiče, dakle, ako imete neku manju poličinu, ponovu podataka, ponovu, dakle, možete odbiti te podatki u kombinovat i sa plain textom. Međutim, ono što je glavna razlika, je što prosto ovegornji deo, kao što vidite, nije više konkateniran sa izlazom prosto iz ovo kusora, pa gde vi prosto kažete, ha, sad smo dobeli neku šifrovani ideo podataka i sad to koristimo kao feedback zanaradno viteraciju, kao što bio skolče...
 dakle kod prethodnog algoritma. Već sada prosto direktno izluzi zenkripsionog algoritma koristimo kao ulaz za sledeći blok. Prednosti takog načina funkcionisanja su prosto što kad pobljedate dakla u šemu, ono što ne morate da radite je da čekate da se prvo kriptuje ovo C1 i da rezultat tog šifrovanja vam zapravo predstavlja input naredne iteracije zada što vam to prosto pravi neku serializaciju u samoj inkripsiji odnosno dekripsiji. Ono što vam ovakam način funkcionisanja o mogućeva je prosto da vi možete i u naprede da izračunate sve ove gorne vrednosti, odnosno ako krenete od neku podatka koji vam se u napred nalazi u registru nekom, recimo to neka nosprejdnost, ali dakle je neki podatak koji je u napred pripremljen. I izvaz algoritma inkripsije za taj podatak sa zadatim ključom, dakle se može izračunati potpuno naravno nezavljistno od toga šta je vaša povanuka i kako doleze dakle ti podaci i kako ćete ih vi prikupiti i u kojom momentu dakle prikupljete konkretne podatke plaintext. Izvaz iz dakle tog konkretnog algoritma inkripsije za datje, za datu vrednost koja se inicijalno nalazi i potpuno neometno može proslediti dalje, da ćemo mi zapravo izračunati za sledeću iteraciju izraz izlaz iz algoritma inkripsije za sledeći blok, pa za sledeći i tako dalje, potpuno nezavljistno od toga kojom brzinom vam zapravo stižu podaciju odnosnovi plaintextovi koji se dalje kombinuju sa tim izlazika. Jedino što naravno, u koliko prosto sama brzina, dakle nije synchrona, odnosno praktično, u koliko se ove vrednosti ne izračunavaju u istom trnutku kada pristižu podaci, onda se naravno one pamte, ne gde da bi se koristila prosto kada su ti podaci tu i kada možemo da ih izkombinujemo dakle sa samim plaintextom. Tako da to je našto zapravo dominanti na razlika, što se ovdje može povećati efikasno zapravo ovog izračunavanja, tako da u koliko retimo, boste mi je to od načaja, kada podaci prosto pristižu nejednakom brzinom, tako da vi zapravo možete predpracesirati ove gornje vrednosti, izračunati i onda dakle koristiti i kada imate veći priljitih podata, kada je prosto ne morate čekati sa samim šiprovanjem konkretnih bita plaintexta, dok izračunate, odnosno, engripto, e te sama algorita. U čemu je stvar i zašto je zapravo ovo posebno odznačaj? Zato što doni je u šem, koji zapravo kombinuje, pardon, donja polovina u obje ove šeme, da tako kažem, dok le koja zapravo kombinuje plaintext, odnosno, ciphertext, sa nekim autputom iz engriptjionog algoritma, zapravo pretavlja običnu operaciju ksora i to je dominantino jako brza operacija. Sa druge strane sam proces engriptije je nog usplorija operacija od ovog. I vama zapravo u svaku iteraciji ovog neku algoritma, da tako kažem, nogo više vremena treba da engriptuje da ovegornji podatak, nego naravno da urodite operaciju ksora. Sbog toga je posebno odznačaj, ako možete to da urodite u napred, prosto nećete pauzirati i čekati sa slanjem samog šiprovanog teksta, dok praktično izračunate tako ovegornje podatke, već ćete ih imati u napred pripreveno. Tako da je to, to je neka optimizacija odnosu na prethodni mot. Dao sam... Ja, jedino što sam imam što je da kažem, izvinjam se, je za algoritm deshifrovanja. Dakle vidimo jako slično i identično, zapravo svar u onom što smo videli malo pre, a to je da naravno, košto si ponovio radi engriptije nad pomoćnim podatkom, koji nije, dakle, sam plain text s prilikom šifrovanja, prilikom deshifrovanja. Dakle, potrebna nam je inverzna operacija, ili tako za samo deshifrovanje šifrovanog teksta, pošto se radi operacija XOR, dakle, inverzna operacija je sama operacija XOR, i jedino što na ulas, dakle, sada dobodimo šifrovanje tekst u mestoplane tekst i naravno, ovu vrednost koji smo dodatno koristim. Ta vrednost mora biti u potpunosti ista, dakle, još jednom do podlačim, kao i u slučaju engriptije, izbog toga se dobije na identičan način, ponovu algoritmom za engriptiju, a ne dekriptiju. Da nemaj togo da pomešate, i upravo, ono što Adrijeni rekao, akas mi počali da radi vam odove funkcionesanja, probajte da ne učite ovu nužno napomjet, nego prostko da budete svesni toga, šta vam im potrebno, kao input, dakle, za samo šifrovanja, gosno, deshifrovanja podataka, ukoliko je u pitanju, dakle, konkreta, na neki plain text, koji se šifruje, naravno se mora deshifrovi. Ali ako se kriptuju neki pomoćeni podati, a koristi se operacija XOR na kraju, na dnjima, otarko, u tom slučaju inverzno operacije i dalje operacija XOR, odnosno identični podati se moraju dovesti na ulazi, zbog toga ponovu radimo engriptiju. Ok. Dobro, završeli smo z ovim modom, možemo dalje, da li imamo možda neta pitanja ovdje? Možda pitanja. Možda moda, na razreci. A sam uklik koja je sigurno na ta šema, pošto, visim, ličin na one-time pad, ali nisa siguran, da li je sigurnio da ovog predkodne na šema koji ste reka i sejferu feedback? Pa ovako, znači, ono što što je, se može reći, da je cvrb, možda si gurnija, zbog toga što prosto svaki praktično narjednje ulas takođe zavisi ne isključivo od produkta engriptije, već zavisi i od samog podatka. I to je malo slično odame što smo vaš pričali na početku, zašto koristimo ono inicijalno vrednost, naravno prosto što više podataka imate kao ulas nekoga algoritma, koji su među sobno nezavisni, vi praktično tako imate sigurniji algoritma. A sa druvim strane, ne može se reći da je nesiguran algoritm, zbog toga opet što se ovih, dakle, ono što bi bilo prosto jako nepovoljno za ovakvu jednu šemu, je kada bi ste dovodili, dakle, iste ključeve, isto je zapravo neku vrednost na ulas ksora, ali tako, znači to je ono što ne smedase radi i svake budi moramo imeti drugačije vrednosti koje dobodimo na ulas operacije ksora. E sada sam rezultat engriptijonog algoritma je dakle ponavno nešto što je naravno drugačija vrednost u odnosu na ulas, pošto imamo feedback za sledeću interaciju, onda naravno takođe radi se od rezultata prethodne iteracije, a ono što je takođe dobro, još to se oslanjamo i na samu sigurnost algoritma koji radi engriptiju i da nam recimo, dakle, ta je algoritm koji radi engriptiju dobro radi i znači, takođe, nam reprodukovat različite vrednosti, pa nećemo imati taj neki problem, gde u samoj operacijih ksora nam se pojavnjuju paterni. Čim imamo ovaj neki feedback, dakle, prosto to paterna neće biti, zato što, dakle, sam rezultat algoritma, koji radi engriptiju, nakon prve iteracije, nam neće dati istu vrednost kao što je nos, i čak videli ste da i kod desa algoritma prosto on pokazuje dobra osobine time da neki ulasni bit, dakle, i prosto utiče nam nogo izlazni bit, tako da će ta vrednost vakako dostavarirati u odnosu na nosu. Saj mi ti možete poštaće, ne utiče, dakle, značajno nas i gurnost, a ono što je dobro je što nam omogućava, dakle, već u brzinu, posebno za ove situacije kažem kada je to slanje raz ovih podataka prosto nekako neravnomerno izjelimo da optimizuam. Tako. Jasno, samo još piting je, za nos, dale je to fiksno ili se pojedeš? Ne, ne, no, nos je vrednost koje se generiše. Dakle, u ovom slučaju posebno to ne bi, ne bi nikako trebalo da bude, dakle, neka fiksna vrednost, zato što kada bi prosto to bila neka u naprav poznata vrednost, time, autonatski, dakle, smanjujajte pouzdanost al algoritmo. Zato što vam onda, dakle, cijel algoritm zavisni slučivo odključa, a to definitivno nije nešto što koćemo da uradimo. Tako da bi smo ovde, dakle, ulaz, nos, vrednost izgenerisali nekako i onda, naravno, to vrednost postvali zato što prektađa kao seed zapravo za prvo iteraciju engrebcija. Jasno, kvalam. Nemane če. Dobro. Imamo li možda još neko pitanje? Neo. Ok. Sledaći mod, jako jednostavan mod, sličan je kao prethodnim. Osim, dakle, što on tipično, dakle, radi nad nekim blokom podataka, ne može se, mislim, u principu se ne koristi za, kao stream i blok, nego prosto radi kao blok. Međutim, ovaj je, dakle, jedanom, interesantan mod funkcionisanja, jer se koristi dosta često u samim algoritmem, a funkcionis je, tako što prosto, kao inicijelno vrednost, u stavrenu z bloka, podataka koji uzima sam engrebcijoni algoritm, prestavlja neki brojač. I taj brojač, dakle, prestavlja sam blok, on se šifruje nekim tljučem. I rezultat ove engrebcije zna da je koristi slično, kao kod oflob moda. Dakle, kao ulec postava ovog dela, koji se ksoru, opet operacije ksoru sa samim plain tekstom, koji onda, naravno, će biti na adekvatnoj širini. Slično sa ovkom, buvam se odgledaj u tome, što prosto, opet, dakle, ove podatke možete u potkonosti pretprosesirati, zbog toga što su nezavisni, dakle, od samo plain teksta, odglusno, dakle, mislim, pre svega, na izračunavanje samog autkuta algoritma engrebcija, koji se radi na osnovu od samog countera. Sa zašto kažem, da je ovo dosta često porišćeno,
 prindzipu datakla i kada smo prošli put pričali o salsa algoritmu, cha-cha algoritmu, dakle, pričali smo zapravo o situaciji kada vi imate neki tok podataka, gdje prosto taj tok podataka kombinujete, odnosno svaki zapravo sam biti odnosno podatak iz nekih poroke koji šitrujete, kombinujete sa nekim ključem, a zapravo taj ključ je dobijen praktično nekom modifikacijom neke inicijalne vrednosti ili nekoj skupa inicijalnih vrednosti koje su zadati. Sad kada vi ste prosto tako nekako posmaterali ovu operaciju engryptovanja kao neke black box da se može nalaziti zapravo i takam neki algoritm koji prosto modifikuje ulazno vrednost kao što recimo slučaj bio i koj salsa i koj cha-cha gdje smo mi zapravo na osnovu neko ginicijalno pljuče, na osnovu nekih dodatnih vrednosti između ostalo brojača ako se sečete i neke nonz vrednosti i nekih konstanti, dakle smo modifikovali taj blog podataka, što zapravo je tako neki svoj avrstan algoritm za engrypciju i onda smo tako modifikovanji blog podataka kombinovali sa stvarnim podacima iz same fork. Zbog doga, dakle, ovo je mod funkcionisani je dosta često korišćen, zato što ima dobra osobina i da osnovu što može raditi predprocesiranja kao što je slučaj i kojd ofabl moda. Dodatno, dakle, je mogući postići paralelizam, prosto zbog toga što vidite da ovde nema čeinovanja između različiti hiteracija, samim tim dakle ne poslohite pidbe kojd predhodne hiteracija. Iako dakle slučajski uvidonju su brojači, tako da su nekako povezane, naravno, vrednosti samih brojača, među vidim ono što omogućavu paralelizam u ovakoj situacije upravo to što vi možete, dakle, potpuno nezavisno do radite enkripciju nad pojedinačnim, ovim inicijalnim vrednostima koje se dostavlja i samom algoritmu za enkripciju, a onda na kraju prosto bez obzira na to kojima redoslagom su poslednim blokowi podataka slati na strani prijama, dakle, uvek se može restaurirati počet na poruka odnosno plain text, prosto na osnovu vrednosti brojača. Dakle, moguće je restaurirati početnih položaj samih blokova bez obzira na to, dakle, kojim ste redosledom šiprovali slali i tako dalje, zato što, dakle, nisu uzajemno prosto povezane ove stvari, da se potpuno nezavisno mogu raditi šiprovali. I isto, dakle, kao i malo, pretprosto imamo ovaj gornji deo koji pretprocesira podatke i na taj način, naravno, ponovoradimo algoritm enkripcije i za šiprovali i za dašiprovali. Dakle, potpuno identično poradima, tako da ne bih se više zadržavalo na tome ako nije potrebno. I, dakle, ovo se može koristiti kada je potrebno postići veću brezinu, opet zbog toga, dakle, što je moguće dodatno ispršiti paralelizaciju. Ok. Dalje, možda, imamo ovde neko pitanje? Dakle, treba da pređamo na ovaj algoritm, tako zako vi smo rekli da je najkomplexni, nešto, malo, više vremeno otišlo na ove predpodne modove. Dalje, imamo neko pitanje iz ovoj predpodno telam? Ako ne, haj modma dalje. Dakle, slediči mod funcjonisani je zapravo mod funcjonisani koji kombinuje dva od predpojebi koji smo videli i on zapravo kombinuje CBC mod funcjonisani i counter mod funcjonisani. Sa counter smo baš videli malo preo, dakle, bazira se na nekim brojačima i u principu imamo ona nezavisno šiprovanje. Dakle, dok od CBC, dakle, ostam na logika pa ću ga samo lako ukrotko posjetiti bez potreba da se sada vraćemo, pošto ne vam baš previšto vremena, je da prosto koristimo, dakle, ulančavamo zapravo koristimo odkuti z predhodnih iteracija i na taj način imamo feedback, dakle, gde prosto koristimo informacije koje smo predhodno izračunalili za sledeća računanje. Ono sa što je dober ove mod funcjonisanje je da ono bezbeđuje tajnost, oduzno šiprovanjem podataka, ali takođu obezbeđuje i autentikaciju. Zato što, dakle, radi izračunavanje maka, odnosno message authentication poda i, dakle, upravo autentikacija šta radi, dakle, na osnovu autentikacija i verifikovanja poruke, dakle, mi treba da budemo osigurni, da je oneg zdokog smatrimo da nam je poslo o poruku, upravo je poslo o poruku i da poruka nije promenjena od strane nekog trećeg lica. Dobro, sam, dakle, mod funcjonisanja ponovno jasno koristi neki blok algoritm i oni je ovdje u principu bazire na simetričnom loka algoritm sa veličinom bloka od 128 bita pa je to pre svega a s algoritm, tako da ćemo mi ovojim primirimo da ka pričeti konkretno upotrebi a s algoritma, a s algoritmov Bardonu i, dakle, kao što smo videli i do sada kod ovi predhodnih podovog funcjonisanja, naravno, dakle, kjilče nešto što mora biti u napred poznato i na strani slanja i na strani tijema, međutim, dakle, zbog specificnosti ovog moda, ono što je potrebno i da svi podaci koji se koriste na uozlu budu u napred spremni, zato što se na osnovu, dakle, ukuplnih podataka koji se korista, videt ćemo na osnovu šeme, kako se oni koriste, dakle, radi neko predprocesiranje i radi se neko formiranje različeti zaglavlja i dalijčina podataka, tako da je potrebno da svi podaci budu u napred spremnih prej sameprimene algoritma. OK, s ozviča, samog ulaza algoritma, dakle, ono što se nalazi na uozlu su, naravno, koristnih podaci i to su, dakle, podaci koji se šifruju, a naravno, i autentikuju. Dodatno, osim toga, imamo neke pridružane podatke i te podatke ćemo upravo koristiti i prilikom autentikacije i, dodatno, naravno, generišemo non-sprednosti, dakle, videli smo, i mnogu putu smo već da smo vzio sada pomijali non-sprednosti, prosto se koriste protiv karakterističnih napada i one se na neki napčin generišu, pa samim tim, dakle, predstavljaju jedan segment algoritma, dakle, koji dodatno pomaže prosto njegovu sigurost. Samo mod, dakle, naravno, prosto podrozumljama neka dva procesa, do sada smo, dakle, pričali u procesu šifrovanja i deshifrovanja, a sada, naravno, u skloku šifrovanja imamo i generisanje samog autentikacijonog koda, odnosno maku prednosti, a u sam proces deshifrovanja, naravno, dolazi i verifikacija samog autentikacijonog koda, zadoš do, naravno, ako deshifruvaju poruku i potom vidimo da ona ipak nije od tog pošijavca od koga smo smatra li da jeste ili da je promenjena, nama takva poruka ne znači ništa i onda ćemo je jasno odvahcići. U oba, ova postupka se koriste, dakle, i cbc mod i counter mod, kao što se vrekla, ovaj mod prosto predstavlja kombinaciju tdv vrednosti, zato smo ta dva moda, pardon. Tako, dakle, što se, brilikom generisanja samog maka, koristi cbc mod, koji se primenjuje nad ulaznim podacima, dakle, koristim podacima, pridružanim podacima i noci prednostima, a dakle, na kraju se counter mod primenjuje na to maku vrednosti i koristim podacima, kako bi se prosto dobio šifrovani tekst. I nadalje, naravno, moramo poslati i šifrovani tekst, moramo poslati i šifrovane maku podacima, tako da ekspojimo u jednu poruku, kojiu potom šaljemo do strane prijema. Što se diče prijema, dakle, odnosno procesu, procesa dekriptcija, dakle, s jedne strane, dakle, moramo da dešifravimo samo poruku, a druge strane moramo da dešifravimo, naravno, i mak vrednosti, da je uporadimo, odnosno, verifikuvalo zapravo taj mak. Tako da, naravno, da bi smo verifikovali samo mak, moramo izgenerisa ti ga eldako iz početka i provjeriti sa ovom dešifravanom vrednošću maka koji smo dobelim i zato ćemo, naravno, ponobno koristiti cvc mod, dok za samo dešifrovenje koristimo u principu counter mod. I to je nešto što ćemo vidati na samo i šemi i tako će biti zapravo i najjednostavnije da vidimo kako ovaj mod funkcionisanja inoče izgleda. Dobro, kao što sam rekla, već, o, naravno, moramo verifikovali samo mak. OK, prve šemi, okroz koji provizimo je šema za generisanje samog autentikacijonog koda. I kao što vidite, dakle, ova šema je cvc praktično šema, odnosno, imamo taj block chaining iz svakje iteracije. Na samom ulezu algoritma koja radi inkripsiju nalazeram se neki blokovi podatak. I ovoj blokovih uleznih podataka se, dakle, u napred izračunava i u tu sad ima neki hen ili jednom posijednom blokovu, nije bitno, dakle, nešto ćemo kastnjem pričati od ovdje. I on praktično prestavaju ulez inkripsijunog algoritma. Pošto, ovu funkcionište kao klasičnom cvc, znatite kako to izgleda, dakle, rezultat svak je inkripsije pojedinočno bloka dovodi se na ulaze za naradnu iteraciju. Kombino je za sad većim blokom i tako radimo prosto iterativno. Rezultat svakog, na svakje inkripsijem, je neki blok koje smo ovde numericili od y0 padlo yn. I ono što nam je naravno cilj na kraju je da od te vrednosti koji smo poslednju isprodukovali, ako je zapravo kao što ste videli na osnovu cvc moda, je dobijene na osnovu svih predhodnjih, ili tako iteracije, odnosno svih predhodnih blokova vrednosti. Da od tomu poslednje bloka formiramo mak vrednost na kraju i to radimo tako što izdvojimo ms bl. Dakle, je praktično operaciju koja izdvajamo nekih ka najviših bita za mak vrednost. Dobro, hajmo sada vidimo, malo detalje algoritma, odnosno kako smo dobili ove blokove, koliko ih ima i tako dalje.
 Dakle, imamo nekih en blokovog uleznih podataka algoritmo i rekli smo oni se u napred izrečunave i sve vrijednosti prosto moraju biti u napred podatak. Oni se sastoja iz različitih podataka u opštnih slučaju i B0, ognosto prvi blok, sadraži kao prvi byte neke flagove, takođe sadraži, dakle, nonz vrijednost i sadraži binarnu predstavu dužine poruće. Šta se nalazi u tim flagovima? Dakle, to je avo što možete videti kao struktur u ovde zapravo, to je nekih osam biti, odnosno, jedan byte flagova, gde je ove prvi zasenčen i biti, neki bit koji sadara nama nije od velike važnosti, takođe sremo samo odisputovati ono što nam zapravo jeste bitno i na osmom u čega određujemo pojedine paramete samog moda funcjonisanja. Sleći bit, dakle, koji nam govori, adata koji nam govori, da li ima pridružanih podataka ili nema, jer, naravno, na osnovu toga, dakle, formiramo sledeće blokove, tako da imamo nulo u slučaju da nema pridružanih podataka ili jedinica u slučaju da ih ima. Nakon toga, zanima nas dakle koja dužina na kraju treba da bude mak vrednosti, jer ćemo, naravno, na osnovu toga i odlučiti o tome koliko ka najvišših bita ovo gipsilom n bloka mi je uzimamo, je odakno. Takođe nekde moramo da spakujemo taj podatak i upravo ga pakujemo ovde, tako što nekako enkudujemo tu duži. Prosto ne moramo ovde pričiti konkretno o detaljima toga enkudovanja, ali možemo da kažemo da razlog zašto enkudujemo, prosto zato što ovo mogu biti neke specificne vrednosti, a mi želimo da zaozmemo prosto što manje mesta tako ili našim blokovima izbog toga na neki način kodiramo same preposti. Osim toga je takođe poslanja tri bita, makle, ovo su bila tri bita za enkudovanja dužina maka, a poslanja tri bita prestavaju enkudovanu širinu prestave poruke, što zapravo znači da mi, dakle, poruku, od uzu širinu, dakle, same poruke, možemo prestaviti na različetom broju byte-ova. Tako poruku možemo prestaviti na različetom broju byte-ova, gdje, naravno, minimalni broje byte-ova je određam vodećem jedinicom, ali, naravno, da možemo i na više byte-ova. I pošto ćeram to takođe biti jedan od parametra algoritma kastije, onda taj podatr, takođe, želim da ugradimo u ovde, u ovde neko zaglavlja. Tako, izbog toga ćemo ponovona specificu način, upravo, enkudovati na koliko to byte-ova mi zapravo želimo da prestavimo našu poruku. Ok, to se sve nalazi u prvom bloku, zatim, imamo neke sledeće blokove, blokove od b1 padu neko b u, i, dakle, tu se zapravo nalazi na početku, enkudovana veličina pridruženih podataka, što znači, kaže nam koliko mi tih pridruženih podataka imamo, enkudovana na neki namčin, i nakon toga slede pridruženih podaci. Dakle, određeni broj blokove prosto se drži te pridružene podatke, zavisno od toga je tako koliko njih zapravo ima, i oni su prosto kunkatenirani jedni nad rokem. Ukupno do kraja, dakle, te pridruženi podaci ne dođu do kraja bloka, radi se padding, i nakon toga imamo određeni broj blokova, u kojmano se nalaze koristni podacij. Dakle, određeni broj blokova za dodetne podatke pridružene, i na kraju blokove za koristne podatke, koji zapravo predstavljaju ono što ćemo mi i daši, prujemo. I, eto, dakle, to je kako formiramo ove ulazne blokove, vidite kako i koristimo, dakle, primjenom cbc moda, prakvično dobijemo na kraju ove poslednji blok, to nam je i psilone n, selektuermo najviših kabita i dobrovo na osnovu ove enkudovane dužine maka i dobijemo vrednost maka. Ok, možemo dalje. Slednice šema je šema za šiprovanje porok. Dakle, tokom šiprovanja, radimo formiranje maka, odnosno vjenerisanje i šiprovanje same porok. I ovde koristimo counter mod. Kako koristimo counter mod? Imojmo neke blokove brojače, kao što to možete da vidite. I sad, bajde, prvo da vidimo, dakle, ove brojače blokove od ctr1 pa do ctrn, koristimo direktno, da bi smo šiprovali samu poroku. Odnosno, dakle, same brojače prolačimo prozalgoritama enkrypciju, kao što jeste slučaj sa counter modom. I dakle, od toga formiramo neke enkryptovane blokove brojače, sve ih kumkateniramo i kombinujemo sa plaintextom, da bi smo zapravo dobili šiprovanji tekst. Naravno, pošto nas plaintext možela se nalazi na nekoj širini, koji je prosto ne odgovora o vim kumkateniranim brojačima, mi ćemo izvojiti one i broj bitaj, od ako, koji će odgovoreti tom plaintextu, a da bi smo to mogli da uradimo, naravno, imamo prosto informaciju, na kojoj širini mi predstavljamo korisne podatke i prosto ta informacija je encodovana u same blokove brojače. A kao što možete dakle viditi. Što se vića prvog brojača, musela koristi malčici i drugačije, dakle to je ovaj nuti brojač, a razlog je zato što prosto, naravno, osim samo šiprovanja poruke, mi moramo šiprovatiti i mak vrednost, koji ćemo slati sa samom porukom, zato što jasno da je nešto što će nam koristiti za provjeru autenticnosti poruke, nećemo sigurno slati kao plaintexti, tako da ovaj prvi blok, unosno nuti blok koristimo specificno za šiprovanje maka, međutim u potpunosti na isti navčin, kao što to radimo sa drugim blokovima. Dakle, ponovu izdvarjamo odgovarjeći brojbita, kombinujemo sa makom i spakujemo to sve sa šiprovanim tekstom. I kad smo to uvradi li, dakle izglederisali smo mak, šiprovali smo glane text i sada imamo kompletne podatke, koje šaljemo na stranu prijeman. Ako sad radimo, kako bi smo radili dekriptiju? Dakle, daču dobijemo ovaj šiprovanim tekst i dobijemo šiprovanim mak. Kako ćemo poruku da deshifru? Pa pošto ponovu vidite da radimo ovakvu operaciju za provo ksora na plaintext. Sto moh da je jasno da će imverzna operacija, ponovu biti operacija ksora i opakvo, samo što ćemo ksorovat i šiprovanim tekst sa istim ovim podatkom gore, koji je pripremljen, da bi smo dobili odkovara ići plaintext. Što znači, moramo njesgeneristati, dakle, potpuno istu svar, samo iskombinovati sa šiprovanim tekstom i dobijemo naš plaintext. I u principu baš i u tomu i pojnita, da se mi ovdje upravo oslanjamo tu potpunocti na ono kako izgleda counter mod, nevezano za to da tako šta je gore. Dakle, odre su malo drugači i konkretni detalji implementacije, ali sam da ideo je potpuno ekivalenta na onome što smo malo prevideli kod counter moda funkcionistir. Sa druge strane, moramo naravno da uredimo i verifikaciju maka, odnosno kode za utentikaciju i sada ćemo to da uredimo, tako što ćemo prosto iz tog šiprovanog dela, koji smo dobili atakod, da izvadimo šiprovanim mak i da ga uporedimo, tako što ćemo zapravo tako da ga desiproemo i da uporedimo sa stvarnom vrednošću maka, koji ćemo naravno da izgenerišemo. Zat kako dakle to radimo, pa, no što se tiče dakle samo gde šiprovanja, kao što Adrian pokazuje, dakle identično upotrebom counter moda, znači uzimamo šiprovanu verzi u maka i radimo operaciju ksora sa pripremljenim vrednosti. Potpuno identično kao counter mod. Dobijemo dakle neki mak iz same poruke koji smo dobro. Međutim, kako ćemo da znamo, da li je to zapravo baš ta vrednost koja odgovara dator i poruci, pa tako što ćemo prosto ponovno da izgenerišemo mak vrednosti odako na isti način kao što smo to radili i da prosto verificujemo da se radi u identičnoj mak vrebstvi. Ako se radi u identičnoj vrednosti, to će značiti da praktično su podaci nepromenjeni, značemo tako moćemo da autentikuemo zapravo samu poruku i tada naravno ta poruka za nas ima nekog značanja. Ako dobijemo da se mak nekog klapa, onda ćemo tako poruku odvaciti, zato što je praktično praptit, znači nije ispravna poruka, onakva kako smo je očekivali. Ok, recite mi, da li razumete kako funkcioniše ove mod funkcionanja i da li zapravo imete neko pitanje vezano za ove šeme, za to kako smo uklopili ovdje counter mod i cebeć je mod, da li vam je ovde nešto ostalo nejasno? U principu sam primer koji smo planirali da pređemo danas, međutim šas je gotov, ćemo onda ostaviti za naravni čas, pa ćemo se tima da vam pocititi uš jednom ovoj moda u kretkoja. Tako i onda ćemo završiti praktično modove funkcionisanja sa prosto uš jednim modom, koji dosta liči na ovaj, ali je nekako modnificovan i tim ćemo dodatno otvrditi gradi vokolih modov i funkcionisanja preprelaskana sledaću da znacenu tem. Recite mi da li imate neko pitanje? Truka i treća laboratorijske vešba oddankli temi su nam AS-algoritam i kao temu prosto drugi laboratorijske vešba, AS-ES-AS-A, treć je Diffy-Hjelman i RSA-algorit. Što se diče gradiva za polupljom, jesmo li to podvukli crtu? Aki? Pa, drebalo...
 Dakle još dva dvoča se da imamo. Pratpasljam da se opita za RT ismer. Još dva dvoča se tako da zaklično sa S-Mime prezentacijom bi trebalo da budem. Ali, ali, ovaj, ali jest to tako u stvari? A ako stignemo da pređemo da S-Mime, svakako pećemo, stičemo da pređemo S-Mime. Ne, ne, ne, ne, ne, ne, S-Mime stižemo tek za dve nedelje tako da je to za S-i u stvari tema. A za RT ismer mislim da smo rekli da delimo na pola. Tako da bi o trebalo da bude posljenja tema. Zaklično naravno sa tim ještje jednim modom funkcionisani. Ako da, da, da, da, P-G-P, S-Mime idu na ispitu. Ali, ali, hajde, proverite mo to pa ćemo, pa ćemo nekom mailu poslati ovaj tačno gradivo za kolok. Ok, ali vidite, ako je neko pitanjem? A pa nije mi samo bilo jasno, kako se tamo u counter modu, kako se ginešiti counter. Dakle, ovi blokovi, pa to ćemo vidjeti sljedeći put na primeru. Dakle, pa što je u konkretnu imamo aplikaciju koji će vam poknimo, pa ćemo vam pokažemo na jednom primeru. Međutim, dakle, postoje prosto neke informacije koje se tu nalaze. I dakle informacije koje su engkudovane u svaki ovaj blok je, možda sam to propustila neko da pomenem, jedan byte flagov. Gde je, dakle, ovdje, kao što vidite, ovdje je struktura tog byte flagova. Oprvo i te byte flagova su ponovog, dakle, neke vrednosti koje sad nama, dakle, nisu bitne za razumevenje, to se prosto detalji algoritma, izbog toga su ovako zasivljeni. A poslednja tri bita ponovog predstavljuju engkudovanu vrednost ku koja se zapravo, dakle, odnosi na širinu predstave same poroče. Osim toga, dakle, nalaze se non s vrednosti i nalaze se vrednosti samih brojača. Vrednosti brojača svakako moraju biti nekako uključene, zato što je to suština pod counter moda, da ugot možete da rekonstruišete ov tako redosta i da to prosto bude još jedna vrednost koja se tu nalazi, a ovo non s vrednosti, dakle, nešto što dodatno pomože prosto pod stajnosti. I sad, dakle, te vrednosti se poređaju, tako što imamo, dakle, prvo, taj byte flagova, nakon toga dolaze non s vrednost u zavismu s pjednjenje veličine i nakon toga se dodaje vrednost brojača i po potrebi, dakle, se radi peding praktično te vrednosti da bi smo došli do kraja blok. I naravno samo količina brojača zavisi i od količina blokova koji su potrebi za samo šifrovanje navadno blok. Ja, to znači da je counter nula plus 1, jednako counter jan, i tako da, ili ne. Nisam razumela da je counter? Ja, to znači da counter nula plus plus 1, counter jan. Ja, ne, ne, znači, znači, ovako, sam blok podataka se sastoji od više podataka koji su ugnjaš da nijunutra, dakle, od sastoji se, od jednog byte za ove flagove se stoji od non s vrednosti i vrednosti brojača. Svaki pojedinačni brojač jeste inkrementirano za 1, ali sama c4 nula, c4 jedan i c4 n vrednost nisu isključivo brojači, vece sastoje i od ovih flagove i od non s vrednosti. Tako da, dakle, nisu toliko predefinisani, al tako u napred, već, sadrže samo u nutra i bedovanu praktičnu vrednosti brojača, međutim, sadrže i dodatne vrednosti koje su potrebne, jer inače da se radi isključivo brojaču, dakle, tihme bi smo dostosmanjili sigurno samo algoritma za ingreću. Da, mislim sam na to što ste reče, samo sam s nisam na obu istadze, ali da. Ja, ja, ja, da, da. Alaj. Ništa. Dobro, ili omodiliš na neko pitanje? Imamo pitanje kako se radi kolakvijom na računarima ili na papiru. Dakle, trenutna ideja, mislim da će to ostati. Zasigurno, jeste da se kolakvijom radi na računaru, odnosno, uokviru model test. E, sad imaćete papire ispred sebe, neka treba nacrtati šemu ili, ili... Ili uroditi zadatak? Ili uroditi, naravno, zadatak. Tako da neke delove koje se tiču nekih šema i nekih crtanja ćemo uratno pregledati iz obrazaca koji ćemo vam dati ili iz vežbanki, a imaćete i prostor da rešavate prosto zadatke, ali nam udul ćete unosite neke odgovore koje mogu tako da se unesu kao neki text koji nisu neka slika ili našto drugu. Dakle, neće biti isključivo teorijska pitanja. Pa sad da zaokuzvajte ili u tom nekom smislu već da vam tražiti razumevanje svega. I u tom nekom smislu prosto imaćete više načina da odgovorite, ali konačna odgovora, kao što reče, ali prosto ćemo nositi preko mudla. Dakle, ukliko nije u pitanju nešto što je eksplizitno treba načrta ti ili napisati, pa zato ćete imati dodatne papire. Dobro, još neko pitanja? Ako nije ba više pitanja, onda je toto za danes, da je tada slajite slajite kućim u radici i prosto videte jedan primero ovoga. Dakle, ako bude prosto nekih nepoznanica, nešto što ne razlunete, i završavamo joj tako sa algoritmima, odnosno modovima funkcionisanja i idemo dalje na sljedeći u temu. OK, ništa, hvala svima i čujemo se i vidimo sljedeći put. Pozdrav.
