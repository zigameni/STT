 Pritisnemo taster i dobijemo taj broj. Aha, sada sam orekao. Znači moramo ne deljivo da pritisnemo taster, da uvećemo taj broj za jedan i da preuzmemo papirić. Da niko ne smet da nas prekine dok to radimo. Zvok toga je, ovo je dole u okvirin red stavljen, tako cerveno kako je napis. Nakon toga, ja kažem, a wait, turn od i jednako next. Čekam dok le god se na display ne pojavi moje broj. Kada se na display pojavi moje broj, ja kažem, ja sam na redu i ja sam jedan jedini koji je došao u kritičnu sekciju. Na kraju, ja treba da pustim prvog narednog, da kažem, sledeći i taj sledeći treba da dođe na red. I sad mi nekako treba ovo da transformišemo, tako da možemo da realizujemo ne deljivo. Sad njih pitanje, da li to možemo da odradimo ili ne? A ovo ove može da se odradi... Opet, ksad, kako? Ovo je ove poslednji deo, ove možemo samo deljuminišemo ovu zagradicu, ovo ove što smo napisali kao course grain rješenje, zato što? Ako smo jedani, jedini proces u kritičnu sekciju, nema nikakvih problema da kažemo da je next jednako, next plus jedan. Mi jedini, pristupamo da to je promenjio. Ovde za sada ne razmatramo da je ta promenjiva takva da ne može da stane u jednu dužirnu operanta. Znači da ne možemo da odradimo do delu vrednosti atomski, kažem za sada to ne razmatramo kao mogućnost. Ovde prepostav kako cih ovih ovde algoritma da je do delu vrednosti atomska operacija. Da nije atomska operacija, onda bi smo morali mi malo ovo ovde da usložnimo sve ove naše algoritma, ali za sada je to atomska operacija. Dali ovo ovde await možemo da prebacimo u najnormalniju while pet, znači while... A kako smo rekti da su ovo ovde transformiši? Turn. Od i. Dok legod je to različito da next. Skip. Nemojte zaboraviti ov ovde skip. To skip kaže, probaj nekako da ne trošiš procesorsko vreme. To može biti neki od algoritama gne mi radimo wait, može biti stvarno zaposneno čekanje, a možda postoji i kon hardwarea mogući da mi nekako odremamo malo, ne radimo, uspavamo naš procesor na neko vreme. Možda postoji i tako nekakva instrukcija. Odradili smo ovde dva coarse grain, dela prebacili smo ih u fine grain i sad je pitanje jedino. Kako ćemo realizuvati? Ovo ovde turn od i. Numbre je jednako number plus 1. Dali tu možemo da razlišimo poslava relativno jednostavno? Neki procesori posledu instrukciju koja se naziva fetch and add. Sa će vi neko dva sreći. Pa šta samo izmišljaju ove instrukcije? Ovo ovde najobičnije instrukcije increment koji ste vi videli na predmetu architektura računara. Ako kod koji je o vrednost našeg operanda koji smo domukli negde iz memoria ostaje kao kopija u akumulatoru. Stara vrednost da nam ostaje u akumulatoru. Tako da. Tu ste vi instrukciju u suštini već koristili na predmetu architektura računara. Samo što je ovo ovde specializovanja instrukcija nećemo da, kako se zove, uvećevamo za 1, nego ćemo da uvećevamo za increment. Dali je ta increment 2, 3, 10, sve jedno? Ovde je samo stavljeno da bude malo u obštenija varijanta naše instrukcije. Ovako nešto imate u programmskom jeziku java, datu kod nekih atomskih operacija da biste mogli brzo, baž brzo da realizujete pojedine synchronizacijone algoritme. I kako radi ova naša instrukcija? Znači ova je instrukcija, nije fungcija. Ova naša specijalna instrukcija na procesuru FATCH.NET kaže, temp je jednako ta naša promeniva. A u suštini, ako se sećete predmeta architektura racunara, to je kada smo učitali naš operant iz memorie, smestili smo ga u akumulator. A onda smo u onom registru B uvećali operant za ta increment, koliko god da iznosi ta increment 1, 2, 3. Ovo ovde uvećali smo za increment koji je u našem stuči dovoljno da bude 1 i vratili smo ovo originalnu promenivu. Znači da smo odradili ovde, uzelismo tu promenivu koji smo učitali, uvećali smo za 1, smestili smo nazadno ovde promenivu, a u akumulatoru nam je ostala stara vrednost dati promenivu. Ovo ovde je istrukcija koji ste vi već koristili, to je istrukcija incrementiranja. Super. A ako smo ovo ovde uspeli da realizujemo u jednom jedinom redu, ono turn odija jednako number i nam brija jednako number plus 1, mi smo odradili kompletan naš posao, a ovaj naš deo može da se realizuje u jednom jedinom redu. Tako da kompletan algoritm glasi ovako. Turn odija jednako fashion add number za 5 i 1, uvećali smo number za 1 atomski i upisali smo ga u našu lokalnu promenivu. Turn odija lokalna promeniva, jako je ona gore navedena, tako da svih mogu da je vide, ovu ovde je u stvari lokalna promeniva koja mogla da se nazovi turn koja bi bila samo data u procesu i ovo izvučeno gore samo da vi smo mogli da ga poredimo sa beker i algoritmom koji ćemo razmatrati na naravnom času. Ništa druga. I da vidite koje promeniv je postoje, ali turn odija lokalna promeniva nekog procesa. Nakon toga se vrtimo u wild petli dokle god se na displayu ne pojevi naš broj, kažem u ja čekam taj broj, ja čekam taj broj, kada se pojavi to čudo. Ovdje nije ticket, nego smo nazvali number. A ovdje će pisati turn koja je ko poredu. Sačekamo da turn odiji postane jednako next, kad se desi da je to jednako next, jedan jedini proces ulazi u kritičnu sekciju i next je jednako next plus jedan kad zavšan, čvijete nema nikakve synchronizacije. U suštini il mora ovako da se realizuje koristic jednu specijalnu instrukciju, pa ne mora. Šta mi radimo ovde? I sad mali pocetik, šta radi ovde feče net? To smo videli na pretkonom slajdu. Radi jedan vrlo kratak posao. Radi jedan vrlo kratak posao. Aha, način mi je bismo u suštini da nema ovoj specijalnu instrukciju feče net na datom procesoru. U stvari, ovaj ovde feče net mogli da realizujemo koristići petersenovalgoritm. Gde tu ima vrlo malo posla, tako da ćemo mi vrlo brzo verovatno odraditi sve ovo ovde što treba da se odradi, ovde synchronizaciju ćemo brzo odraditi, znači ovdje ima 5 instrukcija koji treba da se odradi. U suštini učitaj, saberi, smesti i ostane nam ta kopija. Dakle da ima vrlo malo posla koji treba da se odradi, a ako ima malo posla možda tu možemo svarno da iskoristimo ono zaposlenu očekanje iz nekog od pretkonih algoritama na 5 instrukcija koje došlo prene, nema nikakvog značaja. A što onda dođe? A onda dođe ovde del koje smo imali i pre. Šta radi? Ponovi mi još jednom. Šta radi ovi sve synchronizaciju i algoritmi? Oni treba da obezbede ovo ovde. Ono što opisujemo kao coarse grain resenje. Sa će odraditi dati del atomski. Svi ovi naši algoritmi to rade. Tu nije problem na tih 10 instrukcija koje se izvršene. Ovdje je problem zato što posao koji će možda nekod raditi u kritišnih sekcijima na hiljada instrukcija. Na tih 10.000 instrukcija više nemojmo nikakva vrednost. Ono samo dok su trkuji, prve dve, trebu instrukcija. Dil došlo neko pre, sad ili tri instrukcija posna toga ili deset instrukcija posna toga. To je krajnje nebitno. To nije neka velika razlika što se toga koja ranije došla otiče. Oni su došli što se nas tiče možda isto vremeno. Ako program krene da se izvršava i uzi u kritišnih sekciju koja ne može da se kontrolišer. Ovu ovde kritišnih sekciju mi ne možemo kontrolišeru. Ne om predstav je koliko traje. U tom slučaju nam je dosta bitno da napravimo pošten redosled. I ovaj prvi algoritm koji pravi pošten redosled dozaka samo što ima jedan mali problem. Ovaj ovde mali problem je zahtjeva promenivu koju si vide, si menjaju, a samo jedan treba da proće. Sa sam sad rekao. Ajde, zavratimo u gore na neki od donih slajdova. Kada neko završi sa poslom. Kada taj neko završi sa poslom. On će doda da pritisne taster na ovom ovde. I da kaže next.