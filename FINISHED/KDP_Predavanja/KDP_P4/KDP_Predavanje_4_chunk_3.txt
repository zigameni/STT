 i značitajte dokumentaciju za javu, vidjet ćete da je do CLH algoritm tako i označenu. Reglij smo da koristimo posebno istrukciju, to je getNset. GetNset istrukcija dohvata staru vrednost, to će nam biti povratna, a tu našom promenjivu var će postaviti na novu vrednost koji smo mi prosledili. To ćemo iskoristiti da bi smo mogli da razrišimo ovako nešto, priviju se jednako tail, tail je jednako node, to se razrišava, jednostavno kažemo priviju se jednako getNset tail and node. I ovog ovo je naše fine grain rješenje za CLH algoritm. Node je jednako true, privijus koji nije postavio, mislim deklarisani samo pokazivače line i ono što se ukazuje, je jednako tail, tail je jednako node i wildPrivijus.loc skip, čekaj dok me neko ne pusti, onaj prvi je dobio dozvolu, isto kao kod Andersonovog algoritma. Prvi dobija dozvolu kada on završi, on pušta prvog narednog, možda niko ne čekan na tim prvom, na tim narednim elementom, to će čuvati, a onda onaj tail, tail će dozvoliti prvom ko dođe, ok, možeš ti da radiš, možeš pristupiti, zato što niko trenatno ne koristi kritičnu sekciju. I ovo je jedan od malo modernijih algoritama za synchronizaciju. Dalje je najmoderniji? Nije, ima ih još Gomila. Dalje ćemo raditi još ovih algoritama? Nećemo. Dosta je ovo ovde da upoznate synchronizacijone algoritme. Imate jednu lepo knjigu, The Art of Multi-Processor Programming, gde možete se upoznati sa dodatnim synchronizacijonim algoritmima, ako su vam oni od interesa. Dodatni synchronizacijon i algoritmi koji će koristiti ili neće koristiti specijalne instrukcije, jer neki jezici to možda podržavaju, java podržava, počuvod versije 5, ali python možda ne podržava, pa onda tamo možete viditi još nekih interesantnih synchronizacijonih algoritma. Mislim da je dostopna na netu da možete prehozati tu knjigu sa neta i da pogledate kako su realizovani ti lock-free synchronizacijone algoritme. To su synchronizacijoni algoritmi koji ne koriste zaključavanje. Oni su veoma brzi ako je potrebno sodredi neki posao, ako je posao koji se negde radi dugu trejan, onda imaju malim problem sa zaposlanim čekanjem. A zbog toga nemojite ovde nikad pisati samo tačka zapet. Ovde uvek stavljete ovu ovde skip, jer možda postoji način da se vi nekako, odnosno da se vašanit nekako uspava na datom procesoru. To nije vej tu javi. Ako budete gledali nekad deteljno programski jezik java i nešto što se nalazi ispod programskog jezika, videte da postoji mogućnost da koristite nekom javinu biblioteku koja se zove Unsafe, ali koje vam umogućeva da vi radite neku dodatno blokiranju. Ona zašto i Unsafe, zato što koristi neki dodatne mehanizme koji se nalaze ispod, nisu standardni javini mehanizmi, ali nju koristi java da bi napravila da semafori rade brzo, da monitori rade brzo, to je sve neprvdjeno nekako fino upozadini. Onda vi možete isto tako nešto iskoristiti ako želite da napravite optimizaciju u javi, ali ako ne radite u javi, onda morate da vidite tačno šta vama programski jezik dati pruža. Možda ne pruža ništa, osim semafora i onda ćemo morati samo semafore da koristimo. Možda nam ni garantuje ni ono Wallatile, što nam je garantovala java, a Wallatile, nadam se da se sečite šta nam sve garantuje. Garantuje nam postojanje relacije Happens before, šta bilo pre, bilo je pre, znači šta bilo pre datok pristupa, će se sigurno smestiti u memoriu kad ja dođem da čitam te promenjive, znači to mi garantuje sam javin programski model, znači šta se desilo pre desilo se pre, za pristup tim promenjivama koje su označene kao Wallatile, za ostale ne garantuje, za ostale je dopušteno programskom prevodiocu da potpunno menja redostlet izvrša, odnosno ono kako smo mi napisali da bi program mogao bošta brže da se izvršava. I šta nam juž garantuje Wallatile, garantuje nam pristup do promenjivih koje su dužine od 32 bita, garantuje nam da će biti atomski smeštene. Java kao programski jezik nam garantuje pristup do 32 bitih promenjivih da će su jednako biti od atomski odrađeno za 64-bitno nam ne garantuje i onda može se pojavi nekad prelom promenjive, do sad nisam uspe baš da ga reprodugujam, ali kažu da može da se desi, da probate da čitate neku tako long promenjivu i da pročitate neku blesavu vrednost koja nikad nije postoja, a slučajno se pojavi. Ok, znači, bismo ovim prešli naše synchronizacione algoritme. Oste nam sad malo do kraju ovog časa da vidimo nešto ovo synchronizacije na barijera i da vidimo šta je to barijera, jer je barijera jedna korisna struktura koja nam omogućava da se synchronizujemo, da synchronizujemo veći broj procesa, a videte ćemo da možemo naprivo cykličnu barijeru, da se koristi više puta, i da ćemo naprivo barijeru koja može samo jednom da se iskoristi i videte ćemo kako možemo da napriamo synchronizaciju ako imamo proces koordinator. Postojanje dodatnih procesa je poželjeno u nekim slučajima u distribuiranom programiranju. Nekad je obavezno u distribuiranom programiranju ako ne možemo da pristupimo drugačije promenjivima. Ali kod konkurentom programiranja korišćenje dodatnih procesa i procesa koordinatora ako može bez njih bolje bi bilo da se system razreši, da su synchronizaciju razreši bez njih, jer oni mogu da uvedu dodatno neko kašnjenje. Ali su oni korisni ako nemoj mogućnost možda korišćenja njikih drugih mehanizama za synchronizaciju. Šta je posto jednog vorkera? Treba dobrati da se odridi neki posto i treba da se synchronizamo sa svim. To je posto koji mi treba dobrati. Odradi nešto sačekaj da svi ostali završe pa pređe ili na naradnu iteraciju ili na nešto drugo. I to je načinšće ovako kako sam ja napisao. Znači, da li barijera mora tako da izgleda? Ne mora. Ali najčinšće izgleda tako, koji nekih algoritama za obradu, a odradite svih, celtom samom treba da se završi i kad se završi, aj pano. Kad se završi, svih opet to iteraciju, ajmo slijaciju iteraciju. Ovo ovde je pogodno koji nekih iterativnih obrada. Kako bi ovo vrlo neefikasno mogu da se realizuje? Pokranete niti, koko treba da se radi posto, i tamo na mestu da se sikronizuje, sve niti treba da se završi tu. I to je to. Napravljeli smo barijero. Ako ne znamo, po metni i način kako možemo da napravimo, pusteli smo niti, niti su odradile posto, niti su se završile. I onda mi čekamo ovo ovde, ovo i oce je ko Big Incient. U suštini, u javi bi bila Star Thread. I na kraju bi bilo Wait da u suštini čekamo da niti završi posto. Zablokiramo se dok le godje ta naša nit živa. A ovdje je po nom i ušenom vrlo neefikasno resenje. Pa su onda njudi razmišli, ok, može malo da se napravi to efikasnije. I ovdje ćemo da napravimo jedno resenje za nešto što se naziva jednokratna barijera. A jednokratna barijera je barijera koji možemo da iskoristimo jedno i bacimo uđubre. Znači sačekamo da n procesa dođe, kada dođe n procesa mogu da nastavio dalje, ali datu barijeru nemogu da koriste u najrednoj iteraciji. Zašto? Ajde, nemo kako je napravljeno ovdje resenje, ovo barijera. Što smo rekli, dođe ja do barijere, moram do većem brojač. Kajšem ja došao, u većem count za jedan. Nakon toga treba da sačekam da count postane jednoko n. Što znači count jednoko n? Svi procesi došli do barijere. Kada svi procesi dođu do barijere, mogu da nastavio dalje sa svojim izvršavanjem. I ako pogleda tovo resenje, ovo vrlo jednostavno može da se realizuje, korističi o ne istrukcije koje smo do sada imali, o ne fetch and add ili tako nešto. Ovo je prvi red koji kažem count je jednoko count plus 1. Vrlo jednostavno realizuje, korističi o ne fetch and add, kažemo fetch and add count za pete i je dan i rekriz uvećali smo novi način ne delivo našom prometi. Kako ćemo realizovati ovo await count jednoko n? To je while count različi to dan skip. Napravili smo barijeru koja može da se koristi jedno. Zašto samo jednom? Nadam se da vidite šta je problem sa ovakvom barijerom, ako bi smo pokušali da je koristimo i u narjednoj iteraciji. Pa ne možemo da je koristimo u narjednoj iteraciji, zato što je barijera došla do svog zasićenja, došla do vrednosti n. Nemamo nikt de reset. Ako bi ja ovdje kojem slučajem sada napisao,