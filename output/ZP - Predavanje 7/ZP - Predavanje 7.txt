 Na predhodom predavanju smo došli do ovde, tada smo tuli šta smo to mesi do identikejšom kodovu i odnosno koja je to vrsta funcija. Videli smo da su to funkcije koje su slične. Heš funkcije imamo smislu vrda i izlaz koji je fiks na dužine, ali za razlik od Heš funkcija koja je kao ulaz u tu funkciju imaju samo ulaznu poruku, ovde postoji još i an dodatni ulaz, a to je ključ koji je bezbeđuje. Danapadač ne može na tri bjela način da promeni i sadraže porubke, i sadraže tog mesi do identikejšom koda. Ja sad ćemo preći na narodni slajdove i videti šta su neki zahtevi, koji su postavljeni pred mesi do identikejšom kodove i takođe po zabove ćemo se neki mesi do identikejšom kodove ima koji se danas koriste. Vidi ćemo malo i kako se razvijelo neke koji su postavili tokom 80-ih godina i kasnije, vidi ćemo kako se razvijelo način razmišljanja o mesi do identikejšom kodoveima, pa će vero je biti sve jasno. Znači, ono što je, ja mislim iz svega što je do sada rečeno, o mesi do identikejšom kodoveima, jasno to je da uvek postoji nešto što treba da bude teško na podaču, da ako zna i poruku i mesi do identikejšom kodove, zato što videlište na predkodom pridavanje jedno od onih šema, kako se premjese podaci koji su zaštićeni mesi do identikejšom kodovem, prosto jedna od tih šema koja podrozumeva otvore na slanje podataka, znači da se šalje poruka i njen mesi do identikejšom kodovem. Znači, to možemo da podrozumemo, da napadar svakak zna. E zato na podaču treba da bude teško da u nekom razumnom remenu, naravno što je to zavisi od primjene, okoliko je to razumnom remenu, da u tom razumnom remenu nađe i neku drugu poruku, koji će generisa tip isti mesi do identikejšom kodovem. Ono što je takođit aktiv, to je da mesi do identikejšom kodove treba da bude uniformi distribuirani, odnosno treba da, verovat, noć je pojavljivanja različitih mesi do identikejšom kodovem bude približno jednaka, nikada to nije idealno jednaka, ali treba da bude približno jednaka i takođe ono što je slično kao kod Heševak, mesi do identikejšom kod treba da podi neko zavisi od svih bita poruk i ja bih još dodao na ovaj bulit, treba podi neko zavisi i u svih bita tljuča. I to je ono što dobra mesi do identikejšom kod funkcija treba da ispunjava. Ja sad ćemo se malo pozaboviti time, koja je težina i koji je način, a koji je neki napadač na mesi do identikejšom kod funkciju može da dođe do onoga što njega interesuje, a ono što na padače najviši interesuje to je da dođe do ključa. Zašto? Za to što ako uspe da pronadji ključ, onda će kasnije moći onda generiše mesi do identikejšom kodove za proizvodnu poruku. Postoji druga vrsta napada da je on može da proba da pronadje neku drugu poruku koja će generišati isti mesi do identikejšom kod, a da ne zna ključ, ali prosto to bi bilo neka vrsta nabadađenja, odnosno ne bih mogu da bude siguran da je to za isto radi. Tako da ono što je cilj na padača, obično to je da proba da dođe do ključa, kojih se generiše mesi do identikejšom kod. I ovdje ćemo se pozabiviti jednim primjerom, a ta i primjer kaže sledeće, razmotrićemo jednu situaciju u kojoj, ovdje ću ovdje naći izlajati mesi do identikejšom kod funkcija, prosto samo da se pocitimo, znači postoji poruka m, koja dolazi sa jedne strane i postoji ključ kak, koji dolazi sa drugi strane, a ovdje kao izlaz imamo taj mesi do identikejšom kod. Ključ k je veličine k bita, poruka m to znamo, ona može da bude proizveđne dužine, a ovaj izlaz mesi do identikejšom kod je n bita. E sad naravno tu postoje 3 variante, jedna varianta je da su ključ i ovo n jednake dužine, i to je prosta varianta, bićemo razmotriti ovo jednu variantu, koji je interesantna kada je k veći od n, znači ako je broj vita ključa veći od mesi do identikejšom koda, šta napadač mora da uradio onda. Znači ako bi, ono što naravno rekao sam malo preciđna padača, to je da poguša nekako da dođe do onog ključa koji mi generi sam dat, dat i mesi do identikejšom kod. E sad da bi to uradio, ako sam algoritm siguran, dakle ako ne postoje neki strukturni problem u algoritmu, koji ćemo mogućiti da nekom prečicom dođe, do ključa, onda jedino što mu preostaje, to je brute force napad. E sad, brute force napad koji će on ginerisati, znači da on mora da napravi 2 na k različitih ključeva i da za datu poru po m izračuna 2 na kati različitih mesi do identikejšom kodov. Međutim pošto rekli smo da je k veći od n, to 2 na k različitih ključeva, znači da će, ako pretpostavimo da su mesiđu identikejšom kodove, koji gineriše ova funkcija, da su oni uniformno raspodeljeni, ono što možemo da očekujemo, to je da će biše od jednog mesiđu identikejšom koda, koji tako bude ginerise sa različitim ključima, dati isti mesiđu identikejšom kod kao ona i koji je dobijen tajnim ključem, koji napadač ne zna. Zašto, zato što je 2 na k veći od 2 na n i ukoliko je baš uniformna raspodela mesiđu identikejšom kodove, onda zapravo ono što će zdesiti, to je da će približno 2 na k minus n različitih mesiđu identikejšom kodove, da se, ono izvinjase, dobije se 2 na k minus n istih mesiđu identikejšom kodove za različite kliučeve, koji su ubaceni u taj brute force napad. To je pod uslovom da je uniformno raspodela mesiđu identikejšom kodove. E što sa to dalje znači? To dalje znači da napadač, ako je k veći od den, ne može u prvom brute force napadu da pronadži tačno određeni ključ, koji im je generisam dati mesiđu identikejšom kod, zato što će za više različiti ključeva dobiti isti mesiđu identikejšom kod, kao nek koji je dobio korisnik koji zna tajni ključ. To znači da bi on mora, onda sada da uzme sve te ključeve, koji su dati, dalje i generisali odgovarajući mesiđu identikejšom kod, i to su sada u stvari ključevi, koji su kandidati. I ono što mu dalje treba, to je sada druga poruka, znači, novi par poruka i mesiđu identikejšom kod, neko ovi će sada primeniti samo ove ključeve, koji su izvučeni u prvom krubu prolaska ključeva. A sad zavisi od toga, kakavi odnos izm. k i n, treba ćemo nekada dva prolaska proste ključeve, nekada tri, ovaj sad ćemo na jednom primeru to da razmatrimu, koliko mu treba, ali svakma slučaju posle nekoliko rundi i posle nekoliko parova poruka i mesiđu identikejšom kod, on će na kraju doći do to ključa. Ali to znači da njegom posao će da bude zapravo složeni od dva na k izvašavanja mesiđu identikejšom kod funkcija, sad ćemo tačno vidjeti koliko je. I ovo ne bi bilo loše, da malo prostudirajte i da pokušite, razumite, ranje smo imali i neka pitanja, koja se se odnosila na ovaj slučaj. Recimo ako pretpostavimo da je k recimo 80 bita, što je danas neprimereno mala dužina za ključ, znači danas se ne koristi niša, što je manje od 128 bita. I ako pretpostavimo da je n 32 bita, što je opet neprimereno mala dužina za mesiđu identikejšom kod. Šta napadaš treba da bi urodi? Napadaš treba da uzme i da dobije prvi par poruka i njen mesiđu identikejšom kod, koji je generisao neki koristik tog mesiđu identikejšom koda. Treba da urodi 2080 operacija izračunavanja mesiđu identikejšom kod za sve varijante ključeva od 80 nula do 80 jedinica. Pa sad pošto ima 2080 ključeva, a pošto ima uklupno 1232 mesiđu identikejšom kodova, ono što se očekuje, to je da će 2 na k minus n, to je 80 minus 32, to je 48. Znači on će po se tog prvog prolaza dobiti 2 na 48 različitih ključeva, koji su generisali isti mesiđu identikejšom kod kao onaj tajni ključ koji ima taj koristik. Šta on dalje mora da urodi? On mora dalje da sad da izvrši ovih 2 na 48 mesiđu identikejšom kodova, ali sad da to ne može da primeni na donom prvom na prvim parom poruka i mesiđu identikejšom kod zato što je već od atle dobi ove kandidate, nego on sad da mora da ima drugi par, znači druga poruka i drugi mesiđu identikejšom kod da urodi 1248 mesiđu identikejšom kodova pomoću tih različitih ključeva i onda će opet generisati neke mesiđu identikejšom kodove, koji su jednaki početno mesiđu identikejšom kodu i u tom slučajući dobijeti sad da 1248 i minus 32, to je 1216 kandidata ključeva. Pa ako je dobio ovo, treba ćemo i treći par, znači poruka M3 i Mach3 i pošto ima svega 1216 ključeva, on će recimo tu u trećoj rundiji uspeti da pronadže tačno određeni tajni ključ. Ali ono što vam sugeriše ova kalkulacija, to je zapravo da, kao što možete da vidite, kad je proces brute force napada u ove situacije, kada on hoći da pronadže taj ključ, služeni...
 od ako je k veći od den, čak je složeni od pretrage svih mogućih ključeva, zato što ako je prostor ključeva veći od prostora mesiđu od dvidejšem poda, onda ćemo trebati nekoliko rundi da uredi i zapravo ukupam broja operacija koji ćemo trebati da bi došao do konašno ključe, bi mogu da se iskaža ovako, kao 2 na 80 i plus 2 na 48 plus 2 na 16. Naravno ako je k manje od den, ako je recimo veličina ključa 80 bita, a n128 bita onda je prostor ključeva 2 na 80, prostor mesiđu od dvidejšem kodove je 128, već je prostor mesiđu od den, autentikljišem kodove i ono što može da se očekuje, to je da će nakon 2 na 80i proloska kroz svih 2 na 80 ključeva najverovatnije dobiti samo jedan ključ koji je kandidat. Naravno može da se desiti do dobije i više od jednoj kličeva kandidata, al to bi značilo da samo mesiđu od autentikljišem kodvi funkcija ima možda neki strukturni problem, koji ne daje uniformu raspodelu mesiđu od autentikljišem kodove. Elem to je neka vrsta analizija i kalkulacija toga šta je sigurnost mesiđu od autentikljišem kodove i sad ovo se odnosi na to, na napad kod koga napadač hoći da pronađe tajni ključ, zato što mu to onda otvora mogućnost da gine rješe mesiđu od autentikljišem kodove prakčno za bilo koju poruku. Druga vrsta napada je da proba za određeno poruku da samo tu poruku zamini nekom drugom koja daje isti mesiđu od autentikljišem kod. U tom slučaju će njegov zadatak biti nešto što je minimum odnosno manji broju 2 na k ili 2 na n, ali on u tom slučaju će pronaći neku drugu poruku koja daje dati mesiđu od autentikljišem kodove, ali neće imati ključ, tako da neće imati mogućnost da gine rješe neku treću poruku koja će dati neki mesiđu od autentikljišem kod, koji će proći proveru onoga ko dobija tu poruku. No dobro, to je neka mala analiza sigurnosti mesiđu od autentikljišem kodove i kako ova dva parametra, to su veličina ključa za jedne i veličina samog mesiđu od autentikljišem koda utiču na složenost posla koji ima napadač. E sad naravno, ono što uvek može da si desi, to je da algoritm nije siguran i vidi ćemo ono što je interesantno jedan od primer algoritama koji će vam pokazati na kolik sledećnu slajdu, je primer algoritma koji je napravljen, koji je biostandardizovan, koji se zvanično koristio 20. godina, a imao je u sebi jedan problem, pa ćemo da razmatrimo kolik je taj problem i da li je to ozbiljen problem. U zvokom slučaju ovdje imate primer jednog trivijelnog mehanizma za mesiđu od autentikljišem kodove, gdje se mesiđu od autentikljišem kod izračunova na način, kako je pokazano u trećim buritu, to je ovdje. Mesiđu od autentikljišem kod se računo tako što se urodi eksklusivno ili svih blokova, poruke, poruke izdaljenu blokova, određene veričine, podrozumeva se da si koristi neki simetričan algoritm koji ima upravo tu veričinu bloka, kao što je veričinu blokova poruke na koji je izdaljena, izračuno sa eksklusivno ili tih poruka i sad mi smo videli na predhodom predavanju da te primjere ih jaš funkcija koje koriste eksklusivno ili i tada smo prokomentari sali da je kojoj takvih primjera trivijalno pronajati drugu poruku koja zadovoljava koja ima isti heš, tako da smo nekako disfalifikovali te algoritme. Ja ovo je neka varijanta u koja neka kaže, joj dobro, ja sad neću da koristim samo eksklusivno ili, nego ću ja kada uradim eksklusivno ili svih tih delova poruka da onda to šifruje v simetričima algoritmom, pa ćemo moj message authentication kod zapravo da bude eksklusivno ili svih poruka koja je šifrovano svih blokova poruka izvinjano se koja je šifrovano simetričim ključom. I sad to kao delo je da je sigurnije, međutim zapravo nije sigurnije, zato što umest ove poruke m koja je ima naprim. n blokova moguće da se napravi bilo kakva druga poruka y koja će imati isto recimo tih n blokova, gde će n-minus 1 blokova imati bilo koji proizvoljnu vrednost, a ovaj anti blok, znači ovaj ovdje blok y-n, treba da se podesi na ovu vrednost, znači da bude eksklusivno ili svih blokova od y-n do y-n minus 1 i eksklusivno ili ove poruke m. I ako se napravi da je to blok y-n, znači svaka taka poruka y koja ima izbudjen sadržaj od y-n do y-n minus 1 i ima y-n podešen na upravo ovaj način, će imati isti message authentication code kao poruka m, odnosno trivialno i podmetnuti drugu poruku koja će dati isti message authentication code. Zašto je to tako? Pa to je prilično prosto, možete lako da ove to i sami znači ako je poruka y se sastojio od y-1 do y-n i ako napravimo sada kako se za taku poruku od y-1 do y-n formira message authentication code, to bi bilo y-1 eksklusivno ili y-2 eksklusivno ili tata-ta Pa sad do y-n minus 1 i onda eksklusivno ili y-n, pričemu y-n formirano na ove način y-1 y-2 pa sve do opet y-n minus 1 i onda imate na kraju eksklusivno ili ja ću sam to napisati kao ovo m, ovde da pošto nemam baš prostora na slide. Ja mislim do ovde već možete da vidite šlaći da si desi, znači imamo y-1 eksklusivno ili y-1 poće dati nulu, isto tako y-2 y-2 i y-1 se y-1 tako da je praklično si ovdje faktori će postati nula a ono što će vam na kraju ostati kao message authentication code, takve poruke i isti message authentication code kao message authentication code poruke. I ovaj primjer jednog algoritma koji ne valja i ako delo je kao da je siguran zato što koristi encrypciju koristi tajni ključ, a opet je trivialno pronaći drugu poruku koja će ginerisati isti message authentication code. Ja sam reko na sledeće slide jedan algoritm koji ne valja, ovu zapravo nije algoritm koji ne valja, ta je ta će doći na naravnim slide-u. Ovo ovde što vidite sad je jedan algoritm koji valja i ovo je jedan od najčešći korišenih message authentication code algoritama koji se zove hmac odnosno hash-based message authentication code, znači message authentication code koji je baziran na hash funcijama. Zapravo ovde što vidite neka vrsta ekstenzije hash funcije, sad ćemo da prostudiramo malo kako funkcioniše sam hmac, pa će vam to biti jasno. Sa jedne strane, ulaz u hmac funkciju je ovu ovde i to je poruka koja je izdeljena u određeni broj blokova neke dužine. Koliko će biti veličina tih blokova, zavisi od same hash funcije, znači kao što vidite ta poruka ulazi u hash funciju i recimo ako se setite sa predkodnog predavanja kako izvada SH512, SH512 ima blok veličine 1024. Dakle ako se opirovog algoritmo koristi SH512, onda će ovo veličina B biti 1024 bita. E sad naravno ono što se još dodajeno to, način imamo jedan ulaz da tako kažem u hmac funkciju koja je poruka je. Ono što nam ne dosta je, to je drugi ulaz u hmac funkciju, a to je ključka. E sad taj ključka se formira na takav način da zavisi naravno od togo koliko bita ima sam ključ, ako je B 1024 bita ključ najčešći neće biti tako veliki pa onda bi trebalo taj ključ dopuniti nulama. Znači ako je imamo ključ koji na primer ima 128 bita, a veličina bloka nam je 1024 bita, onda će nakon prvi 128 bita ključa da se dopiše odgovariti i droj i nula kako bi se ključ podužini izjednačije sa veličinom bloka hješloguritva, a onda ne samo o to, nego se taj ključ dovodi na ekskluzivno ili sa nečim što se zove ipad, a to ipad ima vrednost 36x decimalno i to se ponavlja liko puta, koliko je potrebno kako bi se izjednačili taj produženi ključ i veličina bloka i sam ipad. I onda se to što je dovedeno, a to zapravo sada ličin ovakvu strukturu, znači poruka konkatenirana sa nekom tajnom vrednošću ili sa ključem, to se dovodi na hješfunciju i dobije se prvi ovaj izlas koji predstavlja hješ od te tajne vrednosti i same poruke. E sad to nije kraj, nego se onda takav hješ dovodi na drugi blok hješfuncije, gde se sada ponovoprimenjuje ključ, pričemo se sada ključ dovodi na ekskluzivno ili sa ovom ovdje vrednošću koja ima vrednost 5cxx, naravno se opet ponovljenu, ili kutak u liku treba da bi se dobilo b bita, ponovlj se radi hješfuncija i dobije se ono što je izlaz koji se zove message authentication code. I kao što možemo dovidimo, ovo zaista jesne message authentication code funkcija, odnosno ispunjava neki uslovek koji su postavljeni pod message authentication code funkciju, a to je da ima dva ulaza, jedan ulaze poruka, drugi ulazi je neki tajni ključ. A sa druge strane, ono što čini sigurnost ovakog algoritma, to je sigurnost samih hash funkcija.
 Zgodno kod HMAC algoritma i zašto se taj HMAC algoritm koristi i danas, a ako se nevoram, on je nekde 95-96. godine napisanje RFC dokument koji im je taj HMAC definisan. Ono što je zgodno kod ovog algoritma to je da ukoliko neka hash funkcija zastarit, a u vreme kada je nastav HMAC koristile su se ona prva verzija MD5 koja imala lečinu hash od 128 bita i prva verzija SH algoritma koja imala lečinu hash od 160 bita, pa onda se posledaj svetak godina zaključilo kako ti algoritmi više nisu dobri. E, ono kterunka kada se zaključi kako neki od ih algoritma više nije dobar i kako treba da si poristi neka nova verzija, sve što treba da se urodi, to je da se samo zameni ovaj hash block. Naravno, sama algoritma mora da se prilagodi, tako da se ova veličina bloka sami poruki, koji će se poruke izdeliti, potrefi i podesi da odgovara o nome što je sam taj hash algoritm, ali u principu nije teško implementirati tako modifikaciju, tako da se HMAC funkcije i dan danas koriste. I to vaši rečunari i telefoni ih koriste i dan danas svaki dan kad go dodete na neki website, jedna od stvari koji će koristiti vaš browser plikom razgovaranje sa nekim tamo websiteom će biti upravo neka verzija HMAC funkcija. Takođe pričaćemo isto ko da ip seka se koristi hash manager authentication code, tako ovo je zaista jedno jako često koristio na forma message authentication code. A kao što mošte da vidite, ja verujem da ako skinete code za neku hash funkciju, da vam ne bi trebalo baš mnogo vremena da napišete kod koji će generisati hash message authentication code. Praktičo ja verujem da već posebno SI četvrta godina da bi to mogu da napiši za manju ocat vremena i da napravi svoju HMAC funkciju. Naravno, postoje sve te funkcije već napisane tako da ako vam treba da iskoristite za neku vašu aplikaciju samo treba nađete odgovorit ću klasu ili šta već da to implementirate. Dobro. E sada, ono što, tako i jedna strategija je da si za message authentication code-ove koriste hash funkcije. Druga strategija je to je ono što smo videli na slide do malo rani, je to je da si koriste symmetric i algoritmi šifrovanje zagenericenje message authentication code. A to je nekako i logično da postoje te dve strategije, zato što jedna strategija posmatra message authentication code kao nešto je srodno hash funkcije što da je izlas fiksne veličine i onda samim tim, ajde da probamo da nekako raširimo hash funkciju kako bi smo dobili message authentication code. Sa druge strane, message authentication code-ove imaju taj ključ koji je simetričan i onda ajde da probamo da nekako proširimo simetrične algoritme kako bi smo dobili message authentication code-ove. I jedan od prvih standarda koji je napravljeno, to je standard koji se zove DA, odnosno Data Authentication Algoritm i to je algoritm koji je nastao 1985 godine, dakle dosta je davno nastao, to je vreme kada je DES bio praklično jedini široko prihvačeni algoritm za simetrično šifrovanje i taj DA standard je dugo bio korišćena, vidjet ćemo da ima jedan strukturni problem. Ajde sad da vidimo prvo kako radi, da da je DA je zastavljena na des u Cypher Block Chaining modu, sad bi trebalo da znate što je Cypher Block Chaining, dakle Cypher Block Chaining je onaj mod kod koga neće svaki block biti jedinstveno šifrovan ključem i kao što se koristi kod elektronik codebook moda, nego će izlaz i tog bloka biti dovedet na ulaz bloka i plus 1 i exuzivno sabran sa blokom i plus 1, pa će se onda vršiti eklipsija. Dakle iz perspetive šifrovanje to je mod koji je zgodniji, a taj Cypher Block Chaining mod ima jednu zgodnog subinua, to je da praktično kad pogledamo poslednji blok koji je šifrovan, to je ovdje blok ON, taj blok ON i biti u njemu su funkcija svih bita koji predstavlja i ulaznu poruku, zato što i neki bit koji se nalazi ovdje će uticati kroz šifrovanje na izlazni blok tog prvog, na ono što je šifrovanje u tom prvom bloku pa će to uticati na drugi blok, na ulaz drugog bloka i tako dalje, tako dalje, dakle uticaće svaki bit ulazne poruke na message authentication code. Esad sam da je a algoritam je predvijđao da taj message authentication code ili data authentication code kako se u njemu zvao, bude izvučen iz tog poslednjih bloka i da ima 16 do 64 biti. Zad naravno, celokupno je ovdje do sadašnog priče vama i jasno da je to kratko, ali za to vreme, znači da je mali broj bita, nose mnogo 16, to je zaista smešno, ali ajde, čak i 64 da suzme kompletan blok, to je danas gledano su više kratko. To je jeste jedan problem, ali to je problem sa samim algoritmom koji je korišim, prosto i njega je pregazilo vreme i on se već z 20 godina gotovo više ne koriste. Međutim, ovo je algoritem ima jedan drugi problem, sada ćemo da pokažemo šta je taj problem. Ajde da posmatramo samo prvi blok. Ako pretpostavimo da je poruka kratka, znači poruka ima 8 byte, 64 bita, takva poruka se neće podeliti u više od jednog bloka i ona će imati samo taj blok, da je jedan. Praktično, message authentication code algoritem će biti samo ovo šifrovanje, a message authentication code neće biti sada nešto što je funkcija više blok, a ne će biti izlaz ovog prvog bloka. I to je message authentication code. E sad, šta može napadač da uradi? Napadač može da uradi slajjeću stvar. On zna i uhvatio jednu poruku koja je veličine jednog bloka koja ima 8 byteva i znanjen message authentication code. Ono što napadač može da uradi, on sad može se napraviti poruku koja je veličine 2, da ću ja malo ovdje obrišem. Može da napravi poruku koja je veličine 2, koja će biti na ovaj način formiran. Znači, ajde, ovdje ćemo da ovo predstavimo, ovo je neko o1. Ako on doda, znači, na prvi blok da bude blok d1, a onda napravi da ovaj drugi blok bude ova stvar, d1, eksluzivnu ili o1, ako tako formira drugi blok, što će se ovdje desiti? Na to d1 eksluzivnu ili o1 doći će ova operacija novog eksluzivnu ili, da će se još jednom dodati o1, pa će o1 i o1 dati 0 i zapravo što imamo ovdje, način u ovaj ovdje tački ćemo imati d1. Ako u toj tački imamo d1, to je ispru što imamo i u ovaj ovdje tački od poruke koja je veličina jednog bloka, a što to znači, znači će izlaz ovdje biti, ona isti izlaz o1. Što avo dalje znači? Dobili smo drugu poruku koja je ovako formirana, znači to je poruka koji izloga ovako d1, pa je na nju konkatenirano d1 plus o1. Takva poruka će gini risati isti message authentication code kao ova prva poruka, odnosno na jedan vrlo triviala način smo pronašli drugu poruku koja daje isti message authentication code. I to je nešto što čini jako nesrećenim ljude koji se baju kretografijom, to odma znači da postoji problemu samom algoritmu i da tu nešto niju vredu, pa ćemo vjetiti sad malo kasnije na koje i način je taj problem i rešen kojih nekih kasnijih algoritama koji su se pojavili. Sada dalje ovo ozbiljno, koliko je ozbiljno, pa sad o tome može da se diskutuje, zapračo za neke duže poruke je teško izvesti ove napad. Recimo, ako poruka veličine 2, ono što napadač vidi, on vidi ovo, ovo vidi, vidi uloznu poruku i vidi ovo je ovde o 2. Ono što je njemu zapravo teško, to je da sad da zna šta je ovde uslo na ula za ovog bloka, zato što ne vidi ulaz prvog bloka, tako da mu nije baš trivialno da napravi poruku dužine 3 koja će da ti isti uklipiti kešnko. Miđutim, ako se uzme u obzir, recimo, te, druga polovina 80-i godina, 90-i godine, recimo, tada je windows imao neki svoj archaicni sistem za čuvanje lozinki koji imao jedan način čuvanje lozinke, ako lozinke imaju do 7 byte-ova, a drugi način ako imaju do 14, maksimala veličina lozinke 14 byte-ova bila u tim starim verzijama windowsa, jer recimo, tako situacija ako neko uzme i napravi lozinku koji ima 6 slova, mrziga da kuca više, onda tako, ako bi si čuvala recimo nekim ovakom vrstom hash ili message-authentikiškom funkcije, tako kratka poruka, onda bi nekom je bilo mogući da generiši drugu poruku koja daje isti message-authentikiškom kod. Dakle, ovo je nešto što nije dobro i što je loša stranova aguritma, a sad videte ćete na narodnim slajdovima kakve taj problem reši. No, prenego što pređemo na tu, na taj drugi algoritm koji se zovec MAC, samo jedna mala digress, ja u moživremenu je bio napravljenja algoritm koji se zove billpool koji su napravili ljudi koji su napravili i IS algoritm i to je algoritm koji tako
 kodže pokušalo da napravili hash message authentication kod iz kryptografskog algoritma s tim što je ovde zasnovan na jednoj modifikaciji AS. Znači, ovo što ovde vidite, to naravno nije ceo algoritm za šifrovanje. Ovo je algoritm koji šifruje samo jedan blok. I ovdje je dosta sličano ono me što smo videli na predhodnom slideu pod ideje A-A-algoritma. Raznikve se izlazi iz tog bloka. Znači, ovo ovdje što vidite, ovo W to prestavlja ta algoritm za šifrovanje koji je jedna modifikacija AS-a koja može da se pronađe. H i-1, znači, izlos predhodnog bloka se dovodi, ali sada se dovodi kao ključ naravnog bloka. Znači, sad više nemoj isti ključ u svakom bloku. I to H i-1 se dovodi na ekskluzivno ili, ali sada se ne dovodi na ekskluzivno ili pre-enkrypcije, nego se dovodi na ekskluzivno ili i zaenkrypcije i tu se dovodi i i ti blok. Znači, malo je modifikovanja ova funkcija kompresije, i tak, funkcija kompresije su zovem jaguči tremel i naravno ne morate paprići ovo ime, nego prosto da znate da postoje još neke varianti i možda najđete negde na ovaj virupolo algoritama. A on je interesantan zato što je to jedan od typograskih algoritama koje autori nisu chceli da... nisu chceli da napre patent od njega, tako da je slobodno mogao uvek da se koristim. E, dobro. Ono što je još ostalo, to je sad ovaj cmat algoritm, odnosno sajfer-based message authentication code. To je algoritm koji je jako sličan o nam DAA algoritmu i zapravo prestavlja jednu modifikaciju tog DAA algoritma. Da došto ako pogledajte način na koji se generiše message authentication code, to je ovo ovde, sve je gotovo isto do zadnji koraka. Ovde imate klasičan sajfer block chaining, gde se dovodi isti ključ za svaki blok, da se izlaz predhodnog bloka dovodi ne ekskuzivno ili sa ulazom narednog i da se message authentication code izlači kao jedan deo ovog posljednjeg bloka inkripsije. Ono gde je napravljeno jedina razdika koj sajfer-based message authentication code, to je zadnji korak, to je ovo ovde, da je vidite jedan dodatak. A taj dodatak je šta? Taj dodatak je ovde dodatni ključ koji je napravljeno. Znači ako malo je sitni slide, ali nadam se da se vidi, na svaki blok zašifrovanje se dovodi ključ K. Za razliku toga, na ovaz posljednji je ekskuzivno ili se dovodi ključ K1. Taj ključ K1 je izvedan iz ključa K. A zašto je ovu urađeno? Ovo je urađeno upravo zato da bi se sprečila una vrsta napada koji samo malo predemonstriralo pod DAA algoritma, gde ako je poruka kratka, može da se gine riše druga poruka koja će dati isti meseđ autentikljivšem kod. Ovde to ne možemo dovradi možemo, zato što u posljednjem poruku na to ekskuzivno ili dolazi nešto što mi ne znam. A to je taj ključ, odosno ne mi, nego napadač ne znam, a to je taj ključ K1. I u samom algoritmu postoje dve varijante. Jedna varijante je kada je poruka jednaka tačno, celom broju blokova na koja potrebno izdeliti poruku. I u tom slučaju se kodeti ključ K1 i u druge varijanti kada je poruku potrebno dopuniti nekim pedingom, onda se koristi ključ K2. A ključevi ka jedani K2 su izvedeni iz ključa K. I ovde imate recet kako se to radi, ali ne morate to da gruvate, zato što neću vas maltretirati i da morate to raznate. Koristi se modular na ritmetika sa polinomima. Dostaj, neobič modular na ritmetike sa brojvima. Tako da, samo informativno imate da objeznam šta je, možda neko bude chtevo da se poigra. Prvo treba se generiše vrednost tev koja se dobija kao rezultat inkripsije nule tajnim ključem K. A onda se ključevi K1 i K2 dobijaju kao množenje tog L sa X, odnosno sa X na kvadratu, odnosno sa od uzavisnjosti u toga kolika je veličina ovog L ako se to prestavi kao polinom, a poštu i pitanje modular na ritmetika po ovom nerazloživom polinomu ovdje CS128, kori eče 128 bitnim blokovima, zapravo to može da može da znači da je K1 samo šiftovan za jedno mesto u levo taj, taj nizbita L. Ili za dva mesta u levo K2, ukoliko su vodeće nule tog, tog broja L nule. No dobro, u svakom slučaju ono što ne morate da zapomitite, to je ovaj polinom i te stvari kao se formiraju i ključevi K1 i K2, ali ovu logiku zašto je to urađeno, to treba da zapomitite i to ako pogledate neke starije rokove moćete da vidite da je to isto bila jedno pitanje koje smo volili da postojimo zato što ovaj volimo da vidimo da razumete logiku samog načina funkcionisanja ovih algoritanu. E dobra. Za kraj, ostalo je da vidimo jednu primenu meseču authentication kodova koja je ovako interesantna i ovo ste možda nekad videli. Ovo ovdje što vidite o sličicu ova dva, ove dve drangulije koje postoje, to su tako zvanih hardware-ski tokeni i to se nekad koristi, recimo, to vole da koriste banki, ako je potrego se napravi dodatna provera nečeg identiteta. E sada ide prenevo što vam objestim kako funkcioniši ovih tokeni i šta smo oni zapravo, da napravimo jedan korak u nazad i da vam napravim nekoliko definicije. Kada se recimo loguete na fakultetski sistem, taj fakultetski sistem odva straži da unesete i uza nemipastit. Takva vrsta autentikacije, to se zove jednofaktorska autentikacija, zato što vam je zato potrebna jedna tajna informacija i tajna informacija je vaša lozika. I sada pošto svi znamo da su sistemi podložni razbijenju, tome da neko dođe do svih lozimki nekog sisteme i stavno čujete u medijima da postoje takve slučevi, onda u onim situacijama gde se radi sa nekim podacima koji su osjetljivi, kao što su, na primer, finansisti podaciji, kao što recimo mogućenost da izlošite neko plaćenje većih svota novca preko banki, takvi sistemi je obično traže dodatno odentikaciju, odnosno dodatnoj proveru identiteta. I recimo možda ste to je videli ja konkretno koristim banku Intezu kada plaće na nešto preko interneta, i recimo banku Intezu ima mogućenost da kao dodatni mehanizam autentikacije tog plaćenja mi pošalje jedan ovaka brojšest o cifreni kao što je novim tokenima koji je dobije mesemesom. I to je ta dodatna autentikacija, ovo su to je tako zvona dvo faktorstka autentikacija, zato što, pored toga što ste vi nekom sistemu predstavili svoji username i password, treba da predstavite i jedan ovaka dodatni broj koji je formirano na osnovu, sad ćemo viditi čega, kao dodatni stepen provere identiteta. Naravno, ovi se brojvi menjaju i to ćemo da vidimo sad kako se menje i čak ćemo mi malo ove to demonstrirati da vidite kako to izljeda svarno u praksi. Posto je dva algoritma, stariji algoritm se zove hotepa, odnosno chmac-based hotepa, odnosno one-time password koji je zasnovan na chmac-finici, a sad znate što je chmac. A novi algoritm je tako zvaný time-based hotepa, odnosno totepa i ovdje što vidite u Harbevski i Software šti tokeni i Google autentikator koji ćemo vkazati, oni koriste taj hotepa. Hotepa tako će koristi hash-funciju, sad ćemo vidimo kako to izdava. I sad ćemo da pokušamo da obislimo kako to radi. Ono što je ulaz u chmac-funciju, postoje dva ulaze naravno kao u svaku chmac-funciju, to je ključ. I taj ključ je generisant kada ste dobili servis. Svećimo, ako vam bank daje onaj hardware-ski token, u taj hardware-ski token je unesen neki ključ, odnosno taj hardware-ski token je napravljen sa nekim ključem, a u trenutku kada vam bank daje taj hardware-ski token, onda će neki tamo operator uneti uz vaše ime i uz vaš nalog koji je to ključ koji treba da se korist. Znači to je jedna tajna informacija koja je podeljena svakom koristiku u nekom trenutu. Druga informacija, ono što ulazi u taj algoritm, to je vreme. Sad naravno, to vreme je tako da se naravno negli da svaka 100 tinka i svaka 10 tinka, zato što bi, ako bi se menjeli ti brojevi na sekundu, bi ne bi ste stigli da vukućate broji za odgolače vreme, ono što je neka ulobičaj na prakse, to je da se brojevi menjaju svaki minut. Tako da i ovo ovde vreme koje vidite, to je ove vreme naravno uređi, moraju da budu nekako vremencki synchronizovanji, ali synchronizacija na nivou sekunde 2, to je jako lako ostvarivo, to će mojaš komentare se ti naravnih predavanjima. I znači ovde imate vreme koje se menja svaki minut i onda se nosno u vremena i ključa izračuna chmac vrednost toga i dobit ćete neki izlas koji ima, sad zavisi od toga koji se sha algoritm koristi, recimo dobijete 256 bita ovde izlze i smac funcije. E sa 256 bita 2 na 256 je prilično veliki broj, a tamo smo videli da oni hardeljski tokeni imaju obično 6 cifara i to je neka praksa da recimo za minut nam neko da da ukucete tih 6 cifara i to je nešto što čovek može dovradi čak istari i neko ko se slabije znalaze sa rašunarima. Tako da se onda od tih 256 bita na primer koje smo dobitili
 ili smac funcije, skrati na 31 bit. 31 bit u tomu dođe nekde oko 2 milijarde, 2 na 31 i time praktično može da si gdje ne riješe osmocifreni broj, ali, ajde, kažemo što cifreni broj nešto što nam treba i onda se iz toga izvuče 6 brojela. To skraćivanje na 31 bit nije trivialno, nije izvedeno tako što se uzme donjih ili gornih ili ne znam kakvih 31 bit koji su jedan za drugim, nego se, nego postoji neki algoritm na osnovu vrednosti tehješ funcije koji se biti izabero. I u svakom slučaju ono što je izlaz, to je neki 600 cifreni broj iz tog uređaja, taj 600 cifreni broj će se promeniti svaki minut. Znači svaki minut ćemo imati drugačiji uvrednost tog one-time pasvorda, a ono što će sistem očekivati, to je da u trenutku kada se logujete, pored vaše lozimke, uzrene imaju lozimke, vidite stavite i taj broj koji mora da ima u tom minutu onu vrednost koju sistem očekuje. I sad ćemo da vidimo, sad ću da zaustaviti deljenje sa ovog tableta, a posti ću deljenje na drugom računaru da vam pokažem kako to izgleda za primer Google Authenticatora. Evo vidite, ovo što vidite ovdje, ovo 6341336, to je broj koji važi u toku ovog binuta. U doljom desnom uglu možete da vidite, mislim tog prozočića, vidite ovaj sat koji kao ističe, i ovo znači da za 15 sekundi ovoj broj više neće važiti. Evo sad će onda potrveni što znači da uskoro ističe vrednost tog broja, i sad da evo ga počaje novim minut i generisanja novih 600-cifrenih broj. E sad taj broj je funkcija neko ključa koji sam nja uneo kada sam ovo konfigurisava, koji mi je dat kada sam formirala nalog za ovu virtuo privotnu mrežu koju koristi. Tako da, naravno evo sad vidite sad taj dokelo pričam, novi minut ističe, a onda će sad da se pojevi naredni minut i onda tako to vrti, vrti, vrti stalno, pričajmo u onom trenutku kada meni treba, kada unosim taj broj, način ako bi se sad logo ovom morao bih da imam ovu vrednost koja je ovde navedena. Dobro, ja se nadam da je ovo bilo jasno, evo je sad zaustaviti snimanje. Digitalni podpis je praklično poslednji teorijski koncept koji postoji, koji se odnosi na elementek kritografije koji se koriste kasnije u formiranju različnih aplikacija i predstavlja jedan od najinteresantnih algoritama i mehanizama koji su napravili. Ono što smo do sada videli, to su algoritmi i mehanizmi kojima se štiti poverljivo sporoka, to su algoritmi za šifrovanje, videli smo kako funkcionišu algoritmi kojima se vrši razmina klučeva za se metične algoritme, videli smo kako funkcionišu asimetične algoritmi koji mogu da se koriste i za razminu, kako funkcionišu asimetima klučeva za troveru nećeg identiteta, videli smo hash funkcije, mac funkcije i sada su ostali digitani podpisi. Šta je uloga digitalnom podpis? Uloga digitalnom podpis je da u potpunosti zameni klasičan pisani podpis, rukom pisani podpis. Da bi smo razumeli što pačo treba da radi digitani podpis, da vidimo šta mi to radimo kada stavimo podpisi za neku dokumentu. Kada stavimo podpis na neki dokument, to onda obično znači da smo mi autor tog dokumentu ili makar da se slažemo sa sadržem tekst, koji se nalazi u tom dokumentu. Također ako ta dokument ima na sebi napisan datum, onda znači da znamo i tačno kada je generizat datum, tim mi garanto je autenticno sadržete poruke i u nekim uzbiljnim situacijama kada se zaktiva ako je ta poruka pisana na više listova, onda nije dovoljno podpisati samo na svaku, na zadnju stranu, ne bi o potrebno parafirati sve strane tog dokumentu ili se čak stavljali i pečati na sve strane. I ono što običnog podpis treba da o mogući, to je da neka naša izijava ili da neka naša obave za, tim je postane pravo snažno. Na primer kada podpisemo da želim da prodamo automobil, da kupimo automobil, da prodamo stan, da damo neku izijavu povodom neku događe i tako stvari, to onda mi radimo tako što stavimo svoj podpis. Nakle, taj podpis je na tom celom dokumentu nešto što je relativno malo, nešto što je svojistveno nama, podpis svako ima na neki način drugači, ima da sad, da se dobro uatno svako u dva sveći može da se kaj že malo dobro, ako može da se falsifikuje i ako biste pokošali da falsifikujete neči i potpis, ja verem da vam ne bih mnogo vremena trebalo. Za okrom slučajom trebalo manji vremena da naučite kako da falsifikujete neči i potpis, nego što bih trebalo nekoma da, kada postoji digitarni potpis, da mehanizmom brute force napada napada takav digitarni potpis. E, digitarni potpis i treba to sve da nam mogući samo u digitarno mobil, dakle da to bude nešto što će biti neki nizbita, koji će biti funkcija dokumenta, koji se podpisuje, koji će biti funkcija autora i koji će biti, ono što je najvažnije, to je da se streči mogućnost poricenja toga da je nekoliko sam dokument podpisao. To su, one stvari koje predstavljaju digitarni potpis, ono što je sad dodatno potrebno, to je da taj digitarni potpis bude relativno lak zakrivenje, dakle da mi ne treba četri dana računanja da bih izračuno digitarni potpis nekoliko dokumenta, nego da to mogu da uredimo par sekundi, također kad nekod obje dokumenta može relativno lako da proveri da je taj dokument zaista potpisan od strane, one osobitu koje treba da bude potpisan, to treba da bude lako, ali se drugi strane, ono što na podaču treba da bude teško, da kada imaja neki digitarni potpis, to je da podmetne neki drugi dokument pod taj digitarni potpis, koji će prevariti sada nekoga i koji će zatvjučiti, recimo naostom u tog podmetnutog dokumenta, da je u pitanju, koji će naostom u tog postojećeg digitarnog potpisa, verifikovati neki podmetnuti dokument, znači falsifikovani dokument. I vidićemo, kakvi su to algoritmi koji zadovoljavaju osobinje digitarnih potpisa, ono što bi nekome od vas mogu da padne na pameti, što verujem da je, ono su siguran sa pošta miški dobio tako pitanja, što bi nekome mogu da padne na pamet, to je pa dobro, a zašto ne bi smo iskoristili hash functiju, pošto hash functija nam daje nešto što je malo i što je funkcija same porukje, s jedne strane, i z druge strane zašto ne bi smo iskoristili privatnik pjuč, kod asimetričnih algoritm, zato što privatnik pjuč je nešto što samo ja imam, i na taj način da creiramo digitarni potpis. I ovde na gornih slici imate jednu takvu šemu, koja zadovoljava te uslove, koja smo sad malo prepomenuli, ja će se pozabaviti samo u gornim šemu, jer se donja šema razdikoj samo u ovom bloku, zato što tu se šifruje sadržaj poruke, da je razdike samo u tome da se čuva poverdivosti, i ne. Kod u gornih šemi postoji poruka M i ta poruka se daje nekome, u krajnju liniji mi znamo da, recimo, kada propisujete neki ugovor se nekim, to nije tajni dokument, ne treba ga scrembolovati, i nekako hi šifrovatite, prostupaj dokument, koji treba da može da se pročita, da takav dokument buder na neki način potpisa. I mi je tog dokumentu uznamo i izračunamo hash, dakle dobilj smo neki niz od 256, 511 bita, koji su funkcija ovog dokumenta M, i onda smo taj hash uzeli i šifrovali smo privatnim ključom. Šta ovo znači? Ovo znači da ako ja sam jedinicu i posledam taj privatni ključ, samo ja mogu da ga šifrojam, i sada ako pošljem vama neki takav dokument, recimo, pošljem odoveštenje da će kolokljom biti 5. maja u 11.30 Da biste vi proverili, da li je ta informacija zaista autenticna i da li je došla od mene, šta treba da uvediti? Treba da uzmete tu poruku, da izračunate njen hash, treba da uzmete ovo taj izračunati digitalni potpiste poruke, da ga dešifruvajte mojim javnim ključom, pretpostavim da sam dao svoj javni ključ, i nakon dešifruvanja da uporedite taj dobijeni hash, odnosno izračunati hash sa onim, što je dobijeno dešifruvanjem. Ukoliko se pokope ova dva hash, adončijako su jednaki, onda vi možete da kažete da, o u poruku je posla profesor, i ja zaista verujem da je kolokljom u 11.30. I vi dođete 5. maja u 11.30, kad ono nema nikogu, ni mene, ni asistenanta, nema nikogu. I dođete tamo da se žalite i nekomu, da ste bili prevareni, da ste došli kad je najavljeno, da se to nije desilo, koji je način kako bih ja mogao da se branim od toga? Ono što je moja linija odbrana, to je da kažem, ja se izvinjavam, meni je neko uhakovo moji računar i neko je ukravo moji privatni ključ, i to u stvari, nisam tu poruku ja, generisio, to je možda generisio neki vaš koleg. Ono što je problem ko dovoljak veš m, i da je postoji neka vrsta mogućnost i poricenje toga da je neko uradio određenu aktivnost, a poricenje postoji zato što postoje, to je tako zvanad direktne še moj, učestvoju samo dva entiteta. Ako se opet pratimo u analogni svet, u svet običnog potpisivanja, treba da vidimo, kada postoje tako i potpisi, da li uvek postoje samo dva entiteta? Znači samo one dve osobe koje, recimo, radite kukoprodoju stana, kukoprodoju otomobila, ja nevjerem da je bilo kovo dva sto radio i još te dovoljno mladih da ne morate da se bavite takvim stvarima, ali ako je neko od vas radio, onda znaš što treba da se uradio tako u situaciji. Ako nevo sada ću om reći,
 izdati jednog dan. Dakle, ako recimo kupujete i prodajete auto, ili prodajete auto, taj ugor između dve strane morate da odnesete kod notara i da ga tamo verificujete. Znači, ono što u tom svetu koji više nije svet raconara, nego svet papira, mora da postoji, to je neki arbitar, to je neko treće telo, kome svi implicitno veruj. U ovom slučaju kupoprodajeno gugora, na primjer za automobil, taj treći entitet je neko koji je ovošćeno strane država da radi taj posao i da verificuje ovu vrstu transakcija. I kada vi potpisete, znači nije dovoljno da vi potpisete ugor, nego kada se taj ugor podpisuje, vi odlozite kod notara i tamo u neku njegu bu debjelu knjigu se takođe potpisete, takođe tom prilikom donesete svoju ličnu kartu, on je očita i to na neki način dokazuje da ste zaista vi bili tu i da ste zaista popisali taj dokumen. Dakle, ono što u ovdje še mi ne valja, ono je u tehniczkih gledajno potpuno ispravna, već tima ono što u toj še mi ne valja, to je što ne postoji taj treći entitet. I ono što je zapravo kod digitalnom potpisa uvek potrebno, to je da postoji neki taj treći entitet koji će verifikovati vaš potpis. Evo još jedan primjer iz sveta papira, recimo to ne znam da li znate, naš dekan pa i svaka druga osoba koja je na rukovodeće mestu u nekoj instituciji, ona pri likom stupanjanu dušnost mora da uroditi jednu stvar koje se zove deponovanje potpisa. A to je da uzme jedan kartončić na kome će se potpisati i onako kako se inače potpisuje i taj karton sa deponovanim potpisom se stavlja u trgovinski sud. I sad sutra ako bi došli do nekog spora, zato što je te je potpisalo sa nekom firmom neki ugor, onda bi se koristio taj karton i proveravao bi se potpis neki grafolozi, bi morali da kažu, gali u pitanju autenticom potpis. Znači u takoji situaciji postoji, u situaciji kada firme komuniciraju među osobnosti kada imaju i ulaz u neke pravno obveziviče dogovore i u takoji situaciji opet postoji neki taj treći arbiter koji implicitno učestuvaju ovaj razmine. I sad što se tiči digitalno potpis, ako što rejko, hova še ima gore je u tehnicu smislu ispravna, hova še ima gore je takođe ispravna i može da bude ispravna i pravno formalno posmaterno, ali tu fali još jedan dodat. I sad što je taj dodatak, ovaj nežalos nemogu danes, znam kažen nego ću imati spričati sveći nevedelje, to su digitale certifikati i hierarchije certifikata i cijel taj mehanizam formalni koji postoji i za kojem se je omogućeva da se uspostavi ta pravna struktura u digitarnom komuniciranju i digitarnom potpisivanju dokumentata. Na ime jedno stvari koja mora da postoji, to je naravno, ja treba da imam digitarno certifikat na kome se nalazi moj privatni ključ, ali također postoji jedna obave za za mene, da ako ja detektujem da je neku ukravu moji privatni ključ, ja moram to da prijavim certifikacijonom telu, certifikacijonom telo mora da oglasi nevažeći moji certifikati, u tom slučaju vi ja više ne bih morao da se vadim da mi je neko to ukrao, nego bi to sad bilo nekako pravno ozvanično. Naravno tu su bitni trenuci kada sam ja prijavio to što se daš avalo u među vremenu, ali sve to slično možete da tu situacije neke vrste krađe identiteta, možete da zamislite i u svetu koji nije svet računarad, da je to neko ukrade vašu ličnu kartu i recimo malo liči na vas i pojavi se negde i da vašu ličnu kartu nauči o nek potpis koji se stavili tamo koji onakot verovatno ne liči na vaš potpise što pisa li po nekoj plastici koja nije baš prirodna za pisanje i može da se lažno predstavi u mestu vas. Tako da treba voditi računno u načinima prađenje identiteta, krešam ova šema koja ovde vidite gore jeste jedna šema koja se koristi za digitarno popisivanje ali nije dovoljno ovakva sama kakve, dakle direktno izmžu dva identiteta, mora da postoji neki trećen identitut koji će verificovati, koji će uspostaviti neki sistem pravila kako se rukovalovi ovim identitetima i kli učegu. E sad ljudi su ovoga bili svesni još davnih dana, pa su svesnih su tog problema direktnih digitarnih potpisa, kad postoji direktnih digitarnih potpisa samo izmžu dva identiteta, da u takvih situaciji i dalje postoji mogušnost odricanja toga da je neko nešto radio i postoji mogušnost toga da se neko pravi blesan i da mora da postoji neki arbitar koji će učestovati u proveri digitarnih potpisa. E sad ćemo da vidimo, prenego što se bacimo na ove prave algoritme digitalne popisivanje, vidite ćemo neke šeme, ja ću ovde detaljni obraditi samo prvu šemu, koja će da vam pokaža jedan način kako može da se izvrši arbiterne digitalni potpis, čak recimo u sistemu gde se ne koriste asimetrični algoritm. E sad, znači ono što se očekuje i što postoji ako postoji neki arbitar kod digitalni potpisivanje, to znači da mora da postoji neki odnos sa tim arbitarom. I sad možemo da prepostavimo da je taj arbitar neko koji je ili državno ološćim da radi taj posao ili neko koji je unutar neke firme se napravi mehanizem digitalni potpisivanje, pa je to neke entite tu unutar firme kome svi verujem. U svakom slučaju taj arbitar takođe možete dodoživljavati kao neki distribušn centar, ako se govori samo o simetričnoj ekipciji, koji posleduje ključeve za komunikaciju sa svakim od entiteta. Pa sad da vidimo kako to izgleda. Znači ovde imamo tri entiteta, imamo nekoga x koji podpisuje neki dokument, on taj dokument šalja arbitru na verificaciju i kasniji arbitar to šalja ovom drugom učestniku komunikaciji koji za interesan za taj dokument, kako bi on imao tu vrstu digitalno potpisar ovog dokumenta. Znači, ovdje šalje x to je poruk m, šalje arbitru, a arbitar će dobredi sledeći. Izračunno će hash od m, odnosno, izvinja se, x će to dobredi, izračun će hash od m. Na hash od m će dopisati svoj identitet, to može da bude nešto u formi nekog, onog email adresa, nekog uria ili tako nečega. I on će taj svoj identitet i hash od poruke m, šifrova ti ključom koji znaju samo x ja, simetričim ključom koji znaju samo x ja. Dakle, taj ključ iznađu x ja i u spostavljem u nekom trenutku ugoči u opšte početka podpisivanja ovih dokumenta. E sad šta može adre uraditi? A kad je dobi ovaku poruku, darmo može da snimi poruku m i to je nešto što notari radi, dakle svaki vaš ugolo, oni će neko kopiju, nekaj tamo da smestili svoju arhivu, da u situacije ako postoji neki spor, kasnije može da se tako opije kao validna izvuče. A zatim, ono što može da izračunimo, tako će izračunit će hash od m, tim istim algoritmom, znak hoji identitet o log x i moći će da proveri da deshifro je u poruku koji je dobio od x i da proveri sa vrednostima idx i hash od m. I ako je sve u vredu, taj armitar će smestiti i sačuvati ovo. To je dokument m i to je njegov digitarni potviz, znači njegov digitarni potviz i u tom stručaju ovo je ovde nizbita koji razumeju x i a. E sada ako je u pitanju neki dokument koji x propisao, koji ugovor sa y, onda će a da pošalje y, taj dokument na sljedeći način. On će šifrao ati ključom koji znaju samo a i y, poslaći identitet o nogu koja generisao poruku i poslaći sadrže poruke i poslaći vreme kada je poruke generisana, to u mnogim situacijama je veoma značena informacija. Znači vreme kada je dokument generisan je jako važno. Vjec imam možete da zamišli situaciju koji se radi kupoprodeja automobila ili kupoprodeja stana i da se jedna strana obovezuje da odmah isplati na primjer 30%, a nakon 2 nedelje da istotni preostalik 70%. E što znači sa to nakon 2 nedelje? Nakon 2 nedelje znači od trenutnog kada je generisana taj dokument i zato je vreme generisanja dokumenta b. Znači, time će a dobiti poruku, dobit će identitet o nogu koja je generisao i dobit će vreme kada je generisana dokumenta, i poslato i ovolode, a to je zapravo prekopiran ovaj digitani potpis koji je generisao x. I to je nešto što je za entitet y nepoznoto, zato što on ne može da pročita u poruku koja je šifrova na ključem između x i a. Mi ću tima ukoliko dođe do nekog spora, on će moći da se obrati ovome arbitro a i da kaže, dali ova poruka je autentićna, deće onda arbitrar moći da kaže, deće arbitrar moći da kaže da je autentićna. Pitanje, dali je vreme generisana dokumenta o strane x ili strane a, pa sa to je dobro pitanje, ali pretpostavljajte se, znači kada ovdje te recimo da overite neki ugovor, ono što će se posmatrati, to je datum kada je notar to prihvatil. Dakle, ja pretpostavljajte majde se dove neka hipotetića šema, ja pretpostavljam da bi to bilo, bio trenutak kada je ova poruka koja se nalazi u drugom bulitu, znači od x ka, kada je ta poruka stigla kod arbitra i kada je arbitrar to verifiko. Arbitrar to može da verifiko je praktično trenutna što operacije koje se izvašavaju za par minut. E dobra, znači ovaj bi bio primjer jedne šeme, gde postoji arbitrar da se koristi skličiv o simatrične algoritme. Ja se neću baviti ovim narodnim...
 varijantama, ove pošto nisu pretrne interesantne, batite ćemo se na ono kako farno raditi algoritmi, ali možete da pogledate ove varijante. Varijanta dva i istak, kao varijanta jedan, jedino što je obezbljedećeno šifrovanjem nekim ključem izmađu XY, da se porukaje, da arbiter ne vidi tu porukuje. Znači možete da se naprave čak i takva še ima da XY potpisu neki dokument, a da taj takav dokument bude verifikova na strane arbitera koji ga čak i neće videti. Pogledajte, ovo malo, prostudirete malo kako ovo izvijedat, da li vam je jasno ovako delo je složeno, zapravo nije složena šemo. I naravno imate ove varijante kao što varijanta tri, gde postoje asimetrične ekeipcija, da se i šifruje, i koriste se i privatni ključ i javni ključ i tako da je tako da je. No da se ne zadržavam na tim varijantama koje danas nisu označe, idemo na ono što su stvarni algoritmi koje se koriste za digitano popisivanje. Prvi takav algoritm je Elgamalov, digitarni potpis koji je napravio Takher Elgamal, čovek koji radi u onoj firmi Netscape i koji dan danas aktivan u oblusti kriptografije. Ovo i digitarni potpis i njegov algoritm je nastavu ono vreme kada su nastali i ostali asimetrični algoritmi, tako da vidjećete matematika koja se koristi upozlednije i jako slična ono me što postoje kod Diffy Helmanovog algoritma. E sad sam Elgamalov, digitarni potpis ovakav kakav je se ne koristi, ali ću vam go ja ispričiti za to što je ta Elgamalov, digitarni potpis inkorporiran u nešto sdo se zove digital signično standard, oduzno DSS, a to je standard koji je prepoznat kao zvanječan, jedan od zvanječnih standarda za digitalno potpisivanje i koji između ostalo tak i naš zakon u Repubici Srbiji prepozne kao validan algoritm za korišći. Nešto je jednostavniji Elgamalov, digitarni potpis, tako da ću ja, kroz objašnjavanje Elgamalov, digitarno potpis, da vam objasnim veći deo onog kako funkcioniše DSS standardu. Ele, opet da se malo pocitimo, ovo počinje kao Diffy Helmanov algoritm, a postoje dva broja, jedan broje, pros broj Q, drugi broje je broj Alfa koji je njegu privitivni Koren. Privitivni Koren znači da ako broj Alfa podignemo na sve stepene od 1 do Q minus 1 i urodimo tu eksponenciaciju po modu luku, odnosno u delinju sa Q, u pogledamo koji su ostaci, dobit ćemo za sve ove vrednosti Alfa od 1 do Q minus 1 različite vrednosti, a Alfa na Q minus 1 po modu luku će biti 1. I to možete da proverite, to smo već pričali o tome ranije. Ovo je potpun na isto kao kod Diffy Helmanov algoritm. E sada, ako je Q pros broj, ako je Alfa njegu privitivni Koren, onda važe ove dve jednačine dole, a to je da ako Alfa na M daje ostata 1 po modu luku, onda M deli Q minus 1 i to je ako je privitivni Koren zapravo uvijek tačno zato što, recimo, kod broje 19, ako imate broji, ako je privitivni Koren 10, 10 na 18 daje ostata 1 po modu luku 19, a to znači da M koje je 18 po modu luku 18 daje ostata 0 zato što 18 deli 18. I imate drugu ovu jednačinu koja kaže za dva broja Alfa na i, ako Alfa na i kongurentno sa Alfa na jot po modu luku, onda je i kongurentno sa jot po modu luku minus 1. I ovom je označen, ja sam postavi ove plavi broj dva da vam to ukaze, da ćemo baš tu jednačinu koristiti malo kasnije, odnosno ove identite koje su da ćemo koristiti malo kasnije kod opisa Lgm alovog dijigitarnog potpisa. E sada, kako funkcioniš sam Lgm alov dijigitarno potpis, znači, ono što su globalno poznati elementi, odnosno što poznajem, ja koji dijigitarno popisujem dokument i vi koji treba da verificujete moji dijigitarno potpisani dokument, to su broje viku i Alfa, to svi znaj, to nije nikakva tajra. E sada, ja ako koće da potpisem dijigitarno element, ako koće potpisem neki dokument, treba da kreiram dijigitarno potpis i to radim tako što kreiram neki broj xa, gjenerićem neki broj xa koji između jedan i ku minus jedan i to xa je moj privatni ključ, dakle to je nešto ja ne smim nikome da dan. Na osnovu ovog xa, na isti način kao kod if i helmonovog algoritma, ja izračuno vam javni ključ i javni ključ nešto ja treba vama da dan, ako biste kasni i mogli da proverite, da li sam ja zaista dijigitarno potpisao neki dokument. E sada, onda je data poruka m, odredi se ovo malo m koji prestavlja hash od poruke m i to je nešto što ja mislim da ste očekivali, zato što treba da se, reklismo da digitarno potpis treba da bude neka funcija poruke, treba da bude relativno mali, dakle ovo za sad sve deluje, sve deluje normalno. E sada nakon u koraka tri stvari postavio malo čudne, zato što ovom algoritmu treba da se pronazil slučaj broj k, znači ja kada digitalno popisujem, jedno stvari koji treba da urodim, to je da odredim neki slučajom broj k, koji je između 1 i k minus 1 i pri tome k i k minus 1 su uzajanoprosti, odnosno nemaju drugih delilaca osim broja 1. Znači ja treba da pronođem taka broj, to će mi trebat i neku vreme, mora bi da malo tu upotrebim neku matematiku da bi pronoša s gvarećim broj k, ali svakom slučaju pronoša sam tako broj k. Onda slučaju stvari koji treba dorodim, to je da pronođem od tog slučaju broja multiplicativni invers, odnosno broj koji pomnožem brojem k po modulu k minus 1 daje jedinicu i to je nešto što opet je malo procesorski, intenzivno, pronaći multiplicativni invers, ali, ajde, pričali smo tome tako da verujem da to nije pretrenom konflikovanje. Sada ono što je nejasno, šta će nam slučaju broj, kako ono učestu u formiranju digitalnom potpisa, a to ćemo viditi sad na radnom slajde. Esad treba da su izračuna sljedeće stvar, to je ovo s1, što je jednako alfa na k po modulu k. Alfa i k, rekli smo da su to brojvi koji su dostupni svima, alfa i k, a k je slučaju broj. I onda imamo ovo drugo s2 koji jednako ovo je multiplicativni invers brojak k puta hešo poruke m minus moj tajni ključ xa puta ovo ovde s1 po modulu k minus 1. I to s1 i s2 je digitarno i potpis poruke. Esad jedan deo te priče deluje jasno, zato što ovo s2 ono zavisi od heša od poruke od ovoga m i ono zavisi od moj privatnu ključa. Međutim, deluje na prvi pogled priču nejasno čemu ovaj ovde je deo služi, kada taj deo zavisi samo od slučajnog broja k, a taj broj k nije nikakva funkcija poruke. I sad ne samo to videte ćemo da nam, u slari s1 i s2 trebaju za verifikaciju na druge strani. Znači pošto u s1 imamo k, a u s2 imamo k minus 1, odladi će se priliku u tom procesu verifikacije, ta dva broja potreti, vidjet ćemo u kom trnutku. Znači ono će se nekako poništiti i u procesu verifikaciji zapravo k neće ošto figurirati. Odnosno, hoće figurirati, ali će neestati da tako kažem. Mjegi ćete možete, ono što je mnogo interesantnije, to je jedna osobina ovog digitalnog potpisa. Ako je suprat na ono intuici koju imamo, ako bi smo chceli da preslikamo svet analognih potpisa, odnosno, ručnog potpisivanja nekog dokumentu. A to je sledeća stvar. S1 zavisi i on je funkcija slučajnog broja k, s2 zavisi i on je funkcija broja k minus 1. I u kraju linii ovo s1 zavisi od k. Što je označi dalje? Ako ja uzmem, pa uzmem jedan dokument, uzmem neki word dokument, izračunam hash od njega i primjenim lgm digitalni potpis i pronažem neku slučajnu urednost k1 izračunam njen multiplicativni inverse i izračunam digitalni potpis, dobit ću jednu urednost za s1 i s2. Ako uzmem malo kasniji, odredim neku drugu slučajnu urednost k2 i njen multiplicativni inverse k2 na minus 1, dobit ću druge vrednosti za s1 i s2. Znači, ono što lgm malo v digitalni potpis, a on ne samo on, nego ćemo uviditi nešto kasnije i d, s, i još jedna varijanta rsa, imaju, to je da za jedan isti dokument, korišćenim jednog istog privatnog ključa, ja mogu da dobijem digitalni potpis koji ima različite urednosti. Znači, ove urednosti je s1 i s2, će imati različite urednosti. One će naravno biti u medžesom noj vezi koja je takva da može da se izvrši verifikacija. Ali to je potpunu suprupno, ono intuiciji koji imate kada posmatrate klasičan analogni potpis, gde se očekuje zapravo da vi kada se potpišete da vaš potpis bude isti ili što je moguće s lični onom nekom potpis u koji ste depunovali ili koji uvičeno podistiti ili koji u krajnju liniji imate na vašu lične karte. Znači, lgm malo v digitalni potpis će za različite urednosti k, generisati različite urednosti s1 i s2, pa će sve jedno uprkost ome što su to različite urednosti sve te vrednosti.
 jednosti se odnose na tačno isti dokument i mogu da se koriste za verificaciji. To je ono što je interesantno. U drugi strane, je zgodna osobina i otežova posao na padaču, zato što nije dokraje jasno na padaču, šta on kad vidi za isti dokument razlišti potpise, ne može da uhvoti mehanizam kako su oni krajirano. Naravno, kada se zna algoritam, on zna kako je krajirano, ali to je dodatni nivosigurnosti, ove slučenje brojka, je dodatni nivosigurnosti u samom algoritmu digitalno popisivanje. E sad, zna sad veruje, da mi veruje, da je ovo digitane potpise S1, S2, ovaj par, ove dve vrednosti koji se šalje uz neki dokument. Ono što je sad preostalo, to je da one koje dobije sa drugi strane poru prem i dobije ove vrednosti S1, S2, i zna vrednosti alfajku, na osnovu toga može da izvrši proveru digitalno popisana. E sad, što radi, ove sa druge strane, ove sa druge strane naravno zna koji se hash algoritam koristi, izračunava hash poru km i onda sprovode ove dve kalkulacije. Ovo v1 je alfa na m po moduliku, alfajku su, ove brojevi koji su poznati njemu. I druga stvar je izračunava v2 koje je y na, to je moj javnik ljuč, na S1, to je ono što je prvi deo ovom digitalnom potpisa, puta S1 na S2, to su sad opet oba dela digitalnom potpisa po moduluku. Ako su v1 i v2 jednaki, potpis je dobar. I sad ovde, ovde na prvi pogled deluje skroz čudno, kako je veze imaju sad ove vrednosti v1 i v2. Međutim na narodom slajdu imate zapravo, celo taj postupak verificacije napisan, v1 je alfa na m po moduluku, v2 je javnik ljuč na S1, puta S1 na S2 po moduluku. Pa sad ovde imate tačno, na koji način je izvedeno, i na koji način treba pokazati da ako su ove dve vrednosti, jednak je da je zapravo digitan i potpis jednak, pa se ovo y na, što je moj javnik ljuč prikaže kao alfa na xa po moduluku, jer je to način kako sam odredio javnik ljuč, kao alfa na privatni ključ po moduluku. Pa onda druga stvar, ovde S1, to smo videli da je napisano, da je to određeno kao alfa na k po moduluku, pa smo zameni ligomesto S1 alfa na k, pa imamo alfa na k, puta S2 po moduluku. A sad druga strana je, ovde alfa na xa, S1 sam prebacio na drugu stranu, pa imam alfa na m minus xa S1 po moduluku, je to je četvrti red, jednako alfa na k, S2 po moduluku. E sad dolazimo do one jednačine broje dva, koja kaže da ako alfa na i je konkurentnos alfa na jav po moduluku, onda je i konkurentnos alfa po moduluku minus 1, odnosno m minus xa, to je ovde gore, je konkurentnos alfa na k, S2 po moduluku minus 1. Pa onda ako prikažem šta je S2, ovde izbacimo u rednosti S2, i ovo ka puta ka je jedan se skrati, pošte to ima vrednosti 1, onda se zapravo dobiju istje vrednosti sa obje strani. I to, ovde provera treba da vam ukazan na to, da proveravanjem ovoga v1 i v2 zaista može da se proveri ove digitarni podpis. I sad ovde vam je ostavljeno da probate da se poigrate malo sa ovim različitim vrednostima za relativno male brojeve, i probajte da ovo da uradite, ne bi trebalo da bude pretereno teško. Ono što samo će se malo vratiti u nazad, bi trebalo da primjetite, to je sveveće, to je osobina da je relativno lakko izračunati digitarni podpis, dakle, ovo je operacija eksponenciacija po modulu koja može da se izrači u neko poljino milo vreme. Ova ovde operacija takvođe eksponenciacija, odnosno čak nije ni eksponenciacije, nego neko gnoženja po modulu. Ono što je malo problematićno, to je pronalazanje ovog multiplicativnog imverza, ali to može da se uredi offline, odnosna kažem u neko vreme prene, ako što prene digitalne opisivanje dokumentata. I ja mogu da čuvam parove ka i ka na minus prvi, koje sam odredio negde, da ih čuvam negde u memori i da ih stasniju potrebni, kad mi budu trebali. Za drugi strane takođe, provera se se stoji od eksponenciacije po modulu i eksponenciacije po modulu, dakle, to je nešto što sve može da se uredi relativno brzo. A za napadača da izvrši napad na ovaj algoritm je potrebno da izvrši ove operacija diskretnog logaritma koje su po danasnjem znađu matematike i ješu uvek nemogu da se izvrši u poljino milo vreme, da bi izvršio brute force napad na ovakal algoritm. Tako da ja vam preporučam da prođete kroz ovaj recept, kako se izvršava lg malo algoritm, da se uverite za ove male brojeve da to stvarno radi i da malo razmistlite o tome, šta je postavica kurišnja ovog slučajnog broja k, odnosno ta čudna stvar da za jednu istu poruku možemo da dobimo različite vrednosti digitalno podpis. E sad dolazimo do onih standarda koji se koriste i koji su u zakornom priznati. Dakle, jedan od algoritama je RSA i kad pogljate ovdje šema, ona istakva, jedno šema ranije sa neku tamo drugu, trećih slajda, o koje smo detaljni i već dvijedskutoli, međete, muslo da bi ova šema funkcionisala, jer da mora da postoji ta neka hierarchija, digitarna certificata i načina kako se dodeljuju ovi ključevi, kako ne bi mogu dodođi do poričanja određeni aktivnosti. Druga varijanta je ovo ovde i to je DSS algoritm. Sad ćemo viditi na narodom slajdu kako funkcioniše DSS algoritm, ono što je za DSS algoritm karakteristično, kao iz ovaj algoritm, koji smo videli malo pre. Za razlik od era sako i može da si koristi za inkripsiju nekih poruka. DSS algoritm kao ilgamalov algoritm koji smo videli malo pre. Svoji algoritm koji se isključivo i samo koristi za digitalnom podpisivanje. Ja ću protračati kroz DSS algoritm, pošto je nešto služenije od ilgamala i ovaj od vas neću očekivati da morate da ga naviflati na pomet, pošto je, vidjet ćete ima dosta nekihelamenata i nemam mogu smisla da to nabubate na pomet, ali ilgamalov probajte da navoči treba će vam. Dakle i ovde postoji elementi koji predstavljaju ono što je globalno poznuto s nima, to su ovi elementi p, q i g. P je prost broj, q je delilaz broja p-1, g je neki broj, koji izvedan kao h na p-1 sa kupom modulo p. Dakle to je nešto što imaju u obe strane. Opet određuje se jedan slučajn broj x, koji je privatan ključ, određuje se broj y na isti način kao ko delgamala koji je. Javni ključ određuje se sesijski ključ k, odnosno opet imamo, opaj zvinjase, opet imamo vrednost k koje pseudoslučajan ceo broj, dakle ovo je sad potpuno preuzet koncept iz elgamalovog algoritma, da imamo slučajnu vrednost. I onda, evo kako izgleda digitalno propisivanje kod DSS algoritma, dakle postoji poruka m koja se šalje ovde, postoji hešot poruka m koji ulazi u ovaj jedan blok tu, ibamo slučajnu vrednost k. I opet se digitalni potpisa stoji od dve, od dve iz dva dela, to su ovi delovi r i s, pri čemu r se računa kao g na k po modulo p po modulo k, imamo od vostruku eksponenciaciju pod vostruku modulu, po modulo p i po modulo k. I opet kako delga malog algoritma imamo ovoj delo r koji samo izključivo zavisi od slučajnog broja k. A sa druge strane imamo opet ono vrlo sličnu strukturu, kako što smo imali kod elgamalovog digitalna potpisa, to je ovo vrednost s des koje zavisi od multiplicativnoginverza broja k, od heša, od dem i od privatnu ključa i ove vrednosti r koje izračunate. Dakle, ako biste malo uzali pa napisali, sve ovo vidaćete da zapravo ovo ovde što vidite je veoma slično elgamalovom algoritmu, samo što je on neznatno jednostavniji. Sa druge strane, kad se dobije ovakva poruka, onda o nešto što je dobio tako poruku, treba da izračuna hešete poruke i treba da u porodi izvinjano sa ovu vrednost r koje je dobio i vrednost v koje je izračuno na ovaj ovde način, i ja kažem neću ulaziti u te detalje, suštivno je i sta, kako delgamalovog algoritma, to je da je provera jednostavna da se vrši eksponenciacijem po modulu, istok kao izračunavanje digitalnog potpisa, a sa druge strane, ono što je interesantno i kod DSS-a, to je da digitalni podpis jednete isti poruk, ako se radi sa različitim vrednostima K, može da ima različite vrednosti, to je ono što je suprotno nekoj intuici. Na narodnom slajdu imate još jednom nacrstvarno ovo isto, što ste imali malo prei napisanu kako izgledaju ove funkcije F1 i F2 kojima se vrši digitalno podpisivanje. E sad još ćemo da uradimo ove jedan mali algoritm koji se...
 zove RSA-PSS, to je jedna modifikacija RSA algoritma koja služi samo za digitalno popisivanje o PSS-skraćenice od probabilistik signušerskim, odnosno neka šema za popisivanje zastavno na verovat noć. Nije preterano komplikova, možete sad sada da je pokažemo na narodnom slajdu. Pre nego što objasnimo šta se dešava sa poruklu, na koji način se ona ovom šemu popisuje. Prvo moramo dovedemo nešto što se zove MGF, odnosno mask generation function, to je nešto što je sastavnj ideo ovog algoritma. E što znači mask generation function, ako imamo neki uroz de string x, či je dužina L-bytola. A hoćemo da dobijemo neku poruku koja je dužine k puta, izinjant se, nisam dobro neko. Znači imamo uroz je neki string x, koji je dužine odrećene galičine, imamo, recimo dužine hash funcije. Izljz iz ove MGF funkcije L-bytola. Ako je dužina stringa x k puta manja od ovoga L, znači odnosno ako je L jednako k puta dužina hasha od ovog uroznog stringa x, onda se MGF dobija k o konkatenacija k tih različiti hasheva, da je prvi hash poruka x konkatenirana sa 0, hash od toga, pa drugi deo je hash od poruka x konkatenirana sa jedinicom i poslednji hash je hash od poruka x konkatenirana sa k. Znači to je neka funkcija koja se dobija neki pseodostučen i niz, proizvoljne dužine. E sad koliko je to dužina, zavisi naravno od toga kako će izdajati digitarni potpisa, to ćemo vidjeti na narednom slajdu. E naredni slajd pokazuje kako izgleda ovo še ima digitačno odpupisivanja i tu možemo dovidimo kako se, šta se daje še ove sa porukom. Ači, originalna poruka M se ubacuju u hash funciju i sa ta hash funcija može da bude, šta je znam, neka recimo, na sh512 da daje hash voličine 512 bita, odgovareći dužine. Na taj hash se dodaje salt, a to je neka pseodostučen na vrednost i na to se dodaje ovaj ovde padding. Padding 1 ima vrednost nule, znači sve su nule. Pa se onda na ostavu toga, a sad već ovde imamo opet ovu jednu čudnost vara, to je da imamo ovaj salt koji utiče na formiranje samog digitanom potpisa. Ope ćemo imati ovo nisu situaciju da će digitani potpisi zavisiti o te slučene vrednosti, odnosno da će imati različit u vrednost svaki put kada se izračunila iznova novi digitarni potpis. Znači sve ovo zajedno, taj padding prvo izračunati hash i ta slučena vrednost dolazi u drugi hash. Pa sad ako izlazi to hash, recimo, 512 bita, i ako se odredi da ovaj ovde izlazi z tog MGF, treba da bude na primjel 2408 bita, onda ćemo imati ono što sam malo prepokazao, ono MGF funkciju primjenjenu četri puta na ta četri različitah hasha sa konkateniranom 0, 1, 2 i 3. I onda se ta MGF funkcija dovodi na eksplozivno ili ovde sa drugim paddingom koji je opet ni z nula samo završen 1, 1 i opet ovom ovde slučenom vrednosti. I ovako se izračuna ova poruka koja se zove E-M. Znači ta poruka E-M, ona je funkcija orignalne poruke E-M, funkcija ovoj slučenje vrednosti salt i nekih modifikacija koje su prikazane na onslajt. Digitarni podpis je ovdje. Znači, digitarni podpis je ta poruka E-M podignuta na D, to je ovoj klasičan RS algoritem gde je privotni ključ se sastoji od D-M a javni ključ se sastoji od E-M. Znači ta poruka podignuta na D, što je privotni ključ po modulu M, a onom tamo nekomeko proverava ovo digitalno popisivanje Sam Dal, javni ključ, tako da će ovom klasni morate da izvrši dekripsiju ove poruke E-M i da izvrši odgvaraću proderu. Znači, ovo što interesantno i kod ovog RS-APSS algoritmo za digitalno popisivanje, jeste da će digitalni potpis opet imati različite vrednosti za jednu te istu poruku podpisanu jednim te istim privatnim ključem, zato što će u samom algoritmu postojati ova salt vrednost, koja je pseudo slučajena i koje će svake puti imati neku drugu vrednost, te će samim tim sam digitani podpis biti drugači. Što se tiče same provere, provera je naravno ceo ovoj mechanizm samu u nazad. Prvi korak je naravno da se izvrši dešifrovanje tog digitalnom potpisa, znači S se podigne na E, što je javnik ključ po modulu N, dobije se EM-vrednost i znese izvuku od glareći delovi i ceja proces se primeni u nazad, kako bi se proverio od glarećih jaš. Ovo je šema koja nastala preneh 10. godina u RS-APSS i oni smatraju da je to šema koja je najsigurnija za digitalno popisivanje. I ona još uvek nije, recimo, kod nas u zakunu prepoznat tako šema koja treba da se koriste za digitalno popisivanje, ali će verovatno, kako se te stvari stavna menje i kako se stavna življaju, verovatno jednog trenutku biti moguće i ona da se koriste. Evo, ovni smo praktično završili sve, samo kojišo da vam, što se tiče digitalnom potpise, kojišo samo da vam ukazim na neke stvari koje postoje, a to je da, pošto je digitalni potpis, kod nas u našem zakonodavstvu potpunost izjednačen sa analogim potpisom, sa onim žvrljkenjem potpisana papir, onda postoji nijegih dokumentata kojima je tačno definisano, šta znači na koji način treba digitalno potpisati neki dokument, da bi tako digitalnom potpisan dokument bio prihvaćen kao pravnu valit. I ovde imate iz ovog nekoj pravilni, kao digitalnom potpisivanju, imate tačno definisane algoritme i tačno imate definisane parametre ovih algoritama, kakvi treba da budu, da bi se prihvatio takav digitalni potpis kao pravno validan. Znači ako se koristi klasična RSA šeema, onda modul M mora da ima minimalu 2448 bita, ako se koristi DSS algoritm, odnosno digital signature algoritm, onda oni parametri P i Q treba da budu tačno određene veličine, znači to je tačno propisa. Naravno, treća varijanta je sa elitičnim krivama, da to nismo raditi niti, ćemo raditi uokirovu kursa, ali za tu varijantu postoji definisano tačno kako treba da izgleda taj digitalni potpis. E sa to nije jedinu što treba da postoji, treba da postoji još jedna stvar, a to je da neko vam da, odgvareći digitalne identitet, pa ćemo videti i to na kraju korsu ta tela koja dodelju digitalne identite. Ono što je takođe interesantno, da, naravno što stiče hash funkcija, opet propisan je su tačno određene hash funkcije i ovo je interesantno izgleda, kad je to u zakonu nešto što ste učili na ETF-u, a to su tačno određeni algoritmi, koji se koriste da bi uokiru tih algoritama za digitavno podpisivanje. Ima ješ jedna stvar, a to je ono što sam isto komentari se na ovom času, to je da kada se podpiši neki dokument jednostvari koje je jako bitna, to je da se tačno određi vreme kada je određeni dokument generisan. Da bi se to uradilo, na taj digitari dokument treba da se upiše i vremenski žig. I to ne može da se urodi tek tako što bi uzmete, recimo, sistemensko vreme sa vašeg računara, pa to stavite u dokument, možete to doroditi, ali to nije pravno validno. Pravno validno je da vam neko telo, koje dodeljuje vremenski žig, dodeli vremenski žig i da vam podpiše taj vremenski žig svojim privatnim ključem. I ovde imate pravilni kiju o vremenskom žigu, koji kaže koji se koriste algoritmi, ovde se nisu trudili baš da na lep način prevedu nazive samih algoritama, pa imate ove elliptic-curve, digital signature-algoritm, čiriricom, ali dobro, mislim da nam je jasno o čemu se raditi. E, na kraju, ko su ta tela, koja mogu da vam daju odgovareći digitalni potpis, pečat, vremenski žig? Ne može bilo ko, odnosno, vi možete da napravite u svojoj firmi neko zatvorenu okruženji i da sami kažete u nutar firme gje ovo važeće infrastrukture. Mi ćete imako koćete da digitalno potpislite neki dokument i da stojite i za njega, recimo, prijavljete porez, ili tako nešto, i to koćete i da uradite digitalno, onda to možete i da uradite sa digitalnim certifikatom, odnosno sa vašim digitalnim identitetom, koje su izdala samo ove ove tela, koje su ovlaščene da tako nešto istajemo. A oni su ovlaščene, i zatošno su prošli određene infrastrukturni i organizacijone provere, kojima se pokazuje da oni su u stanju, da čuvaju identitete, da ih izdaju na određeni način, da to bude potpuna kopija, da tako kažem, o njih ličnih karti koje imate samo u digitalnom obrih. I to, naravno, je najhto i nije da uradite u MUPU, pošto neko šta ništa, i da svoj digitalnih certifikat na ličnih karti aktivirate, a ako hoćete, možete aplatite, kod recimo, ovih nekih privatnih firmi ili kod privredne komore, koje izdaju digitalne certifikate, a ako on treba vreme za podpisivanje neku dokumenta, to su pošta i kancelarije z informacijne tehnologije, koji izdaje vremnitske živlove, i to je ono što je potrebno za infrastrukture. E sad, ono što ne dosta je u okru cela ove priče, to su ti digitalnih certifikati koje sam ja pominjalo, ali o njima ću vam pričati naredni nededje, pa ćemo tad...
 da vidimo šta značiti digitavene certificati i još ćemo se malo vratiti na ove stvari kao što su digitaно podpisivanje, vremenjske žigoje da vidimo kako se to radi kada budemo izlučili tu X-509 infrastruktur. Dobro, to bi bilo to od mene za danas.
