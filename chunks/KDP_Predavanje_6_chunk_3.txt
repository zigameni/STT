 On pravi del za synchronizaciju. On pravi objekad, monitor nad kojem će se raditi synchronizacija. A drugi će samo koristiti taj monitor i kaže odradi za daj mi dozolom. I taj neko će pisati ono što zna da piš. Kako se kuva ručak, kako se ubacuje nešto u buffer, kako se vozi automobil, to je neko će tako nešto pisati. Neće se uopšte baktati synchronizacijom. Za synchronizaciju će dobiti. Evo ti objekad za synchronizacija ima dve metode. Start ride and ride. I to je to. Ne treba ništa druga da vadiša čuna, nije o čemu. Samo da ih zoveš u pravilnom redosledu. Znači, koji monitora nam je bitno da neko to koristi u pravilnom redosledu. Ako da imamo neko, mi kažemo, prvo treba da započne vožnja, pa onda da se završi, a ovaj kažem je završio, sam vožnjo nikad nije počao. System će verovatno doći u neko nekonsistentno stanje. To mi je kao imate autobus, prazan i onda izadje 3 osobi za autobusa i uđe 3 osoba imate obet prazan autobus. Ne može tako. Znači mora prva neko dođe autobusom i neko mogu dizadji za autobusa. Imate primera autobusa, zato sam to navio kao primjer koji ćemo koristiti na ovom ovde predmetu. Probom vožnji autobusa. Ajde da imamo šta to se postoje kod monitora i zašto oni liče na objeknu orientisonu programeranje, odnosno na klasse i objekte koji postoje u objeknu orientisonu programeranjoslu u toj paradigmi razvoja naših aplikacija. Znači želimo da naparimo abstrakciju. Sakrilismo podpunno podatke koji se odnosne na synchronizaciju. Sve to smo stakrili u nutra tako da nikod to ne može da vidi, nikod ne može da pristupi tim podacima. Samo želimo da pustimo nekome mogućnost da nešto odrati. Aha, nači mi hoćemo da sakrijemo podatke a da pustimo nekome mogućnost da se synchronizuje koristići neki objekat. Dobro, ok, može to. Dobro, dali je monitor nit? Ne, monitor, absolutno nema nikakovezis niti. Monitor je pasivni objekat. Monitor je objekat, nije pred. A u njemu se čuvaju podaci za synchronizaciju. Procesi koji će koristiti monitor su odvojeni procesi. Tako da kad budete pisali zadatke koji se odnosne narati sa monitorima treba da napišete dve stvari. Prva stvar je da napišete monitor, al to nije dovoljno. Morate da napišete, ako imate jednu monitorsku metodu to je doleno. Ali ako imate dve monitorski metode, morate napišete, prvo se zove ova metoda pa se zove ova metoda. Možete napišete u komrevno sa dosete metode pozivaju. I da li oni možda, nekako treba da razmenju neki podatki. Prva metoda će vratiti nešto što će ona druga metoda koristiti. Možda i o tome treba voditi radun. Što postoje kod monitora? Garantovanuje međusobno isključivanje. Monitor sam po sebi. Kada ućete u neku monitorsku metodu, garantoje međusobno isključivanje. Tomo je po definiciji. Ako imate monitor i ako neko pozove neku monitorsku metodu, garantovano imate ekskuzivno pravo, pristupa datom objektu. Vi i nikodrugi dat o instanciji objekta. To br sad sam to reko datom instanciji objekta. Što odgovora stvarno objekteno orientisani programski mjazicima. Ali oni programski mjazicima koji se nalaze tu negde između, će imati ove statičke objekte. Pa ćemo onda moraći na jednim monitorom da imamo samo jedno, samo nešto. Nećemo moći da imamo baš sto nekih stvari, neko ćemo moći da imamo samo jedan monitor, ali u sušteni pih jezika više nema. Tako da možete da posmatrate da ćemo raditi synchronizaciju nad instancom, ne nad klasom. Ako se sečete programskih jezika java, tamo ste ključno reči synchronizaciju. Mogli da stavite i na statičku metode. I onda mogu ste mogu da se zapitati. Čekaj, a šta je objekat nad kojem ja radim synchronizaciju, kad ja nisam napravio ni jednu, jedinu instancu? Ne ima instanc. To vi mislite da ne ima instanc? Ima instanc. Čak je ako napravite statičku metodu, uvek se to poziva nad nekom instancom da odradi neki posao. Samo što ta instanca pripada klasi klas. Postoju javi klasa koja se zove klas, a koji pripada i u sušteni ove statičke klase. I tu se nalazila ove statičke metode koje treba da odradi neki posao. Tako da to je u sušteni kao da ste zaključali objekat taj, na kome se nalazi to iznad. Znači zaključali ste taj objekat tačka klas. To je što se medjusobno gisključivanja tiči. Pora do ovoga da bi to mogu dofuncionišli, treba nam ustunno synchronizacija. Ustunno synchronizacija je lepo realizovanak od monitora, realizovanak koristiti koncert u sluvene promenjive. Vidite ćemo da te u sluvene promenjive imaju različite načine funkcionisanja. Nije rede sve u sluvene promenjive na isti način. I da li su svim programom schijeziciji naprednjeni na isti način, nisu. Java koji sam maloče spominja, ako je zamislnina kao objeknu orientisan jeziku i remaz radi sa monitorima. Možete nije možda baš i neradi sa monitorima, onako kako su to zamislili ovi koji su napravili monitori. Ali to bilo lakše o ima koji suupravili javu da tako naprave. Tamo nekde 96. godine kada su to se pravili. Pa su su onda u nekom trutku zamislili, kad je došla verzia 5, rekli su, e, a mi ćemo sad ipak da napravimo, znatite, ono štako piše po knjigama za rad sa monitorima, zato što niki programjeri baš, kad nađu knjigu kako se nešto radi sa monitorima, ne znaju kako da prepevaju to u ono što je postojalo uparve četri verzije javio do verzije 5. Tako da ćete viditi na vežnjuma, u suštini i dva razvečite načine kako nešto možete raditi u javi. Stvide li da sad je 1 na objeknu orientisanu programiranju, to je na nekom metodu da stavite knjučno neče synchronista. I to je ono što postoje do verzije 1-u. Ali to nije što što baš 100% liči na monitorima. To liči mnogo na monitorima, mnogo liči. Ali ima jednu malo razliku, nemo veći broj usnovnih promenljivih. Znači vide ode stoje, kondišn promenljive, nije kondišn promenljiva, možete biti više, način možemo na cvakim objektom imati više usnovnih promenljivih. To je osnovni koncept monitora. I na 1 metri verzije jave može biti samo jedna usnovnih promenljiva. Ves, ne može biti više. Šta smo rekli da imamo koncept monitora, aktivni procesi su niti. Monitori su pasivni objekti. U monitoru se samo nešto čuva od podataka, a monitora nije nit, nema svojitok kontrole. Kad budemo prešli u distribuirano programiranje, susrećemo se se konceptom aktivnog monitora. I možete monitor morati da dobije svojitok kontrole, ali u konkurentnom programiranju, monitori su pasivni objekti. A ovi aktivni procesi šta rade? Ozivaju metode monitora, ovoj pasivnog objekta. I taj pasivan objekat će onda da radi synchronizaciju. E, ali šta nam ovo je ovdje moja? Ovakam koncept priča, pruža, pošto smo rekli objekti, i u križi komkurentno i distribuirano programiranje. To je jedna divna stvar, da ona i što koriste i naš monitor nema blage veze kako smo mi to napravili znotri. To znači da možemo da napravimo više različitih implementacija monitora. I u knjizi konkurentno i distribuirano programiranje vidjet ćete da postoji više različitih način na kako nešto može da se implementira, kako je nešto implementirano, na primjer problem čitala C-pisaca, kako je to sve napravdino da funkcioniše. Imojmo jedan podpis, znači star 3, den dred, star 3, den dred, jedan jedini podpis imamo, a imamo različitih implementacije. Ali to ono ko ko koristi monitor baš briga, njemu kaže, ili ti meni garantuješ da će to, kad kažem star 3 da dobim exklusivnu pravo, ja kad kažem den dredi da napostiment exklusivnu pravo, ovaj tu kaže ja garantujem. E, a poslata to nivo garantija, to baš pošteno ili malo više pošteno, ili malo manje pošteno, je malo brishe brzu, ili malo manje brzu resenje, znači zavisio toga, kakvo resenje hoćemo. Znači resenje može da bude pošteno, tako što će, sada znači što je pošteno. Dali mi garantujemo da će neko uvek doći na red, ili garantujemo da će odmah doći na red. Znači pitanje samo kada neko me nešto želimo da dozvolimo, da neko može da odrati.