 Sleću našu temu, prestavljaju potisni automati. I već smo zapomenali da potisni automati zapravo prestavljaju vid prepoznavenja desno linarni gramatika kao bez konteksni gramatika. Svok toga što sušljavski funkcionoš u drugačiji ne održavaju konteks na isti način i generalno služa da pamte, zapravo, konteks korišćenjem steka upravo za ovakve gramatike. Njihova sama konstrukcija je napravljena tako da svakom onom regulurnom stanju kod končnih automata odgovara jedna ovakva tabela gde ta tabela ima neke ulaze. Vrste predstavljaju neka stanja steka u okviru tog stanja gde je obaviozno po svoju inicijalno stanje steka, odnosno stanje praznog steka obično označano ovako obrnutim troglom i neka simbolička stanja, odnosno simbolički nazivi stanja tog steka što ćemo vidjeti kako se kasnije formije. Koloni su ubeleženie konkretnim simbolima koji se nalaze na ulazu, odnosno koji mogu biti delovi sekvence i dopođeni su ovim znakom za kraj sekvence pomoću koji ćemo prosto doodredimo kada se neka sekvenca prihvata. Ove konkretni automat koji vidimo na ovom primeru, sastoji se od samo jednog stanja, samim timu, sama ove jedne tabele, a ulaze su popunjeni praktečno sa operacijama koji utiču na sam stek i operacijama koje se odnose na procesiranje same sekvence. Što zdišno steka, jasno je da tu imamo dve operacije ili operaciju puš ili operaciju pop, gde operacija puš smešta neki simbol zapravo na stek. Na ta i način može kontrolisati različite stvari. Da primerovi su automati pogodni također za kontrolislanje nekog odnosa pojedinih simbola koji se pojavljuju samo i sekvenci što ćemo vidjeti kastnije neke primere. Što, principu, nešto od toga nismo mogli da regulišemo kod klasičnih konočnih automata, jer smo koji njih prosto pamtilili kontekst na drugače i način. Tegli, stoga, postoji operacija puš koja smešta neki simbol na stek i postoji operacija pop koja skida simbol sa steka i u principu operacija pop nema argumentu dok operacija puš dakle obovezno ima argument koja značeva uprvo šta se smešta na steka. Osem toga, postoji operacija koja se odnosi na procesiranje samo i sekvenci i ta operacija ili advanced ili retain, gde advanced predstavlja praktičnom nastavak kroz samo i sekvencu što znači da trenutni simbol koji se posmetra na ulazu postaje onaj koji je sledači u samo i sekvenci, odnosno, pomera se taj pokazivač da tako kažem. Retain znači da se ne menja taj simbol, odnosno da se zadržava trenutni simbol i dodatno u okviru ove tabele vidimo operacijer reject ili accept koja je zapravo prikazuju da li prihvatamo ili odbijemo sekvencu. Dodatno, ono što nije prikazano u okviru ovoga automata a razlog je to što postoji praktično samo jedno stanje, to jest jedna ova tabela je u slučaju postojanja više stanje cakođe postoji operacija prelaska na drugu tabelu ili ostanka u konkretnom stanju, gdje je dovedno napisati osim ovoga da se bradi neki skok na drugo stanje, znači recimo S1 samo ili S0 da bi se prikazalo dosta u istom stanju, u principu da bude dovoljno jasno kako se naslije procesiranje kroz sam automat. Dobro, to smo bila neki ostavni gradivni element i ja sad u principu ako pogledamo na primjer, kroz neki primjer sekvenci a kako funkcioniše ovaj automat, recimo, nalazimo se naravno u inisirom stanju, stanju prazlog steka i vidimo ako nam dođe malo a, radimo puš a i napreduvajmo u našu i sekvenci. Puš a zapravo znakčova da mi na neki simbolički način želimo zapravo da razdvojimo to stanji steka od nekih drugih stanja steka. I ako bi smo sad ove posmatili čemu nam to može uslužiti, pogledamo puš a, nakon toga, na vrhu steka se nalazi uprvo simbola. Te mi z toga gledamo sad i slučivo ovu ovde vrslu, jer je to našo trenutno stanji steka. I ako recimo ponovod dođe a, mi ćemo ponovod radimo puš a i da napreduvajmo u toj sekvenci. I vidimo da sve dok dolazi malo a od početka, mi gomilamo ovo a na steku. Koniko nakon toga dođe b, mi ćemo automatki redjektovati sekvencu, što znači da recimo, ni jedna sekvenca koja počinje sa a, potom dođe b, ne može da uopšte bude sekvenca prihvatanja. Međutimo, ako dođe malo c, mi vidimo, radimo pop i advanced. I primjećujemo da sve dok dobijemo c malo, ali tako mi radimo pop i advanced. I zapravo, ako imamo iedistven, odosno, identično broje pojevljivanja ovog simbola a na ulazu, kao i pojevljivanja simbola c na ulazu, mi ćemo raditi puš a ono likoputa, koliko smo pojavila malo a na ulazu, i nakraj ćemo imati prazen stek. I ako nakon toga dođe znaka za kraj sekvence, mi ćemo tako u sekvencu prihvatiti. Dakle, očigledno, ovaj ovde automat prihveta sve sekvence koje imaju isti broj a i c. Dakle, i desno recimo, prvo se pojavljuje a određeni broj puta, nakon to na c određeni broj puta i radi se stanje. Radi se prihvatanje zapravo tako sekvence. Ako se c pojavljimo veći broj puta nego a, vidimo al tako, dobijemo redrekt. S ovoj strani, ako recimo dođu prvo b na ulazu, pušrujemo simbol b. I sad zašto ne pušrujemo istom simbol a. Simbol nije tuli koji je konkretno naziv simbola. Dakle, možete dati koji god naziv koćete. Bitno je u principu da na neki način razlikujemo ta stanj. Što postižemo zapravo tim nazivanjem simbolu, na steku različito, pa postižemo da prosto ne želimo da mešamo neke simbole u sekvenciju. Naprimer, ako kada dođe malo b, mi kažemo, dobro, pušvamo simbol b na steku. Mi time kažemo, sada, lako prevacujemo se u ovo ovde stanje i gledamo šta se dešava. I sad, naprimer, ako dođe malo a nakon togo, mi pušvamo simbol c na steku, što znači prevacujemo se ovamo u ovu ovde vrstu i praktično nadalje radimo procesiranje na isti način u samom automatu. U principu ovakom različitim simboljima, dakle, mi možemo da forsiramo gomilanje recimo nekih pojedinočnih simbola u određenoj sepenci, ili recimo nekombinovanje nekih simbola, ili neki poseban specifican poredak. Nešto kasni ćemo vidjeti, dakle, nekom konkretnom primieru koji mi je koztruišamo, zapravo kako to funkcioniša, ovdje bio cilj da prosto vidimo kako izgleda jedan takav automat. U principu ovde informalizovan sam algoritam rada automata, gde je da je to smo već prikazali na određenom primieru, kreću se od stanja praznog steka, dohveta se simbol uloznene sekvence, dohveta se neko trenutno stanje. U principu može u proizbiljnom stuču i nemoram to biti stanje praznog steka, može biti i neka tekuća konfiguracija, uz avisnosti od stanja na koje se skače. I, dakle, naravno, ukoliko je neko stanje prihvatanja, onda prihvatimo uloznu sekvencu i stime smo završili usuprudnom, dakle, dokvajte moću kombinaciju tekućeg ulaza, konfiguracije i tekućeg stanja i posmatramo šta se tu desave, već videli smo odgovarajući način. U stekla se sekvenca odbijanja, mi je naravno odbijemo, a u suprudnom prostu, dakle, primenujemo konfiguraciju steka, primenujemo procesiranje nad samom sekvencom i skačemo potencijalno na neko drugo stanje. Dobro, ovdje su takođe nekih primari sekvenci koje se prihvataju, mi smo i sami videli, dakle, nekih primara, kako funkcioniši. U principu, ono što najbolje često je svaciti i zapravo, kako funkcioniši samo u tom, tena taj način formirati konkretne sekvence. Dovrno moguće je uvesti ušijetnu operaciju za rad s stekom i to je operacija replace, koja će zapravo skinuti ono što je posledena steku i zameniti to onim što je specificirano kao-kao argument same operacija. Dakle, projektova ti potesni automat koji prepoznaje uvaznaje sledaći skup sekvenci. Jedinice se ponavljaju n puta, nakon čega se nule pojavljaju m puta, tako da je to m veća d, a oba su nekih pozitivnih brojev. I zada to skupa izbrati jednu sekvencu dužina veća od 3 i pokazati proces njenog prepoznavanja. U suštini, ako bi smo chceli da analiziramo ovaj problem, dakle, ono što se prvo postavio piti, njih koliko različitih stanjenam je potrebno, tako tako da je to biti neka stanja steka, u principu za sva ove resunje možete formirati, govorite sve javle probleme, možete formirati različite rešenje, kao što smo i kod končnika automata imali različitih rešenja u smislu broja stanja, različitih prelaza. Te, naravno, i ovde je to moguće, gde će nam, naravno, uvog biti cilj da prosto formiramo rešenja sa minimalnim brojem stanja i minimalnim brojem i simboličkih stanja na steku, jer što bi smo, naravno, alasirali stanja koja nisu suštenski potreb. E, sada kada ovde treba, dakle, usloviti u ovom konkretnom rešenju, dve svare. Jedno je međusovni poredak 1 i 0, gde prosto nesmemo, o slučajno poslići to da postoji neka kombinacije 1 i 0 koja nije baš u ovom poredku, a z druge strane, međusovni odnos, n.
 prva stvar je, kako ćemo obezbediti da nemo na izmenično pojavljivanje 1 i 0. Najmaksite da to obezbedimo je time što ćemo uvesti dva stanja u ovom ovdaj automatu. Sad zbog čega, pa zato što vi mirili smo u klasičnom, onom konočnom automatu, rekli, dobro, nekoma smo inicijelnom stanju od tako i dok vam se pojavljavljio jedinice, mi se vrtimo u tom inicijelom stanju, kad se pojavljio prva nula, mi se prvacimo u drugo stanje i tamo nam se vrte nule, ne vrat ćemo se ponovno ove jedinice i to nam bude neko stanje prihvatanje. Tima bi smo prosto u klasičnim, konočnim automatom, regulisali to da nam se prvo pojavljuju i sljučivo nule, a nakon toga da nam se ponavljaju i sljučivo nula. Izbog toga nema razloga da to isto neprimenimo i ovdje da kažemo dobro, da imamo dva stanja, znamo da za svakvo tako stanja lociramo po jednu tabelicu, uprvo će nam biti, da vam se pojavljuju i sljučivo nule, jedinice, kad nam se pojavljaju prva nula, prebacimo se u drugo stanje i tamo nam se ponavljaju i sljučivo nule. Džetimo, da je takvim automatom, dok u klasičnim, konočnim automatom nezgodno postići, kako bi smo ovdje zapravo uslovili da nam se te jedinice pojavljuju više puta, nego što nam se pojavljuju i nule. Ove prvi problem tog uslovljenog pojavljivanja prvo jedinice po nula nije problem, dakle to znamo kako ćemo da rešavamo, već jutim kako da odlučimo, kako da zapravo sprečimo da nam se nule pojeve iso ili više puta u odnosu na jedinice. E to ćemo upravo da rešavamo ovim simboličkim stanjima na steku, time što ćemo dok nam se pojavljuju jedinice, da pušvamo jedan simbol na stek i samim tim, ono liku puta, koliko smo simbol pušovali na stek, mi smo zapravo uveli neki tako zveni brojačnih jedinica. Dakle mi suštinski, ono liku se bolje, koliko imamo na steku, to nam je neki brojačnih jedinica i znamo da nula ne smemo da skinemo tuliku, koliko smo jedinica pušovali. Prosto na osnovu toga ćemo moći diskontrolišamo naše rešenje. Tako da sam suštinski rešenja ovog problema očetne nije komplekovo na... Dakle, videli smo imamo neko dva stanja, čisto je zato razloga da bi su možli da kontrolišemo, da je slučivo idu prvo jedinica, onda nule i da ne bi bilo tih mešanja. Što znači, krećemo od stanja praznog steka iz prvog ovog stanja i kažemo, ako nam se pojavi prvo nula, to je stanje odbijajno. I to znamo, tako što ako se pojavi nula, znači nula će biti više ili jednako jedan, je o ponavljanja, a jedinica nam sopšte nisu pojavljivale. Samim tim rezultat nije dobar izbog toga tako se kvencu treba odbiti. Isto prazna se kvenca se ne prihveta, videli smo zbog čega, zato što je ov tako, obje se moraju bari jednom pojaviti, tako prazna se kvenca se ne prihveta. M.i. ako nam dođe jedinica na ulez, onda kažemo, pušujemo a na stek, rekli smo da nam to već predstavlja kao neki broječ, ovde se zove a, da se zove to simboličko stanje, to je potpuno nebit. Pušnamo na stek, s druge strane napredujemo u našu i sekvenci, rekli smo od posvatramole tri aspekta. Šta radimo sa sekvencom i dalje ostajemo u istom stanju, ili prelazimo u sljedeći. Tako napredemo sa sekvencom i ostajemo u istom stanju. Zato što nam je a na vrhu, steka, mi je al tako prelazimo u ovo simboličko stanje, steka u tom startnom stanju i al tako kažemo, dobro ako nam i da mi dolazi jedinica, mi ponavlo povrdu, a nastavljamo kroz našu sekvencu i ostajemo u istom stanju. I to je jasno, mi hoćemo da prebrojimo, koliko mi to zapravo imamo jedinica. Prvi put, ako nam stigne nula, mi kažemo dobro sad znamo da više jedinica nemamo i što treba dalje da radimo. Među vremenu takođe, ako nam i u ovom stanju a stiglo znak za kraj sekvenci, to znači da nismo imeli ni jedno nulu i tako je sekvenca takođe treba odbitir, smo videli moramo imati barija. Ok? E sada, kada sam se pojavi prva nula, tako da mi kažemo, skidamo sa steka, ovo što se nalazilo na vrhu, napredamo našu sekvenci, međutim moramo se prebaciti na drugi del automata i praktično prebacamo se na drugi del automata, zato što sad to upaćemo da kontrolišemo pojevljivanje tihnula upravo. I sa te strane, nekaj nema, sve se prvno sve se prvno odbitir. A u koliko nam se pojavljuju nule, mi ćemo da popujemo, popujemo i napreduvemo u našoj sekvenci. U principu, kada treba da se zaustavimo, odnosno, o koje sekvence prikvjetamo, o koje sekvence odbijam. Prikvjet ćemo sve one sekvence, koje u drugom, o ovom stanju S2, su se završilo sa simboličkim, sa simbolom ili tako A na steku, to znači da imamo više jedinica nego nula, jer smo mi pušavali a kad godom se pojavila jedinica na ulazu sa nulom smo skidali. Tako da sve dokram je to, a i dalje na vrhu steka mi znamo da imamo bar jedno jedinicu više od nula i to je za nas regularna situacija. Zbog toga, ako dođe znak za kraj sekvence, mi kažemo, ha, to je za nas uredno, prikvjetamo tako u sekvencu. Z druge strane, ako bilo u kolom momentu, skinemo bar isto, ako smo imali na steku, u tim je dobijemo prazan stek. U svakom slučaju treba da redrektuvar. Nakon toga ne smet do ti jedinica, jer je već došla neka nula, a u to znači da ćemo imati bar isti broj nula ako ne i više od jedinica i to takođe treba odbiti. Tako da u ovom slučaju videljismo kako kontrolišamo dve stvari. Kako kontrolišamo redoslet pojedivanja simbola, to je dakle sa ovim stanjima. Upravo, ako želimo da ne dozvolimo, da nam se mešaju konkretne simboli u toj našoj sekvenci, zasvaki alociramo novo stanje kao što bi smo radili sa konkretnim vkonačnim automatu. I na kraju, ako li ko želimo da prebrojimo međusobni broj konkretnih simbola, to ćemo uraditi pomoć u simbola na steku, tako što ćemo brojačima, odnosno simbolimo na steku simulirati brojače pojedinih simbola koje se pojavljuju u ulazlu, u ovom slučaju u jedini cnova, i na taj način kontrolisati međusobni redosled i broj operac, ovih simbola. Ove nedanje nastavljamo sa parsiranjem, kao pojavljamo i posljednom brstom parsera, a tu su botom na parsir. I želim da razimiramo, dakle, parsiranje neke konkretne sekvence i odvijati po algoritmu, koji za datu ulaznu sekvence određuje, da li ona pripada jeziku neke zada te grammatike. Ukoliko pripada, parsera određuje izvođenje posmatrne ulazne sekvence, počuva startno u neterminala te grammatike. I u principu, u tom nekom smislu, parsere se dele na bottom-up parsere i na top-down parsere. Razlikaju toma što se stavilo, izvođenja koj top-down parsere i dok je koj botom up, kao što je samo ime kaže, situacije da se ono konstruiše od listova naviše ka korena. Inače, idea Shift-Rid-U-S parsera je da zapravo, oni imaju nekoliko grademi elementa. Dakle, imaju, to je zapravo potisni automat sa skupam nekih ulaznijih, dakle, zodreženim skupam ulaznih simbola, skupam simbola steka, početnimo inicijanim stekom i potisnom tabelom i kontrolnom tabelom, dakle, svaki u tih grademi elementa ima neku svoju funkciju i u principu kroz zadatke koje ćemo početi da radimo sada, dakle, videćemo na primjerima koja je svaka njihova uloga i kako ćemo zapravo na arno konstrui se ti sam parser. Dobro, prvi zadatak služi da nas uvede u pojem botom up parsera. Teg, s toga je dakle, zadata glasio, ako parser od znaka vrhu, napravlja na osnovu sledići gramatike, prepoznaje smena u zadatu i uloznoj sekvenci, po sledećima redosledu, dakle, sam pri savom parsiranju ovdje smena u gramatici koji uklupnaj ju na četiri, i do redosledom, četvrta, četvrta, četvrta, prva, četvrta, četvrta, prva, treća i druga. I sada dona što mi treba prva da uredimo je da detektujemo o koja uloznoj sekvenci je reć, a nakon što smo to uradili da prikažemo kako radi parser u loznoj sekvenciju koji smo dobilili dobro. U principu, kad agradimo sada uloznoj sekvenciju, mi ćemo raditi supratno redosledu koji ćemo kasnije primenivati u prilikom samog prvce sa parsiranja, što ćemo nešto kasnije viditi. Dakle, supratno, kad kažem, to znači da ćemo mi zapravo umesto da primenjujemo redom ove ovde smene, kao što je slučaj koji prsiranja, i će zapravo zdesno u levo, a to znači primenivati uprvo smene u obrnutom poradku. To ćemo raditi da bi smo terminale ostavljeli na samom kraju naše smene, dakle išli od listova kakoranu, a praktično uzimali po jedene termine gledajući iz desna u levo i njega menjali prema odgovarajuće i smene. I kada kredamo malo kroz primer pa ćemo da vidimo na koji način tačno funkcioniša i zašto baš s tim redosledom ratima. Dakle, krećemo od startnog neterminala, neterminala s, i kao što smo videli, dakle krećemo s desna u levo, te prvu primenjemo drugu smenu, a ta druga smena s
 Dakle uzmi taj neterminal s i zameniga sa neterminalom s i nakon toga b. Dobro, to smo uradili. Nakon toga je sledeće, otako nam je uprovo trehće smena ova ovde. Te ćemo uzeti ove krajnje desne neterminal s jedini u ovom slučaju. Zameniti se tri neterminala s jedim c. I time smo zapravo grupisali ove terminale s desnaje. A ono što radimo je da uzimamo prvi desni, odnosno krajnji desni neterminal i njega dalje menjamo. Kada pogledamo dalje ove redu sled praktično tih smena koja kova uzimamo, sledeće po redu je prva smena što znači uzet ćemo ove ovde neterminal s i zameniti ga sa 2 s i malim a. Nakon toga nam dolazi četvrta smena po redu, dakle uzet ćemo ove ovde, zadnje neterminal s i zameniti ga sa malim d. Nakon toga, ponobom nam dolazi četvrta smena, dakle ponobom ćemo uzeti ove ovde neterminal s i zameniti ga sa malim d. I u principu nastavljamo dalje naš postupak, sledeće što radimo uzimamo prvu smenu, po sledni neterminal s, menjamo se neterminal s, neterminal s i a. I tako dalje, ono što je na kraju, naravno, krajni cil je da dobijemo upravo sekvencu konkretnih simbola. To znači da smo krenušili u dovolj našeg startnog neterminala, dobili neku stvarnu sekvencu ovih pa šulaznih simbola koji su za tu dašavili, što znači da upravo ta sekvenca je formira naprema ove našoj grammatici, a ona što je naš sledeći zadatek je da upravo za tu konkretnu sekvencu vidimo kako izgleda sam protes parsiranjem skladu sa ovom grammatiku. I tada će nam biti jasne zašto smo baš uzeli ovakav poredak smena, dakle zašto smo posmatrali u nazad praktično ove ovde smene. Sad kao što smo rekli, naš bottom-up parser u principu ima neki stek, odnosno potisni automat, gde zapravo imamo simboletog steka, imamo neku konkretnu sekvencu koji uparsiramo i akcije koje sprovadim. U principu vo stoje četiri akcije koje se mogu ovde koristiti, to su akcije shift, gde akcije shift uzima, dakle konkretan simbol i same sekvence, smenšta taj simbol na stek, zatim akcije reduce koja prosto neki skup simbola sa steka menja nekim drugim simbolom. U principu to je česta pojava da u konkretnu gramatici, al tako ako uspemo da uklopimo desnu stranu, to je neki skup terminala i neterminala, dakle za neku smeno, uredimo i reduce po toje smeni i time taj skup neterminala i terminala zamjenimo samo jednim neterminalom koji se nalazi sa leve stranje. Dakle cilje da na taj način upravo zamjenimo veći skup nekeh simbola jednim neterminalom i da dozimo do onoga, što je zapravo i pointa, a to je da sve obuhvatimo startim neterminalom i tako i pokažemo da upravo ova sekvenca može biti isparcirana prema dato i gramatici. Ukoliko smo prepoznali samo sekvencu, onda akcije koja prestavio neki specifican reduce zapravo prestavio akciju accept, dakle došli smo do kraja naša sekvenci i prihvatamo je i postoji naravno i akcijer reject kada prosto ne prihvatamo neku kombinaciju simbola i stanja steka. Dobro, u principu ovdje kada jemo sada prazna steka dođemo o malo D na ulazu, radimo akciju shift, uzimamo D iz naše ove sekvence i smestamo ga na stek, te naš stek izgleda ovako, a naša sekvenca je sada umanjena za jedan prvi simbol. Nakon toga pogledamo ovu našu gramatiku i sad na samom steku imamo malo D. Pre toga stek je bio prazno, tako da sada kada pogledamo gramatiku, vidimo da postoji ova četvrta smena koja je zapravo to malo D može da zameni sa neterminalom S. Da smo mi zapravo prepoznali desno stranu neke smene i menjemo je ovim neterminalom S i zbog toga kao što vidite radimo upravo operaciju reduce 4. U sam reduce potrebno je navest i po koje smeni se radi taj reduce. Prvo da bi moglo da se rekonstruiša, al tako ta zamena, odnosno upotreba samih smena u gramatici. Sada ove reduce šta podrazumeva, podrazumeva da ćemo uraditi jednu operaciju pop, skinuti ovo desna steka i nakon togo uraditi push, neterminala S na stek i time smo zapravo zameni li sve, ono što bilo sa desna strane desmana, neterminalom S, naš stek izgleda ovako, naša sekvenca izgleda ovako. Sada je o tako operacijom shift, premašlamo ovo malo dena stek. U principu, kada nista sigurno i da li se radi operacija shift ili reduce, dobio vam pogledati gramatiku i videti, da li postoji neka smena, od koja je ono što se trenutno nalazi na steku, odnosno postoji prosto jedna niz neterminala i terminala gledano s vrha steka, koji zapravo preslevja desno strano neke smena, a u koliko je to slučaj, dakle, tako se kvencu možemo zameniti sa onim što na levoj strane takve smene, ako ne prosto radimo ovde operaciju shift, odnosno smešlamo u ovom slučaju D na vrh steka. Ponovno posmadramo našu gramatiku i u principu, ono što je naša uvek ideje da zavenimo što veći skup tih simbol. Pošto ovdje nemo neterminal S pa nakon toga D, sa desna strane neke smene, najvišće što možemo da nazivamo je ponovno početvrto je smeni upravo ovod D koje će biti zamenjena sa S, tako ćemo ponovno da radimo reduce 4 i zapravo ćemo skinuti ovod D sa steka i smestiti na stek neterminal S, pa će naš stek izgledati ovako, a naša sekuvenca je sada umanjena za jedan kongretan simbol D. Nakon toga ćemo ponovno raditi operaciju shift i z isto grazloga kao i malo prijatno, to je zato što ne imamo ni jednu smenu koja sad ima ove, vracimo, dva neterminala S ili jedan neterminal S, samo sa desna strane. Te radimo operaciju shift, smestimo D na stek, ponovno proveravamo gramatiku i vidimo da nam se ovo jedino uklapa u četvrtu smenu kao i da sada, tezbog toga radimo reduce po četvrtoj smeni, što znači skidamo D sa steka i smestimo S na stek i imamo ovakvu konfiguraciju na steku. Samo se gvenca ostalo nam je ovo, tako da radimo operaciju shift, time smestimo malo A na stek. Nakon što smetimo malo A na stek, ponovno pogledamo šta je s našem gramatikom. I vidimo da sada zapravo možemo da uklopimo, ono što je na vrhu steka, to je neterminal S, neterminal S i malo A, da skinemo to sa steka i da zamenimo neterminalom S prema prvoj smeni, tećemo nakon ovoga uraziti za prvoj reduce po prvoj smeni. Reduce po prvoj smeni nam ovdje u bukvata niz akcija, pop koja skida malo A, pop koja skida neterminal S i još jedan pop koja skida neterminal S i nakon toga puš neterminala S na stek, to će naš tek izgledati ovakvom. Nakon toga radimo operaciju shift, znači malo D nam dolazi na stek, pa ponovno radimo reduce po 4 smeni. I tako dalje, ono što je naš cilj, kada potrošimo celu ovo sequenc u kojem se pojavilo na uvruzu i dođemo do kraja te sequenc, odnosno ovog posebnog znaka koji smo uveli, jedan o steku imamo samo neterminal S, tada možemo da kažemo, aha, radimo accept. Šta zapravo ovo znači? Znači da smo mi uspeli da korišćem shift reduce parsera, zamenimo celu okupnu ovo sequenc u startnim neterminalom S samo jednim. Na taj način zapravo kažemo da korišćem ove grammatike i možemo prepoznati konkretnu sequenc. Da je na steku ostalo još nešto, mi bi smo rejdrjetovali takvu sequenc, ovo znači da ne može se podvesti pod ove startne neterminal, kao i da u bilo kompternutku prosto neka kombinacija nije bilo mohuće. I sad, o princi, pa ako se vratimo malo na početak, kako izgledalo ovo naše parsiranje, ono što možemo primjetiti da smo prvo očigledno iskoristili smenu četiri prilikom parsiranje da bi smo uradili naš prvi reduce. Nakon toga smo ponovu iskoristili smenu četiri i nakon toga smo ponovu iskoristili smenu četiri. Posle toga, smenu 1. I upravo kada pogledamo samo postavku zadatka i vidimo da je to ono što smo joći kivali, al tako. Zadošto se i u samom zadatku kaže da parser prilikom parsiranja upravo koristi po ovom ovde redosledu same smene da bi prepoznao neku sequencu. Prvo četvrtu, pa nakon toga četvrtu, pa nakon toga ponovu četvrtu, pa prvu i tako dalje. Mi kada smo go rekonstrujestali samu sequencu išli smo u obrnutom poretku upravo zbog toga što smo uzimali krajnji desni neterminal i o tako, i menjali ga prema toje smeni. Time smo zapravo gurali neterminali ka početku i onda na kraju zapravo kada smo došli do ove prve smene koje je primenja na prilikom parsiranja mi smo zapravo nju iskoristili kako bi smo zamenili krajnji levin neterminal koji nam se pojavio prilikom tog izbođer. Te sami u tim potporno ima smisla što smo uzimali upravo smene u ovakvom poretku kada smo rekonstrujisali samu sequencu. Videli smo dakle kako izgleda rad parsera za to u sequencu i na taj način smo prosto prikazali kako izgleda koncept botom pasiranja i kako izgledaju praktično osnovni segmenti parsera. Ok, naravno ovo se do kraja prosto izvede ali videli ste već princip je potporno identično ovo što mi je cilj jedna kraju.
 da obijemo upravo samo neterminal, startni i znak za kraj sequence i tu imamo accept. Ok, sljedeći naš zadatak vrlo sličan zbog toga što i dalje da se uvodimo u pojem botom oparsiranje. Tako da ponavo imamo neku gramatiku, imamo neki nisi simbola koja treba da procesiramo i da prikažamo zapravo kako će izgledati shift-reduz parsiranje. Međutim, ove kako je dodatno informaciju imamo ovaj neki ideo grafa koji bi trebalo da nam pomogu na prilikom toparsiranja. Upravo ideje je da vidimo još neke dodatne segmente i sad ja ću samo ukratko malo objasniti o čemu se radi u ovom segmentu grafa a onda kada prosto pređemo na rešavanje samog zadatka to će biti jasnije naravno kroz sam pljema. Ove segment grafa zapravo modaluje stanja na steku, odnosno simbole koji se tamo mogu naći u skladu sa tim koji simboli konkretni nam dolaze sa ulaza, da li radimo operacije shift ili reduce. Pa tako vidimo da recimo krećemo od startnog simbola na steku koji podrozumeva praza na stekl. I onda recimo ako nam dođe a na ulazu, iz tog stanja premešlamo se u stanje a1 što će eksplicitno značiti da mi zapravo kada uradimo shift u našu konkretnoj smeni, potisnemo to a na steku, a zapravo na steku dobije simbol, odnosno svoje simboličko ime a1. Ne samo a, iz prostu graznogu što je moguće da će se to a pojaviti u još nekoj od smena. Sad u to nismo imali u konkretnom prvom zadatku, imali smo uveke jedinstvene terminale prema konkretnim smenama, te samim tijem nije nije bilo potrebe za uvođenim ovoga. Međutim, pošto naravno u obštom slučaju moguće imati i kao što ovde vidite, dakle moguće imati iste terminale u različitim smenama, da bi smo prosto jedinstveno odredili od akle ove potreču, mi ćemo tom simbolo na steku dodati i sam indeks koji će upravo označavati konkretnu smen. Te smo zbog toga dodali ovde a1. Ako nakon toga se prepozna, ovej ne terminal a1, on se takođe a, pardon, on se takođe potisna na stek i dobije svoj naziv a1. Nakon doga ponovog možemo raditi shift b i smestiti na stek b1. Dobro, dakle to su samo neke uvodni elementi, kako bi smo videli od prvike čemu služuje ove graf, ali kao što reko, u samom rešenju stavno ćemo se vraćati na graf, tako da ćemo prosto i druge segmente uviditi i približnije se upoznati sa ovim grafom. Ono što on treba da urodi, je da nam praktično pomogne u našem rešenju, da možemo ispravno da rekonstruišemo sam proces prsiranja ove konkretne sekvence. Dakle, na početku u tom procesu prsiranja krećemo od stanja praznog steka i imamo, naravno, ove ulezne nizu odnosno uleznu sekvencu. I u principu, kad da sad pogledamo naš graf, da vidimo šta ćemo mi to da radimo, i koje akcij ćemo nas provodimo, vidimo da kada krećemo od startnog stanja steka, što je prazan stek, dolazi nam a, zapravo radimo shift operaciju i a, potisnemo na stek i toga potisnemo, dakle, kao a1, t je naš vršni simbol na steku sada a1. Nakon toga, naravno, ove naša sekvence više nemat oprav o a i pojavio se ovo malo b. Sada ponovopogledamo ove ovdje naš graf, vidimo, a, dobro, imamo malo b, ponovopogledatak uo potisnemo na stek i ovo će sad da imeti zapravo oznaku b3 i to je ono što možemo ovde videti, odako. Nakon toga dolazi ponovopom malo a, konsultujemo ove naš graf, vidimo, dakle, šta se tu dešava i sad, ono što možemo primetiti u ovom ovde grafu, je da grana koja ide između a1 i b3 je povratna grana. Što znači nakon togo b3 u principu može biti prepoznat ili ove, ili ove ovde deo, pošto je sada je došlo malo a, dakle, uredimo shift, potisnemo na stek i ponovopo će to biti simbol a1 koji ćemo ovde dodati na stek. Kada sada dođem malo c, ponovopogledamo šta se dešava i za ovog malog a1, dođem malo c, pa imamo ovo c, 6, ili tako, te samim tim uredimo operaciju shift i potisnemo c6 na stek. E sad, u samom onom grafu videli smo da, kada smo došli do toga c6, mi smo došli do kraja tog dela grafa i upravo ako i pogledamo 6-tu smenu, pošto smo rekli da ćemo ove indika su prvo to značavati, vidimo da smo tu prepoznali smenu, kao što smo malo preo onom prvom zadatku i sadili sa prepoznavanjem celo desan strane, recimo onog d. I to tu pracično radimo reduce, tako radimo reduce po 6-tu smeni i zapravo ono što se dešava pri tom reduce-u, je da mi skidamo sa steka ovog ovde c, vraćemo se na ono što nam je poslednje bilo na steku, a to je bilo malo a1 i nakon toga, ovdakopu što pušuemo na stek b, to upravo radi ove naš reduce, ovdakopu 6-tu smeni, mi zapravo smeštamo ovo b4 na steku. I sad ako pogledamo naš stek ako izgleda pa evo ga, upravo kao što smo zatjučili, dakle, skida se c6 steka, a smešta se b4 na steka. Nakon toga dolezi malo b, i sad kada opet pogledamo ove naš graf, evo ga malo b, to je b4, te prosto potisnemo na stek b4, evo ga ovde. Nakon toga što je došlo b4, tako mi vidimo da nema ničega više ovde, i ako pogledamo četvrtu smenu nema, ili tako i za ništa, te ne radimo shift, nego radimo reduce, prepoznali smo na vrhu steka, neterminal b i nakon toga malo b, i prosto ćemo ih zameniti neterminalom a. Ako se pitamo koja je to a, pa vidićemo da ćemo mi zapravo uraditi pop sa steka, pop sa steka, i vraćemo se na ovu ovde stanje, tako je prosto pogledamo šta nam je to na vrhu našeg steka. Pošto kada urodimo ove dva popa, na vrhu steka nam ostane ovo malo a1, onda smo videli da upravo ove i neterminal a, koji može doći nakon tog malog 1, označava nam je tako simbol a1, te ćemo njega smestiti na steka. Jasne da ove ovde neterminal a1, nije mogu da se pojevi na ulezu, ili tako pa zato namero nisam to obješnjavala ranije, kao što je recimo slučaj sa ovim simbolom konkretnim malo b, već je zapravo došlo tako do neke redukcije, odnosno do reduce-a, i onda ovdje zapravo je prepoznat neki deo sekvence, koji je zamijenje ovdje a. I sada mi je uopšta razmislimo šta mi se da onda radimo, kao što vidimo sada ovom konkretnom primjerom. Ovo neko malo c smo zemenili ovdje b, nakon toga smo tu praktično c b zemenili ovim nekima. I ono što smo mi ju suštine rekli, je pa sada kao sve, ono što može biti ovdje b, i nakon toga o b mi menjamo s ovim ovdje a, i prosto tako rekonstruišamo, dakle žalimo da dođemo do inicijelnog neterminala. Dobro, dokli smo bešli stikli. Sada smo smestili ovo a1, nakon toga shift videli smo već smestamo b1, i došli smo do kraja, ili tako o ne grane, te savim tim, dakle moramo raditi reduce. Pošto radimo reduce po prvoj smeni, radimo pop sa steka. Pop b, pop a, i pop malo a. Nakon toga je o tako treba da smestimo na steka s, samo treba videti koje je s pošto vidimo da je imamo viš. U principu, nakon što urodimo ovo ovde skidanje sa steka, nakon što urodimo ovo ovde skidanje sa steka, kako radimo? Dakle mi skinamo sa steka ove tri stvari, na vrhu steka nam je ostavu simbol b3. Te kada pogledamo u ovom našem grafu. Kada nam ostane b3, mi se zapravo nalazimo ovde u samom grafu i dolazi nam s nakon toga, to je upravo ovde s, zato smestamo s13. I tako idemo do kraja praktično, i kao što vidimo, tako, cilj nam je da nakraju, prosto naravno prihvatimo našu sekventu, ako ćemo brzo da prođemo kroz to, nakon dakle ovog b3, tamo smo imali reduce po trestu i smeni, što znači? Šta nam je treće smena? Evo je ovde, skinamo s, skinamo b sa steka, to sve menjamo nekim a. Kada pogledamo, dakle, skinulismo ovo, skinulismo ovo, šta nam je na vrhu naša ksteka? Na vrhu nam je a1, tako kada smestamo a nakon toga na ostavu grafa, vidimo da imamo ovo a1, nakon toga radimo shift, imamo malo b, b1, tamo i radimo reduce po prvoj smeni, skidamo sa steka i redom, što znači, pošto su nam ostala samo 3 simbola, vraćemo se na prazan stek i nakon toga je ovde s0. S0, i ako sužnenski ovde ne imamo ni jednu smenu, koja je nulta smena, kao što možemo da vidimo, je prakajšu smena koja se veštočki ugodi, vidjet ćemo nešto bliža o tom imamo sveljećem zadatku, gde je zapravo ta smena služi samo da se kaže, nakon što se prepozna sve što podrozumeva ne termina s, dolazi znak za prihvatanje sekvence, te samim tim to je prosto jedna veštočki uvedena smena, koja nam upravo tome služi da ako celu njom prepoznamo, a dođe na kraju znak za kraj, sekvence mi kažemo, prihvatamo taku sekvencu i samim tim smo ovde prikazali, kako funkcioniše parsiranje ove konkretne sekvence i dodatno smo videli, upravo,
 i ovaj jedan prikaz koji nam ože pomoći, a to je neki ideog rafa koji smo ovdje koristili. U principu, na danjem, mi ćemo sami sada konstruisati parser odnosno njegovog automata, tako da ćemo konstruisati sve što nam je potrebno, da bi smo i mogli da uradimo parsiranje na nekom konkretnom primeru. Da bi smo zakonstruisali neki parser, potrebno je u principu prvo da se odlučimo koji ćemo automat tog parsera konstruisati i u zavisnosti je toga mi ćemo raditi neka 3 različita automata, a to su L0, SLR1 i LL1 parser, gdje je dakle u toku danošnje lekcije ćemo raditi prva dva, a ovaj sledeći je jednostno poslnji ćemo ostaviti za sledeću nedalje. U principu, oni se razlikuju po svoje kompleksnosti po načinu funkcionisanja i kao neki uvod mogu ovako da kažem da prakđeno L0 parser, odnosno automat koji formiramo prakđeno parsiranje radi i sklučivo na osnovu trenutnog stanja steka, odnosno simbola koji se nalazi na steku, nevodeći ročuna o tome koji je sledaći simbolu u samu i sekvenci koji dolezi. I to možemo i videti uprvo prema nazivu ovoga automata, da je to što ovaj broj, odnosno cifra koje se nalazi u zagredama koje kojde L0 zapravo značeva koliko simbola ulazne sekvence posmatramo pridonošanju odluke takle kako će izgledati i samo parsiranje. Što zdiče SLR jedan automata, dakle jasno je on posmatra i sledaći prvi simbol koji se nalazi na ulazu odnosno te koji uzima i to u razmatranje pridonošanju neke odluke. Miđetom dakle to je neki devo kojem ćemo se kasnije malo više baviti ako prvi naš korike da formiramo automat, nečim što se zove konfiguracijna metoda i u principu ovaj je automat izgleda identično odnosno prvi delobar formiranja dakle toga automata, izgleda identično bilo da se radi o LR parseru ili SLR parseru, a onda dakle same odluke odnosno kako se parser ponaša, će zapravo kasnije varirati kada budemo uprvo pričali o akcijama koja oni sprovode odnosno odlukama koja donase u smislu onih shift, reduce akcija, accept ili reject. Dakle prvi naš korak kao što reku je da zapravo formiramo automat konfiguracijnom metodom. Sada ćemo dakle na primiru ove neke gramatike koje postoji u okviru ovog zadatka, vidjeti kako se to radi, uvijek nam mora biti zadeta način, neka gramatika nosno u koje ćemo mi zapravo i da pravimo parser te u ovom zadatku imamo neku gramatiku sa 4 smene koje možete videti prosto ovde, gde dakle starte i netterminal je netterminal s. Kao što sam pomenula na kraju predkodnog zadatka, ono što se uvek dodaje u gramatiku ovakom situacijama je neka nulta smena, tad nulta smena najčešći izgleda baš ovako. Evoj strane je netterminal s-prim koji kaže, e pa ova će nam biti starte netterminal i on su uvek nalazi samo u ovaj nulta smeni koju mi dodajemo. I zapravo ta nulta smena izgleda zanemaimo sad ovu ovde tačku koje ovde stoji, dakle kao netterminal s i nakon doga dolazi znak za kraje sekvence. I ono što nam ove smena upravo govorio da nakon što je prepozat cel, ta je netterminal s koje starte zonu inicijovnoj gramatiku je otako, dolazi znak za kraje sekvence i mi takvo sekvencu prihvatamo. Tako da zbog toga, dakle, dodajemo prosto ovu neku startu smenu kako bi nam olašala prosto to parsirenje, znamo kad je kraj i znamo kad će sekvence biti prihvaćena ili eventuolno ne. E sada, kako formiramo mi u prvo, ovaj, autor? Krećemo od neku inicijelnog stanja koja je predstavlja startno stanje na steku i vidite, nazivamo ga ovako kao simbol praznog steka. Dakle, to je to. U principu svaku, ovo naša stanja načrto, kao neki polder, ima neki svoj sadrže i ima svoj naziv. I u principu vidite ćemo kako su formiraju nazivi i kako su formira sadrže svakog takog stanja. Dakle, ono što sad mi zapravo ovde pravimo je ono neki automat konfiguracjonom metodom. Krećemo od startne smene i za nas je to za ovo prvo stanje, u prvo ovdje nullta smena koji smo dodaali. Što se diče dakle te smena, ono što možete primetiti je da osim, naravno o njih normalnih svariji koji imamo u smenama, a to su neterminali i terminali, a tako u ovom slučaju imamo i ovu ovde tačku. Ta tačka predstavlja tačku parsiranja, odnosno gde se trenutno nalazi parser sa procesiranjem sekvenciju skladu sa ovom ovdje gramatikom. I sad tačka na početku uvek smeštena na sam početak sa desna stranešta, upravo su Geriša da još uvek to parsiranje njih njih krenola u samom procesiranje, da tako ono košće će biti ubukvaćeno ovaj neterminal s, već deparsiranje na samom početku. Tako da ukljećemo ovakvu jednu konfiguraciju dakle to se zove konfiguracijan na početku. I upravo konfiguracija u koja se tačka nalazi na samom početku, naziva se konfiguracijem u prveni, a bazična konfiguracija predstavlja druge konfiguracije da se tačka prosto nalazi negde drug, da je odnosno u drugu poziciju u samo i smeni. E sada, da će se postavlja pitanje, kako ćemo da nastavimo parsiranje, odnosno konstrukciju ovog našega automata, kako ćemo da formiramo nova stanja i kako ćemo ove postojeće stani, što u ovom slučaju samo ovo jedno inicijalno trenutno stanje, praznog steka da dopunimo drugim smenama. U principu, dodaju se dodatne konfiguracije na osnovu ove početne konfiguracije. Tako što se kaš, ako se tačka parsiranja nalazi ispred nekog neterminala, u datostanje potrebno je dodati sve smene, koje odgovareju tom neterminalu ispred kojih se nalazi tačka, tako da je tačka parsiranja na početku desne strane. E, hajde da vidimo, a šta sam ja sve to repl. Tako, ovo što ćemo uraditi je pogledati ovu našu gramatiku, pronući sve smene koje se odnose na terminal s, što će u ovom slučaju biti prve dve smene i njih ćemo uključiti odnosno konfiguracije, ćemo uključiti u ovo startno stanje praznog steka, ali tako da tačka parsiranja bude na početku. Zašto smo to uradili? Pa kad pogledamo sada, dakle, ove naše jedno stanje automata. Sajim tim što se tačka nalazi ispred ovogo ovdje neterminal, ona se zapravo eksplicitno nalazi ispred nečega, što može biti ili ovo malo a, ili ovo je ovdje skup terminala i neterminala na mesu ovog ovdje s prosnu, ne postoji ništa treće u skladu sa ovom gramatikom, što tu može biti. Tako da zbog toga mi ovdje effektivno dodavimo upravo te smene i na taj način parsiru kažemo, dakle, sledaće što može da se desi, je ili da to bude ova ovda smena ili da to bude ova ovda smena, hajde da vidimo kako će onda se ponaše. Kada smo dodaali ove ovde smene, sada pogledamo naša tačke parsiranje nalaze ispred terminala, tisavim tim nemoramo rekruzima ponavijati ovaj postupak, dakle, ne dodajemo nikakve nove smene u ovo inicijalno stajno. Time smo mi zapravo formirali kompletno ovo inicijalno stajno, sledaćemo da vidimo kako dodajemo druga stajna. I druga stajna se dodaju uprevo na osnovu kako će naše parsiranje da izgleda. I u principu u okviru jednog stanja, bilo to ovo inicijalno stanje ili neko drugo stanje, prosto dodavanje ovih konfiguracija preslujio operaciju koje se naziva closure, znači dodajemo sve konfiguracije zatvarenja, za smene, za one ne terminale ispred koji se našlo ova tačka parsiranja, dok kada prosto formiramo nova stanja, to se zove operacije on go to, odnosno prelazak u nova stanja automacit, kako se dešavaju te prelazje. Tako što ćemo pogledati svaku smenu ovog nekog stanja i reći, aha ako se na ulazu pojevi malo a, kako dalje nastavlja naše parsiranje, ako se pojevi otvarna zagrada, kako nastavlja naše parsiranje, ili ako se pojevi ne terminal s, kako nastavlja naše parsiranje. Sad naravno, kada kažem ako se pojevi ne terminal s, isto kao i malo preo onom zadatku, kada smo videli ovoj deografa, sam naglasila da eksplitivno naravno ne terminal s ne može da se pojevi uloznoj sekvenci. Međutim, može neki del sekvence, koji će biti prepoznat kao ovoj ne terminal s, bi će urađena operacija Reducio, tako, i sam ti mi onda naravno kažemo, ovde dolazi ne terminal s. E sad, plastično posmatrno dakle za svaku dovih smenu. Mi sad gledamo šta je i za tačke parsiranje. Za ovom unultu smenu odnosno prvu, bi će to ne terminal s, te ako prepoznamo sledeće ne terminal s, mi ćemo reći, ha dobro, naša tačka parsiranja sada prelazi i za tog ne terminala rc, jesmo njega prepoznali, gjel tako, i evo je ove tačka parsiranja, mi formiramo jedno novostanje. Kako se naziva to naša novostanje? I mena stanjan suvek formiraju, prematome. Pokom simbolu terminalu ili neterminalu je rađem prelaz u novostanji al tako automata, ovom slučuje to ne
 s terminal s i koje smeni odgovorat što bi bije onaj neki index što sam im pomenalo u predhodnom zadatku. Pošto, da je u pitanju null zna smena, dakle to će biti neterminal s0. Tako će se zvatio ovo ovde stanje. Smena koja se uključe u takvo stanje i skluči u ova smena po koja se desio prelaz, odnosno koja u principu podrazumeva ovo da su u parsiranju obuhvatilo nešto što predstavlja neterminal s i nakon toga tačka parsiranja je prosto pomerena za taj neterminal s i stala je ispred ovog znaka za kraj sekvence. Što zdiče toga je da li ovo kompletirano naše stanje pa jeste, zato što se nova stanje ovde dodaju kada je ova tačka parsiranja ispred nekog neterminala pošto to ovde nije slučaj, dakle nevamo šta novo da dodamo. Slednji stvar, dakle koju imamo, je naravno dobrati ima pažno. Dalje prelaz može da ide iz ovog inicijavnom stanja, kao i naravno prelaze i svih ovih sledećih stanja koja je uključimo u naša lptomat. Kojim ćete redom da radite, potpuno je sve jedno. Ono što je jedino značuje, naravno da ne zaboravite neke prelaze i da uključite neka nova stanja, tako samo budete pažnjivi i to je sve. U ovom slučaju, dakle iz ovog stanja es nula, sledećeg gde se može ići, je ako se parsiranje nastavi, tako što upravo dođe znak za kraj sekvence. I ako dođe znak za kraj sekvence, dakle tačka parsiranja prelazi preko tog znaka za kraj sekvence i time prelazimo u ovom novo stanja automata koje nismo imali do sada, padaka zbog toga uključujemo u sa lptomatu. Kako se naziva to stanja? Kao je malo predakle, samo stanje dobije svoj naziv prema simbolu po kome se dašava transicija u automatu, a to je u ovom slučaju znak za kraj sekvence i ponovno indeks sa sami smene u gramatici, što će biti nula i tako smo u principu i dobili naziv za ovost stanj. Zato je od značaja da nazivete stanje oprav ovako i da to je ispravno radite? Zato što na osnovu toga, što date praktično naziv odgovarajicim stanju, ako koristite u pravove načine nazivanje, vi tačno možete odreti da li to stanji već imate u automatu, pa ćete samo da povežete medjim sobno stanja ili je to neku nova stanja koje praktično dodajete. E dobra, pošto smo videli je o tako da se tačka parsiranja poverila, sada je tačka parsiranja stigla do samo kraja, te samim tim znamo da vdje gledano iz ovog stanja nema prostu dalje prelaza u sljedeće stanje, tu smo završili. Po nekoj putanji smo završili kada tačka parsiranja dođe do kraja podgovarajući smenji, to će prosto značiti gledano s onog aspektu akcija da ćemo mi u tom trenutku raditi reduce, izbog toga, takve to je kao na ideografa koji smo imali malo predošli smo do kraja neke grane i nema dažem. Dobro, videli smo da smo sajim tim završili i sa ovim stanjem i sa ovim ovdje stanjem, ono što nismo završili je sa ovim inicijelnim stanjem. Ostalo nam je pitanje šta se dešava kada u našoj sekvencii dođe malo a. Kada dođe malo a šta radi parser? Parser je ili tako kaže prepoznajem to a i pomijeram tačku parsiranja izatog a. Time formiramo ovo novo stanje koje ćemo nazvati ili tako a1 zbog toga što smo transiciju iz pretkodnog stanja automata, u novo stanje automata radili po terminal a i pošto to odgovare o tako prvoj smen, mi ćemo ga nazvati a1. E sad ove naše stanje o bukvata prakodirčom samo ovu smenu s koje se odnosi na terminal a i tačku smo pomerili na kraj, ne uključujemo ništo novo pošto dakle ova tačka parsirenja na kraju, te sajim tim nema nikakve nove sekvence odnosno konfiguracije koji ovde možemo uključiti, te smo i s ovim ovde stanjem završili. Ostalan mi još da vidimo šta se dešava kada u inicijelnom stanje automata ovog naše parsera dođe otvrna zagrada. Ako dođe otvrna zagrada parser će da prepozna tu otvrno zagradu a svoju tačku parsiranja će pomeriti nakon nje. Kako će se nazivati naše stanje parsera u tom slučaju? Znači naziva će se otvrna zagrada i nakon toga indeks na koji se odnosi ta smena. Ako nista sigurni prosto da ovde o koje se smeni radi, vi pomerite se pogledate gramatiku, vidite redni broj te smene i na osnovu toga data naziv. E sada, ova ovde naša tačka parsiranja pomerila se nakon otvrna zagrada. Međutim pošto se ona sada našla ispred neterminala s, rekli smo da u tom slučaju dodajemo. Sve smene gramatike za taj neterminal s, tako da tačka parsiranja bude na početku. Zbog toga ćemo dodati upravo ovu smenu i ovu ovde smenu sa tačkama parsiranja na početku. Juš jednom ću naglasiti da to i zaspekta parsera ima potpuno smisla jer smo mi zapravo došli do tačke parsiranja u ovom ovde stanju automata ispred nekog dela sekvence koji će biti prepoznat kao neterminal s. E sad, dakle šta je to s, pa to je ili a ili ova sekvenca otvrna zagrada neterminal s, neterminal e. Tako da ću mi zapravo uključivanjem ovi smena reći naša tačka parsiranja zapravo time što je ispred ovog neterminal s je zapravo ili ispred a ili ispred ove otvrne zagrada u ovaj kogretnu smenu. Zbog toga nam je bilo potrebno da to dodamo. Dobro. Kada gledamo sada ovo stanje, pošto smo ovo inicijelno stanje obradili, šta možemo da zaključimo? Ako dođe otvrna zagrada, mi zapravo ostajemo u istom tom stanju. Kako sa to možemo da vidimo? Pa to možemo da vidimo na više načine. Prvi način, ako ćemo zaključiti tako nepu stvar, je kada kažemo, ako nam je došla otvrna zagrada, tačka parsiranja nam se pomera nakon te otvrne zagrade i naša početna konfiguracija za evento alo neku novostanju u kojeg bi se radila transicije je s koje se preslikava u otvrnu zagradu tačku parsiranja s i e. Što je equivalento na ovom je ovdje? Tezbog toga mi ostajemo zapravo u istom stanju. A još jednostavnije je verovatno da probajte da nazovete to stanje i da onda kažete, pa stanje bi se zvalo otvrna zagrada dva ili tako, prema tome što se transicije radi po simbolu koji otvrna zagrada, a radi se od drugoj smeni naše gramatike, te se stanje naziva otvrna zagrada dva, vidite da već imate to stanje i onda se dakle samo vraćete u njega. Ovo naravno, pod uslovom da upravno koristite ovako na manklaturu i da to ispravno radite. E dobra. Ako dođe malo a, dakle parser će da prepoznat o malo a, da tačku parsiranja pomeri izat toga, što znači preći će u stanje A1. Mi to stanje A1 već imamo ovde, izbog toga, dakle samo ćete prosto navesti da postoji transiciji između stanje otvrna zagrada dva u stanje A1 i to je sve. I ostala nam je, dakle, ovde još jedna smena koji nismo obradili, a to je upravo ove prva ovde smena. Šta se dešava ako bude prepoznat neki deo? Još tako vej grammatiki, odnosno neki deo sekvence, potisnut i redusovan u ovde neterminal s i, ako prepoznavo to kao s, parser pomeri iz svoje tačku parsiranja nakon toga s. Kada je pomerana ta tačka parsiranja, zapravo naša startna konfiguracija u tom sluču i ovog stanja ovde je s koje se preslikava u otvrna zagrada neterminal s tačka parsiranja neterminal r. Dakle, samo smo pomerili tačku parsiranja iz neterminala s. Nazvaćemo to stanja, ako ponovot prema neterminalu u ovom slučaju pokome rađen prelaz, odnosno, transicija u drugo stanja automata i indeksu je, tako odgovarajuće smena, to je s2. Sada vidimo, u odnosnu na ovu startnu konfiguraciju, dakle, ovoga ovde stanja s2, tada je naša tačka parsiranja se nalazi ispred neterminala r, što znači moramo dodati sve smene za neterminal r, naravno, sa tačkom parsiranja na početku i upravo ćemo to i uraditi. Dakle, dodajemo treću i četvrtu smenu, tačkom parsiranja ćemo staviti na početak. Sada vidimo, smo završili sa obradom stanja otvrna zagrada 2, ostalo na mjerožda vidimo šta je s ovim stanjem s2. I to praktično imamo 3 smene po kojima se našto deša. Prve smena, tačka parsiranja nam se pomera iz ovog neterminala r i u principu formiramo nova stanje koja se naziva r pa 2, al tako, zato što je se radi ovoj drugoj smeni po redu iz same gramatiki. Nakon što se pomeri tačka parsiranja preko ovog neterminala r, tako, što je prepozna deo sekvence koji se odnosi upravo na taj neterminal r, tačka parsiranja se nalazi na savom kraju i samim tim smo ovde sigurno završili, dakle, nema uključivanja ostalih konfiguracija u samom stanji. To je to, dakle, odliće se raditi neki reduce. Dakle, što zdiče ostalih smene, dakle, šta se deša ovako dođe za arez? Tačka parsiranja se pomera iz za areza i mi praktično formiramo nova stanja. Zato će se ovo stanje nazivati, stanje se naziva zarez prema transici i tri prema i.
 index. Aha, dobro, u ovom ovde slučaju, dakle, prvo smo odlučili da radimo po, ovoj poslunjoj smeni, zato što je jednostavnija, u principu kojim godre do sledom radite sve uredu, ajde onda, tako ću i ja, dakle, ako dođe zatvrna zagrada, tačko parsirinja se pomeri za zatvrne zagrade i to je samo ovdje konfiguracije, stanja se naziva zatvrna zagrada 4, to je to, sada ona situacija je malo prej, o tako, ako dođe zaraz, ili tako, to je zaraz 3, upravo je ovo ovde naša konfiguracija i, ili tako, tačko parsirinja se pomerila i za zaraz. E, sada tačko parsiranje ovde je ispred neterminala s. Te samim tim, pošto ispred neterminala s, dakle mora biti ubaceno sve što se odnosi na sam neterminal s, a to će značiti prvu i drugu smeno. Tako da ćemo mi zapravo ovde dodati s, dakle, tačko parsiranja na početku, nakon toga malo a i ovde tačko parsiranja na početku, nakon toga otvrna zagrada neterminal s neterminal r. Takle, to ne smo ima zaboraviti, obvezno moramo ubaciti sve smene koje se odnose na neterminali s pred koga postoji tačko parsiranja. Gledaj ću sada ovdje ovde stać. Ako dodje malo a u samoj sekvenci, tačko parsiranja se pomere i za toga a, stać je a1, to stać a1 već imamo u oku ovoga automata, tako da ćemo se samo povezati na njek. E, sada ako recimo kao meni u ovom slučaju na ovom slajdu, recimo ne može da vam stane sve na 1 list ili, dakle, ovom slučaju na 1 slajd, onda ono što uvek možete uraditi i prostu referencirati sa na stanji koje se nalazi negda u automatu, samo netrenutno na ovaj ovde slici. Tako što ćete ovako upravo povezati sa nekim kružićem u oku u kojelj koji će stajati naziv tog stanja i tako se zna da vi prosto kažete da ako parser najdje na malo a, on se dalje nastavlja, tako svoje parsiranje u stanju a1. Ako najdje otvrna zagrada, parsiranje se nastavlja, dakle, u stanju otvrna zagrada 2 i u principu tačka parsiranja naravno ide ovde iz otvrnu zagradu 2, smo takođe imali u drugom delu automata, da samim tim ponovu ćemo ga referencirati ovako, kao što vidite, ne dodajemo nova stanja. Što se tiče ove ovde smene, tu nismo imali još do sada, tako da kada se prepozna nešto što odgovora ovom neterminalu s, tačka parsiranja se pomeri za jednu poziciju u desno, naše novo stanje će biti s3, tako i naše inicijalna konfiguracija izgleda upravo ovako. Pošto se tačka parsiranja nalazi ispred neterminala r, mi ćemo naravno uključiti sve konfiguracije koje se odnose na sam neterminal r i to će biti 3 i 4 konfiguracija. Tako izgleda ovo naše stanje. Sada završili smo sa obređivanjem u ok prethodnog stanja, te samim tim ostalo na njihoš ovo što je prostolo okvir o ovog stanja. Tu ponovu imamo neke svare koje smo već videli, neke svare koje nismo videli, te u principu ako dođe zarez, to odgovorao ovo je ovde drugo izmeni. Vidimo kako izgleda početna konfiguracija, tačka parsiranja se premešta nakon dođe zarezu što odgovora početnoj konfiguraciji upravo ovogo ovde stanja i samim tim je odako, znači ako dođe zarez naše parsiranja se nastavlja od stanja zarez 3, tako da se vraćemo zapravo ovo. Ako dođe zatvrna zagrada, tačka parsiranja se premešta nakon te zatvrne zagrade, te samim tim se vraćemo u stanje zatvrna zagrada 4. Ono što nam je novo je ova prva ovde smena, ako bude prepoznat ovaj neterminal r, tačka parsiranja se pomjera preko njega i mi zapravo se premeštamo u stanje r3, naše tačka parsiranja je tu na kraju, te samim tim prosto nemamo više novih stanja koje ćemo uključivati u ovaj naš automat. I ti me smo zapravo završili formiranje automata konfiguracijonom metodom. Ok, što se od nas još tražilo u zadatku? Dakle, ako smo formirali automat konfiguracijonom metodom, ostala mi još da vidimo kako će zapravo raditi LR0 parser, kako će raditi SLR1 parser i oni se zapravo razlikuju po tome koje akcije sprovode. Da bi smo mogli da odredimo koje akcije sprovode treba nam zapravo kontrolna tabela, ali mi ćemo zapravo sada formirati nešto se zove potisna tabela i nešto se zove kontrolna tabela. Ako se sečete u onom uvednoj priči, smo opomenili da Shift-Rid-U sparser i dakle imaju i kontrolnu i potisnu tabela. Što se diča same potisna tabela, potisna tabela se formira na osnovu baš ovoga automata koji smo napravili. Kao što vidite, ovo ovdje prav sve je vrn klasični automat. Dakle, na osnovu konkretnog simbola premeštamo su u naravno stanje. Koristimo al tako i ove neterminalite samim timnom i potrebanu proba steka da bi smo mogli da menjamo al tako određeni skup simbolak koji se pojavljuju na steku da ga menjamo nekim neterminalom. I samim tim je al tako, ovdje smo formirali klasičan jedan automat. Sa samo potisnu tabelu formiramo direktinima piranjem ovoga automata 1 na 1 na jednu tabelu. Tata Bela zapravo sodrži neke vrste i neke kolone gde vrste predstavljaju sva ona stanja koje smo malo preimali u onom automatu, odnosno sve simbole koji se mogu pojaviti na steku. Tako da zapravo tu biste samo krenuli po ovom ovdje automatu kakom smo formirali i popisali biste sve konkretne simbole koji se pojavljivali. Mi smo veš še imali. Simbol praznog steka nakon toga stanje S0, znak za kraj sekvence 0, a1 otvrnu zagradu 2, S2, R2, Zarez 3, S3, R3 i zatvrnu zagradu 4. Kakav god redosled ovdje uzme za da ih popišajte, potpuno je sve jednom, vodite ročuna samo da ne propustite neki. U principu možete zbog toga najzgodnije koristiti već ove indekse kada ih imamo, kao što je ovdje urađeno u nekom neopadajicom poredku. Tako prosto sigurno znate da ste prošli sve s 0, sve s 1, sve s 2 i tako dalje. S ozdiče naših kolona, koloni će biti konkretni simbolipu kojima se može dašavati transicije u samom automatu, što znači terminali i neterminali, da je postoje da prelazi između nekih staćnja. I sad, kao što rekuh, potisna tabela predstavila jedan na jedan mapiranje između onoga automata i sada je tako ove ovde tabele, gde prosto ako je postojeva transicije između neka dva staća na osnovu određenog simbola sa ulaza, mi ćemo to napisati u ovaj ovde tabeli. Tako da ja ću sad, dakle, uzeti ovde pošto prosto pregledno je na jednom mesto u stavlja na sva stanja i na osnovu toga ćemo formirati redom ovde tabela. Što će reći, dakle? Iz inicijalnoj početnog stanja što vidimo koje sve transicije vidimo? Vidimo transiciju po neterminalu s i ta transicija nasvodi u stanje s0. I to samo upišemo ovdje. Vidimo također da postoje transicija po terminalu a i ta transicija nasvodi u stanje a1. Također postoji transicija i po terminalu otvrna zagrada, i ako iz nekog razloga to ovde ne piše, i vodi nas u stanja otvrna zagrada dva, tako da te tri svarićemo da zabeležemo i to je ono što imamo iz ovog stanja praznog steka. Što stiče stanja s0, tu imamo praktično transicije u stanje ovde i al-tako, u slučaju da je došla simbola za kraj sekvence, tako da ćemo to isto predstaviti. Što se tiče ovog ovdje tu prosto nemo nikakvih transicije, to je zavrašno stanje za tu neku putanju, tako da iz tog stanja se ne ide dalje nikde. Dobro, idemo dalje. Stanje a1 pogledamo ga je ovdje, iz a1 takođe ne idemo nikde dalje, tako da isto nepopunjavamo ulaz. Otvrna zagrada dva pogledamo ovde, ako nam dođe otvrna zagrada ostajemo u istom stanju, ako nam dođe ne terminal s, prelazimo u stanje ne terminal s2, i ako nam dođe malo a, prelazimo u stanje malo a1, i to ćemo i popuniti ovde u ulaz. I stanje s2, ako dođe ne terminal r, odnosno prepozna se ta ideo sekuvence kao ne terminal r da se pravil mi izrazim, prelazimo u stanje r2, ako dođe zatvrna zagrada, parser prelazimo u stanje zatvrna zagrada četiri, i ako dođe zaraz u stanje zaraz tri.
 Dobro, iz stanja R2 nema daljeh transicija, ok, zarez 3. Znači, ako dođe otvrna zagrada, par se prelazi u otvrno zagradu 2, ako dođe malo a u stanje A1, ako je prepoznatno, prepoznatno je terminal s, onda u stanje s3. Tako je. S3, ako se bude prepoznatne terminal r u stanje R3, ako dođe zarez u stanje zarez 3 i ako dođe zatvrna zagrada u stanje zatvrna zagrada 4. Stanje R3 nam je završno tu nema daljeh i stanje zatvrna zagrada 4. Takođe, tako da smo samim ti mi formirali potisno tabelu. Dakle, ove potisnate dela, preslikavanje 1 na 1 prosto iz onoga automata, prostorom služi da bi smo jednostavnije kasnije procesirali konkretnu sekvencu. U principu i jedna i druga stvar nosi istu količinu informacija, kao što i sami možete da vidite, baršto se ovih prelaza tiče, prosto, isto i iz onog videa automata možete zaključiti, ili tako kakvi se prelazide šave, vidjeti moj prosto kompaktnije zapis te zbog toga, dakle koristimo i tako nešto. I druga stvar koji treba odrediti je kontrolna tabela. Ja sad kontrolna tabela nama suštenjski označava koja akcije se vrši u kom stanje. Te samim ti kontrolne tabele za različite parsere se razlikuju. L0, pošto ne posmetra simbole sa ulaza, kao što sam već rekl, praktično obavlja akciju i skličevo na osnovu stanja parsera, gde se trenutno parsiranje nalazi. I ta stanja su označena, naravno, ovim simbolima kojima smo njitamo i ih označili ataku u onom automatu. Tako da akciju sprovedimo na nivou pojedinočneh stanja, ništa drugo ne koristimo za diferenciaciju. U principu, akcije su određuje tako što ćemo pogledati ovo naše stanje i videti gde se nalazi naša tačka parsiranja u svim konfiguracijama koje se nalaze u okviru nekog stanja. Ako se tačka parsiranja negde nalazi na kraju, to znači da će se raditi operacije reduce dok u koliko se radi bilo gde drugde, nalazi bilo gde drugde, radi se operacija šiftovanja što znači čitanja, ili tako bišo svelećek simbola smještanja na steki prosto napredovanja u samom automatu parsera. Pošto u startu, minicijalnom om stanju, vidimo da je tačka parsiranja negde u samim konfiguracijama, i ćemo raditi operaciju šifto. Što se tiče stanja S0, ponovno tačka parsiranja je negde u sredini, te ćemo ponovno raditi operaciju šifto. U ovom ovde stanju tačka parsiranja je na kraju, pa ćemo raditi operaciju reduce i to ponulto u smeni, što je zapravo specificno jer se radi operaciji accept. Odnosno prihvatanje segvent. Stanja A1 naša tačka parsiranja je na kraju, što znači radi se reduce i ponovno, kaj je malo prej, objevezno želimo da ustaj reduce, naglasimo po kojoj smeni se radi redukcija, te ćemo napisati reduce po prvoj smeni. Otvrna zagrada 2, tačka parsiranja je negde unutar samih konfiguracijate, se radi shift. S2 stanje, evo ga ovde, tačka parsiranja takođe u sve 3 smene, negde unutar samih konfiguracije, znači radimo shift. U stanju R2, tačka parsiranja je na kraju, tako da radimo reduce i to po drugoj smeni. Nara možemo i da pogledamo u gramacici po kojoj smeni radimo reduce, međutim ako se setite, mi smo zapravo ove indexe ovde uprovo davali prema smeni odgovarajuće i tezbog toga oni će uprovo odgovarati tom indexu. Slec je naše stanje, za R3, vidimo da se tačke nalaze, negde unutar ovi konfiguracijate se radi shift. U stanju S3, takođe se radi shift, tako tačke su unutar ovih konfiguracija. U stanju R3, tačka je na kraju konfiguracije, te će se raditi reduce po 3 smeni i u stanju zatvrna zagrada 4, tačka je takođe na kraju konfiguracije, te će se raditi reduce, ali sada po smeni 4. I osjetkao što vidite, odli smo na nivog samog stanja, određivali jedinstvenu akciju, čak i za situacije, da je tu prosto bilo više različiti konfiguracije. Moglo se naravno desiti da u nekoj konfiguracije tačka parsiranja se nalazi negde unutar same konfiguracije, dok posloji konfiguracija, gde je tačka parsiranja na kraju. U tom slučaju bi se desio konflikt i to bi se zvao shift reduce conflict, ili u koliko je, dakle, posloji više konfiguracije, gde se reduce radi, ali se radi po različitim smenama, to bi se nazivalo reduce reduce conflict. U principu, ovaj LR0 parsiri zato jako jednostavan, zato što određuje jedinstvenu akciju prema samo stanju, ali ono što je, dakle, mana, je što prosto je povećen broj konflikata, pa u nekim ovakvom slučavima, naravno, prijavile bi smo prosto konflikt, zbog toga što ne bi smo mogli doodredimo jedinstvenu akciju na nivog pojedinočnog stanja. Dobro, u samom zadatku je bilo potrebno odrediti i kontrolno tabelu za SLR1 parser. SLR1 parser, kao što rekao, funkcioniše malo drugačije, što nam u pravo sugeriša i ova ovde jedinica, koja se nalazi u samom nazivu tog parsera, a ona upravo kaže da, osim što posmatramo samo konkretno stanje, parsera, odnosno automata, vi posmatramo i taj simbol koji se nalazi na ulazku. Inače, potisna tabela je identična za sve ove parsere, zbog toga što se formira i sklučuju na osnovu onih prelaza na osnovu automata koji smo formirali konfiguracijunima etodo. Međutim, kontrolna tabela se razlikuje to u pravo akcija koju parser sprovođe. Što se tiče toga, kako formiramo kontrolno tabelu? Prjenigu što prođemo kroz ove baš neke detačiće i oču samo ovako malo da prođem, pa ću prosto da kažem, da kontrolna tabela koja desela i jedan parsera izgleda slično, ali ipak različito. Zbog toga što, naravno, akcije se sprovode na nivou stanja da ćemo ponovno imati ovako stanja data, ovako u ovaj ovde nekoj koloni, gde je potrebno ponovno do pobrojimo sva stanja koja postoje, kao vrste pardon, dok će nam kolone zapravo predstavljati konkretni simbol i koji se mogu javiti na ulazu. Dakle, ono što različ po kontrolnu tabelu SLR1 parsera u odnosnu na potisnu tabelu je to što ovde kao što primjećujete. Nemožemo imati neterminale u kolonama. Zbog toga što, dakle, ovde samo smeštamo konkretne simbole koji stvarno mogu biti simboli steqvence, jer prosto parser kada se nalazi u nekom svom stanju, u svom automatu i na ulazu dođe konkretan simbol otakno mora da zna koju akciju vrši. Nešto smo o tome već pričali kada smo radili one regularne izraze, dakle, da parser prosto mora da zna jedinstveno na osnovu sada ovog simbola i toga šta je kako je stanje automata, kako će biti njegova akcija koju se provodi. Sad nakla akcija, isto kao je malo prej, shift, reduce, accept, naravno i reject. Kada radimo shift, kada radimo reduce, prvo da vidimo, dakle, dakle nam o polaku pa ćemo našto preci iznije videti. Dakle, sada o zazljako od onog LR0 parsera, umesto da određujemo jedinstveno akciju na njivo u stanje, mi ćemo zapravo za svaku kombinaciju stanje i ulazno u simbola da određujemo akciju. U principu možemo koristiti potisnu tabelu, kako bi nam pomogla tako, možemo koristiti i ovo ovde, dakle kako god vam je lakše. U principu, ako koristimo potisnu tabelu, samo da vidim, dali je ona ovde formirana. Aha, evo je ovde. Možemo koristiti potisnu tabelu pa, evo da vidimo, ali u principu možemo i na osnovu onog automata. I stanja praznog steka. Već smo videli, al tako, ako nam dođe otvrna zagrada, radimo shift i prelazimo u stanje otvrna zagrada 2. To znači, mi je efektivno radimo shift, ali potiskujemo otvrnu zagradu na stek i time al tako prelazimo u stanja otvrna zagrada 2. Takođe, ako nam dođe malo a, kao što vidimo, radimo shift, prelazimo u stanje a1. Sada ignorišamo trenutno ovdo, zbog toga što, kao što reko koji ne postoji, ne terminal s koji nam se može javiti na uozu, već se to dašovi sklučiva koja postoje neki reduce, što smo videli iz onog zadatka sa parcijalnim rafom. Pa ja tako smo onda prepoznali nešto što podrazumeva, taj ne terminal s. Dobro, i tu imamo shift. Za s0 Ako pogledamo ove naš ovde u tomat, ko' desnula, ponovom,
 radimo neki shift ili tako, prebacujemo se u ovu ovdje stanje. Međutim kada smo se prebacili u to stanje, kaj se kvence nola, vidimo da je tačko presiranje tu na kraju. I iz ovaj potis na tabela mi vidimo, ali tako da se ne prebacujemo dalje nikt. Tako da košto rekont možete informacije izvući iz potis na tabela i vi iz ovog samog ora automata. To znači da ćemo zapravo raditi neku operaciju reduce. I sad razljeka u odnosu na ono što smo videli kod ele rnula automata i što ne definišemo reduce na nivou celokupnog stanja, već samo na nivou pojedinečnih simbola za to stanje. Te ono što ćemo zapravo ovdje definisati je za koje simbole konkretne ćemo mi raditi reduce. Kada se radio ovaj konkretnoj situaciji, to je reduce nula, odnosno accept mogli bi smo da kažemo i da to radimo na nivou celokupnog stanja, znači da je to jedinstva na situaciji. Ali u nekom opštom slučaju zapravo se određuje nešto što se zove follow scoop za taj neterminal koji me odgovara praktično ova ovdje smena, gde je u toj konfiguraciji tačka parsiranja na kraju. Tako da u ovom slučaju mi bi smo radili follow scoop za neterminal esprim. Šta zapravo predstavljaju follow scoopowi za neke neterminal? Follow scoopowi podrozumevaju scoop konkretnih simbola sa ulaza, koji se mogu naći nakon nekog neterminala. E sad, ako bi smo mi recimo u okviru ovog našeg zadatka, chceli malo da predupredimo celu situacije pa da odredimo follow scoopove za sve neterminale za koje to možemo, to su nam dakle neterminali SS, PR i ER. Recimo, hajde da vidimo kako bi smo to uradili. Follow scoop od F neterminal je kao što rekoh scoop svih konkretnih simbola, koji negde u našoj gramatici u bilom koje smene mogu doći nakon tog S. To znači da mi zapravo trebao da pogledamo sve ove naše smene, njihove desne strane i da pogledamo šta se to nalazi i za tijetog neterminala S. Iz ove nullte smene mi vidimo da je to znak za kraj sekvence, pa ćemo go uključiti ili tako. Ove drugo smene njemamo neterminal S od desna strane, tako da tu ništa, a iz druga i treća smene vidimo da nakon ovog S se upravo nalazi neterminal ER. Tako da ono što je nama iz S je upravo ona čime počinje ovo ER. Pa ćemo mi pogledati u ove našoj gramatici čime počinje to ER. Znači tražimo sve one smene koji se sa leve strane nalazi neterminal ER. I to su treći i četvrta smet. I vidimo da to naš ER počinje uvek zarazom ili zatvrnom zagradom. Pa ćemo sve to uključiti u ove naš skup i znači follow od des predstavlja zapravo jednom skup koji se stoji upravo dova tri terminala. Znak za kraj sekvence, zaraz i zatvrna zagrada. Dobro. Hajde recimo da odradimo follow skup od ER. Znači ponavob bi smo pogledali sve naše smene koji se ER nalazi sa desna strane. To su naše druga i treće smene. I kada pogledamo šta je to iz-a ER. I zove drugi smen. Ono što je ovde iz-a ER, nače ono što dolazi ovde u nekoj konkretnoj smeni, je ono što je praktično iz-a svega ovog što je s desna strana. Pošto ništa sad konkretno ne vidimo kako malo preko od ovog sada dolazi iz-a ovog ER. Dakle, ono što je zakučeno je da kada prepoznamo, znači, pasiramo tu neku našu sekvencu, ono što će doći iz-a, je praktično ono što je iz-a svega što smo prepoznali ovom ovde smene. A to znači da će follow-o-o-der na osnovu ove ovde smene biti zapravo follow-o-od-s. Jer je to follow-o-od-onoga što je sve ovo sa desna strane, a to zapravo z desna strane je zaménjeno s ovim ovde-s, te je follow-o-o-der isto što je follow-o-od-s. I z ovdje ovde treći smene mi obismo ponovu reka, to ono što je iz-a ER, je ono što je iz-a svega ovog sada desna strane, a to je zapravo ovaj neterminal ER. Tako da je follow-o-o-der isto što je follow-o-o-der. Međutim, to nam nije nikakva nova posebno informacije, tako da ćemo se zadržati na tome da je follow-o-der zapravo follow-o-od-s, pa će to ponovu biti ovo ovde tri termina. I uši jednom, dakle, follow-o-od-s prim će biti ono što je iz-a, ovog ovog ovde, sad mi naravno nemo dalje, ali tako pa ćemo se zadovoljiti time da kažemo da je to predapravo znak za kraj sekvence, jer prosto, dakle, i za kraj sekvence naravno ne dolazi ništa, o to je specifican slučaj za s prim. Nadam se da je ovo bilo jasno, to će nam sad značiti, kada budemo prosto nastavili dalje sa ovom kontrolnom tabelom, jer ćemo zapravo, kao što shift akcije popunjavamo, samo u onim ulazima gde zapravo postoji neka transicija za odgovarejicje stanje i, dakle, neki prelaz, neki kogretan simbol. Isto tako ćemo akcije reduce, odnosno specificu na ovu reakciju, akciju accepta, izvinjom se, popunjavati za one ulaze koji odgovareju, dakle, vrsti koju označova neko stanje, a koloni koju označova konkretna simbolu. I za to ovde imamo accept. Što se tiče stanja? A1. Podledamo ovu našu tabelo, dakle, nevamo nikakav shift, i uprvo kada pogledamo naše stanja, A1 ima tačkom predciranje na kraju, tako da radimo reduce i tu radimo reduce po prvoj smeni. I sad, za koja konkretna simbola? Pogledamo ovu našu smenu i vidimo da su ona odnosina neterminal s, tako da nam treba follow scup od s, i to smo beše šta rekli, da nam je bilo, dakle, znak za kraj sekvence, zaraz i bila nam je zatvorena zakat. Tako da ćemo za ova tri simbola upisati da se radi o akciji reduce. Sa što je ovaj parser nešto bolji od onoga elejrnova? Zvok toga što recimo, smo ovde mogli da tolerišemo da je postojo shift po recimo otvorno i zagradi ili simbolu A, ne bi se detektuvao konflikt, te samim tim beće manje vrvatnoće za pojagom konflikt. Dobro, otvorno zagrada 2. Šta beše otvorno zagrada 2, dakle, ima shift za otvornu zagradu i shift za malo A. Nakon toga S2, dakle, shift za res i shift zatvornu na zagrada, zatim R2 nemajel tako shift akcija, to znači, vrvatno ćemo imeti neku reduce akciju pošto nam se tačka parsiranja nalazi na kraj. I ponovog pogledom našta se odnosi ova konkretna smena, pa odnosi se na neterminal S, tako da uzmamo follow od S ili tako, i za te simbole radimo operaciju reduce po drugoj smeni, što će ponovog biti zare zatvornu na zagrada i znak za kraj sekvence. Nakon toga imamo stanje zarez 3, gde radimo shift i prosto po kojim konkretnim simbolimo radimo shift, pa otvornu na zagrada i A. Nakon toga S3, radimo shift, zarez i zatvornu na zagrada, al tako, nakon toga R3, R3 pogledamo, tačka parsiranja je na kraju, dofaj radimo reduce, reduce za neterminal area, al tako koji se nalazi sa lejne strane, te ćemo zapravo pogledati follow scoop od R i to će nam ili tako biti u ovom slučaju ponovog ista ova 3 simbola, ali to je samo zato što follow scoop, jer odgovara follow scoop od S, tako da ćemo uraditi reduce po 3 smeni za ove simbole. I još nam je ostalo samo dakle zatvorn na zagrada 4, tu ponovog imamo neke reduce po 4 smeni, te tražimo follow scoop od neterminala R i za date simbole radimo reduce po 4 smeni. Time smo zapravo kompletirali kontrolnu tabelu SLR1, par se videli smo po čemu se razlikuje i u ovom trnutku, dakle trebalo bi da smo sposobni da prvo konstruišemo sama automat parsera, konfiguracijonom metodom koje je zajednječka za bilo koji je dobit parsera, da nakon toga formiramo potisnu tabelu koji ćemo 1 na 1 opirati izuprovo toga automata i da budemo sposobni da formiramo kontrolne tabele L0, SLR1 parsera. Uraditimo još neki zadatak, kako bi smo al tako absolvirali ovaj deo što se tiče L0, SLR1 parsera. Tako da imamo neku sledeću gramatiku na osnovu koje al tako trebu da konstruišemo ova dva parsera i za neku konkretnu sekvenciju da prikažemo prosto kako će oni raditi. Ok, isto ćemo sve dakle kao i do sada. Dakle, imamo neku manju gramatiku koja se zostoji od neke 3 smene kao što možemo videti i ovoj prvi kora koji ćemo napraviti je dodamo 0-tu smenu, al tako koja će da nam bude neko S-prim, gde ćemo prosto samo da kažemo nakon toga S-u dolazi dakle znak za prihvatanje sekvenci. I formirajemo dakle startni...
 ovoga našega automata koja ćemo nazvati je tako prema praznom steku i dodaćemo tačku prasiranja na početak. Dakle, krećemo ovo ne prve konfiguracije da koje se odnosi na ovu nulltu u provod aletu smenu pošto tačka prasiranja će nam biti ispred neterminala s. Onda je tako dodaćemo sve smene po tom neterminalu s, odnosno prvu drugu i treću smenu i tačku prasiranja stavljamo na početak. Već smo reklio tako pošto ovaj ovde, takla, ovo prva konfiguracija gde je upravo tačka prasiranja ispred tog neterminala s, takla, odnosi se na poziciju parsera trenutno u dramatici, nakle, na poziciju gde se trenutno dakle parsira neka konkretna sekvenci. Sa ta sekvenca, odnosno taj njen sd, da je ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo gde ovo g ti... Oke. Nastavljamo kao i do sada. Ajde prvo dobro, dimo ovo je jednostavnije slučaje. Dakle, ako parcer prepozna i na ulazu u sekvenci, samo će ovo tačka presiranja da se preboci nakon tog i. U tako naše stanje će biti neku stanje i 3, tako prema nazivu konkretnog simbola po kome radžem prelaz i smener, odnosno, rednom broja smene koja odgovara ovom prelazu, tačka presiranja se premešla na kraji, tako to će nam biti stanje i 3. Također ako dođe otvrna zagrada, tako iz ovog inicijelnog stanja, to će biti neku stanja otvrna zagrada i 1, tačka presiranja se prebacuje nakon te otvrna zagrada, i pošto je tačka presiranja ispred ovog našeg neterminala s. Tako to znači da ćemo upravo dodati sve smene koje odgovaraju ovom neterminal s, tako da je tačka presiranja na početku, tako da ćemo mi zapravu uključiti ove 3 smene. Sada gledano dakle iz ovog ovde stanja, ako dođe i na ulazu, par ser će prosto da se prebaciji iz ovog stanja u stanje i 3, a ako dođe otvrna zagrada, ostac će u tom istom stanju. Kao što sam već rekl, to možete proveriti na 2 načine, ili tako što ćete pogledati, kako će vam zapravo izgledati start na konfiguracija. U ovom slučaju dakle samo bi smo pomirili tačku presiranja, nakon i vidimo da je to identično o nome što imamo ovde, tezbog toga je to baš to o stanje, a s druge strane, takođe, naravno, isto priče iz ovdje otvrna zagrada, dok takođe možemo prosto i samo da nazovamo ta stanja i da vidimo da se radi baš o tom konkretnim stanjima automata. E, dobro, to su bili ovi jednostavni slučavi, zato smo to odmako bradili, ali, naravno, ne smo da zaboravimo sve ove preostale, koje nismo obradili. Tako i z ovo genicijelnog stanja, nismo obradili šta se dešava sa situacijom, kada prepoznamo neki deo sequenci koji se odnosi na neterminal s. E, sad, to se značiti da mi treba da formiramo jednu nova stanje, međutim, ako pogledamo, postoje dve smene u ovom ovede inicijelnom stanju, a to su ova nulta i ova druga smena, kod kojih tačko versirenje se pomera nakon s, ako je to je su pravo prepoznato kao neki deo sequenci. Međutim, dakle, do stavu nismo imali situaciju da to bude po dve različite smene iz nekog stanja. Tako da, e to, jedna nova situacije za nas. Kako nastavljamo sa izradom praktično ovog parsera? Pa tako što ćemo obete konfiguracije uzeti kao početne i obaciti ih u jednu novo alociranostanj. E, sad, ovo novo alociranostanje ćemo nazviti kao kompozitnostanje za ove dve smene. Tako da, dakle, naravno nazi vide prema ovo terminalu, odnosno, neterminalu, po kome se desio prelaz u konkretnom automato, što će biti neterminal s, ali, dakle, ne radi su o jednom indeksu, nego o kompozitnom spoju praktično ova dva, dakle, nullto i drugo, tezbog toga imamo nulla dva. I prema prvog i konfiguraciju ovo je ovdje, tako, tačko parsirnja se pomirila nakon neterminal s, tako da, evo je ovdje, ispred terminala, tako da ništa, novo ne dodajemo, a prema ovo je ovdje, je o tako, pomirila se nakon ovoj neterminal s, to nam je ovo je ovdje, da je ovo ponovno ništa, ne dodajemo. I u principu, uvako izgleda ovo naše stanje, tima smo završili sa obrdom inicijelnog stanja. Što zdiče otvrne zagrede 1, tu nam je još ostalo, a šta se dešo, ako se pojevi neterminal s, tako, tačko parsiranja može po prvoj smeni da pređe je ovo ovoj smena, ali takođe može i povoju ovoj smeni. Dakle, vrlo slična situacija kao ono što smo imali malo prevo ovom inicijelom stanju, stanju praznog steka. Tako da ćemo ako se prepoznajo tako neterminal s, ponovno izvršiti transiciju u neko novost stanji, i to će sad biti stanje s1,2, da ćemo zapravo početne konfiguracije biti u prvove dve iz stanja otvrna zagreda 1, ali sa tačkom parsiranja koja je pomerena nakon neterminal s, što možemo vidati u prvo u ovom stanju s1,2. Pošto se naše tačke parsiranja ovdje nalaze ispred terminala, zbog toga je dakle nemamo dodavanje nikakvih novih konfiguracije, nego prosto to je to. Dobro, je sad naravno u okviru obata stanja ostalo je nedovršeno, je otako, ostale su nedovršene konfiguracije, tegako iz ovog stanja s0,2 imamo prelas po znaku za kraj sequence i po zarazu, dok iz ovog s1,2, znači imamo prelas po zatvornoj zagredi i zarazu. Pa, hajde da krenemo od nečega. Ako iz s0,2 dakle, parser detektuje zaraz u ulaznoj sequenci, pomerit će se u sledeće stanje koja se naziva zaraz dva, zbog toga što je otako sastavjeno, taj nazim od konkretnog terminala po kome se dešava prelaz u ovo automatu što je zaraz i indeka sa same smena što je dvojka. Tako da se tačka parsiranja pomera nakon tog zaraza, i to je uredu da chvetačko parsiranje ispred terminala time smo završili, ako je došao znak za kraj sequenci, otako pomeramo se u stanje znak za kraj sequence nola. Sada pošlo vi tran, to nemoj mest na nom slajdu sada ćemo staviti kao napred ovu samo oznaku neku stanja, to stanje će kasnije biti razrađeno da plej tako možete uraditi. Isto priča za stanje s1,2 znači ako dođe zatvrna zagrada, biće nešto, ako dođe zariz, ponobo, dakle tačka parsiranja se pomera nakon tog zariza, tako da će to biti stanje zariz 2, te ćemo samo prosto povezati ova dva stanja, nećemo locirati novo stanje. Dobro, ako dođe zatvrna zagrada, dakle biće to neku stanje zatvrna zagrada 1, i u principu to ćemo obraditi na sledećem slajdu. Takođe, ako iz ovog stanja zariz 2, prepozna se, dakle parset prepozna i u loznoj sequenci, biće, da će se prielazu u novo stanje koje neko stanje i 2, a dakle transicije naravno po tom terminalu i samo ovo tačka parsiranja se pomera nakon i. E sad ćemo naravno obraditi svala la trej stanja. Dakle, zatvrno zagradu 1, tačka parsiranja se samo pomera i za zatvrne zagrade. Znak za kraj sequence prakcično uveki stijel, tako, tačka parsiranja se pomera i nakon ovog znaka za kraj sequence za ono uvlaznu dodatnu konfiguraciju koji smo napravili. I 2, tako, tačka parsiranja se pomera i nakon ovog i u odgovarejićem stanju. I tim smo prosto kompletirali ovaj naš automat. Nakon šta smo kompletirali automat, ostajem da formiram u potisnu tabelu i kontrolne tabele za LR0 i SLRi. Ponovog potisnu tabelu ćemo isključivo formirati na osnovu automata koji smo napravili. Ja ću ponova sada to uraditi na osnovu automata koji imamo ovde, ka pošto je on prikazan jedinstveno, takran na jednom ovo mestu pa da se ne bih vraćala kroz ove slajdove. U principu šta imamo ovd? Ponovog eltakon. Ovde su nam sa leve strane sva stanja koje imamo, a gore imamo tako sve prelase koje mogu biti terminali ili neterminali u smislu potisne tabele. Tako krenemo redom, ponavljem sve jednoje koji mi radosledam navedete pravčično ova stanja. Ovdje već nije tako o nam predhodom zadat koje bilo možda elegan ten je bolje u smislu manje vrlo otno ćete zaboraviti neko stanje. Tako ako krenete da ih numerišete, pa prosto i redo sledom njihovih indexa ih navodite. Sva sve om kovo god uzeli, bitno da su tu sva. Te iz ovo ginicijlnog stanja znači ako se prepozna neterminal s prelazise u s02, ako se prepozna i prelazise u i3, a ako se prepozna otvrna zagrada prelazise u otvrenu zagradu 1. Te ćemo tako poponiti. Iz s02, dakle dođe znak za kraj sekvence idemo u znak za kraj sekvence 0,
 Dođe zarez idemo u zarez 2. Iz i3. I3 je da kvetakoprasiranje na kraju, tako da tu nemoš ita. Otvrna zagrada 1. Evo nas ovde. Znači, dođe i, prelazimo u stanje i3. Dođe s prelazimo u stanje s1,2. I dođe otvrna zagrada, ostajemo u tom istom stanju. S1,2. Dođe otvrna zagrada, prelazimo u stanje, zatvrna zagrada 1. A ako dođe zarez, prelazimo u stanje zarez 2. Zatvrna zagrada 1. Tako da tu ništa. Zarez 2. Tako da dođe i, prelazimo u stanje i2. Znači, zakraj sekvence nula. Tu će tako da biti na kraju pa ništa. Ašpo se tiče i2, tako da nevamo nikakve prelaze u samoj tabeli. I ti smo mi kompletirali našo potisnu tabel. Sledaće na redu su nam kontrolne tabele. Prvo za LR0. Ponovom je tako, ovde nam se nalaze isključivo naša stanja. Z druge strane akcije se uvek definiše jedinsveno nivou stanja. Tako da imamo samo po 1 ulaz. Ponovogledamo naš automat kako izgledam. Možemo da pogledamo potisnu tabelu. Možemo da pogledamo ovdje ovdje automac ve jednoje. U principu za startno inicijelno stanje. O tako, tačke presirenje nam je negde unutar samih konfiguracije. Tezbog toga se radi shift. U stanju s02, tačke presirenje su za sve konfiguracije. Takođe, unutar samih smena se radi shift. U i3, tačka presirenja je na samom kraju pa će se raditi reduce. I to potračuje smeni. Otvorna zagrada 1, tačke presirenja su negde unutar samih konfiguracija pa će se raditi shift. Stanje s02, tačke presirenja su unutar pa će se raditi takođe shift. Zatvorna zagrada 1, tačke presirenje na kraju, dakle i da je reduce po prvoj smeni. Zare s02, tačke presirenja ispred terminala i dakle bi će shift. Znak za kraj se kvence 0, tačke presirenje na kraju. Tu će biti reduce null toj smeni, kao što znate, to je accept. I i 2, tačka presirenja na kraju, dakle i reduce po drugoj smeni. I ti me smo zapravo formirali kontrolno tabelu za L0-automat. Sledaća stavka, kontrolno tabela za SLR-jet. Dakle, kao što smo rekli, razlikujse po tonu što kod SLR-jetem, zapravo formiramo akciju na osnovu kombinacije trenutno stanje i simbol koji se nalazi na ulasu. Dakle, posmatramo ta jedan konkretne simbol koji se nalazi na ulasu. I sada ponovol možemo da konsultujemo. Ovo možemo da konsultujemo potisnu tabelu sve i jedno. U princip za inicijelno stanje, već smo videli kada radimo shift-tjel. Tako, shift ćemo raditi za sve ove konkretne simbole, od kojih postoje prelazio u automatu. Dakle, to su otvrna zagrada i terminal i. Što se tiče stanja S02, također radimo shift, u koliko dođe zariz ili znaga za kraj sekvence. Tu smo uradili, dobro, gde se ne vidi, pošlo je lepše, ali tu je shift e i onda dolazimo do E3. E3, tu imamo čigledno reduce pošto se tačka nalazi na kraju, međutim, i to reduce potračuje smenim, međutim, postoje se pitanje, za koje simbole radimo reduce. Dakle, reduce ovdje ne definiša na nivou pojedinočnog stanja, već na nivou svih pojedinočnih simbola u kombinaciji sa tim stanja. Tako da, ovo što nama beješe ovdje treba je zapravo da odredimo follow scoop za odgovarajući neterminal, to će biti neterminal koji se nalazi sa leve strane, te nam treba follow scoop od S. Da bi smo drezili follow scoop od S, pogledat ćemo još jednom ovo našu gramatiku i hajde da vidimo šta se to nalazi sve i za S. Pogledamo sve s mene i ono što je dS sa desne strane. Dakle, iz nullsta s mene i za S nam je znak za kraj sekvence, te ćemo ga uvrstiti u follow scoop. I z prve s mene i za S nam dolazi za tvrna zagrada, te ćemo uvrstiti u follow scoop. I iz druge s mene dolazi nam zaraz, te ćemo i to uvrstiti u follow scoop. Trećo i s mene ovdje se ne vidja, a o trećo s mene je bila samo ite, nemamo neterminal S, pog toga je, dakle, smena taj način formirali naš scoop. Mi praktično sa ovim gledajom šta je i za nekog neterminala, stajemo prvi put kad znamo da je nešto neponištivo, kad znamo da to ne može da se zaobiđe. Jer mi zapravo follow scoopom definišemo na globalnom nivou u same gramatici za bilo kojoj sekvencu, koja će biti prihvaćena ovoj gramatikom, šta može biti i za nečega što je buhvaćeno ovim ove s. Pošto ništo do ovog nije poništivo, ne može biti preskočeno, ali tako, onda će se naš scoop sastojeti uprvo od ovih simbola i to je ono što možemo i videti ovte. A vidimo, dakle, potreću i s meni za uprvo ovdje 3 simbola. Dobro, otvrna zagrada 1, šeć radimo po i i radimo po otvrnoj zagradi. Stanje s1,2, dakle, radimo šift za zaraz i za zatvrnoj zagradu. Zatim, zatvrna zagrada 1 je ovdje ćemo raditi i reduce ili tako po prvoj smeni za sve simbole koji su u follow scoopu od s, to smo već videli koje su to 3 simbole, tako da radimo reduce po prvoj smeni za njiho. Zaraz 2, radimo shift ili tako i to samo za i. Znak za kraj sekvence, dakle, radimo accept. Accept bi smo ovdje radili, dakle, za follow od s prim, ma da može se i globalno definisati. I za i2, stanje i2, dakle, radimo reduce, reduce po drugoj smeni, za simbole koje pripode u follow scoopu, neterminal s i popunjavamo to na ovakav nače. Tim smo odredili i kontrno tabelu za SLR1 parser. Dobro, posljednja stavku u okver ovog zadatka je bila, hajde da vidimo kako ćemo neku konkretnu sekvencu da prepoznamo upravo, dakle, korišćenjem ovih automata. Dobro, uzet ćemo je tako kontrno tabelu i potisnu tabelu kako bi smo radili ovo parsiranje. U ovom konkretnom slučaju manje više nam je sve i jedno. Dali ćemo uzeti LR0 i SLR1 zbog toga što ni u jednom i u drugom slučaju nismo imali neke konflikte. Da nam se recimo, da esilo kod LR0 da imamo konflik, dakle, da eseleri 1 da prosto u taj konflikt ne postoji, tada bi smo naravno više želili i verovatno dokoristimo ovaj automat, odnosno parser kod koga ne evamo konflikt pa bi smo sigurno koristili njegovu kontrnu tabelu u samom rešenju. Ovako, dakle, nije mnogo bitno. Vide ćemo sada, dakle, kako ćemo koristiti ove informacije da bi smo isparcirali konkretnu sekvencu. Inače, dakle, moguće je da u koliko postoji konflikt u LR0, on ne postoji kod SLR1, obrnuto nije moguće, a moguće je naravno da konflikt postoji u oba takva parsera. Ok. Na početku, slično o nim početnim inicijalnim zadahcima koje smo radili, samo malo doopunjeno, imamo praznog steka i imamo ovu sekvencu na ulezu i sad gledamo koju akciju sprovodimo. Da bi smo znali koju akciju sprovodimo, baš kao što sam rekla, posmatramo potisnu i kontrnu tabelu. Sada kad pogledamo potisnu tabelu, dakle, na osnovu čega određujemo akciju. Evo nam ga naš trenutno stanje, jednostno simbol na steku, to je simbol na ulazu, nam se nalazi otvorena zagrada. Samim tim vidimo, da ovde na osnovu potisnu tabela vidimo tako da smo imali prelaz u neko stanje, ako posmatramo kontrnu tabelu, kao što reku na nivou LR0 parsera koji takođe možemo posmatrati, vidimo da u bilom sluču i radimo shift, međutim pošto verovatno nam je praktičnije da gledamo SLR1 i ruvek žalimo da koristimo bolji parsera, onda kada pogledamo, dakle, konkretnu kombinaciju simbola na steku i simbola na ulazu, vidimo da se radi operacije shift, dakle operacije shift će biti naša akcija, to znači da ćemo uzeti konkretan simbol i smestiti ga na steke. Sada kada želimo da vidimo koji mi to simbol smestimo na stek, pa za to upravo koristimo ovu potisnu tabelu, gde je upravo taj simbol otvorena zagrada 1, tako da mi na stek smestimo otvornu zagradu 1, a sa ulaza smo skonili ovaj konkretan simbol. E, u principu, ovaj korok smo mi nekako već imali određeno u onom zadatku gde ne bi bio dat deografa, pa je za nas bilo već uređeno šta ćemo mi zapravo smestiti na stek, a ovde sami koristimo dafne informacije koje smo formirali u predhodnom delu zadatka i sada prostu samu koristimo te informacije i
 i parsiramo ovu našu sekneci. Sledajosništa radimo posmatramo na vrhu nam se nalazi otvrna zagrada 1. Na ulazu imamo otvrnu zagradu koju akciju sprovadimo. Ponovat ćemo pogledati ove naš parcer. Otvrna zagrada 1, otvrna zagrada na ulazu, radimo operaciju shift. Nakon što znamo da radimo operaciju shift, pogledamo našu potisnu tabelu i vidimo koji simbol smeštamo na vrh steka. Vidimo da na vrh steka smeštamo otvrnu zagradu 1. Ponovu ovde ne imamo otvrnu zagradu više na samom ulazu. Sledajosništa radimo gledamo ako je na vrhu steka otvrna zagrada 1 a i na mija na ulazu šta se dešava. Ponovu konsultu u kontrnu tabelu. Naravno ako konsultujete kontrnu tabelu L0 ni ne treba on taj simbol na ulazu. Ulazu sve što biste reklji. Dolaze mi otvrna zagrada 1 šta godil tako, ja radimo shift. Te ću sa te strane. Ovde prosto raditi akciju shift a onda ćemo naravno konsultovati potisnu tabelu da bi smo videli kada je prosto otvrna zagrada 1 na vrhu steka a dođe i. Dakle šta smeštamo na vrh steka, pa to je simbol i 3. Ja vam sve jedno savitam da ipak koristite one precizni što SLR1 jer u slučaju prosto da imate takve konflikte. Bolje je naravno koristiti parser pojprasto prijavljuje manje konflikata. Pošto suštenski, naravno postoje konflikti koji su realni a postoje konflikti koji su samo tapravljeni tako zbog toga što parser prosto nije o stanju da razlikuje pojedine smene odnosno situacije. Već vidite dakle situacije u kojima bi LR0 prosto prijemljiva o konflikte čak i tamo da ih nema, a SLR1 recimo ne. Ili naravno kada budemo na sledećem času radili LR1 koji je još dakle na višem nivou i još manje prijavljuje stih nekih lažni konflikata, odnosno bolje u stanju da ih razrešlja. Dop. Saču sad na mjero vrhu steka i 3 simbol, a na ulezu nam se pojavljuje zaes, pogledamo našu kontru nutabelu, i kontru nutabela kaže dobro ako je i3 na ulezu a zarezi se pojavljuje. RADIMO RIDIUS po 3 smeni. RADIMO RIDIUS po 3 smeni dakle to će biti naša konkretna akcija. Što znači šta? Kada pogledamo kako izgleda naša grammatika RIDIUS po 3 smeni znači kaže skinemo sa steka ovo ovde i i nakon što smuradili pop tog i 3 smeni tako što smuradili pop tog i trebao da pušujemo ovo s na steka koje ćemo s da pušujemo na steka pa pogledajemo šta je to nama ostalo na našem steku. Dakle, onog momenta kada skinemo ovo i 3 sa steka, na vrhu steka nam ostane otvor na zagrada 1, dakle to vidimo, i treba tu da smestimo ovo neko s, međutim koje s ćemo da smestimo, pa to ćemo da znamo, tako što ćemo da pogledamo našu potisnu tabelu. I vidićemo da će to biti s1,2 Evo kakle potislimo na stek s1,2 Pa nastavljamo dalje kao i do sad s1,2 na ulazu nam je zarez pogledamo našu kontrnu tabelu kontrnu tabela kaže ako dođe zarez, radimo šiv Dakle smestimo ove zarez na stek gledamo el tako i potisnu tabelu kako bi smo videli koji zarestavljamo na stek, evo ga ovde dakle zarestva, tako da to smestimo na stek dođe nam nakon toga i sad ću pogledati ovo ovde kontrnu tabelu zato što je bliže radimo šift pardon imamo zarestva radimo šift sve jedno, dobro Dakle smestimo na stek ovo ovde i, samo je pitanje koje i smestimo na stek, dakle zarestva, ako dođe i zaremo i12 evo ga zatim imamo zatvrnu zagradu ako je i2 u pitanju dođe zatvrna zagrada na ulas akcija koji sprovedimo je pogledamo tako i2 stanje zatvrna zagrada reduce po drugoj smeni šta je nam druga smena pogledamo druga smena takle, pretstavi, neterminal s, zarec i i tako da treba 3 stvari reskinamo sa steka i da pušujemo na steka. Ako skidamo 3 stvari sa steka, dakle skinućemo neterminal s1,2, zarec i i2 sve to zamenimo sa 1s što znači, treba da vidimo ako nam nevrhu ostane otvrna zagrada i1 nakon skidanja ove 3 stvari sa steka a sledaće, što nam dolazi na ulazu tako neterminal s, koje će to zapravo sbiti, pa vidimo da će to biti s1,2 ok naravno što treba primetiti je da kada radimo reduce mi zapravo ne potrušimo ni jedan konkretan simbol sa ulaza prosto, taj simbol koristimo recimo kod slr1 da bih smo samo videli šta je sledaće na ulazu kako bih smo mogli dobrodimo reduce za manji skup simbola nego što je to slučaj kod lernula međutim, parser ne potruši dakle taj simbol sato što suštinski to sradi samo operaciji i shift to znači, proneđenje simbol idemo dalje sa parsiranjem takle, nismo prošli poritok simbola nego smo ga samo videli tamo na ulazu i znamo da treba dobrodimo operaciju reduce ok ako imamo s1,2 na ulazu i upardo na nasteku i imamo zatvornu zagradu dakle, zatvorna zagrada dešava nam se shift i na stek smeštamo zatvornu zagradu 1 i ako nam je zatvorna zagrada na ulazu koju u akciju sprovodimo pa radimo operaciju reduce po prvoj smenji e sada šta je operacija reduce po prvoj smenji odnosno šta je prva smena dakle, prva smena ob upvata otvornu zagradu s i zatvornu zagradu te ćemo mi ponovod da uznamo i da skinemo ove 3 stvari sa steka tako da ćemo raditi pop, pop, pop i pushova ćemo jedno s na stek koje s pa ono s koje dolazi kad je na vrhu steka ova otvrna zagrada 1 već mo nekoliko puta imali tu sviduaciju tako da će to biti s1,2 ne potrošimo ni jedan simbol ovaj ovde sa ulaza prostu zato što je što je ovo bilo operacija reduce dobra imamo sad zatvornu zagradu trenutno stanje na steku je s1,2 tu ćemo raditi shift i smeštamo na stek otvornu zagradu 1 nakon toga imamo zaraz ako nam je na vrhu steka zatvornu zagrada 1 pogledamo našu kontrolnu tabelu evo ga zaraz, radimo reduce po prvoj smene što znači skinemo otvornu zagradu s i zatvornu zagradu dakle 3 pute radimo pop i sada nam trenutno na vrhu steka je ovaj zapravo simbol naš praznog steka što znači nalazimo sa onom staknom stanju i ovo gradu i oš treba da vidimo dakle koje ćemo mi smestimo na steka to ćemo da pogledamo na osnovu naše potisne tabele što znači kad smo u inicijom stanju a dođe neko s to će zapravo biti stanje s02 tako da ćemo njega smesti na ovaj ovdje stek nakon toga imamo zaraz shift je tako s02 shift, znači smestimo na stek zaraz 2 nakon toga imamo i ponovol tako pogledamo našu kontrunu tabelu, znači radimo shift i sada šta smestamo pa smestamo i 2 i nakon toga pošto imamo znači za kraj sekvence radimo reduce po drugoj smeni sada reduce po drugoj smeni dakle podrozumeva tako zamenu ovaj ovdje smene što znači skinućemo 3 stvari so vrha ponovol ćemo imati prazem stek i to znači da treba da zamenimo da pušvamo se jednim neterminalom est što će biti ovaj naš neterminal s02 što smo videli da njega stavljamo kada nam je pretkudno na steku simbola za prazem stek i praktično time ćemo prihvatiti na kraju našu sekvencu i ja to videli smo, dakle pristno u ovog iskonstrujsenog parsera prosto u korišćenjem potisne i kontrolne tabele mi možemo da isparciramo neko konkretnu sekvencu da prikažemo kako dakle izgledalo to parsiranje ok, u okvaru danošnjeg časa čisto da bi smo utvrdili gradivo proćemo kroz još jedan primirk ako bi smo sljedeći put mogli da nastavimo sa lr1 parserom da prosto prokomentarišemo u čemu je razleka između tih parsera koristimo uvesti i neke primere da ćemo videti dakle kada koji prijavljuje konflikte i u principu onda ćemo time prosto objediniti bottom-up parsiranja dobro još jedan naš primirk, čisto da treba da konstruišemo lr1, lr1 parser za sljedeću grammatiku da prikažemo izgled teka ulaza i akcija pri procesiranju nekog ulaza lr3,5,6,d ok, dakle ponamo kako ćemo da formiramo inicijom u tabelu odnosno u tomat krenućemo dove grammatike i ponamo ćemo je proširiti nulltom smenom, dakle nikada nemojte da zaboravite treba
 da proširite ovom nulltom smenom, jer nju koristimo da bi smo značili koje sekvence prihvatamo, ili tako. Ponovno, da kli formiramo naše inicijalno stanje, stanje pravzmog steka, tako što ćemo da uključimo tu inicijalnu konfiguraciju, pošto sona nalazi ispred s, to znači da ćemo ubaciti ovde sve konfiguracije koje su početne ili tako za smene koje je odgovarejne na terminalu s, što je u ovom slučaju samo prva smena. I uvajt možemo na jedinstva načinja dodamo ovaj ovdje del oko procesiranja ove nullte konfiguracije, dakle tačko prsiranja se pomera nakon s, to će nam biti stanje s0 i nakon toga tačko prsiranja se pomera izza znaka za kraj sekvence, to će nam biti stanje znak za kraj sekvence 0, tu je naša tačko prsiranja nakraj. Počat će iz stanja inicijalnog steka. Ako parser prepozna malo a, tačko prsiranja se pomera izza njega i tu imamo dakle sledeću konfiguraciju koja nas vodi u stanje a1, 50 tačko prsiranja nalazi ispred neterminala x, samim tim je potrebno da uvrstimo sve smene koje je odgovareju ili tako neterminal x gdje je tačko prsiranja na početku. E sada iz ovog a1, dakle imamo mogućnost da parser prepozna jedinicu na ulezu, četvorku je 1 na ulezu ili 7 na ulezu naravno bilo koja druga kombinacija bi bila neadekvatna, tako da racimo ako bi su ovom slučaju poznalo racimo 2, pojavilo 2, to bi bio classican rejectil, tako. Dobro, ako nam dođe 1 na ulezu, prelazi su ovo stanje 1, 2. Iz stanje 1, 2, dakle tačko prsiranja tu je iz ove jedinice, a ispred ove dvojke, tu je praktično tačko prsiranje ispred neterminalate, zbog toga je to jedina konfiguracija ovog stanja, su znači ako dođe dvojka, tačko prsiranje će se pomeriti za te dvojke i nakon toga očekujemo trojku i tu smo završili se prepoznavanjem ove ovde sve. Ovdje su samo naznačene na ta neka stanja ovim kružićima, kao da će biti kasnije napisana, dakle, o potpunosti i ako poštu smo sada već malo bolje upoznati sa ovim parserima, da to neće biti na ovom konkretnom slajde durećeno, ali ću pokazati u sami materialima, međutim, kao što rekok, možete se ovako tako proprovo naglasiti, a onda kasnije referencirati u provota stanji i prikazati ih opširljima. Ako smo prepoznali četvorku, prevacujemo se u stanje 4 i 3, tu se tačko prsiranja pomerila nakon četvorka i nakon toga može doći petica, nakon toga šestica, dakle, prelazimo u ta stanja. Takođe, i za jedan moglje da dođe iz sedmica, pa bi smo se prevacili u stanje 4, a tačka prsiranja bi se pomerila nakon t sedmica. Dodatno, postovo je mogućnost da, i to će se i desiti, ali tako, nakon što se bilo šta od ovog ovdje prepozna, da li po drugoj, treće ili četvrtoj smeni, to će zapravo biti potisno to i zamjenjeno sa neterminalom x, te zbog toga, ukoliko se, dakle, iz ovog stanja e a1 parser prepozna nešto što je bukotio tim neterminalom x, prelaziti u stanje x1, gde se tačka prsiranja pomera nakon toga neterminala xa ispred v, i nadalje, naravno, u stanje v1, gde tačka prsiranja ide do kraja. I u principu, kad bi smo razradili još ova stanja, to bi izgledalo nekako ovako, dakle, to bi bio naš kompletan automat. Što se tiče potisne tabele, potisnu tabelu smo do sad vađda naučili, dakle, ona ide automatskim preslekavanjem iz ovog automata potisnu tabelu, tamo gde postoji prelaz, ponovanaglašavam, dakle treba razlikovati, dakle, od potisne tabele kolone su nam svi terminali plus svi neterminali se dašavaju na prelazima. Te ćemo na osnovu toga formirati ovu potisnu tabelu, tako što prosto, ako je tamo postoja ov neki prelaz, mi ćemo ovde samo označiti u koje konkretno stanje se realizuje taj skok. I što se tiče kontrolne tabele, dakle, potrebno je doodredimo akcije, tako da ćemo reći za naše inicijalno stanje. Radi su operacije shift ili tako, zato što su nam tabčko prsirenja unutar, dakle, ovih konfiguracija. Za stanje a1 radi se takođe operacije shift, za stanje s0 takođe operacije shift, za stanje kraj sekvenci 0 operacije accept. Za stanje x1 operacije shift u stanju b1 biće operacije reduce i to reduce po prvoj smeni, da, fnam je te da zaboravite da naznačite o koje se s meni radi. Za stanja 1, 2 i 2, 2 biće shift, doke koj 3, 2 reduce po drugoj smeni. 4, 3, 5, 3 će biti shift, 6, 3 reduce po treću smeni. 7, 4, 8, 4 će biti shift, doke će biti reduce po četvrtoj smeni. I u principu ti ime smo formirali kontrolnu tabelu za l0 autoat. Što se tiče kontrolne tabele za slr1, dakle biće nam potrebni polu skupovi od s i od x. Da nam beše gramatika? Ponovobismo podledali o takovu našu gramatiku, videli šta je iza s, pa iza s je samo ovaj pardon terminal za kraj sekvence, što znači ti ime određeni ja smo polu skup. Iza x takođe isključi vb koje je uvek neponištivo izbog toga, dakle polu skup se sastoji samo od simbola b. Tako da budemo radili reduce za neki od ovih neterminala, mi ćemo zapravo imati iza sljučevo po 1 simbol. Dobro, i sada dakle za sve ovekut kojih je postojao prelas u samoj potisnoj tabeli, a za konkretan simbol i uš jednom ću ponoviti to je razljake zmeđu kontrolne tabele i potisne i u tome što ovim kolonami iza sljučevo specipicirate simbole koji se pojavljuju na ulazu, a ne neterminale. Dakle iz startmak stanja ako dođe malo a radimo shift, to vidimo ovdje, tako, iz s ako dođe znak za kraj sekvence radimo shift u znak za kraj sekvence nula radimo shift. Stanje a1 shift radimo za 1,4,7. Za stanje x1 shift radimo u sluči danom se na ulazu pojavi malo b. U stanju 1,2 shift radimo ako na mi na ulazu 2, al tako, u stanju 2 shift radimo ako na mi na ulazu 3, a u stanju 3,2 ćemo raditi reduce i sada ovo se odnusi na neterminal x, tako da za follow skup od x stoje b, mi radimo za prvo reduce po drugoj smeni. U stanjima 4,3 i 5,3 bešo radimo shift za simbole 5, odnosno 6, a u stanju 6,3 radimo reduce po 3 smeni, takođe za simbole koji pripadaju follow skupu od x stoje samo b. Ekuvalentno tome i u stanjima 7,8 i 9,4. I u principu to bi bilo to što se tiče ovih konkretnih primer. Dakle, prodažbali smo par sere SLR 0, SLR 1, pardon i L 0. Ovdje dodatno u ovom zadatku je bilo još procesiranje i konkretne sekvence na steku, al u principu postupak je potpno identičan kao što smo malo preradi. Doprođemo čisto kroz par simbola, dakle ako je prazen stek na ulazu nam se pojevi a, ponobu bi smo konsultovali ove naše tabele i rekli bi smo prazen stek na ulazu nam se pojevi a, radimo šit a na stek smestimo malo a1. Nakon dogaj na ulaznam dođe četiri, ponobu pogledamo šta radimo, kada smo u stanju a1 a na ulaznam dođe malo četiri, dakle radimo štift. Šta smestimo od simbola i al tako pa biš nam je došao četiri, dakle smestit ćemo četiri 3. Nakon dogaj nam dođe 5, ponobu radimo štift, šta smestimo, pogledamo iz ove naše tabele, kad smo u stanju četiri 3 dođe nam 5, smestimo 5, 3 na stek i tako dalje u principu na identičan način, kao što smo malo preradi sa sekvencom. Ponobu nam je cilg da na kraju imamo s0 i nakon toga znak za kraj sekvence i upravo to ćemo i prihvatiti, to nam je naše stanje, stanje prihvatanja. U principu bilo u koja je od drugiho drugih opcija, naravno nepopunjenih podrozumeva reject, ali to nije ono što je slučaj sa ovim našim konkretnim sekvencama, pošto ovde dakle je cilg da vidimo kako je ispunjenu, kako je ispunjenu samo persirenu, odnosno kako je izgledeno uspešno persirenu
 na primjeru ovih sekvencija. Dakle, u okviru današnjih lekcija i uš jednom videli smo kako funkcioniše bottom-up pasiranje, na primjeru L r mula i S L r i 1 parsera, videli smo koja je njihova razlika, dakle, u tome da S L r i 1 posmatra i konkretan simbol prvi koji se pojavio na ulozo, savim ti mi ustanju da je li miniše prijev u nekih nepotrebnih konflikata, Sheets, Reduce ili Reduce, Reduce. U konkretnim primjerima mi nismo imali tako komplek, ali vidat ćemo ovaj stredači put, kada budemo radili i treći parser L r i 1, koji, dakle, još dodatno pokušava deli miniše neke situacije u kojima se nepotrebno prijavljuju ti konflikti i to je na kraju krajava i parser koji ćemo mi koristiti u izredi našeg projekta. Prošle nedanje smo videli L r nula i S L r i 1 parser, a ove nedanje krećemo sa L r i 1 parserima i dakle, hoćemo da vidimo na koji način oni funkcionišu, kako se razlikuju od predhodne dve vrste, izbog čega su nam na kraju opšte i potrebnih. I sad naravno ovdje ima nekoliko zadataka u okviru koji se obrađuje tema L r i 1 parsera, takle, ili u vidu zadatka gde je prosto potrebno samo konstruisati takavi 1 parser, ili, naprim. konstruisati uporediti sa nekim od L r nula S L r i 1, ili, naravno, svatri uporediti, naprim. u neke gramatike. Dobro, prejmo što pređemo na konkretan zadatak, gde za početak hoćemo da vidimo dakle kako funkcionišu i kako se konstruisio ovaj parser, samo bih se predhodno dovezala na ono što sam već pomenula prošli put, a to je da na usnovu samog naziva već mogu da se schvata neke stvari. Tako da praktično u savom nazivu nalazi s ovaj jedna brojka, tako da vidite, dakle kod L r nula parsera to je nula, kod S L r i 1 i L r i 1, dakle to su ove jedinice. Ta jedinice podrazumeve da prosto priodreživanju one akcije, dakle koje se sprovodi u samom parsero, što mi možemo vidjeti u okviru kontrolne tabele, se dakle osim stanja steka posmatra jedan trenutni simbol koji je prvi u ulaznoj sekvencii u tom trenutku. Ok, kada kredjemo sad s ovim zadatkom, dakle inače, ponovu kao i kod ona prezihodna dva parsera, upravo što treba da uradimo je da formiramo automat samog parsena, nakon toga da formiramo potisnu i kontrolnu tabelo. E sad, prinjegu što tu uradimo, dakle ovaj sam zadatak zahteva da mi prikažemo, kako se određuje nešto s ovu predikcioni simboli automata u početnom stanju, tako da ćemo zapravo ovom jednom uvadom zadatku vidati šta uopšte predstave koncept predikcionog simbola i vidat ćemo kako se ti simboli odosno skupovi i određan informiraju za ovo inicijelno stanje. Tako da nećemo raditi kompletno konstrukciju parsera u ovom prvom zadatku, ali ćemo naravno nešto kasnije proći kroz se o zadata kvezana za uvrstuparsera. Dobro, kada imamo dakle datu gramatiku, znate proširimo prvo nultom smenom, što znači uvedamo s prim kao neku početnoj o tako startnjine terminale, koji nam kaže da nakon neke sequence koja je prepoznata ovom našom gramatikom pod neterminalom s, na kraju, u koliko je tu kraj seqence, mi ćemo naravno to prikvaditi, odnosno zbog toga ćemo i uneti ovakvu jednu smenu. Tako da kada krenemo od našeg praznog stanja, mi naravno krećemo upravo od te nulte smene, koji smo sad da uvili i tačku parsiranja stavljamo na početak. I generalno kada konstruišemo samo u tomet za LL1 parser, videli ste već da je situacija kao ko deseler 1 i LL0, dakle, taj prvi korak je potpuno identično. Tako da ćemo u ovom stanju, ili tako, uvesti smene, u kojoj je odgovaraju ovom neterminalu ispred koga se nalazi tačka. Tako da, kao što vidimo, poštivamo tačku ispred s, treba ubaziti zapravo sve smene, odnosno njihove početne konfiguracije, dakle, da će tačka parsiranja biti na početku praktično tog djela prepoznavanja, za neko s. I kada pogledam, odnosno pozitimo se kako izgleda naša gramatika, videte ćemo da praktično postoji samo jedna smena za taj neterminal s, tako da ćemo i uvesti upravo tu smeno, gde će tačka parsiranja, naravno, biti na početku same konfiguracije, tome smo već pričali prošli put. Dakle, tačka parsiranja, još jednom čisto kao pocetnik, predstavlja gde se trenutno nalazi parser sa procesiranjem ove naše smene. I onda praktično, odnosno naše sekvence partner. I onda, ako se tačka parsiranja nalazi ispred ovog neterminal s, taj neterminal s zapravo može biti prepoznat jedino ovako, tezbog toga tačka parsiranja se nalazi upravo ispred toga, što označava sam neterminal s. Zdaj pa što vidimo da je vada tačka parsiranja ponovu ispred nekog neterminala, što je u ovom slučaju neterminal a, mi ćemo ubaciti i sve one smene koje su upravo odnosno na neterminal a, odnosno u njihove početne konfiguracije, to će biti još samo jedna ovakva. Međutim, vidimo da se tačka parsiranja ponovu se nalazi ispred nekog neterminala i to je neterminal b, pa ćemo dodati isve one smene koje zapravo se odnosne na neterminal b. Ponovu to je samo jedna ova smena, tačka parsiranja je uvek na početku i istuto radimo iz neterminal c ispred koga se nalazi ova tačka. I sada po što smo poslednju smenu, odnosno konfiguraciju koji smo dodali, tačka se nalazi ispred terminal c, time smo zapravo završili dodavanje smena za ovo startno stanje. Pošto je trebalo u ovog uveru ovog zadatka, dakle, izključivo da vidimo šta su to, dakle, ajdeš jednom da se pozitimo, šta su to predikcioni simbolje, da vidimo kako se oni određuju i da to izključivo radimo na njivou ovog startnog stanja, mi dakle nećemo sada formirati ceo automot, odnosno parser, već ćemo izključivo pričati ovome na njivou pojedinočnih stanja. E sada, dakle, ovo je dobar trenuta, gde vidimo zbog čedanom, obšte treba elali jedan parser i zaštrom nisu dovolj na ona predhodna dva. I tu ćemo se malo pozititi prvo u čemu je prednost, gledano, dakle, iz perspektive, SLR1 parsera u odnosno na L0 parser. Vidili smo kod anih akcija koje sprovodimo. Akcija shift i reduce. Dakle, SLR0 parsera akcija sprovodimo na njivou pojedinočnog stanja, odnosno ne posmatramo koji je sledeći simbolu sekvenci. I to smo na neki nalčen popravili kod SLR1 parsera, time što smo rekli, dobro sada ćemo posmatrati kombinacije u trenutnog stanja i simbola koji se pojavljuju na ulasu. Međutim, da bi smo nekako odredili, al tako koji ćemo akciju sprovoditi, prilikom kombirovanja te dve stvare, rekli smo koji shift'a tu nevamo problem, zato što je jednostavno na osnovu ovoga automata koji formiramo, mi vidimo dakle kada za određeni terminal postoji transicije iz jednog stanja automata u neki drugi, znamo da tada radimo akciju shift. Međutim, za akciju reduce, smo rekli, dobro, umestu da radimo akciju reduce na njivou celog stanja, mi ćemo bešo odrediti follow scup za to stanje i reći, tu smo, za taj neterminal koji odgovara neku ismenu, pardon, i reći, dobro, dakle, za sve one simbole koji mogu slediti ovaj neki deo naše sekvence koji je prepozat, mi ćemo zapravo raditi reduce. Ali, dakle, ta akcija podrazumeva opet neki globalni skup na njivou celog grammatike, zato što prostu follow scup od nekog neterminala, odnosi se na bilo koji je smenu, gde se taj neterminal nalazi, nekde se daj se na strane, pa mi tražemo nešto što je izaj opako. Ali, dakle, u okviru celog grammatike, ne na njivou pojedinačne smene. Međutim, po što mi u ovom stanjima imamo neke pojedinačne smene, ono što nas vodi, kaj sledam, će bi koraku, a to suupravo LLR1 parsiri, je da ne posmetramo nekako globalno taj follow scup, međutim, da ga posmetramo dakle na njivou pojedinačne smene, odnosno produkcije, i da onda još više suzimo, ako je moguće, taj skup simbole kada zapravo radimo reduce. Sada, zašto nam je ovo značeno da to bude što manji skup simbole, pa zato što mi zapravo želimu da izbegnamo prijevljivanje nepotrebnih komplikata, što ćemo vidjeti kasnije kroz nekih par za dataka, te nam je cilj da mi radimo reduce samo za one simbole kada je stvarno očekiwano da će se ti simbole pojaviti negde u sekvenci na osnovu ove grammatike, a ne na osnovu dakle celog kupne grammatike, koju imamo već baš na tom konkretnom mestu, gde trenutno radimo parsiranje, o čemu imamo informaciju prosto na osnovu ove tačke parsiranje, dakle, taj trenutak u savom parsiranju nam je bit. Kada krenemo saca primirima pa će malo biti jasnije, pa ću ja još je ponoviti nešto od ovog. U glavnom dakle predikcioni simboli pripadaju skupovima. Za svaki u ovu smenu, odnosno svaku produkciju u okviru svakog stanja automata na osnovu koji ćemo poslo dređivati koja akcija se sprovadi. I sad kako se formiraju ti predikcioni skupoli? Krenemo od startnog stanja, to je o stanje praznog steka i krenemo od njegove prve produkcije. I to je, dakle, uvek ovde produkcije koje se odnosi na smenu, koje kreće od esprimil, tako i uopšte, dakle, nije bitno, naravno, kako se zove na terminala, ali podrozumeva da si kreće od nekog startnog neterminala i da na kraju očekujemo znak z...
 za kraj sekvence. Prediktioniskuup u ovom slučaju dakle je uvek prazan skup i kao što još jednom rekoh taj prediktioniskuup, podrozumeno pobljšanje u odnosu na follow skup, takođe predstavlja skup nekih simbola koji se naleze i za nekog dela sekvence, međute baš lokalno posmatrno a neglobalno na nivou cele grammatike. Dakle to bi je bilo u slučaju da kažemo šta je na ovom mescu i za nekog neterminala, a nešta je bilo gde u grammatici i za tog neterminala. Potom se razliklaj. Dobro, i sad u principu mi bismo rekli, i za ovog ovde esprimne postoji ništa, zbog toga je u principu ovaj selekcioniskuup praz. Kako formiramo sledeći selekcioniskuup? Za svaku narodnu smenu moramo da znamo zbog čega mi uopšte uvodimo tu smena. Sada sama ova druga produkcija je nastala zahvaljujući tome što je tačko parsiranja bila upravo ispred ovog neterminala s. Dakle, celo ova druga smena se uvodi zbog toga što se tačko parsiranja nalezi baš ispred ovog ovde s. E, kada to znamo, a hoćemo da kažemo šta se nalazi i za ove ovde smena, odnosno doodredimo foloskup, ali ne foloskup za bilo koje es, za es u celo ove naše gramatici. Već eksplicitno da kažemo šta je baš i za ove naše ovde smena, što znači šta se može pronacit u našoj sekvenci nakon što se isparsira upravo ove ovde de. Pa mi onda kažemo, odakle je došlo ovo es, došlo je iz ove ovde prve produkcije, tako da ono što je i za je upravo ono što se nalazi i za tog neterminala, či je ove produkcija što predstav. Za nas ovde to je ove znak za kraj sekvenca, te ćemo zbog toga reći da on pripada se lekcionom skupu ove naše druke produkcije i pošto se tu uvek mora naći znak za kraj sekvence, onda smo time formirali naš selekcioni skup. Što zadiča sledeće smena, to je ove ovde smena koje odgovara neterminalu a. Ponevogledamo šta se nalazi za toga, dakle šta bio follow, ali ne oda bilo gde u gramatici, nego baš za ovo ovde a. I onda pogledamo odakle je došlo to, a i za što smo mi je uključili ovo smenu u naše inicijovom stanji, vidimo da je razlog za to, to što su ova tačka persiranja našla uprvo baš iz pred ovog ovde neterminala a. I sad ono što se nalazi i za tog neterminala a je ovo ovde x. Tako da ćemo mi reći da se lekcionom skupu ovog ovde a pripada ove čime počinje za pravo ovde x. Sad kako da znamu čim je počinje to x, pogledat ćemo u naše gramatici sve smene koje se odnose na x. I sada u okviru ove gramatike možete konkretno vidjeti ovak u jednu produkciju, ali zapravo koja značava suštinski dve smene, što znači x predstavlja ili malo x, ali tako prepoznaje se u sekvenci kao malo x ili kao prazna smena. Samim ti, ukoliko se radi o malom x, odnosno da smo prepoznali negde u sekvenci malo x, onda je jasno da će to malo x i upravo i za ovog ovde a, i nićemo ga zbog toga uključiti u naš skup za ovu ovde smena. Međutim, problem nastaje kada razmislimo a šta ako ovo ovde x ne postoji? Šta je to što će se nalaziti i za ovog a, ako ovog x ne ima? Kada smo pričali prošli put u opštenom follow-skupovima, mi bismo reklen, a pa dobro, to je ono što sledi i za svega ovog, a da smo se nalazili, i tražili bi smo šta je to follow-des na osnovu celog grammatike. Međutim, ješi jednom pocećam, ovde ne gledamo globalno celog grammatiku, već pogledamo isključivo ovu ovde smenu zbog ko ga smo i došli do parsirenja ovog ovdega a te ćemo reći šta se nalazi i za ovog x ako njega ne ima? Odnosno ako je ono poništev što u ovom slučaju vidimo da može biti zato što može biti epsilo. A mi prosto moramo razraditi sve takve slučaje. I onda vidimo da je i za tog x upravo ovaj ovde predikcioni skup. Snamo da smo ga već formirali i znamo da smo tu takođu posmatrali lokalno baš za tu smenu, tako da ne moramo da brinemo, te ćemo u slučaju da je ovo x poništivo naslediti u ovaj predhodni predikcioni skup i prakđno ovo ovde će postati naš predikcioni skup za ovaj ovde ne terminal, a odnosno za ovo konkretnu smenu ovoj. Dobro, idemo daje. Sledaće naša smenam. Ponemo gledamo koji je to predikcioni skup za ovaj ovde ne terminal, b, znači posmatramo odakla nam je došlo ta smena i ono nam je došlo jer je tačka parsiranji iz ove predhodne smena uprubo bila ispred ne terminala b. Tako da šta će ulaziti u predikcioni skup za ovaj ne terminal b, odnosno baš za ovu ovde smenu, pa ono što se nalazi izajel. Tako b, a to je ovo naše y. E sad iz grammatike vidimo da ovo naše y može biti prepoznato kao malo y, te ćemo ga zbog toga uvrstiti u ovaj ovde sam skupil. Tako isto, kao i malo prešto smo radili za x. Međutim, u slučaju da je poništivo, a ovde vidimo takođe da jeste, zato što može biti ili malo y ili ništa. Dakle, cea ovej deo u našoj sekvencii može da ne postoji, onda ovo što se nalazi izatog b je zapravo ono nešto što se nalazi nakon ovo gipsilo. A mi smo već udredili šta se to nalazi nakon ovo gipsilo i to je upravo ovej skup koji se očinjavaju x i znak za kraj sekvence, izbog toga ćemo mi upravo reći da svijo oni čine naš selekcioni skup. Tim smo zapravo rekle da nakon dela sekvence koji je isparsiran po dovim ne terminalom b, znači c i c, dolazi nešto što može biti y, x ili znak za kraj sekvence. I mamu još samo jednu smenu odnosno produkciju okviru ovog stanja početnog i to je ova smena koja se odnosi na terminal c. I sada ponavok alovi malo predat, šta se nalazi baš izatog dela, šta se nalazi iz ovog c, pa nalazi se al tako ovo što je buhvaćeno ne terminalom c. E sad šta je u buhvaćeno ne terminalom c. Ponavokonsultujemo gramatiku i vidimo da to može biti ili malo c koje ćemo zbog toga uključiti al tako u taj predikacijunisku. Tako da može biti malo c prost u mestu ovog ne terminala c. Ili u koliko je to prazno ovde nema ništa, onda će se iz a ovog c nalaziti baš ono što je označeno da će biti i za cele ove ovde smene, a to su y, x ili znak za kraj sekvence. I time smo mi formirali predikacijune skupove svake ove smete. Dakle, kada formiramo LLR i 1 parcir to je potrebno durađimo na njivo svake produkcije u okviru svakog stanja. Vida ćemo kasnije čemu nam to služi, ali u principu ovim sužavamo u opštom slučim follow skupove, zato što ne radimo određivanje šta sledi nakon tog dela u sekvenci na globalnom njivo, kao na primjero da smo ovde sada reklji šta može biti i za b bilog deogramatici. To nas ne zanima, jer se mi ne nalazimo bilog deogramatici, mi se nalazimo baš u ovom ovde trenutku parciranje. Dakle, u ovom ovde i za ovog ovde b što je došlo u ovom ovde trenutku parciranje. Dakle, ne zanima na cisla, ako se kasnije nekad sto ponobu pojavi naši sekvenci, već šta ako se pojavi baš u ovom trenutku. Izbog toga mi je uprovo ovako lokalno određujemo koji su to simboliji koji će se sledaći javljati na samom ulazu. Dobro, to sam nas tražilo u okviru ovog zadatka. Dakle, za neku gramatiku da prikažemo, kako su određuju predikciju nisi boli i da vidimo uopšta šta su oni i kako LRLR1 funkcioniše. Sleći naš zadatak je ipak da iskonstrujšemo dakle, ceo LRLR1 parser i da prikažemo kontrolnu i potisnu tabelu, tako da ćemo nastaviti al tako sa ovim osmim zadatkom. Sada kada znamo al tako kako ćemo doformiramo predikciju na skupove u okviru jednog te istog stanja, još samo da vidimo kako ćemo doda proširimo na ostatak automata i na kraju naravno kako ćemo da uopšta koristimo informaciju koji smo doli. I sad ovo što prvo moramo u raci i to je da iskonstrujšemo automat, to bih znamo kako radimo, pa ćemo nešto brže preći u okviru ovog zadatka, pošto se radi podpuno identično kao zadacima koje smo videli do sadam. Te znači krećemo od našeg startnog stanja, vidimo kako izgleda grammatika, naravno proširimo tu grammatiku o nam nullutom smenom S-Prim koja će nam il tako oznacavati da se sekvence prihvataju na kraju koje počinju nekim startnim neterminalom oznacenim u grammatici. Izbog toga što je tačka parsiranja ispred tog neterminala S, mi ćemo u ovom inicijelom stanjem praznog steka ubaciti sve produkcije početne gde je tačka parsiranja na početku koji se odnose na neterminal S. I to smo ovde i u radir. Naravno, takođe znamo dva koraka pošto su oni uvek isti, a to znači ako dođe neterminal S, formiramo stanja S-nula i stanja prihvatanja sekvence i nulla. Kad kažem uvek isti, dakle nebaš uvek nekad su izličnju, zavisnosti je toga naravno, dali postoji još neka produkcija gde bi prosto postojeva transicija po neterminalu S, mislim da smo i s ličnom situaciju već videli u nekom od predhodnog zadataka, te naravno to obracite pašno. Dobro, dakle, taj da o znamo od uradima.
 Ostatno mi je ostalo da iz ovoj početnog stanja, da kažemo šta se deša ako dođe malo a, šta se deša ako dođe malo b, te ako dođe malo a premešlamo se u stanje a1, tačku prsiranja pomeramo nakon a, ako dođe malo b premešlamo se u stanje b2, tačku prsiranja pomeramo nakon b i još dodatno pošto se tačke prsiranja u oba ova stanja nalaze ispred neterminala x, mi ćemo uključiti dakle produkcije koje se odnose na neterminal x, da je će tačka prsiranja biti na početku. Nakon toga narano, iz oba ova stanja, u koliko se pojevi i na ulazu, prelazite se u stanji i3, da se tačka prsiranja pomera nakon i, i samim tim je tu na kraju, dok se iz stanja a1, ako se prepozna, da je o sekvence pod neterminalom x, prelazite u stanje x1, tačka prsiranja se pomera nakon tog x, a i stanja b2, ako se prepozna, da je o sekvence pod neterminalom x, premešta se tačka prsiranja nakon tog x i prelazite se u stanje x2. Dobro, obaj del je bio stanja. Stleći korak, nam je bitan zbog toga, što ćemo vidjeti jednu situaciju koju možemo nismo videli u sadacima do sadala, sasvim je regulirna, a to je što se dašamo kada recimo, i za stanje x1 treba da se desi ponevo transicije po malom a, i sada tačka prsiranja se pomera nakon malo ga i tu neamo naravno nikakav problem jasno, da kakvo funkcioniši samo prsiranje, međutim premanu mentlaturiku i smo da sada koristili za nazivanje samih stanja, ovaj bi smo zapravo nazvali stanje identično, kao što vidite nisu u pitanju identična stanja, dakle, ovo a1 nije identično ovom ovdje, a1 zbog toga moramo preimenovati ova dva stanja, tako da prosto bude jasno da se ne radi o identičnom stanju, zato što znate i sami da ćemo kasnije ova stanja koristiti u tabela. Tezbog toga ćemo prvo stanje označiti kao a1, a1, a2 stanje ćemo označiti kao a1, a2, ponovno, dakle, oba stanja nastaju pod transicijom, dakle, u slučaju simbola malo a, tako da zbog toga tako nazivamo stanja, takođe odgovaraju prvo i smeni, tezbog toga imaju prvi index 1, međutim, pošto se razlikuju međosobno, zato što pozicijono a nije isto u prvom i u drugom slučaju, onda ćemo napraviti diferenciaciju ovim drugim indexom i nazvati ih a1, a1 i a1, a2. Dakle, to je čisto da obratite pažno da je moguće, naravno, da se ovako našto desi. I isto ćemo uraditi i u slučaju ovog drugog dela, naravno, koji se odnosi na b, te ćemo imati stanja b2 i 1 i b2, 2, pošto ponovno, dakle, imamo ponavljanje ovog b na dva, neka, mesta. Uredno. Što se tiče same konstrukcije našega automata, ovdje smo u principu završili, dakle, nemojmo novan stanje koji bi ove trebalo ododati, tačke parsirinje su nam svude došlo do kraja, tako da, sato konstrukcijem smo završili. Međutim, sledeći naš korak, pošto su ovde radi o a1, a1 parseru, je naravno da ove automata dopunimo našim skupovima koje smo malo prenaucili, dakle, kako se formiraju, tako da ćemo lepo krenuti od našeg startnog stanja, stanja praznog steka i vidićemo kako ćemo zapravo formirati predikciona skupova na nivou celog automata. Pomimo da ple krenemo od prve produkcije i njoj dodalimo prazn predikcioni skupo, zato što prosto ne sladi ništa i za toga, kad smo završili našu sekvencu, to je to je otakvo. Što se tiče prve i druge smene, dakle, pogledamo otakvo, one su oba smene uključene zbog toga što je tačka parsirinje ispred neterminala s, pogledamo šta se nalazi nakon tog neterminala s, ali baš u tom trenutku parsiranja, vidimo da je u pitanju znak za kraj sekvence, tećemo zbog toga reći da naši predikcioni skupovi za ove dve smene zapravo obuhvjavaju isključivo znak za kraj sekvence. Ove deo smo i videli do sada kako funkcionešte, dakle kako formiramo predikciona skupova u samom jednom pojedinočnom stanju. Sada se posleda pitanje kako i zapravo selimo u sledeće stanja, kako bi smo zapravo u logiku mogli dispropagiramo na ceo naš autor. Nastavićemo sa stanjem a1,1 naprimer, i ako naravno potpune sve jednom ove redoslatve. Reći ćemo dakle ponovog kao i do sada, zbog čega je ove početna konfiguracija, zbog čega ona posloji u ovom stanji. Ona posloji zbog toga što je došlo ovo na ulas, dakle desilo se šifta akcija i tačko prsiranja se pomerila nakon ovog a. Tako da u principu ova cela ovde produkcije se upravo odnosi na baš ovu ovde produkciju, te sve zbog toga ona naslediti njen skup predikcioni i on će biti identičan. To ok. Nastavljemo dalje nakon toga formiranja predikcioni skupova za sve produkciju opiru istog stanja, tako da ćemo sada za ovo x isto reće, dakle, tako dačko prsiranje ispred bila neterminala x, zbog toga smo i dobili u prvo ovu smenu ovde, šta se nalazi nakon tog x, nalazi se ovo malo a, izbog toga će ovde predikcioni skup biti malo a. Dakle, ne treba nikako pomješati ove dve logike. Ukoliko se nakon ovoga ovde neterminala nalazi nešto što je neponištivo, što mora biti tako, što ne može nina koji način biti preskočeno. Onda će to biti isključimo baš taj simbol koji se tu nalazi. Sa druge strane, ako je to nešto što može biti ili to ili da bude uopšte poništevo da ne postoji, o tako, onda bi smo rekli, aha, uključujemo, dakle, i ono što se nalazi i za toga, a što već imamo ovokviru predikcioni skupa koji je postavljen za upravo tu smenu. Dobro, nastavljemo dalje nakon. Sledaće stanje, stanje x1, stanje x1 je o tako, svoju prvu produkciju dobija upravo na osnovu ovve ovde ovde, o tako, tako što se tačka presiranja pomirila nakon ovog neterminala x, tako da, kao i malo pre, ono će idejaliti njen predikcioni skup i on će samo biti preseljen ovde. Isto priča je manje više za stanje a1-2 koja je ponovog predstavlja identičnu produkciju, gdje je tačka presiranja se pomirila za još jednu poziciju, došlo je a na ulasu i ono je prepoznato o tako, tu je urađena akcija shift, tako da će predikcioni skup takođe biti identičan i za ovu ovde produkciju. Tima smo završili što se tiče ovoga ovde dela našega automata. Sad možemo da pogledam ovaj ovde drugi del, recimo b-del koji u principu vrlo liči na ovo što smo sada uprvo videli, a to znači posmatramo ponovog ovu prvu produkciju stanja b-2-1, kako smo je ovo što dobeli, pa dobeli smo je tako što se pojavilo b na ulazo, desila se shift akcija, parcer se premestio iz stanja praznog steka u stanje b-2-1, tačka presiranja se pomirila za jednu poziciju. Te će predikcioni skup biti identičan onome koji je tu postojo za odgovareću smenu. Pošto se tačka presiranja nalazi ovde ispred neterminala x, dakle uvrstili smo i ovu ovde produkciju u isto to stanje, te ćemo ponovog pogledati šta se nalazi baš nakon tog x koji je to simbol koji sledi, vidimo da je u pitanju malo b, odnosno dakle to je nešto što je neponištevo i kao tako čini prosto jedini element tog predikcionog skupa za odgovareću smenu x, koje se prepoznaje kao i d-tačka presiranja na početku. Što se diče stanja x-2, ovo smo stanje napravili i ovu prvu smenu njegovu i jedinu smo uvrstili zbog toga što se tačka presiranja pomirila preko ovog neterminala x, ali na osnovu i ste ove ovde smene, te pošto ponovog gledamo je o tako šta će biti i za tog nekog s koji je baš ovo ovde s, onda znamo da će to ponovog biti znak za kraj sekvence, pa ćemo prepisati njegov predikcioni skup. Dakle, još jednom da početim, ono što pokušavamo da otvorim ove predikcioni skupani i da uprvo kažemo šta će biti i za tog s koji je gleda, ali ne bilo koji je gleda, nego baš ovo govdje. I u principu, to može imati dakle dosta razlik je, da li primenjujemo logeku sa predikcionim skupani i folosku pojima, akurac jemo imamo više puta na terminale su samo i gramatici. Onda tako folosku bi nam brato i ovo što je za prvo gleda i ovo što je za neko gruog, ali tako dalje, a u ovom slučajima, kada je to jedinstvno ponavljenje, može biti identično, međutim, dakle, ono što je nama situacija kod ovi predikcioni skupove, da mi baš hoćemo da vidimo za to es, šta se nalazi i za njega i nezanimaju nas druge pozice varsiranja u samom parseru. I u stanju B22, ista situacija, pošto se ponovno radi o baš istom tom s, nasledićemo taj identičan predikcioni skup. Stanje I3. E sada, ono što je ovde interesantno koji stanje I3, što stanje I3 je formira tako što se desilo shift akciji i stanja A11, povo je ovde smeni, X koja je prepoznato kao EL, ako je došlo to i na ules, dakle, desila se operacije shift'i, napravljamo,
 napravilo se, odnosno formiralo se ovo stanje, odnosno parceri prešao u to stavanje, otakon. Tešno zbog toga, kao i do sada što smo radili, predikacijunij skup obuhvata ti upravo, dakle sve simbole koji su obuhvaćeni i upravo, pardon, ovim ovde skupam za to smenu na osnovu koje nastala i ova. Međutim, ono što razlikuje ovu situaciju do i u pretodnih koje smo imeli, da to nije jedini način da se dospe u ovaj trenutak parsiranja, veznili u to stanje automata moguće doći i iz ovog stanja B21, kada se pojde asim i na ulazu il. Tako i parsiranje se prosto nastavi po ovaj ovde produkcii. Zbog toga, predikacijunij skup, ovaj ovde startne smene, mora uključivati oba predikacijuna skupa i biti njihova unija, teće u mestu pojedinačnog A ili pojedinačnog B, biti unija obata predikacijuna skupa i biti zapravo AB. Naravno da postoješ neke smene ovde, dalje bi se nastavila logika, ponagu početna smene, koja ima sada ovaj kompozitni predikacijunij skup, sve na dalje na isti način. Dakle, ono što treba da posmetramo je kako smo formirali taj neki početni skup, na osnovu toga, kako smo zapravo i došli do tog stanja u okviru parsera, odnosno samim parsiranjem. Dopa, ostala su još dakle samo predikacijunij skupi u ovaj dva ovde stanja esnula i znak za kraj sekvence, oni su ovde najtrivialni, u principu pošto se ponovno radi, pošto se ponovno odnosi na ovu ovde početnu produkciju, a njen predikacijunij skup je prazan, onda će i ovo preostala dva biti ponovno prazni skupovi i na taj način smo formirali predikacijunje skupove za sve produkcije svih stanja ovog automata. I time smo takle formirali automata LA-R1 parsera. Kad smo to uradili, ostaj nam, naravno, da vidimo što nam je sada ovo trebulo i da vidimo na primeru, kako to funkcioniše, tećemo da formiramo kao da sada potisno i kontrolno tabelu. Gde i za potisno tabelu, mislim da to ne moramo više raditi po koracima, ja stonom i kako se formira potisna tabela, potpuno da identično način je. Zabilo koju transiciju koja postoji u okviru ovoga ovdva automata, mi naravno to nekvi valenta način popunjavamo u samoj tabelom. Tećemo reći da, iz stanja praznog steka ako dođe R na ulas, prelazimo u stanja 1, 1, ako dođe B na ulazu stanja B, 2, 1, a ako prepoznamo neki deo, usnuradimo reduce po ovom ovde S, prelazimo u S0 i tako dalje, dakle na standardni način kao što smo to i videli do sata. E, ovdje je interesantno i ovaj deo sa kontrolnom tabelom i zapravo on se razlikuje, dakle samu u nekim koracima, neki koraciju ostaju veoma sličnijadnosno identični i praktično ponovodakle imamo shift, reduce akcije i one specificne accepto, odnosno reject. Što se tiče samih shift akcija, a shift akcije ostaju potpuno identične i naravno ponovog, kada postoji određen na transicijel, tako u samom automatu, to podrazumeva shift akciju. Nemorom napominjati, jer se podrazumeva, da kao i kodeler 0 i S0 i 1, dakle u kontrolnom tabeli ponovog vrste su nam sva stanja, od tako kolone su nam isključivo terminali, dakle akcije koje sprovodi parser kada se nešto konkretno pojevi na ulazu. Te samih tim ako se pojevi malo, a akcije shift, ako se pojevi malo b, akcije shift, dakle postoja ovi prelazi i tačka parsiranja je unutar, unutar samih smena, al tako, tako da juamo akcije shift shift. I u principu košto rek u kove shift akcije, dakle to je identično kao što smo imali do sad. Međutim, reduce akcije su drugačije. Kod S0 i 1 smo već videli, da reduce akcije ratimo u principu isključivo za članove follow skupa određenog neterminala, međutim, ovdje ne radimo dakle za članove follow skupa, već radimo za članove select skupa, što u opštom slučaju može biti manji broj članova, odnosno, post skup follow skupa. I zada kada hoćemo na primeru da vidimo, dakle ove shift akcije i accept to već znamo kako funkcionišem. Ali recimo u stanju a, opatja, u stanju a1,2. U stanju a1,2 vidimo da je tačka parsiranja na kraj. Te samim tim da te trebu uraditi akciju reduce. Radići se reduce po prvoj smeni, pošto ova smena je prva smena u grammatici, tako da to odgovora tome. E sad kako vi smo dakle radili, pa u okviru L0 mi bi smo radili reduce po prvoj smeni za celo ovo stanje, za SLR1 radili bi smo reduce po prvoj smeni za follow skupa određenog neterminala. A u okviru ovog ovde mi ćemo raditi follow skup za članove predikacijone skupova, što će reći za znak za krajice kvence. Tako da praktično po tome se ovo ovde razlikoje. Tako da odredimo šta pripada našem predikacijonom skupu i radimo reduce samo za to. Dobro, sledit će naše stanje gde ćemo raditi reduce, i to ćemo ponovopogledati o tako predikacijone skupo, vidjeti to je reduce za drugu smenu, ponovopo za znak za krajice kvence, tako da ćemo i to uvrstiti. U među vremenu naravno radimo shift tamo gde se radi shift, ovde radimo reduce tako. I još nam je ostalo da vidimo za stanje i3 i tamo smo veš u predikacijonom skupu imali a i b, tako da ćemo raditi reduce po treću smeni da simbole a i b i tako će izgledati naša kontrolna tabela. Dakle, ja sam da u opštom slučaju ćemo imeti manje simbola, bu koji ćemo raditi reduce, da ćemo moći da napravimo bolju distinkciju i upravo to nam je naravno i cilj, da ne bi smo prijavili neki konflikt, bilo da je shift reduce konflikt ili reduce reduce konflikt, za slučaj kad je realno, taj simbul nije ne može da nam se pojavi kod LR0, tako da je dosad jasno koliko može biti problematikru, zato što radimo na nivou celog stanja, kod SLR1 sa samim polu skupuima takođe nije dovoljno precizno iz prostog razloga što mi kažemo da se sada nakon tog nekog dela sekvence koji je prepozat može naći nešto što se nalazi i za bilo kog takog dela, dakle neček što prepozat, rećimo izana terminala S, ali možda to nije baš taj trenutak u parsiranju. Zgledaj mi ćemo reći, a, učekajmo da će se uraditi reduce, ali sušnjenski može se desiti da tako kombinacija nikada ne može zapravo da se pojavi i da tu nikada neće postojeti stvarni reduce. I zašto bi smo onda uopšta prijavljivali konflikt, ako to nije realna situacija koja može da se pojavi. Tako da zbog toga od interesu nam je da imamo neki parser koji će da prijavljuje što manje moguće nekih stvarnih, odnosno, dakle nekih konflikata koji se u realnosti ne mogu pojaviti, samim tim će on biti na neki način najprecisni. E sad, što se tiče u ovom zadatku, osim same konstrukcije postoji takođe i primer kako izgleda parsiranje neke konkretne sequenci. I sada to parsiranje izgleda naravno izuzetno slično, odnosno, sam postupak parsiranje je potpuno identično, ove što smo zapravo videli da sada, dakle koristimo potisnu i kontrolnu tabelu LALR1 parsera. I znači, krenemo od početnog steka, na ulazu imamo neku sequenci, ono što bi smo radili, pogledali u potisni automot i reklji aha pa dobro, kad imamo, dakle, stanji frazna steka i dođe nam a na ulaz, šta radimo, oddako pogledamo, radimo operaciju shift i stanje koje smeštamo, odnosno simbol koji smeštamo na vrv steka, nam je a1, 1, tako da jevo ga ovda. Nakon to, kad smo stanjimo a1, na pojevinom se i na ulazu, ponovno radimo shift, koje i dodajemo, dodajemo i3, evo ga ovda. Kad smo i3, a dođe nam a na ulaz, mi radimo reduce il tako, što znači, menjamo ovo i3, i kad smo uradili reduce, dakle, ono što ćemo suštenski, tim reduce smo uraditi, skinućemo sa steka ovo i3, na vrhu steka ćemo ponovno imati a1, 1 i pošto, po našu i3 smeni i al tako, ovo i menjamo ovim neterminalom x, pogledaćemo šta se desi kada na vrhu steka a1, 1, a prepozna se neki deo sekvence pod ovim neterminalom x, dakle, smešta se x1 na vrh steka. I tako nastavljamo dalje, naravno na kraju, ovo sekvenca, vidite konkretno, je prepoznata od strane ovoj ovde parsena. I na taj način smo zapravo prikazali kako funkcioniše prepoznavanje neki sekvence, korišćenjem LLR1 automata, kao što reko logika je identična, jedino što ovde obavizno, dakle, koristimo, naravno, kontrolno tabelu LLR1 automata. Ovdje materialimo imateš nekoliko za dataka, koji se odnose LLR1 parsire i naravno
 na i ova druga dve vrste koje smo više radili predhodnji put. Mi naravno nećemo sada prelaziti kroz sve te zadatke sa podjednakim zalažanjem u same detalje. Nije ni potrebno, zato što smo već, usnutrebilo bi da smo već svaladali koncepte. Ja bih vas dodatno samo uputil na još par svario koji smo onako popričali, ali možda nismo videli na primrima, a onda naravno ukoliko bude obilo nekih neansunocija vezanih za konkretne primere, vi možete i pitati kada budemo imali konsultacije. Jedno svar i koje smo pomenuli, a prosto nismo niko nekde videli konkretno primaru je kada uopšta dolazi do tih konflikata, izbog čega na kraju videli smo i uvodimo uopšta ovoliko različiti parser, odnosno tražimo povešanja, par nam nije dovoljeno vej alarmula parser kao najjednostadnje. Da imamo lak u jedan primar gramatike, gde uprovo možemo videti takvu jednu situaciju, gde samo prije nego što vidimo, dakle konkreta na konflikt, ja bih samo jedno svar prokomentarisala, to je da pri konstrukcij ovih automata, naravno, automata se konstruiše na potomno identično način kao što smo do sada pričali, međutim, ono što ote postoja što možda nismo videli u konkretnom zadatku do sada je postojanje jedne epsilon smene, odnosno smene koja prikveta, odnosno koja obuhvata da tako bolje se izrazi, neku prazmu sekverciju. Kako ćete tu predstaviti u samom automatu? Pa predstavljajte se u pravo ovako, dakle, tačka parsiranja bez potrebe za pisanjem u epsilona sa desne strane. Razlog zašto nije potrebno odbišete to epsilon, i ako naravno možete, je u to našto, u koliko pišete epsilon, možete se prevariti, pa onda recimo posmatrati epsilon sada kao neki simbol, gde će prostat tačka parsiranja se u narjedom stanju prebaciti preko tog epsilona. Zabrvo, nije situacija, pošto epsilon obuhvata ništa, neku prazmu sekvencu. Zbog toga, ovo je ovdaj jedina, tako smene, i tačka parsiranja se nikde nek premešta u datoj konkretnoj produkciji. Zbog toga je dovoljno prosto notacijski staviti ovako, i tako je jasno da nema šifta u okviru te smene, nego da se odmah tu nalazi i reduce. I sada je naravno, kad smo konstruicili ovakavu automati, formirali neku potisnota velu što znamo dobro kako se radi. Oste nam još da formiramo kontrolne tabele. I upravo, ovo je ovdaj situacija, ovo je situacija u kojoj postoji takva neka prazna smena. Sada kada pogledate, odgovarili će produkcija za neterminal X-i uključena u startno stanji. I ove preostale tri smene. Vidimo da je jasno da će se tu dešavati neki shift, tako da imamo, kada posmatamo, je lernola parsira, pošto određujemo akciju na njugu pojedinočnog stanja, vidimo da su na moje tačke parsiranje negde unutar samih smena, onda ja sam da bitaj parser radi u akciju shifta posmatrići te tri smene. Višting kada posmatamo ovom četvrtu, tu vidimo da se tačke parsiranje nalazi na kraju s desne strane, i da zbog toga zapravo se to očer, koja je operacija reduce. Ovdje se reduce radi po 30 smeni. Nećutim, da pa šta će onda parser u toj situaciji durete? Ta ništa parser će da prijevi jedan shift reduce komplikt, da kaže na osnovu ovih produkcija, on bi radi još shift akciju, ali na osnovu ove on bi radi u reduce akciju. Istan situacija manje više sa stanjem b1, i tu kao što vidite po ove dve smene, tu bi bila neka shift akcija, međutim po ove poslanje, Lernola bi prijavio da treba da radi reduce akciju i savin tim on će ovde prijaviti konflikta. E sad, da li su ti konflikti realni ili ne? To ne možemo baš vidati na osnovu ovog ovdje parsera, pošto on ne posmatra uopšte simbolu koji se nalazi na ulazu. I moguće je da recimo, postoji konflikt u Lernola parserima, ali sa druge strane ne postoji konflikt u SLR1 parserima i LRLR1, ili da naprimer čak i postoji konflikt u SLR1 parserima, ali ne i u LRLR1. I razlog je u tome upravo što kod LRLR1 parsera dakle imamo najmenji tih nekih lažnih informacije da tako kažem. I sad kada pogledamo, dakle još kako izgledaju kontrolne tabela, SLR1 i LRLR1 parsera, ono što možemo videti je da upravo u takvim situacijama ne postoji shift-reduz konflikt, zato što na osnovu samih stanja možemo primjetiti da će zapravo iz ovog inicijelnu stanja, stanja praznog steka postavjeti akcije shift, samo za konkretom simbol B, dok će ovo ovdje akcije reduce, zapravo se raditi za follow-sqopodex. Kada odredimo follow-sqopodex, dakle to je u grammatici sve što se nalazi od simbola nakon tog x, mi ćemo da kažemo, dobro gdenom se na terminal x nalazi sa desne strane, vidimo da je to u drugoj i u četvrtoj smeni, iz druge smene vidimo da se nakon toga nalazi malo a, iz čaciktoj smene vidimo da nema ništa. Tezato kažemo ono što je i za x i zapravo ono što je i za svega ovoga, a to je zapravo follow-a. A na osnovu druge smene vidimo da ono što je i za a, i zapravo ono što je i za ovog s, tako i za cele testven. To je zapravo to unija follow-a des, a to nam je ovaj znak za kraj sekvec. Izbog toga će polo oddika zbiti a unija znak za kraj sekvenca, odnosno ova konkretna dva simbola. I tu već kad pogledamo dakle akciju, vidimo da se ćemo raditi za ova dva simbola, dok ćemo akciju što je raditi za simbol b i time smo eliminisali potrebu, nepotrebno štiti u konflikta, koji se u suštini neće nikada zaista desiti na konkretna sekvenci. Odnosno, na prepoznavanju konkretna sekvenca. Čekaj kad pogledamo ovo stanje b, u pravo, koliko da kogada takođe, postoji štiti u konflikt u LR-0 parcel. Zbog toga što on vidi tačku parsiranja negde. Unutar smena nakle kaže, to je akcija štiti, vidi takođe i tačku parsiranja na kraju, kaže dobro, to je reduce puff-konflikt. Međutim, SLR-1 kaže, ovdje nema je realnog šifta i kao što vidimo je ovdje, dakle, prelazi se da šavaju, sklučivo, u koliko se desio neke reduce, pa se prepoznalo x i a. Ali dakle, ako neće doći neki konkretan simbol nosil, koji će se raditi shift. Z druge strane, reduce će se raditi za follow-skoop od x, što smo već videli da su a i znak za kraj sekvence. Te ćemo tu i prijaviti ovaj oddar reduce. Ostatak ejste. A kontrolna tabela, će nam se ovog LR-1 parsira, će nam se možda još malo razlikovati o deselere 1 parsira. I ako pogledamo upravo ovu ovde tabelu i kako ona isgljada, pa možemo primetiti baš razlike u zna, ovom simbolu, praznog steka, odnosno početnom stanju i recimo ovom ovde stanju b1. I u čemu je razlika, recimo kad pogledamo ovo b1, ovo b1, ono što zaprvo primetirujemo, je otako da se razlikuje ove predikcijuni skup za x u odnosnu na follow-skoop od x. I tako će to ćemo viditi u ovom našem početnom stanju. Dakle predikcijuni skup za x se razlikuje od follow-skoop. Šta je uzrok tome? Pa pogledat ćemo kako smo mi ovo šte dobili i otako baš te dve produkcije. Ovo ovde produkciju smo uvrstili, zato što se tačka parsiranja našla ispred ovox, a krenuli smo dovolj startne smene, dovolj startnog neterminala s, koji smo uvrstili opet zbog ovog ovogo. I kada pogledamo šta se nalazi baš i za tog x, vidimo da je to samo a. Isto situacijom stanju b1, ovo smo tačku ovde parsiranja uključili, otako bila ispred neterminala x i zato uključujemo ovo x. Pošto se izgledane nalazi ništa, dakle ono je poništevu, bi nasleđujemo ovoj ove predikcijuni skup za kraj sekvenci. I upravo je dobar ovo primar da bi smo videli kako se mogu razlikovati kontrolnota bila s, l, r, 1, parsera i l, l, r, 1, zato što tim mi zabravo vidimo da su ovoj ovde u ovom ovde trenutku može pojaviti samo a kada radimo reduce, a ovde samo znak za kraj sekvence kada radimo reduce. U suštini da je recimo s, l, r, 1, prijemljivao konflikt u ovom ovde slučaju, recimo u ovom ovde počutom stanju za znak za kraj sekvence mi bi smo zaključili na osnovu l, l, r, 1, da to nije ošto realna situacija da će se pojaviti, ta znak za kraj sekvence pripadu po lsku podiks, ali neće se pronatji u takčke parsiranja u tom trenutku baš koja je predstavlja ovo ovde stanje. Tezbog toga nikada to neću biti realno konflikti, time možemo eliminisati još dodatne prijeve da pletih nekih lažnih alarm. Dobro, u principu ovde vidimo, al tako kako izgledaju kako izgledaju ove kontrolne tabele, bilisom dati neki primari da prosto treba da prikažamo kako izgleda obrada nekih manjih sekvenci, to smo već videli na nekoliko primara tako da prepostavim da nemo potrebe da prolazimo štjedom detaljnije kroz to. Kao što reba ko ovde imate još nekoliko zadataka kroz koja mi nismo prošli, postojiš ove jedna zadata koji je odrađen na predavanjima a koji malo detaljnije prestavlja LLR1 parser, dakle da imete ovako skup nekih stanja i da treba dodeliti o tako predikcionu skupove. U principu, kako što rekoh malo pred, što zdič ove konkretnih produkcija kod epsilonu je otakl, možete pisati epsilon tačko, možete pisati samo tačku, ali obavezno ne posmatrete kao da se može izvršiti šifte akcija tu, dakle, sklučivo, reduce akcija. Jasno nam je da ponovom ko do ovoga automata u stučaju LR0 parsera, bi smo imali konflikt, gde god postoji, dakle, to je epsilon na ove načine oključeno. I ovdje takođe, dakle, još jednom postoji ova revizija pravila, malo formalizuva nakroz sam algoritem, ali kao što je piše, to je rađeno na predavanjima pa mi nećemo ponovom raditi sa taj zadatak.
 i naravno dodaljeni predikciju i skupovi svim ovim produkcijama prema pravilima koja smo već utvrti. Tako što krenete još jednom od ovog početnog stanja, krenete do toga da imete prazn skup na početku i onda posmetrate za svaku produkciju koja se nalazi u okveru tog stanja, odakle ona potiče šta se nalazi za neterminala odakle došla ili tako koji predstavlja u prvotu produkciju, da je poništiv, da je ne poništiv, ako je ne poništiv, isključivo uzimate konkretan simbol koji je i za, ako je poništivo dodajete predikciju i skupovi od te prethodne smene od akodna osnovu koja ova nastala i kada imate transiti u neko od naradnih stanja, selite da je predikciju i skup, eventuolno radite uniju ako postoji prelaz iz više razlačiti stanja u neko stanjem. Dakle sve kao što smo već radili i ne bi trebalo da postoje priliko konstrukcije parsera. Dobro, tako i u principu tu imate još poneki zadatak, ali dosao smo zadataka već prešli skoro sve i, evo još možda ovo je ovdje zadatak i on što nam je ostalo još do kraja ovo botom uparsiranja je da odredimo oporova koji od grešaka. Uslivimo oporova koji od grešaka dosta korisna, interesanta na tema i vići to u oporu vašeg projekta imati na neki videoporavka od grešaka, gde će to biti neke specificirane greške za koje potrebno obezbediti oporava koji u oporu kranomatike. A došto nam je to odznačaja, pozdajšto recimo kada iz aspektu prosto programera napišemo neki programski kod, naravno potencijolo napravićemo i neki niz grešaka. I zada ako nam se desim, su to neke sintaksne greške, dakle ne gada smo zaboravili zaraz ili nešto smo dakle nepravilno napisali, uskladili sa specifikacijom naša gezika, ono što verovatno želimo da se desi i da nam se ta greška prijavio. Naravno ne želimo da se program uspašno izvrši ukoliko postoji greška, tako da on svakako mora se završiti, al tako ne izvršiti se praktično. Miđutimo ono što takođe poželjno je da to nebude situacija u koje mi napravili sad nisi neki grešaka, prosto ako Piler najdje na prvu grešku koji smo napravili i kažem pa napravio si grešku i stane program. Pa mi onda to potpravimo, pokrnamo, ponav, pa, ovo je slajicija greška, hajde sve iz početka. Već je recimo, mnogo, bolje da se tu prijavi više neki grešaka i da bi to mogli da se uredim. Naravno mora da su poravi od prve greške, da nastavi sa procesiranjem koda i da prijavi što više grešaka je moguće. E sada, taj u poravak te radji tipično koristimim nekih dodatnih smena u same grammatici koje su ovako smene koje imaju neki error symboli. Taj error symbol zapravo potrozumeva da će neki deo smene biti ignorisan. Na taj način, u kojiko postoji greška tu, nekda ona će naravno biti prijavljena, ali prosto, takle, može se preskočiti i može se nastaviti parsiranje programa na daljen. Bude onda, naravno, to prijavljivnji grešaka može biti napravljeno uopštenije, može se progutati, dakle, u celom programu bilo koje greška, može biti napravljeno granularnije pa na taj način, takčno izolovan neki specificne greške koji ba želimo da se oporavimo. I videte ćemo kada budemo pričali važda samu specificaciju projekta. Vi ćete tako da će imati neki skup smena u kojima je potrebno oporaviti s odgrešaka, dakle, za neke specificne situacije pa ćete već našto slično i samostavno implementirati. E dobra. Tu ima, naravno, nekoliko algoritama za samoporavu, kevi će vidjet ćemo igu okvir ovih zadataka, da je prvo ćemo krenuti u dolog neku jednostavnijevih premera. Kao što rekog, dakle, da je jednostavnijeg premera podrazumeva, da prosto imate neki nizismena i konkretno ove nekoj gramatici i neku sekvencu koja se naravno procesira na ulazu za neke očigledno aritmetičke operacije i neku smenu koja je uprvo ima taj neki simbol greške. Samo naparsiranje se za počinje na standardni način, dakle, tako što imate jedno počet na stanje steka. Dakle, ili cijel na stanje prazna steka i imate celu sekvencu koja se nalazi na ulazu. Prima, ove na počinje se a jednako. I sada, dakle, tu radimo operaciju SHIFT, smeštamo a na steka. Nakon doga dolazi jednako, opet radimo operaciju SHIFT. Naravno, ovde sad naradimo konstrukciju celog okupnog parsera, nije nijeg potrebno. Vidimo, dakle, šta će biti, gde će biti urodjen SHIFT, gde će biti urodjen RIDIUS, nosno u same gramatike, tako to možemo jednostavno da urodimo. Takođe, ovajom se do ovde stanjima, ne dajemo posebno neka simbolička imena, odnosno dajemo je otako, ali ovde već imamo jedinstvene simbole, pa je zbog toga dovoljno smeštamo, a jednako i tako dajemo. Da te ne ulazimo toliko u te detaje. Dobro, urodimo SHIFT, smestimo jednako, dođemo B, urodimo SHIFT, idemo dalje, otaku, smestimo B, ovde dođe plus, urodimo SHIFT i sljedeće je otako, nam je D na ulazu. Kada pogledamo ove naše smene, mi vidimo da to nije u skladu sa ovom našom gramatiku. Odnosno suštiske u našom parseru u momentu kada imamo ovo plus na vrhu steka, ne bi postojevala mogućnost da mi uopšte vidimo sada na ulazu C. Dakle, ili bi nam na ulazu D, izvjenite, pošto D je konkretno u samoj sekvenci. Dakle, ne bi smo imali D kao za SHIFT, ne bi smo mogli da ga izkoristimo niza ka vridijus, tezbog toga ovde sada parser detektuje neki problem. E sada, detektuje grešku. Kako će da se oporavio te greška? On će da redom skida, da redom uzme i da skida elemente sa steka, svedok neproneđe neki simbol na osnovu posle koga može da smesti ovoj eroš simbol. I kao što reko, kta je eroš, će zapravo da proguta neki deo sekvencik tako da on uzme i skida redom sa steka, plus skida B i tu je došlo do jednako i kao što vidimo, izaj jednako bi zapravo postojo kao neki prelas povom error simbolu, koji sada prestavio našu ovu neku sigurnu smena. Samim tim ovde ćemo da skinamo te svare i da postavimo error i nakon toga ćemo u ovu našu sekvenci da radimo SHIFT, SHIFT, SHIFT odnosno da preskačemo čita v nijih z tih simbola sve dok nedućemo do nečega što je uopirove naše smene i za to gero. Dakle, ono što smo mi zapravo rekli ovom novom smenom kojoj smo obacili i je da, ukoliko se negde napravi greška nakon, a jednako, a sve do ovog tačka zaraz mi prosto to preskačemo, obuhvatamo tim error simbolo i prijavićemo na kraju naravno grešku, ali ćemo se upravo zachvajući ovog oporavitja. Što znače? Preskačemo D, preskačemo plus, preskačemo C, to znači samo radimo od Vans, neradimo SHIFT iz razloga što SHIFT ove podrozumeva dakle akciju premeštanja u sekvencij dalje i smještanja konkretnog simbola na STEC. Mi ovde neradimo smještanje simbola na STEC, mi samo idemo dalje kroz sekvencu, dok nismo došli do onog simbola koji se nalazi nakon toga error a to je ala tačka zaraz. Kada smo došli do te tačka zaraz, a mi kažemo SHIFT, ovo smještamo na STEC, nakon toga radimo RIDUSE, ovde se radi RIDUSE po četvrtoj smeni, otako, a i jednako error se menja sa ovim I. I nakon što mi je to na STEC-u, ponovno je otako možemo da radimo RIDUSE po drugoj smeni, time smještamo S na STEC i pošto će to sada biti dođe nam znak za kraj sekvence, otako to je kojivalentno ono neku inulutu smeni koji uvodimo, mi ćemo takvo sekvencu da prihvatimo naravno taklo praktične prijevene, rekl je bi smo imali smo grešku, i na dalje, nakon te greške, prosto nakon svega ovoga što smo ovdje buhvati, ili nismo više imali nikakvih grešaka. E sada naravno, ako mi napravimo ovo potpuno opšte, tako da buhvate recimo cijel program, onda ćemo imati al tako neprecizno prijevljivanje grešaka, odnosno, dakle neki oporavak koji će da samo išiftuje sve elemente do kraja i da kaže negde tu se nalazi greška. Dobro, to je bilo, dakle, jednostavan zedatak, jednostavan način prijevljivanje greške, postoji, dakle, i drugi način, koji ćemo vidjeti u ovom drugu zedatka. Kaža, ako prikazite izgled teka u slučaju da se na ulas parsera koje pasira, koje botomapil, tako, i opisani je ovom nekom datom grammatikom dovede neki konkretan ulas, da je zakla ovde imamo neke statemente, neke ivden konstrukcija, imamo neke varijavle, imamo neke konstante i očigledno negde u programu imamo odgovarajuću greško. E, po da. Predpostavka je da se zaoporava koji od grešaka koristi jednostavni panic mode algoritm sa sigurnim simbolima tačka zaraz i endiv, a pod b dakle koristi se neki povješan algoritm, ali to ćemo vidjeti kasnijen. Doče, ono što treba prvo da vidimo malo kako izgleda ovog grammatika i onda da vidimo šta je zapravo i oniša na jednom konkretnom primeru. Dakle, kao što reko, kova naša grammatika opisuje neke ivden konstrukte i uokviru toga dakle imamo varijavle to su ovom našem primeru zadatka neko a, neko b, x i tako dađem. I konstante koje su ovde 1, 0 i ta.
 Dakle, ono je pretstom zadatku smo odimeli baš konkretne te terminale kao simbole, onda je sad imamo, dakle, neke variable i neke konstante koje će tako biti prepoznala, ne? Dobro. Što tiča ovog jednostavnoj panik moda, u principu najbolje je da vidimo na konkretnom primero dakle kako će izgledati sam algoritem, kako radimo dakle prepoznavanje. Na početku imamo stanji praznog steka. I onda nam dolazi, a jednako jedan tačka zarazi tako dalje. I u tom slučaju, dakle, radimo šist, a smeštamo na stek. U principu oze, kada kažem, a smeštamo na stek, ne smeštamo baš a, već to prepoznamo kao variablu, dakle, to bi smo dopatili kao neki token koji smo klasifikuvali kao variablu, te smo smestili tu variablu na stek. Nakon toga jednako smeštamo na stek kao specificam znak, nakon toga jedna što je konstanta i nakon toga tačka zaristu smo radili 4 shifta i smestili smo ovom na stek. Nakon toga možemo da radimo reduce po četvrtoj smenijel, tako gde ćemo umesto v jednako c tačka zarist, smestiti i. Dobro, nakon toga nam dolazi, if jednako, if a jednako, jednako 0, što znači? Tu imamo if i za, ovde ponobno imamo smenu ovu drugu, znači podrozumemo ovdje i. Za neki odgovarajuće parser pogledali bi smo joj tako u zagizm stoga koji parsere u pitanju, dakle, za koji simbol radimo nadgovarajuću akciju, ovdje, kažem, ne ulazimo toliko u te detalje, da radimo reduce po drugoj smeni, umesto i smestimo s na stek. I sad idemo dalje ponobno. Pošto kaže if a jednako, jednako 0, smestimo if na stek, radimo shift, ili tako za a, radimo takođe shift, tu smestimo neku varijavlo, jednako smestimo na stek, radimo shiftove, c takođe shift i tako dalje, ili tako znači. Esan, v jednako c, nam v jednako c, radimo reduce po 6 smeni, tima smo smestili ovo e. Evo ga ovdje. Dalje imamo den, b jednako 1, što znači? Smešti ćemo, tako ponova ćemo raditi shift, smestimo den na stek, smestimo ponovno radimo shift, tima smestimo b na stek kao varijavlu, jednako smestimo na stek i c smestimo na stek, dakle tu radimo mnogo neki shiftove. I međutim, neko što smo to odradine, znači sve ovo ovdje imamo na steku, dođe nam ovdje procenat. I sad da kada pogledamo našu gramatiku, ovdje procenat ne postoji, nakle evo ga ovdje u kodu, sve smo do tada uspešno gradili, međutim, on ne postoji nigde u našeg gramatici, time zapravo detektujemo da je došlo do neke greška. Šta se tada dešala? Panik algoritm ove pojednostavne. Radi tako, što krene kroz samu ovu sequentlu koje se nalazi na ulazu i napraduje kroz nju sve dok ne dođe do nekog sigurnog simbola. Za nas i taj sigurni simbol ovdje po postavci za datka bio tačka zaraz ili mdif ako se ne moram, tačka zaraz ili mdif tako je. Tako da on radi advance praktično sve dok ne dođe do prvog sigurnog simbola. To je ovdje tačka zaraz. Što znači svi ovih pojedinočnih, ovih tokjeni koji su se pojavili, su samo odstranjeni iz te sequence, radili smo advance akcije i praktično došli smo do tačka zaraz. E, kad sada imamo taj sigurno simbol, sljedeća akcija koja se radi je schidanje nepotrebnih stvari sa steka, sljedeću ne dođemo do nečega, da to možemo potisnoti na steka. Da možemo uraditi dakle neki ridijus. E sada kada pogledamo ovu našu ovde gramatiku, mi trenutno na vrku steka imamo v1 ko c, sljedeće nam je tačka zaraz i kada praktično to potisnemo na steke, tada u toba štu tačku zaraz što nami sigurni simbol, mi ćemo suštenski raditi sljedeću akciju ridijus, da ćemo po četvrtoj smeni ovve je jednako c, zameniti sa ovim ovde e. Te u okoru dakle ovog drugog pravila, potisnemo na stek ovu tačku zaraz, uradimo shift ili tako, jer znamo da možemo uraditi ridijus po ovaj ovde četvrtoj smeni i tima ćemo smestiti i na steka. Neko što smo ismesterili na stek, vidimo možemo raditi ridijus po drugu smeni, tako da to nam je s, i sada trenuto na steku, dakle imamo na vrhu is e den s. Dobro, to nam liči na ovu ovde, međutim i da li je tu ne možemo uraditi neki ridijus, gledamo šta je sledeće na steku, tu je n-difte, zbog toga radimo shift, i shift uvijemo tačku zaraz, takođe potisnemo na steke, odakon. Dobro, kada smo uradili potiskivenje toga na stek, sada u tobi nam zapravu bio ridijus po ovom pete smenji, da će ovde biti neterminal s, neterminal i, to nam je ridijus po prvoj smeni, da će ovde biti neterminal s. Kada pogledamo, dok smo mi sada zapravo stigli s ovim konkretnim prepoznavanjem, ovde nam je otako ostalo x1,2 tačka zaraz, i onda ovaj neki n-dif. Dakle, za to x1,2 tačka zaraz ponovat ćemo raditi shift, shift, shift, shift, shift, potisnućemo na stek v jednako c, tačka zaraz, to ćemo sve zameniti neterminal i, dakle ponovat ćemo raditi ridijus po 4 smeni, i nakon toga radimo ridijus po prvoj smeni, dakle ovo s i menjemo sa s, i nakon toga imamo n-dif. Esat, kada imamo nakon toga n-dif, ono što suštenski vidimo, jeda, na osnovu samog grammatike nema te kombinacije, koja bi i nakon neterminala s očekivala n-dif, dakle n-dif jedino moguću ovaj ovde situacije. Te ćemo tu ponovu detaktovat i grešku. Šta će se desiti u tom slučaju? Pa radit ćemo advance kroz samu sekvencu, kao i malo prejel, tako je dok nedoj ćemo do sigurnog simbola, prvog sigurnog simbola. E sada sigurni simboli još jednom, su na u mom zedatku tačka zaraz i n-dif, pošto n-dif je prvi na ulazu, onda ne radimo u opšta advance, jer odmah na početku imamo sigurn simbol, tako to ne radimo. M.dk., kada krenemo skidanje sa ovog steka, dok nedoj ćemo do nečega sa čim možemo kombinovat i taj sigurni simbol, tako da zapravo on pronadji svoje mesto u grammatici, kada urodimo po prvi putil, tako, n-dif ostane prazna steka i na taj način Mi zapravo nismo uspeli da potisnemo ništa na stek. Te u tom tonutku mi smo ispraznili naš stek, a na ulazu imamo n-dif, što značin tu ne možemo ništo uraditi i takva sequenza će biti redrektovan. Dakle, parser nije uspel da se oporavi adekvatno korišćenjem ovoj pojednostavljenog panic moda. Pod b smo imali pobrenšan i algoritam panic moda, koji zapravo ima dodatno još simbol, osim ovih sigurnih simbola n-dif i tačka zaraz. U suštini, ono što je modifikacija, sada, ka algoritma je potpano identičan, ali ono što je modifikacija da u koliku se najđeno neki simbol zaglavlja, on se posebno markira i potiskuje na stek, predstavlja kao neki praktično graničnik. Da tako to ono zove. E. I sad imamo potpano identičan primer. Tako da, hajde da vidimo kako funkcioniš. Ponov ovo je ovo tako, ovo je ovdje del neću prelaziti pošto identično sve, dakle za ovaj ovdje del koji je ispravno parsiren, radimo šiftove, prepoznajamo reduce-ove i u nekom trenutku dođemo do ovog ovde procenta. U tom trenutku videli smo, kod pojednostavljenog panic moda, ono što radimo je da napredovamo kroz samo seklenciu dok neduđemo do nekog sigurnog simbola, međutimo ovde, dolasimo do sigurnog simbola ili zaglavlja. I sada kada pogledamo šta se zapravo ovdje nalazi bliže u samom postaciju, odmah nakon ovog ovdje procenta nama se nalazi if, što je zapravo zaglavlja. Tako da to nam čini sad ovde razliku. Dakle malo prej smo radili je dva, svedok nismo došli do tačke zareza, a sad ćemo prosto raditi samo jedan od vanz dok nedodžemo do ovog ovdje ifa i njega ćemo šiftovati na stek i to je ono što smo rekli jo tako, dakle markiramo nekako to zaglavlje na samom steku. Dobro, nakon toga nastavljamo naše parsiranje. B je jednako 1,3, to je sada ili tako normalno do ovde ovde tačke. B je jednako 1,3, to potiskujemo na stek kao V je jednako 1,C, prepoznajemo ta ideo ili tako radimo reduce, zamenjujemo sa ovim E. Nakon toga imamo den x jednako A plus 1, što ćemo prosto šiftovati, prepoznajte kao den varijabla, jednako varijabla plus constanta tačka zareza i nakon toga, jer tako radimo reduce jer smo prepoznali ovaj ovde del, zmenjemo ga sa i na našem steku. Nakon toga dolazi mdif i tačka zareza. Uradimo šiftovanje mdifa, potom šiftovanje tačke zareza. Nakon toga ponovu prepoznamo ovo kao 5 našu smenu i uradimo reduce. I sad imamo ovaj ovde I, nakon toga dolazi x jednako 2 i sad mi ne znamo baš šta ćemo sa tom kombinacijom, te ponovu ovde vidimo da imamo neku grešku. Što radimo u toj situaciji, pa ponovu napredujemo tako u krasamo sekvencu dok ne dođemo do sigurnog simbola ili do zagod.
 Prvo do čega stižemo je sigurni simbol, to je tačka zaraz u ovom sluči da pladbacujemo x jednako 2 i što potom radimo. Potom moramo da skidamo sve simbole sa steka, sve dok ne možemo da kompletiramo neki deo na vrhu steka i da praktično, kastnije naravno ga prepoznamo, odnosno, reduce-o. Zat ćemo mi skenuti ovo i pošto takođe ne možemo ga upariti nikako ni sa tačkom zaraz, međutim kada skenemo i ovdje ovdje u vrhu imamo v jednako c, to znamo kako ćemo da uparimo sa tačkom zaraz, pa ćemo uraditi shift i kada imamo v jednako c tačka zaraz, radimo reduce po četvrtove smeni, menjemu ga sa neterminalom i, nakon toga reduce po drugu smeni, menjemu ga sa neterminalom s. Sledaće na ulezurnom je ndif-tačka zaraz, što znači radimo shift, shift il tako, nakon toga sve ovo zamenimo sa i, dakle reduce, nakon toga si zamenimo sa s i, sledaće što mi na ulazu, znak za kraj sekvence, uradimo shift i na kraju imamo ovo s, imamo znak za kraj sekvence i to je akcija accept. Tako da u suštini u ovom konkretnom slučaju nama je poboljšan i algoritam oporavka pomogao za oporavak u konkretnom program. Dakle, videli smo kako funkcioniša oj tajne algoritmu svoje osnovno i poboljšano i varianti, videli smo takođe kako na nivou gramatike možemo da rešavamo ovoparsiranje grešaka.
