 ovdje je neko ko će da odradi ove klasa koje će da odradi taj zahd. To istu postoji i sada koći serveriskog svih serveriskog aplikacija. Znači sve serveriskog aplikacija radeno ovaj ovde isti način. Vaša serveriskog aplikacija web server naprimer ili aplikativni server ili server bazi podataka prihvati zahd. I onda odradi svič. Prema tome kako se zove zahd. Izvurila adresa se najčešće izvuče. To je ete bgace rse kroz RTI, naprimer kroz nešto. To treba da se uputi ovom ovde rendereru i onda to samo njemu prosledite kroz neki konfiguracijeni follow. Mi to se upisano. Ovo će da odradi case i oskoči će na odgovarajuće mestu. Tamo radete to što treba da radete. Telo te odgovarajuće metode. Na kraju bi trebalo se vrati odgovor. A ukoliko se radi o blokirajuće ili metodi koji ima povratnu vrednost. Ako je neblokirajuća bezpovratne vrednosti, onda nema potrebe da klijent čeka da se ovo na serveru završi. Bada moš ti to realizuva. Kako želite ima da tu malo usporava sistem. Ako imate neblokirajući sa bezpovratne vrednosti. Kako izgleda klijent? Klijent u suštini uvek izgleda isto. Klijent treba da kaže ja oču da mi se odradi. To je to. Evo argumenata. Nisam lepo reko. Ja. To je ovo ovde ID. Ja. Hoću da mi taj. A sam utačno određeno poštensko sandoče. Kao što bija iz vašeg browsera kašta ja. Hoću da mi se sa Google dovuče nešto. Vi Google opotite zahte. Koji zahtev. Ovo ovde bi bilo Google.com. A ovo ovde bi bilo koju stranicu želite. A ovde su vaši argumenti koji neko treba da izrenderovi. Je tamo na klijentu stranice. I onda čekate da taj neko reply od i. To je samo ovako napisano da bi bilo ovakše za praćenje. U suštini vi očekujete na vašen komunikacijonom kanalu. I onda da primite odgovor. Kao da je svaki korisnik dobio svoj komunikacijoni kanal. Jeste pošto ćete u realnoj komunikaciji. Imajte ip adresu i port. A od atličite moći da prihvatate odgovore koji su vama upućeni. Dobro. Šta smo redali do sada? Kako identifikujemo procedure? Procedure se identifikuju. Tako što u svakom komunikacijonom kanalu. Imojmo potrebu da pošladimo ne samo argumente. Negu da kažemo koja operacija treba da se obavi. Kako se realizuju tela procedura? Ano što smo imali nekad kod monitora. Tela procedura se ovde realizuju unutar case iskaza. Znači unutar jednog case iskaza. Imojmo skup operacija koja je potrebno da se realizuju. Kao da smo isčupali. Prit ćemo za situaciju da nema blokiranja. Da ima blokiranja ovako nešto nikako ne bi valjilo. Znači za sada prajimo servijsku aplikaciju koji ima jednu nici. Nek'o muš da pita. Dali postoje uopšte takve servijske aplikacije koje sve obavljaju u jednoj niti? Postoje takve servijske aplikacije? Postoje uopšte takav način programiranja da se sav posao obavlja u jednoj niti. Uvrlo malom broju niti. Ne znam da što ćete raditi pa pustite novu niti da vam radi nešto paraleli. Ovde ideja da se minimizuje broj niti. Kako imate mali broj izgara, jednoj niti, jednoj je izgori. To oni svako radi neki svoj posao. Ali želite da ta niti bude maksimalno obterećena? Vi želite da pravite neko malo čuvanje konteksta. Ako išto od konteksta treba da se čuva, a ne da to radi operativni sistem, zato što operativni sistem može da napri veliki overhead. Nadate se da vi možete da to malo napravite bolje i da ta vašo niti neprekidno može da radi posao koji treba da radi. Šta je posao koji treba da se radi? Pa evo govdje. I želimo da realizujemo jedan semafor. Značite se, ovdje je kod semafora koji je realizovan korističi tekniku passing the condition, gde onaj što bude i odradi posao za nekog, a onaj koj treba da se probudi, ovo samo treba da se probudi. Aha, dobro što sam ja sa tu rekao. If ako je uslona promenjiva posteljna navrednost nula, ono lokalna promenjiva posteljna navrednost nula, čekaj na uslona promenju. Else niko nečega, i ima nečega, samo u manji ja za jedan. Procedura signalizacije kaže, ako neko čeka, ako niko nečeka, a ti probudi tog nekog. Ovo ovde su malospožveni operacije u odnosu na ono što smo imali malo čas, jer što mi biš da treba da realizujemo ovde? Treba da realizujemo dve metode u našem aktivnom monetu. Jedne metoda bait, druga metoda signalizacije. I sad možemo da krenamo u njom, kako bi ovo ovde trebalo da izgleda? Tu bi bilo jedna bezkunočna petlja, znači while, tril. I sad tu treba da se odradi ovaj posao, koji treba da se odradi. Rekli smo da će ove interna promenjiva koje nekad postojila i dalje postati lokalna promenjiva u našeg monitora, a int je u njom, koji je u njom, a int s i inicializujemo na odgovarajuću početnu vrednost. Alje to nula ili koho godine već neko drugi postavio, to je početnu vrednost. Ovde nemo u sluvinih promenjivih. Ovo nije konkurentno programiranje, ovo je distribuirano programiranje. Ali ćemo nešto morati, pošto vidimo da postoji blokiranje na ovoj usluvnoj promenjivi da realizujemo, kako god znamo i umemo. I što smo rekli da treba još globalno da postoji, odnosno što svako treba da vidi, treba da vidi ove Chen request i Chen niz reply. I što ovaj ovde radi, radi receive a kako se zove, zove se request što treba da primi. Treba da ima od koga treba da primi, način to je neki identificator, treba da primi operaciju i sad ili treba da primi neki argument. Ajde da pogledamo ove dve metode. I ovdje neki argument nema. I ili ma ovdje neki argument nema. A onda je to jedino što ovde treba da primimo. To je receive ID i receive operacija okoliko se radi. I sad dođe ona jedan switch a switch po toj našoj operaciji. I što radimo u tom switchu? Pa jemo dva. Case Veet I ima ćemo još jedan case Signal. Ači u javi nam je dozoljeno na primer da koristimo promenivu koja je tipa string. To nije bilo dozoljeno cih verzije jave, ali u neku verziju jave su do to dozolveve. I nije to svič po stringu, to je svič po hash od stringa, a onda se samo tamo napravi da ali su da dva jednaka. Dobro što sam ja sad to dopisalo? Case 1 i case 2. Dobro. Ja trebalo da nekako iskopiram. Ovo ovde parče koda i ovde parče koda. To bi se bilo super da nema ovog blokiranja. E, pošto će biti blokiranja, onda sad ja treba na smislim kako to da reagljastuje. To baš nije tako jednostavno. Vada nije nikomplikovan. Ale ja idem da krenem. Znači, case signal. I sad mogu da pitam if. Sad ja ovde neam empty. A, ja ovde mogu da pitam, da ali ima nekog za blokiranog gore? Ali ima neko za blokiran gore? Umesto, a ovve uslune promenive i reda blokiram. Sviš, što je to? Ustuna promeniva sa redom blokiranih procesa. Aha, red. Pa ja neću ovdje imati red, ja ću da stajem listu. I mogu da je nazovem pos isto. I što će ovde sad da gažem? If size od pos, ili pos.size, if size od pos, i znači, ako je to jednako jednako.