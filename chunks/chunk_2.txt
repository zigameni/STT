 koji ćemo prevesti u objektni format, u elf format, a onda ćemo taj elf prevesti u Intel Hex. Napravit ćemo zasevan direktorium u koje ćemo smješati se fileove koji se tiču pravljenja jednog Hex filea. Taj direktorium može da se zove main i u okviru njega ćemo napisati taj prvi jednostavni programčić. On se sastoji od nekoliko promeljivih, neka to na primer bude neka intidžerska promeljiva, sa na primer vrednošću 7. Možemo da dodamo i jednu nepromeljivu, neka bude vrednost na primer 6. Možemo da dodamo i makropromeljivu, sa na primer vrednošću 5. I nekakvu neinicializovanu promeljivu koja u stadu sa svojim imenom nema početnu vrednost. Dok će program biti krajnje jednostavan, sadržat će samo dodelu vrednosti ovoj promeljivoj neinicializovanu i to će biti izbir ovih preostalih promeljivi. Dakle, nepromeljive i promeljive. Ovoj file ćemo sačuvati u okviru direktorijuma main i to kao main.c. Sad ćemo probati da prevedemo ovoj file main.c, da od njega dobimo objektni file, što način ćemo i main.c prevesti i asemblirati bez ikakog povezivanja, a onda ćemo od tog rezultućeg objektnoj file napraviti hex file. Da bi smo to ostigli, iskoristit ćemo gcc prevodilac i zato ćemo koristiti omanu liniju. Na ovom mestu ćemo otvoriti omanu liniju i pozvećemo odma gcc koji zna da prevede nekakav uvijednog liniju. Zato ćemo izvorni kod na ovoj x86 masini za arm masinu, to jest koristit ćemo jedan cross compiler. Njegovo ime je arm non eabgcc, a argumenti koje treba damo zadamo je su sledeći. Pošto smo reklji, da ćemo vršiti samo prevođenje i asemblirati bez linj, to je povezivanja, iskoristit ćemo ovu opciju minus c svakako. Ono što ćemo još od opcija dodati, je su opcije koje govore da se zaista radi o konkretnom armovom jezguru koje će se koristiti na ovom kursu, to je Cortex M3 i instrukcijskom setu tam, to su još neke opcije koje ćemo navesti. Tako da ćemo onda reći minus c, da bi imali prevođenje i asembliranje bez povezivanja, reći ćemo opciju M i CPU da je Cortex M3, to je jezgu koje se nalazi u onom našom mikrocontrolleru. Reći ćemo da se koristi instrukcijski set tam, reći ćemo da se izlaz naziva, takle sa minus o opcijom main.o, jer je u pitanju objekni file, dok je ulaz main.c. Nakon prevođenja, ovo ga možemo da vidimo šta je rezultat. Rezultat ovoj prevođenja i asembliranja jeste ovaj objekni file uskladu sa elf formatom, tako da njega sada možemo onda pretvoriti u hex. Alat koji ćemo za to koristiti naziva se arm non eabi objeje copy ili object copy, tako da ćemo sada njega izkoristiti i vidjet ćemo koje opcije njemu treba zadati. Njegova sintaksa zapozivanje jeste sledeća, nakon samog naziva moguće navjesti opcije, a zatim sledi ime ulaznog filea i na kraju ime izlaznog filea. Obće koje još nama jeste neopodna, jeste ovaj output target, da bi smo navjeli u kom tačno formatu treba da bude izlz. Rekli smo, ovaj intel hex format koji mi koristimo je jedan od različitih hex formata koji postoje. Podržani formati u ovom slučaju su sluči ovoga lata objeje copy su navjedeni na ovom ovde mestu i mi ćemo koristiti i hex što je oznaka za intel hex. Što znači, da ćemo k komandu reći minus o pa zatim i hex za naziv formata izlaznog filea. Zatim navodimo ulazni file, to je main.o i još ćemo navisti kako želimo da se zove izlaz, neka to bude main.hex. I u ovom trenutku bi trebalo da imamo napravljen jedan hex file, to je ovaj ovde. I u njemu bi trebalo da možemo da prepoznamo neke elemente našeg programa koji smo napisali na cev. Ono što odma možemo da prepoznamo, jeste da imamo deo sa mašinskim kodom koji prestavlja instrukcije koje će obezbediti da se izvrši ovo ovde sabiranje. Kao i da se ovde nalazi promenljiva či je vrednost 7, kao i ne promenljiva či je vrednost 6. Druga stvar koji u bi trebalo primjetiti, jeste da se nogi od ovih stvari nalaze na istim adresama. Promenljiva 7 se nalazi na adresi 0, kao što se i ne promenljiva 6 takođe nalazi na adresi 0, kao i sam početak ovog programskog koda. Razlog za tako nesto, jeste to što nismo napisali odgovarajuću linkersku skriptu, nismo čak ni pozvali linker kojem bi smo rekli šta gde treba da smesti i ovo je podrazumevan i razmeštaj sekcija iz assemblersko koda. Z toga ćemo sada polako krenuti ka tome da napišemo prvu linkersku skriptu, a pre toga ćemo proči kroz ovaj proces prevođenja, korak po korak da bi smo videli kako izleda izvorni assemblerski kod do koeg dolazi GCC kao prevodilac. Da onda u tom izvornom assemblerskom kodu prepoznamo koje su to osnovne jedinice sa kojima možemo baratati u linkeru. Pre nego što pređemo na prvi korak u lancu prevođenja, zatvorit ćemo ovaj program.hex pošto nam je suvišan kao i ove direktorijome Alate i Bin i Proteus koji više nećemo u ove lekcii koristiti, a fokusirajemo se na predprocesiranje ovog ovde filea. Dakle prva stvar koji ćemo uraditi jeste da izvošimo predprocesiranje main.c izvornog koda. Komanda koja nam treba za to jeste arm non-eAbi GCC sa sledećom opcijom. Dakle želimo samo predprocesiranje opcija za tako nešto jeste minus e. Pa ćemo onda z toga reći da je izlozni file koji želimo main.i od intermediate, da je ulozni file main.c i da želimo samo predprocesiranje. Resultat predprocesiranja i trebalo da je kranji jednostavniji očekio, to je ovada petica koja se ekspandovala zbog ovog ovde macroa macro. Narani korak u lancu prevođenja, jeste da od ovog intermediate filea