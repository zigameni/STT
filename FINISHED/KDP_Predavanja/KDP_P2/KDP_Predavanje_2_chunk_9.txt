 I dojedimo dalih, onda ovo možemo da iskoristimo za rešavanje naših problema. In jedan je jednako true, last je jednako jedan i onda kada ja smem da uđim u kritičnu sekciju. Ja smem da uđim u kritičnu sekciju, ako, pa šta sad piša ovo? Nije in n2 or last jednako dva. A, a je pa noš, sad znači in 1 i n2? A, sad da se tu malo meni u odusnu prošli put. I n1 značilo, ja smem ušao u kritičnu sekciju. I n1 značilo proces 1 i ušao u kritičnu sekciju, i n2 proces 2 i ušao u kritičnu sekciju. Sada in 1 i n2 neoznačavaju da je neko ušao u kritičnu sekciju, nego ja želim da uđim u kritičnu sekciju. Dobro, ako ja želim, šta onda ovo ovde rečenice znači? In 1 je jednako true, proces 1 želi da uđi u kritičnu sekciju i last je jednako jedan. Proces 1 je stigao posledi. Kada proces 1 može uđi u kritičnu sekciju? Proces 1 može uđi u kritičnu sekciju ako je jedini, to znači, ove i drugi nije tražio, ili ako nije jedini, a da nije poslednji? Dobro, znači, to je sad jedan ustav koji mi je spitojmo. Kada mogu ući u kritičnu sekciju? Ako sam jedini od ova dva procesa, ono i drugi ne želi da koristi kritičnu sekciju, ili ako nisam jedini da je ono i drugi došao posledan? Tada ja smo mogući u kritičnu sekciju. I kada završim korišći je kritičnu sekcije, ja mogu da postavim tu svoj promenju in navredno s polska živija, nije koristi više kritičnu sekciju. Slično rješenje iz ovog drugu stranu samo su se promenili indexi. Znači, šta kaže proces 2 in 2 jednako trup, proces 2 žele da ući u kritičnu sekciju? Proces 2 je došao poslednji. A, wait, proces 1 ne koristi ili je proces 1 došao posledan? Ako je tako, ja mogu da proćim. Ako je lasti jednako jedan, to znači, ono i drugi je došao posledan, ja smem da ućim. I ovde sada možemo da naparimo fine grain rešenje. Znači, smem da je korst grain rešenje. Želim da to bude uslov. A sad nje pitanje, da li ovo možemo realizovati za poslednim čekanjem? Znači, transformacijom wait u najobičnih vajelom? Šta je učin, da je učin? Znači, šta je učin? Znači, šta je učin? Znači, poslednim čekanjem? Znači, transformacijom wait u najobičnih vajelom? Šta ovo ovde je čudno kaže? Vajel in 2 and last jednako jedan. Pitanje, da li ovde ispunjeno? Atmos, transproperti, mjoko, atmos, transproperti. Či i ista stvar samo iš govora u odusu na maločas. In 1, in 2, and last čačkao na drugi proces. Tako da ovde nema nikakvog govora o atmos, transproperti. Ali ovo rešenje radi. Ovo ovde rešenje radi, kako sad da dolazimo do toga? Da ovo ovde rešenje radi, tako što idemo i prođemo kroz sve moguće kombinacije. Znači, neko je bio zaludan, je zaludan. Ovo je vrlo jednostavno, če ono je koji ispitivo formalo, da li ovo ovde rešenje radi, kako se provera formalo, da li neko konkurent aplikacije radi? Vrlo jednostavno. Prođe se kroz sva moguće izvršavanja nekoj programmskog segmenta i ako u svakom izvršavanju programmskog segmenta program radi, onda program radi. Ako u bilokom izvršavanju programmskog segmenta dođe do nekoj neprimerenog ponašanja, a u ovom sluči to nije bezkonačno, u ovom sluči je to konača broj. Ta konačna brojka može još i da se proračuna. Znači, šta može da se desi in 1 palast, jednako 1 pa proveri in 2 pa proveri last i kako mogu tad ba da se učešljiv i nekoj je otišao i prošao kroz sve moguće varijante. I zaključuje da ovo ovde rešenje radi. Rešenje je bilo vrlo jednostavno kod ovogo ovde rešenja. Ja želim da koristim i ja sam došao poslednji. Otišli smo i postavili smo. Ja želim da koristim i poslijeg koje došao sam bio ja. To se malo razlikuje od onog ja sam došao poslednji. Ja sam došao poslednji, mi značilo ja u svoju lokalnu promenjivu upisam nešto, a ovako nisam upisam u svoju lokalnu promenjivu, nego u promenjivu koje upisuje, ne su pisuje koje došao poslijeg, nisam upisao svoj identificator. I ono što smo mi ovde videli je algoritm, to je nastavno sredinom 80-i godina, ovo je petersenova algoritm, taj brekjer algoritm. Znači nekad se zove taj brekjer algoritm, nekad se naziva petersenova algoritm, a za dva procesa koji treba da se synchronizu. Ovdje imate pokazano da ovo ovde radi kako treba. Kako smo transforvisali, ovo ovde nije ispunjeno atmosfans property, zato što imamo dve promenjive, s kojem ćemo nešto raditi. Što smo rektili samo uslov, kako smo prebacili, nije b, znači to sad primenimo demorganov u teoremu, znači sejste se ovo jedan demorganov od teorema, nije, ovde ovde je, in, dva, and, last, različito od dva, ili nije last jednako dva, znači to sad, zavisi gde želite da ostavite. Primenili smo samo demorganov u teoremu, znači kada se zablokiram, ako in, dva želi da koristi, a ja došao poslednji. Ako ona druga strana ne želi da koristi, ja smem, pa bez obzira da sam došao poslednji, ili nisam došao poslednji. Dobro i šta sa svojim radimo, šta su mogući iskodi. Mogući iskodi su da će jedno u dovolj dva procesa postaviti da je došao poslednji, koji god da je došao poslednji, a ako je došao poslednji, mora da se zablokira, ako nije jedini. Znači sad da dolazimo već do jednog malo, možda lepšeg uslova, a to je ja se zablokiram, ako sam poslednji, a nisam jedini. Sad neko možda kaže čekaj, ali kako je tu ima veze sa, poštim u dva procesa, to poslednije. I jedini. A viditimo na sljedećem času, da došto ćemo na sljedećem času želiti da transformišamo ovaj ovdje isti algoritm, tako da može da se primjeni na više procesa. Znači nina dva procesa kao sada što smo imali, nego želimo da primjenimo na n procesa. I tu će ovo ovde rečenice, koji sam ja sad rekao, a to je, ako mogu ući, moram se zablokirati, ako sam poslednji, a nisam jedini. To će u mi iskoristiti, da bi smo mogli da synchronizujemo veći broj procesa. Udo što smo danas radili, je bilo upoznavanje se terminima, šta je konkurentno programirana i šta je distribuerana, šta je deljena promenjava, kako to se funkcioniše. Ono smo se upoznali sa konceptom kritične sekcije među u stvarnom synchronizacijom. Kot kritične sekcije nama je bitno da rezultat odgovara nekom sekvencijalnom izvršavaju. Iće se taj izvršiti, propa taj, da se je učinit, i će se taj izvršiti, propa taj, ali nama bitno da se taj skup istrukcija izvrši nedeljivo. To sad ne znači da se oni možda izvršavati, da se neće izvršavati u paralelis nečim drugim, nego samo treba da rezultat tog izvršavanja odgovara nekom sekvencijalnom izvršavaju. Šta smo još videli? Da postoji nešto što se zove At most ones property i je postoji formalan dokaz, mišli ti mi nećemo staviti novom predmetu, a koje nam kaže, ako je ispunjeno da postoji at most ones property nama nije potrebna synchronizacija. A ako to nije ispunjeno, ne znači da programu treba dodat na synchronizacija. Ono smo mi videli kako ta synchronizacija možda se napravi. Videli smo dva algoritma. Na početku to je bio test and set, koji koristuje jednu specijalnu istrukciju i drugi algoritm koji to je bio test and set koji treba da upor za raš izvršavanje. Videli smo treći algoritm. To je bio Pattersonov odnosno Type Breaker algorithm za dva procesa. Ono što ćemo raditi na radne nedelje će biti Pattersonov algoritm za n procesa, taj Breaker za n procesa, onošto filterski algoritm za n procesa. To su se isti nazivi za jedan algoritm. Vidat ćemo algoritm koji se naziva Bakerie algorithm za dva procesa i za više procesa. Vidat ćemo Ticket algorithm CLH i Addersonov algorithm. To je nešto što je predliđeno za naradnu. Nedelju da prođemo kroz sve te synchronizacijone algoritme. Dalje možda imate nekih pitanja koja se odnosno se nagradivo koja smo do sada prešli? Pitajte nešto. Viši namarate sada. Po razmislite kada budete pogledali ovaj material, ono bi trebala se ne razlikujte puno u odnosno što bilo predkodne godine. Baremo ove uvodne prezentancije se nisu menjale.