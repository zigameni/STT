 Stravom, ovaj čas će biti posvjićen prikaz u rada cap alata koji služi za generisanje parsera. I vi ćete koristiti ovaj cap alat tokom izrde projekta, tako da ćemo ovo značiti tada. I ta alat cap konkretno generiše LR1 parser u javakodu u vidu da bez kontekst na antributim na translucionog grammatike. I ovaj primer će biti, to jest ovaj parser i njegov način rada će biti prikazan na nekoj prosti grammatici, gde je ideja da postoji niz izraza, niz aritmetirih izraza koji će pomoću vatributa i akcija da se izraču na onda. Nego, ovdje je prikazano kako bi to treba da funkcioniše da klimani izraza od vojnih tačnog zaraz i treba za svaki od njihoj onda se ispiše na izlazu rezultat. Ovo ću presklačiti za sada, užuštini samo se prikazuje kako treba da izgleda struktura, foldera gde ćemo ovo raditi. Ono što je bitno je da, mevo, kao što možete vidjeti ovde, na vrhu treba se nalaze biblioteke za generisanje s kenera i generisanje parsera, a u okviru ovog simplu podfoldera nam se nalaze specifikacije leksera i parsera. Takođe imamo ovaj ian java file, da ćemo sve ovopovezati i onda. Nel to ću se vratiti do duše kasnije. Ovdje je onda imamo prikaz kako izgleda specifikacija skenera, toh je leksera. Ovo se neću previš odubljivati jer je ovo ovdje bilo radjeno rane, užuštini bitno je šta sve od tokena ćemo prepoznavat. To su plus minus sve ovo oslobe užuštini računskie operacije i zagrade, tačka zaraz i na sve to ćemo prepoznavat i brojeve, koji će biti terminali, koji osječno sadrži informaciju o klasi, t.e. tipu terminala koji su sadržeće i dodatnije tribut koji sode specificira, a to će biti vrednost integera koji presveda taj terminal. Ovdje je onda ukratko obješljeno kako generalno ide specificiranje leksera. Da, ovdje imamo ovu import seksiju gde samo specificiramo da će se lekser nalazi u okru paketa simbol i da trasa importuje iz cap bibliotekje simbol klasa. Da i način simbol klasa predstavlja ovdje, to predstavlja ovaj token. E sada još jedna svar koja je možda biti na zanapomenu, a ima veze sa, istovrbemio i sa parserom, je ovaj ovdje segment, da se specificira da njih očemo da imamo cap interface. I da onda ovaj, da onda treba da se implementirava metoda next token. To je viša informacija za jaflex alat, da on zna kako treba da izgneriše to. So još svemu, to je neki kratak, kratak repuptilacija kako funkcioniše sam lekser. Mi ćemo sada da pređemo na to kako funkcioniše cap alat i kako izgleda specificacija cap file. Ovdje možemo vidjeti da ima nekoliko sekcija, kao što je to bio slučaj i kod leks fileva. Dakle opetimo package import sekciju, deklaraciju koristučku koda, deklaracije terminalnih i neterminalnih simbola, precedence deklaracije i grammatika. E pa dobro onda, sada ćemo doprođemo jednu po jednu sekciju i štao ne znače, tačno. Kao što možete vidjeti, nače, veći na ovih sekcija su neobovezno suštijeni, ma da vidite verovatno prilikomi zrde projekata i pisati te sekcije. U suštini, jedine dve sekcije koje su logično neopodne su deklaracije terminalnih i neterminalnih simbola i samo definisanje grammatike, to je svakako pojenta u galata, tako da ima smisla, moraju da budu obavezne. Odde onda imamo prikaz celog file'a, kako on izgleda i onda ovdje možemo u suštini da ukratko kažemo koja sekcija, kao što smo viće nagalim. Evo ovdje se može vjeti, zapravo neću odde da ga otvorim, nego ću u suštini file'u. U suštini, evo ovdje može se vidi ova prva sekcija gde se nalazi package import sekcije. E sada u ovom primjeru konkretno nije bila koriščeno na jedna sekcija gde se spominje da može se definishe kod, ali zato imam jedan drugi primer ovdje otvoren, da je mogu to da prikazem. Da je ovdje isto možete vidjeti da se nalazi ova import sekcija. Prvo da se vratim ja na prezentaciju, u suštini ovdje možete primjetiti da u okviru to koristničko kod posloje četri, tako da kažem pod sekciju okviru te sekcije. Pa to su ActionCode, ParcerCode, InitWit, and ScanWit. E pa dobro, čemu služi koja do ovih sekcija? Konkretno ActionCode vam služi da se dodaju neke informacije, to je su dodaju neke metode ili šta goda nam već treba, koje mogu onda da se dohvate iz samih akcija. Znači ako vam treba neku polje, sad ne znam zašto bi vam taču trebalo, iskreno nisam video primer za ovu sekciju nigde, ali teorecki ako biste tali neku polje da dohvatate iz akcija koje posloj u gramatici koristite, mogli biste to specificirate u okviru ove sekcije. U služitini sve akcije se u okviru poslimne klasse, koje se zove Parcer Actions, tu se ishendluje sva obrada akcija i onda bi se u teori i ova ActionCode sekcija prilepila dodatno u tu klasu koja se izgineriše korišćenje mog kapalata. To je što stiče ActionCode sekcije. Daljemo ParcerCode sekciju, ona radi slično stvar kao i ActionCode sekcija, samo što će se ovaj kod koji ukućen u toj Parcer koji se sekciju u ec u ovom, biti prelepiljena u Parcer Actions klasu ovdje će biti prelepljeno sam Parcer. Čemu ona može služiti konkretno pa ista logika kao i koji da ActionCode klas se služi za, ako hoćemo da redefinisamo neke metode, da konkretno su redefinisane metode za hendlovanje greški, naprije report error report fatal error tako dalje, i za dodavanje nekih dodatnih polja opet. Konkretno ero deducted je dodat koji onda služi da se zna da li je došlo do greški ili ne. Evo, mislim sad nije bitno tačo šta rade ovaj metode, u štini videte ćete to veći svami kroz izrtu projektu o konkretnu primer koji je uzat sa onih video snima koje ćete vi koristiti za nekodlatno poješnjenje, to kako da krjete sa projektom. Svako slučaju bitno je čisto da vidite kako izgleda deklare sani ove sekcije i bacivanje onda koder. Dobro, to što stiče Parcer kod sekcije, dalje imamo InitWidth sekciju koja služi i inicializaciju, neki inicializaciju nikoz. Naprimer, mislim, ovde iskoristili to da inicializujemo ouprame njovar to deklit with false. Dakle, ta sekcija se izvršava pre prvog čitanja tokijena ili se bola. I, evo ovde je navedajeno je še vam pri...
 skamer može se kreira instancac skena rata. Ili ja u kašto ovde određeno, dakle može samosinicializuje neka vaša promeljiva na način kako i želite. I za kraj imamo scan with section. Scan with section vam služi da se definiše kako kako se čitaju srčitini tokeni. Po defaultu verujem da se samo zove neks token metoda scannera. Z druge strane vi možete to dobrojite na način koji vi želite. Opet u ovom primjeru konkretno je iskorišća nova sekcija za neki ispiseto koji koji token je pročitan i neki informaciju o njemu. Ono što je bitno je da scan with sekcija treba se treba da se vrati, treba se završi sa return na redbom da se vracati od pročitanih simbolu. Dakle scan with sekcija ošernom služi čisto za čitani slajček simbola i po defaultu samo se čitaju slajči token. Dobro, to je što se tiče koristicu koda koji vi možete da ugradite i da onda malo izmenite parcer koji se gine reše. Dalje, slajča sekcija je deklaracija terminalnih simbola. Zapravo ne znašto je samo napisano terminalnih simbolu, u suštini odi se mislilo se verovatno da terminali ne terminalne simbole. Oni su u suštini deklarišu tako što se napisano ključa reći terminali non terminal i samo se onda ispišu svi redom simboli koji su terminali ili ne terminali naravno svaku odgvarećen delu. I još jedna interesanta svaru ovde bi mogla biti ovo integer. Šta ono radi? Pa ono u suštini vam znači da u suštini dodatku mogu integer, vista reklji da number ima tribut koji je tipa integer. Radili smo već atributivno translacijeno gramatiku, tako da ste već upoznatili sa konceptom atributa. U suštini mi smo samo specificirali ovim da terminal number ima atribut koji je tipa integer. A koji će to biti atribut, pa to je ono što smo videli u Lexaru, ovde to je konkretno ovo što smo odgledali. Dakle vredno samog simbola, odnosno integera koji se dobija tako što se pročita vrednost do kena. U stringu je ono se parsiru integer. Naravno, vi ovo možete raditi isto i za ne terminale, da je onda morate definisati u kako su dobija vrednost atributa, ali da je o tom potom. Da vidim, da imaš nešto, možete da sam... Što sam popustio, da, imeno ovvih atributa, pardon, ne atributa terminala, treba da... Če onda da se... može se videti u jednoj od izgenerisanih klasa, da je će biti to oddaljena konstanta svakom od ovih atributa i to je ono što se koristio od u Lexaru. Da, i da, treba logično da se poklapaju nazivi koji ste ovde naveli. Tako je ovo i način, tako će onda mapirati gde se našta misli. Dobro, to je što stiče sekcije deklaracija simbola. Da, dobro, ovde, pa kođer jećeno da postoje neke reči kako ne smije da se zovu ovi terminali i neterminalima da to već možete sami da pročitate, svakako videtećete reći to, u šteni neki od ključih reči samo, ne smije da budu i mena vaših neterminala. Dobro, je sada dolezimo do delu za smene. Kako se smene? Ovo je presen precedence, nam se ja sam to lepo izgovorio, to i delo ću preskočiti za sada. Mislim da bolje prvo da pređemo na delo sa grammatiku. Šti ni kako funkcioniše ona, kako, to jest funkcioniše definisanih grammatike, pa sličo kao što smo radili na vežbama, s leve strane stoji neterminal, z desne strane stoji smena. I ako ja neterminal ima više smena, možete da ih razdvojite tako što dodate ovu uspravnu liniju i tako nanižete onda kako se sve može zameniti taj neterminal. Tako da ne ja potrebe da više puto stavite ekspresion list i onda da napišete njegu u smenu, nego samo možete da ga razdvojite ovdje sa... novu smenu možete ovdje samo dodaite. Svaka smena, tvoj, svaka naredba tako da kažem za... zadefinisanje smeni za neterminal se završava sa tačkom zaraz, tonaviti sa boraviti, ove i ka palet će vam prijeviljivati grešku i da, move dvedbotačke jednako, tluže kao zamenu za... za ono strelicu što smo mi navezivan koji stvili, što sam preposljena da se mogli sami zaključite. Akcija kao što možete primetiti ovde se... se definišu u okviru ovih zagrada sa dve tačke, slično kao što smo i ovde definisali ove seccije koda i nazvom, da li imaš nešto tu redno pomena, da, još jedna bitna svar, atributi se imenuju tako što se stave dve tačke, pa ima atributa koji godoš elite i onda u okviru akcija možete ga iskoristiti. Ove i E1, dokvatite od ADE. Mora se pokljepa u ulične ime. E sa da, možete primetiti ovde postoji i ovaj result, pa što je result? Result je samo predefinisano ime koje se koristi za neterminal, za tribut neterminala koji se nalazi s leve strane te smene. Dakle, vi dodeljom ovaj result promenim, vi dodeljujete vrenu sa tributu expressiona koji se nalazi od sleve strane smene. Dobro, da, još jedna svar vredna pomena je, ne je grammatika kreća od, odnosno, da, start-neterminal kreće, podrzumevan od, kreće se dakle od prve smene i za njega se smatra podrzumevan od start-neterminal, ako to nije, može takođe i da se napiše start-vid, pa ime neterminal ako očete vi neki drugi neterminal da vam bude početni. Videljim ješ nešto, samo što se možete propustio. Još jedna, da, vredna, svar možda vredna pomena je da se akcije, akcije se izvršavaju tek nakon redukcije te smene. E sada to je ok, ako se akcija nalazi kao ovde na kraju sami smene, ali i drugi strane ako se ne nalazi na kraju smene, pravi se poseban neterminal za njog koji je prazan i onda će samo da se, tohce nije prazan, nego nema nikakve neterminala i terminala, nego ima samo tu akciju i onda se prelikom redukcije tog, neterminala, izvršava akcija, ovo je suštenija na poljska translacionog grammatika. Radljiste ovom već na predavanjima i ovo je jedan od uslova zabotom app parsere da podrža atributivno translacionog grammatiku. Tako da, to možete poglati tamo ještje talje nije, ako vas interesuje. Dobro, to je bilo.
 Usoštini što se tiče samog capfila, odnosno, filagde, grijte specifikaciju, gramatike i svega ostalo. Barim za sada, vrati ću se na njega, među vremenu. Sada, hajde vidimo kak u izgleda glavni program. On su program koji treba da poveže sve ovo. Usoštini šta vi oddeodredite, je da kreirate objika tipa parser. To je parser klasa koji se izgenerisati z ovog capfila, pomoć o lata cap. I šta on prima kroz konstruktor, prima u klasu, ne zna kako od izgoverim, y y leks. E šta je to? Pa to je, usoštini, ono što vam izgenerisan iz scanner, koji se dobija i pomoću J-flex alata. I onda ako pozavete funkciju parse, vi ćete drajiti parsiranje ovog zadate već gramatike, koja se konkretno ovde zadate sa standardnu guleza. Ova metoda parse inače kao povratnu vrednost vraća vrednost atributa startnog neterminala. Dakle da, konkretno ovde mogla da vrati vrednost integer ako je startnog neterminala. Duša je ko da nije to primer, pošto može biti nije zakspresjena. Da, nije zakspresjena list. Nema nikakvja tribut. Dakle da onda ništa nije povratna vrednost. Ništa vredno makro. Da vidim da li imaš nešto od vrednih pomena. Ovo je ovu što se nareko. Da, rečeno je da može baći exception jer parse metoda sada posebi može baći exception. Deepug parse takođe moguće napisati. I ako bi smo hteli malo detaljni rad parsera dobil mu na ispisu. Dobro ovde imate prikaz kojim redosledom treba se pokreći ovih file-ov i kako to izgleda sve vremenski. Ali to ćemo već sad videti sami tako da ne potreba da se previše bavimo tom slikom. Dobro, idemo da pređemo na samo isprobavanje ovih lata. Da vidimo da li zapravo ovo išta radi. Dobro, idemo da otorimo komandu liniju u okrvog foldera. Da pokrenemo ove komande koje su mi trašene. Učitini šta pravoradimo je da pomoću Jflex jar. Očemo da izgnerišamo scanner sklasu. Sve smo naš lekser videli da se ovako zove. Dakle, on kao ulazni parmeta primi leks file. Dobro, njegu to nešto ispisalo. I mi možemo viditi smo dobili ove leks klasa. Kao smo već traželi, vidimo da se izvodi da implementira interface scanner. Dobro, vi ono imate ovde gomilu stvari. Ono što vam je možda najpoznatio iz ovog gomila koda je ovva ovdje sekcija. Da se traže ove vraće ovi simboli. Kao što ste vi već definisali u okrvog leks file. Nakle on to radi ovdje. To prepoznavenje. Prepoznavenje Tokena. E sada, ova sync klasa još uvek ne postoji. I mi ćemo tu sync klasu dobiti pomoću parsera. Prvo moramo to dodarimo, aby nam zapravo se načilo išto od ovoga. Da idemo pređemo nazad na pokretanje naših halata. Šta kažem sveć, u zvrstini treba samo kap file napokrenimo. Sada ko nas je konkretno rugacizove da vas to ne zbuni. Odnači odnete da navajete ime vašeg kapalata, kako se već zove. Da znate koji držar pokrećite. Ovde specificiramo, u kom direktorima očemo da nam se nalazi output. Za kraju opet ubacojmo ulazni parametar, ime parsera. Ono sno ime file, da je napisa na specifikacija parsera. Dobro, onda je on ovde ispisal komilu stvari. Da vidimo šta nam izgenerisano. Zgenerisan je su nam dve klase sim java i parser java. Tako tu su klasa parsera i klasa sim. Ovde se nalaze sve konstante koji se koriste iz leksera. To su ovde klase. U okru parsera se nalazi se gomila stvari, učitini opet ono što je dobijeno u analiziranjem kapfajela koji smo mi pisali tamo. Da, ovde možemo da vidimo parser zection klasu. Samo sekund. Da je nađem da se nalazi ovo je ono trašnje klasa. Da, zašto bih sam tevao da vam prikažem? Pa zato što... Što je nije oču da vidite ove akcie da su zaista bila uzetu obzir. Samo da nalazim konkretno gde je. Što je nida? Ovde su bila obrađene zaista ove akcie koje smo mi tamo pisali. Naprimer, vidimo, ako bih odradio ovo. Evo, možete ovo da primjetiti. To je ono što smo mi napisali tamo. Da se naista nalazi ovde. Da, baš možemo da probamo šta akubi... Bi smo ovdje oprepisali u sekund koji smo, vidimo šta bi se desio. Pokrenemo opetsovo. Kako je par se izgleda? Najdaj reloadujemo. Da vidimo da se nalazi ovdje detectet. Pa da, nalazi. Što ni možete vidjeti pašo našto sam pričao na početku. Da se sve prelepilo. Isto bi, detentionisalo i za onda action code, sekciju code. Ne da je opet da vratim nogo staro. I dobro. Ski narisali smo onda i ove dve klasse. Da se specificiraju konstante za terminale. I da se sam par se definiše. Šta nam dalje kaže ovoj nizi istrukcija? Dobro, mi želim o sljedeće logiču da iskompiliramo sve ovo. I dobro to radimo tako što prosljemo ka classpath tekući direktorijom i cap biblioteku. I hoćemo da isparciramo, pardon, iskompiliramo računa i klasu. Da, i nače, ja smo od dve tačke izkoristili. Ovdje piše tačka za arez na linuku. Svim da je separator u okviru classpatha dve tačke, a da nam indus u tačka za arez. Ali svakako trebalo bi da je ista stvar. Kao što možete primjetiti da ovde obrno tako se crta bila ovde uandosu na ovu što sam ja piso. No nebito. Šta je bilo izgenerisano? Paj izgenerisano je klas file-ov iz svakod ovih klasa. Zašto smo mi samo prosljeli računa i klasu, pa ono u okviru sebe koristiove druge klase tako da će samim tim javac.
 javac je komanda prepoznati da treba i njih z kompailera istu u class file-ove. I dobro za kraj šta bi smo želi još duredimo, da preko komanda java pokrenemo izgenene s njih... klas file-ove, pa da. Ovo ima paketa, tačka, čule. I dobro, hajde da ispropamo na nekom primjeru onda. Stvore, ja sam početok sam ovom. Zajste napisu tri. Izgleda da radi. Ajmo na nekom malo težen primjeru. Šta sam u radji zbunio, ja sam gadao sam u nešću na ulazu, strelicu na gore što ga zbunilo onda. Ajmo. Ajmo, dobro, opravamo viši instrukcije. Na primjer. Dao, opravam, strelicu na levo, diskoristim što ga zbuni. Ajmo, 2x2, 2 plus 3. To je to. I u suštini, ni možete vidjeti da ovo radi kako treba. Da, i način je še nasvar vredna pomena. Ode na početku bilo spomenuto da se kao kraj ulaza označava cetrlaza. To je u suštini način kako se prepoznaje kraj. Sequence jer na standardnom ulazu, send, file, verovatno prepoznaje kao cetrlaza. Na linux konkretno sam jacetrla da koristio ako je kome. To bode značilo, bode ispobavao ovoj primer. Dobro, mislja sa stigo do olde. Na, u štini vi možete vidjeti da to radi sve super. Mada ima par svarih koji još moraju da se spomenu. Dobro, ovde možete vidjeti da biliko možete poziviti kapalata da može i dum states. Da se dodakav dodatna opcija. Ajmo da ispobamo da vidimo šta bi jo radila. Smeljepno napisno. Aha, mora dođa crta. Možete da je išto stvo interesanta. Da vam možete proslidživanjem help. Dobijete opcije. To su nije on prepozna help. Gledno da, samo ako ne prepozna nešto će vam ispisati šta sve možete proslediti kako pread izgleda ta komanda. No nebitno. Evo ako bih dum states posledio. Aha, treba jedna crta se samo. Dobijete detaljni prikaz kako se kako izgledalo analiziranje parsera koji ste napisali. Da, obi onda moglo da vam znači u slučaju da imate neki konflikt da vidite gde su on taršu upetljava. E, dobro, ajde se vratim ja sad na onej del ukro cap file koji samo slodužam da nisam objasnuju čemu to služi. Ima ovaj precedentsiz del. Čemu on služi? On služi učitini da možete definišete priorite terminala. I takođe da možete definiti se ti asocijativnosti iz tih terminala. Čemu ovo služi? Ajde, probamo da izbrišamo tu sekciju kako što nam je bilo predloženo od strane ovoj slijdem i da vam se da se tjede. Aha, 25 konflikta je detektovan. I samim ti nikakav kod nismo dobeli. Pa zašto se ovo desilo? Ajde, da se vratimo na to kako izgleda uopšta ova grammatika. Ono što možete primetiti i ovdje je da možete primetiti dve stvari. Možete primetiti da pre svega vi ne zate koja se citimnost ovih operatora na osnovu ove ovde smene. Dakle, ne zate da li treba leva ili desna cistitivnost da bude. Na on slide-u konkretno se bolje vidi ovo što sam treba da vam kažem. Ako biste imali na primer 1, 2, 3, mi ne biste znali da li biste po om prvom, tako da kažem malo lajčki rečen, ali po om prvom ekspresu treba da rastavite stabilo i ovaj izrazili po desno. O to mi služiji u suštini precedence left. On govori koja je treba da bude asocijativnost ove smene. Dakle, kako to funkcioniš da je? O ovdima je malo detaljnije prikazano da bi došlo do shift reduce konflikta. Štini ne bi znalo da li treba da reduce su je ili da shiftuje dalje. Da, svaka koja je to vam je prikazano na tom deliču ove tabele. Da je ovo narao nije kompletna tabela koja je bi se to bilo iz ove specivigacije gramatike. Pritom ima neke default način i kako razrešao konflikti i šta gleda kao prioritetnije. I onda ako biste vi prosvedili expectveni 5, on bi to sam uspoda razreši, ali prosvediti da, ako prosvedite, da ovo baš če možemo da poglamo. Šta radi expect? Aha, koliko konflikte očekujemo, podrozumimo. I onda vi znate, ok, ja ću meti tvoje ispete konflikta, prosvediti taj broj i možete tako da ga da pustite, da se izglediše kod, ako je bilo nekih shift radiuz konflikta ili radiuz radiuz konflikta. No nebitno svakako ove nešto što vam ne preporučujemo nije baš najbolji način. Niste baš ispremogramatiku onda napisali ako propustite ovako nešto. Tako da gledite vi to da razrešite nekako, a ne ovako to zovebil azite. Tako da nije nibitno, kako ka file, mi sim pišavam ovde, kako on to gleda s kojim prioritetima, ali svakako on to podrezueno rešava, no ajmo mi je svratimo na to kako su to može rešiti. Dakle šta sam spomeno? Pa da. Da, ono što sam izpomeno je da postoje dve stvari ovde. Postoje i stvar da mi ne zamo kako, dakle treba da se razvija ovo stavlo, što sam tamo pokazal i onda vam služi tome ova precedenslet. Tako kažem, specijivikacija, taj tu segment i deste vi onda rekli da plusi minus imaju levo asociativnost. E, šta to onda znači? Pa tamo ti napišete plus, ta smena će dobiti istutu asociativnost, tako da će znati da treba da se po ovom ovde ekspresšinu radi rastvene stabla. Da, evo to ovde možete vidjeti, konkretno šta će sam parser onda da radi, da konkretno ako on dođe do tog konflikta, moj vej, u slučaju da je leva asociativnost, on će da radi rigiust, svako je desno onda će da radi šift. E, sada druga stvar koja je vredna pomena je ovde da treba da se definišu prioriteti. Dakle, mi prese goćemo da definišemo da puta i podeljenu treba da budu, na primjer, i, o, ok, moj da treba da budu prioritetnih, odnosno plusi minus. E, pa to vam se opet definiše tako što pomoć ovoj precedens, dakle, dela, vi ne samo da definišete asociativnost, također definišete prioritete. Pa tako ovdje, ako kažete precedens left plusi minus, vi ste reka da plusi minus imaju isti prioritet. E, sada sve što napišate ispod toga, to će imati veći prioritet u dolog iznad. Tako da precedens left times divide mod kaže da...
 Puta podeljeno i mod imaju isti priorite medjusno, ali imaju veći priorite do plus i minus. I onda, kako parcer to internog leda je da usločuju da dođe te konfliktne situacije, na primjer, ako je bilo nezna nija 1 puta 2 plus 3 u tom primjeru konkretnom, on će znaći da je plus, znači on je procesirala 1 puta 2, znaći da je plus manje prioritet od puta i onda znađa treba da radi djus u odnusu na shift. U slučaju da je na primjer 1 plus 2 puta 3, onda znađa treba da radi shift talje. Zašto ovako treba to funkcioniše? Pa zato što, ako vi očite radi shift u slučaju, tako implicitno kažete, ne, nemo još da mi sabiraš 1 i 2, to ne treba da se spoji, treba da sačekaš da viš dalima, neče, treba da sačekaš još, jer si najšlo na puta. A, i dobro onda suuprotno važi znači, ako vidimo da je plus dalje, a imam puta, treba puta odmada redu koje mi je reputa dosta prioritetnije odnosno plus. Dobro, i to što stičete president sekcije. Da, još jedna je to stvar vrenna pomena, terminali koji se nepojevo president z deklaracijom i najnižji prioritet, je to, još nešto vrenno pomena. I može takođe pomoći ovog procena predstva se dodali, dodali prioritet nekoj smeni, naprim. ovdje, ovdje, avokonkretno mi smo rekli da dobija ovu prioritet terminala t ova smena. Dobro za kraj je preosto del, da se prikazuje kako funkcioniše prijevljivanje grešaka i kako generalno ide. U porava kojih potencijalan, dakle, ovdje možete vidjeti, ako naprim. pokrenemo za... ne, ne, šta se možete ovdje ovdje. Ako nešto netarču unese, možete primjetiti da će se prekinuti iz uršavanje našeg programa koji prijime ovdje ulazne i izraze i takođe se neće izvršiti isprenoparsiranje. Dobro, je sada každa osta već videli rani je uokvjerno, onog parser kodisakcija su sredi finisvali neki od ovih metoda. Nehću zavici previšu detalji, oko ovoga možete već počizati ovdje čemu koja je od ovih funkcija služa, očeno štini ideje da se one zovu prilikom izpisa grašaka i preizpisa stacktrace. Međutim, mi ne želimo da se ovdje še ovo da smo tamo videli, mi želimo da opet omogoćemo neku vrstoporavka grašaka. I zato nam služi taj predfinisan i neterminal error koji se onda može doati uokvjerv jednih od smena. To je skala jedna posebna smena za neterminal i radići to mi vršimo neku vrstu e-error handlinga. U štini mi možemo da faktički ignoriše to što je netačno i da nastavite s procesiranjem. Ovo će onda mogućiti da nam neće pući parsera. Kao što to bilo ovom primjeru, samo ja sam vam da radim. Dobro, mi moramo prvo opet parsera da pokrenemo. To je analizu parsera preko ovog kapalata. Dalje moramo opet da iskumpaileramo sve java fileove, tako da pokrećemo opet java c i sada možemo da pokrenemo alat našu klasu računaj i idemo da izpravimo da imaš šta će zdesiti ako ugucamo ovako nešto. Evo, što možete primjetiti ovdje? Zbog ove smene error, on je uspode izignoriše ovu ovde smenu. To je s neogu smenu, zapravo da, smenu. Pomaču te smene on je uspode izignoriše činjenicu da je ovo neizpranu, nije uspelo dobro da isparsira, nego prežo samo dalje, na 2 plus 2. I to je uspode izračunaj onda kako treba. Naprimer, ako bih vuna opet samo ovo, ja ovaj vidite da bi to rezultavalo samo izpis u greške, ali sve vremeni mi radi još uvek, parsir. I to bi bilo to u štini. Dakle, ošem da ponovim ove i kap alat ćete koristiti prilikom izrde projekta, do duše na malo drugačiji način, odnosno ovo što mi je bilo prikazano, ovde imate snimke na sajdu prednjeta, da će vam biti prikazano u konformatu, ćete tačno koristiti parsir tamo. Dakle, vi u ovi prilikom izrde projekta nećete imati akcije, to jestima ćete akcije, ali za veoma selectnih stvari, tako da ovaj, generalno ćete drugačije malo raiti stvari, z druge strane, ovo što vam je ovde bilo prikazano, može doći na ispitu, tako da nije, nije bilo beskorisno. Tako da to bi bilo to, pozdrav.
