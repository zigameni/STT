 da se lokalim promenjima ne može ništa mi se promenju u među vremenu. Dokle čekam, dokle god neko baš mene ne pusti da idem dalje, odnosno na tom slotu na kojem ja čekam ne bude vrednostru. Kad ja završim posao šta smo rekli da treba dodrediti? Ja kažem, ja više ne čekam. Ja više ne čekam i pustim prvog narednog da može da uđe u kritičnu sekciju. A o čemu još treba voditi račuvana? Kako inicializovati ovo o ovde sve? A svi su postavljeni na vrednost false osim prvog koji je dobio vrednostru. Znači ne mojte zaboraviti kako ovo ovde treba da se inicializuje. Prvi treba da ima mogućnost da uđi u kritičnu sekciju. I sad nje pitanje, kako ovaj ovde algoritm realizovati kao fine grain rešenje? Ovdje imamo tri neka dela koje su coarse grain. Dalje možda moguće ovdje odmah samo da se skloni za grijice, pa moramo da razmišljamo. A do sada smo imali ovde koračima se radi samo po jedna jedina akciju. To dodela neke vrednosti. A sada imamo dve akcije nad deljelim promenijoma. Sad nje pitanje, dali to sme da se odradi o tako što se samo eliminishe a ovde već je manje znak koji signalizira da se to radi atomski. Ajde vidjeti? Maj slot je jednako, da će da je fn.net slot plus 1. Dobro, onda to odradimo po modu 1 plus 1. Ovo je ovde delo sada. Radimo samo nad lokalnim promenijom. To je vrednost koji smo dobili, pa po modu 1 plus 1. Tu su se lokalne promenjive. Tako da izračunavanje, ovog maj slot je relativno jednostavno. Odradili smo fn.net. To je ovdje operacija increment u stvari, zato što smo većavali za 1. Nad promenijom slot, taj slot smo odradili po modu 1, uvećali za 1. Dokle čekam. While not flag od maj slot. Dakle god neko, baš meni ne da dozvalu da radim, ja čekam. Kad ja dobijam dozvalu da radim, ja sam dobio dozvalu da radim, nema nikodrugiko smo je da radim. Ja ulazim u kritičnu sekciju, a onda izlazni protokol kaže, flag od maj slot je jednako false, flag od maj slot pomodu 1 plus 1. Prvi naredni. Je jednako true. Pustam prvog narednu. Sada jedna velika napomenam. Ovo dva. Ne smiju da zamene mesta. Ne smijem prvo da pustim prvi naredni proces, a onda da ukijnem sebi dozvalu. Jer se može desiti da ispadne rešenje koje nije ispravno. Zamislite da imamo 3 samo slota? Ovde imam vrednost true. Ovi ostali su postavljene na vrednost false. Ako imam 3 slota, imam 3 procesa. Može se desiti da ja došao, koristio, postavio na vrednost true i ja postavim ovogo ovde na true. Tu je neko čekao. Ok, taj neko će moći da prođe. A dođe još neko, taj će sačekati. A ona i treći se po... Znači, što sam sad rekao? Ajde, ponojim. Proces broj jedan je bio ovde. Onda je došao p2, pa je došao tu možda, pa je došao p3 koji će doći tu, a mi ovde imamo još jednu vrednost true. Šta će se desiti? Da, slučajno, ako ovaj p2... Može se desiti da p2 završi, p2 završi, pa p2 dođe o ovde ponovog, da tu čekaj, i odostan u brzu je odradio to sa ov posao, i on će ponovog ući u kritičnu sekciju, nećemo imati a one naš FIFO od maločas, on će proći i koo znaš, taj će ovde nastati sada kao situacije. Možda nastane i deadlog, a izgubili smo FIFO rednostljot. Ovde je bitno, a odnosno uveku synchronizaciji je bitno, da mi prvo ukinemo neku dozvolu koje smo imali, a onda nekom novom da damo dozvolu. To ćemo imati i kada budemo radili sa semaforima, a to će se zvati preda štafetne palice, prvo mi završimo sve šta imamo, a onda nekom drugom prenesemo pravo, e, evo ti sada ti imaš pravo. Prvo sebi ukinemo, a onda damo nekom drugom. Nemojte da damo nekom drugom, a ja još uvek nisam ukinu o sebi pravo. Jeste da će se to desiti vrlo brzo, ali to vrlo brzo kada se umešla scheduler, ne mora da bude baš tako brzo. Može da nastane neka bezvezna situacija. I ovdje smo mi završili Andresenovog algoritma, značujete, imamo jedan iz i puštamo prvog narednog samog, gde neko čeka. Znači svako čeka na narednoj pozici u slotu, znači nisu pozice prema identifikatoru, nego su pozicija prema redosledu dolazka. Ako su pozicije prema redosledu dolazaka, dobro, to je u redu. Samo što moramo da vodimo računa, da prvo ukinemo sevi privilegije, pa onda nekom narednom nam dozvolimo da radi nešto. I ovaj algoritm ćemo koristiti i kada budemo radili sa semaforima, da obezbedimo FIFA poreda. U stuštini i ove naredne algoritme koji ćemo raditi na početku narednog algoritma, na početku narednog časa ćemo koristiti za synchronizaciju. Kad budemo koristili i semafore i neki drugi stvari, jedan umogućava da to odradimo relativno eleganno. Šta je bilo mana ovoga ovde rešenja koji smo sad posmatrali? I dalje zahteva poznavanje informaciju o tome koliko ima proces. Ovde moramo da znamo koliko procesa postoji. 1, 2, 3, 4, 10 procesa postoji, to moramo znati. Moramo da imamo niz koji je određen prema broju naših procesa. Pitanje ili može bez toga? I prvi naredni algoritm koji ćemo razmatrati posled pauze, cel ha algoritm razrešava problem, a ovaj da nemoramo možda znati broj procesa, a da ipak možemo da napravo synchronizaciju. Dalimate nekih pitanja? Nako nemate pitanja? Pauzam.