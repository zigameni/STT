 da će to zavisju od aspiracija o nogakubude projektovao programski jesik. Šta ćemo imati s ovi semaforima? Pa oni će biti... Ako taj semafor može da ima vredno samo 0 ili 1, to će se zvati binarni semafor. Ok, ajde da koristimo semafor. Kako ćemo razrešiti prvi synchronizacijoni problem? To je... Šta je prvi synchronizacijoni problem? Medjusobno isključivanje. Sve ono što smo radili pred konih... Št... 3-6 časova. Kako razrešavamo koristići semafore? Vrlo jednostavno. Uvajt, mutex, kritička sekcija, signal mutex. Mutex je binarni semafor koji se inicializuje na početnu vrednost 1. I na ovoj način smo mi razrešili prvi, osnovni, synchronizacijoni problem. To je kritična sekcija. Privijalno se razrešava koristići semafore. Kritična sekcija koristite 1 deljeni semafor koji se inicializuje na početnu vrednost 1. I onda kašite, weight mutex, čekate dok li godi internu ne postane veći od 0, čim postane već... Ili nekad kad postane veći od 0, to se umanji za 1, to se se odradi nedeljivo. Kako je napravljim semafor? Ne znamo. Šta radi u kritičnu sekciju? Tu smo 1 jedini proces. Na kraju kad zvašimo posao odredimo signal. To signal će verovatno prebaciti nekoji z neke liste blokiranih u neku listu aktivih, ali ne mora tako da se realizuje. Ako je monitor stariji od semafora, vidjet ćemo šta se dešava u javi kad budemo došli do monitora u programskom jeziku java. Či sad smo videli prvi problem. To je međusobno isključivanje. Ono što ćemo sada da razmatremo je problem... ...projzođača i potrošača. Problem projzođača i potrošača nije samo problem međusobno isključivanja. A ne smel se desiti da pojzođač i potrošač isto ovremeno pristupaju u nekom resursu. Ali ovaj ovde je problem. Ja ne bih mogu o sada da rešim tako što bi stavio ovde wait-view-tex. I ovde dole signal mutex. I ovde dole wait-mutex. To ne bih radilo. Ove smo obezbedili međusobno isključivanje. Ali nismo obezbedili da nakon potrošača dođe projzođač. I da nakon potrošača dođe potrošač. A mi ovde moramo da obezbedimo. A redosled po kome neko pristupa našem resursu. Nije nam bitno da se obezbedimo. Nije nam bitno samo ne sme niko. Dok sam ja, a posle mene kogu doće. Ne, ovde nam je bitno. Ko dolazi posle mene? Ne sme niko dok sam ja, pošte za sada tako problem. A drugo stvari je posle mene mora i onda tačno kažemo ko mora. Ovo ovde je problem gde rešamo koristići jednoj elementni prihvatnik. Ovo ovde je producer Koziumer koristići jednoj elementni buffer. Dobro, onda ćemo uzeti, ajde da vidimo kako možemo razrešiti ovaj naš problem. I problem nećemo razrešiti koristići jedan semafor. Nego ćemo koristiti dva semafora koji štite isti resurs. Ovo i ovde buffer, kome mi pristupamo, neće štiti jednoj elementni buffer. Neće štiti jedan semafor, nego će ga štiti dva semafora. To će biti posebni semafori. Dva semafora štite isti resurs. To su semafori koji imaju poseba naziv, to su raspodeljeni binarni semafori. Tako da ću ja ovde ovde dobrošam, nećemo čekati na miotexu. Nego ćemo izkoristiti dva semafora. Šta ćemo raditi? Wait, dok le čekamo. Kad smemo dobacimo nešto, kad je prazam buffer empty. Kada signa... Šta radimo sa... Šta ovaj čeka? Wait full, čeka dok buffer ne postane full. Šta ovaj oba veštava? Signal full. Šta ovaj radi? Signal empty. I kako smo mi ovo ovde rešenje napravili? Napravili smo rešenje gdje imamo dva semafora. Full. I empty. Full je postavljeno na početnu vrednost nula. Empty je postavljeno na početnu vrednost 1. Ova dva semafora. Oba semafora. Štite, pristup do jedne promenjive, do promenjive buffer. Tako da, ova ovde dva semafora. Nama prave medjusobno isključivanje. Ali nešto, samo što nam prave medjusobno isključivanje. Oni prave uslovnu synchronizaciju. Kada odradi ovaj ovde, on pušta tog dole. Kad taj dole odradi, on pušta ovogo ovde. Tako da mi možemo... da iskoristimo veći broj semafora koji će štititi jednu tistu promenjivu. Ali ti semafori će biti tako raspoređeni da... nisu svi semafori istovrebeno postavljeni na vrednost 1. Ono zna, maksimalno jedan semafori je postavljeni na vrednost 1. E, ako tako nešto imamo, to su raspodeljeni binarni semafori. Mi ćemo se vratiti na te raspodeljeni binarni semafori tehniku prede štafetne palice naredne nedelje. To je jedna od veoma efikasnih i jedna, kažem, univerzalna tehnika koju možete primenivati za rešavanje problema sa semaforima. A vrlo jednostavna tehnika koja vam omugućava da razrešite sve synchronizacione probleme. Samo da, mislim, kažem, to skoro postoje mogućemo da neko pogreši kad nešto rešava, ali tehnika, kao tehnika, je nešto što će nam omugućiti da razrešimo sve naše synchronizacione probleme. Mošemo da napravimo neki drugi synchronizacijni problem kad budemo koristili ako ne pazimo, ali ovo je generalna tehnika koja se uvek posne može primenivati. Znači to su raspodeljeni binarni semafori i prede štafetne palice. Šta smo rekli, proizvođače i potrošače možemo razrešiti koristići ovakava dva semafora. I ukoliko je proizvod takav da se redko pravi, ali čim se napravi da on može da se potroši, ovdje je više nego dovoljno rešenje. Znači naš problem, proizvođača i potrošača, ovdje mogao da se završi i da kažemo, nema boljeg rešenja od ovog kojom smo mi napravili, ukoliko nešto rećko pravi, a čim se napravi, to se brzo potroši. Znači ako je takva situacija, ovo rešenje je super. Ali, sve onda vidimo kako izgleda malo lepše rešenje, ja sam malo tamo zbrđao, nešto ne pišem lepo, znači sve smo rekli, weight empty, signal full. Za koliko proizvođača ovo rešenje radi? Za koliko potrošača ovo rešenje radi? U suštini nebitanje broje proizvođača i potrošača. Ovo ovako napisano rešenje, radi za proizvoljant broje, proizvođača i potrošača, rešenje radi uvek. A, sve dje pitanje, a je dovoljno dobro? To zavisi od konkretne situacije, gde se nešto koristi. Ako je situacija takva, da se nešto redko proizvodi, a da se čim se proizvede potroši, a onda ovo ovde rešenje da kažem idealno, vrlo jednostavno, nema mnogo semafora, nema mnogo synchronizacija. Ali, ako to nije slučaj, ako postoje neke zaliche, ako postoji, ja sam proizvio nešto, a ne mogu da ubacim tu buffer, zato što neko to nije potrošio. Ako takav slučaju, onda ovo naše rešenje baš i nevalja. Nije dovoljno dobro, ono radi kod konkurentog programiranju. U slukodilu, kog programiranje treba da razvojite. Rešenje koje radi, neputca, neblokira, nije da će ono bez konocu neblokirali, tako nešto bez veza da napravi. Ne, ovo ovde rešenje se nikada neće zablokirati bez konocu, da se proizvodi, da će nema deadlocka, nema livelocka, nema izgledivinja, radi fino. Ali ne podržava konkurentnost procesa koji mogu da se izvršavaju. I na ovom predmetu, ne samo