Dobar dan i dobrodošli na predavanje iz predmeta Konkurentno i distribuirano programiranje. Ja sam Zaharije Radivojević i na današnjem času ćemo se upoznati sa predmetom Konkurentno i distribuirano programiranje. Pogledaćemo kako je predmet organizovan, koje su ispitne i predispitne obaveze, da li ima dovoljno literature i uopšte kako izgleda organizacija predmeta.

Krenućemo redom. Prvo ćemo definisati uvod, odnosno reći ćemo nešto o predmetu, ciljevima i ishodima. Šta je to što treba da znate nakon ovog predmeta? Ko drži vežbe i predavanja na ovom predmetu? Zatim ćemo detaljno proći kroz program predmeta, šta se radi u kojoj trećini predmeta i kako je to povezano sa onim što ćete možda nekada videti u praksi. Da li ćete ovo i kada koristiti, koje delove ćete koristiti? Jer, konkurentno i distribuirano programiranje je nešto što se stalno razvija. Nemaju svi jezici od prve verzije sve ono što ćemo mi raditi na ovom predmetu. Nemaju svi jezici čak ni u poslednjoj verziji sve ono što ćemo raditi na ovom predmetu. Ali, mi ćemo ovde proći kroz više različitih paradigmi kako sinhronizacija može da se obavlja. Više različitih načina kako sinhronizacija može da se obavlja. Razlog zašto ćemo proći kroz više paradigmi je taj što nikad ne znamo šta će se pojaviti u nekom novom programskom jeziku, a što može da olakša ili da oteža sinhronizaciju.

Synchronizacija sama po sebi nije baš toliko jednostavna. Zbog toga ćemo mi morati malo da je, ne da kažemo uprostimo, nego da vidimo kako problem koji imamo da svedemo na neki poznati problem. Hoćemo da prepoznajemo neke delove koda koji se negde pojavljuju, neke karakteristične slučajeve koji se negde pojavljuju i da probamo njih da primenimo. Mislim, ovo ovde je projekat, u stvari, ono u smislu kako ste vi to možda slušali na nekom predmetu. Ovo ovde je više uputstvo kako vi da iseckate taj vaš problem koji imate na neke delove koje posle umete da rešavate. Videćemo šta su to stvari koje ćemo stvarno isprobavati od ovog laboratorijskog rada, jer kao što sam maločas rekao, nemaju svi programski jezici u svojoj strukturi mogućnost za kompletno podržavanje sinhronizacija koje ćemo imati na ovom predmetu. Ovo ovde je dostupno, ali nije jednostavno. Jednostavno nisu napravili sve moguće varijante, jednostavno rekli su. Ovo ovde što imamo je dovoljno da bi moglo da se odradi neki sinhronizacioni posao. Pa, hajde da krenemo deo po deo. Predmet se naziva Konkurentno i Distribuirano programiranje. Kako da nateramo više niti na jednom računaru da rade isti posao? Da ih sinhronizujemo. Tako da, kod konkurentnog programiranja ćemo mi u stvari podrazumevati programiranje koristeći deljene promenljive. Svi procesi, sve niti. To nisu sinonimi. Da li nam je svejedno sa stanovišta konkurentnog programiranja, da li su to procesi ili niti? Vi ste sa stanovišta operativnog sistema videli da postoje razlike. Ovde ćemo probati da vidimo da li nas baš briga za tu razliku ili ne. Da li postoje mehanizmi koji treba da nam omoguće da to funkcioniše bez obzira da li se radi o procesima ili nitima. Kod samog konkurentnog programiranja ćemo imati programiranje, gde ćemo imati potpuno nezavisne neke celine koje će komunicirati razmenom poruka. To će najčešće biti više računara. Kod konkurentnog programiranja sinhronizujemo se na jednom računaru. Kod distribuiranog programiranja sinhronizujemo više računara da rade neki posao.


Može li postojati distribuirano programiranje na jednom računaru? Može. Ako budete radili i slušali o programiranju mobilnih uređaja, tamo je komunikacija između procesa realizovana razmenom poruka. Baš na ovaj način kako ćemo mi koristiti ovde, gde ćemo imati razmenu poruka, interprocess communication, imaćemo neko osluškivanje događaja. Ovako kako mi budemo ovde radili, tako su oni u stvari implementirali komunikaciju između procesa koji su zatvoreni, koji nemaju ništa deljeno.

Predmet je na trećoj godini, u šestom semestru. Dobro mesto za pozicioniranje ovog predmeta. Nije ni previše rano, nije ni previše kasno. Odslušali ste i Objektno orijentisano programiranje 1 i 2 i Operativne sisteme. Upoznali ste se sa dovoljnim brojem koncepata koji mogu da vam pomognu oko razumevanja kako to na računaru funkcioniše. Prošli ste i kroz Arhitekturu računara. Videćemo da će nam i to biti potrebno. Znači, šta je koncept virtuelne memorije. Tako da su to sve neke sitnice koje treba da nama da olakšaju konkurentno, a posle i distribuirano programiranje.

Nama ovo ovde sve treba da radi. Treba da radi brzo. Samo pitanje, a šta je ovo ovde što treba da radi? E mislim, na ovom predmetu konkurentno i distribuirano programiranje nećemo se baviti, uglavnom se nećemo baviti samim poslom koji treba da se obavi. Nego ćemo se baviti sinhronizacijom i komunikacijom između procesa. Na nekom drugom predmetu ćete slušati i gledati kako da isprogramirate da se neki posao odradi. Ovde ćemo samo da sinhronizujemo da ti poslovi mogu da se rade u paraleli, da iskoriste to što imate na računaru 4 jezgra, 8 ili 10 jezgara, koliko već imate. Hoćete da iskoristite to što već imate gomilu jezgara da vama program može da radi brže. Jer ste dali pare da kupite bolji računar, ako program neće da vam radi brže. Sam po sebi program neće da se ubrza ako to ona i što ga je programiralo nije predvidelo da može da iskoristi ta sva jezgra.

Kako izgleda fond časova? Imamo 2 časa predavanja, 2 časa vežbi i 1 čas laboratorijskih vežbi u proseku na ovom predmetu. Prve 2 nedelje ili tako nešto ćemo imati samo predavanja. Pošto ćemo na početku na ovom predmetu proći kroz jedan deo koji se ne obrađuje toliko na vežbama. Videćete da će se to posle možda malo obrađivati na vežbama kad budemo došli do konkretnog programskog jezika.

Ali za sada ćemo prve dve nedelje imati samo predavanja. Posle će doći i vežbe. Dva časa laboratorijskih vežbi, jedan čas u proseku, ali to neće biti organizovano kao jedan čas u proseku, nego ćemo imati deo vežbi koji su pokazne, gde ćemo vas upoznati malo sa korišćenjem odgovarajućeg alata i proći ćemo kroz nekoliko primera. To o prolaženju kroz primere će u suštini biti takvo da će neko od nas kucati kod, verovatno ćete imati i malo posla koji treba da se uradi, deo sinhronizacije. Nećemo praviti samo sinhronizaciju, nego ćemo raditi i neki posao da bismo imali šta i koga da sinhronizujemo. Nekada je dosta teško studentima kad prvi put krenu da programiraju ovo konkurentno, distributivno, nešto... A šta je taj posao koji treba da se uradi? Koga ja to treba da sinhronizujem? Nego su navikli da prave aplikaciju. I onda bi za te laboratorijske vežbe bilo dobro da studenti naprave i relativno jednostavnu aplikaciju koja će da iskoristi mogućnosti rada sa više niti, odnosno rada na više računara tog našeg programa koji budemo pravili. Predmet nosi ukupno 6 kredita. I ovde dole piše da je potrebno da je za metod slušanja predmeta objektno retisano programiranje 2 i operativni sistemi 1. A to u prevodu možete značiti programski jezik Java. I što se tiče operativnih sistema, da budete upoznati sa konceptima monitora, semafora, kako to radi u pozadini. Znači, to je da budete upoznati kako to radi, kako se prave niti. Ali nas to uopšte ovde neće zanimati. Nas ovde baš briga kako operativni sistem parkira niti, isparkirava ih, kreira, šta će stavljati u proces kontrol blok, to nas baš briga. A mi ćemo ovde krenuti od pretpostavke da to postoji. Mi ćemo to ovde koristiti za sinhronizaciju. Nećemo praviti taj mehanizam, to ste pravili na operativnim sistemima, izvukli ste taj zanat kako se to pravi.