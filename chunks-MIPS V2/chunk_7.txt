 budu sve sekcije ulazne koje počinju sa tačka date. Locacije da će se ovo smestati ćemo definisati uspomoć memoriskih regiona. Nekat tu sad bude neki region prvi. S atributima read write i execute origin nekamu bude na primer 0x222200 i dužina neka bude 32 kilo. Defini saćemo još nekoliko regiona, neka za početak bude samo još jedan. Neko ovo bude sad drugi region i neka njegovah adresa na primer bude 444444444. I sad ćemo smestiti ovaj u izlznu sekciju program u prvi region a ovu drugu u region drugi. Ako sad samo još ovoda sačuamo, neka to bude lemascript.led I sad ćemo izvršiti prvo asembliranje ovog našeg lema.s filea. Dakle neka to bude arm non eabi gcc.exe minus c je za asembliranje, minus m cpu je cortex m3 minus mtumb minus o neka bude neks isto zove lema.o i ulaz je lema.s. Dobro, ovde nam se asembr samo bude jer nema nove linije, to ćemo do dodamo. Ope ćemo izvršiti prevađenje, nemo nikakih warninga. Sad ćemo izvršiti povezivanje. Dakle arm non eabi ld.exe minus minus script je lema.script.led izlaz je lema.elf i ulaz je lema.o Sad možemo da naprijemo još jedan hex file, dakle arm non eabi obejo copy minus o je intelhex, ulazni file je lema.elf i ulaz nje lema.hex Ako pogledamo kak ulaz na lema.hex, vidjet ćemo da se ovde nalazi sledeća stvar. Na adresi 44444 se smešta ovaj izlaz na sekcije podaci i u njoj su smeštene sve ulazne sekcije koje počinju sa data. Što znači da će na tu adresu 44444 biti smešte na ovaj jedna reč i da će sadržene to je adres i uprobiti ta adresa 44444 i to i odvidimo. Nakle na adresi 444444 nalazi su upravo ta vrednost. Znači ovo je na ovaj podatak sa ove adrese podatak. Ono što imamo u sekciji sa kodom koje se nalazi na adresi 222.2.2.2. Ovo je ovdje ta adresa. Jeste prva instrukcija, druga instrukcija i onda opet ista ova vrednost. Ova vrednost ovde je dodata od strane assemblera zato što je neopodna u armu jer u ova dva byte kolik što je veličina instrukcija sigurno ne može da stane taj podatak. Onda je napraljeno jedan bazen literala iz kog se isto ovde vrednost dokvata. Ono što jeste bitno sada, jeste da vidite da se na adresi na koju je ovaj podatak mapiran zaista taj podatak i smešt. Ove čečetvorkje, ovo je smo ovde rekli da treba zaista tu da se smeste, su zaista i smeštene na tu adresu. Ovo ovde adresa se naziva load memory address, adresa na koju je zaista sadržaj i fizički smešten. Ova odda adresa, to je svoj podatak, zavisi od adrese, što vidimo na osnovu ovoga ovde, je definisan na osnovu virtualne memorijske adrese. U linkerskoj skripti smo ovde definisali sa ovom ovde komandom, nebitno da li smo rekli region ili bi smo rekli samo da smo ovde naveli kao i prošli put ovako. Da li istabistvara bila, smo time naveli virtualnu memorijsku adresu, a ako eksplicitno ne da vedemo load memory addressu, load memory addressa je ista kao i virtualna. Ali mi tu load memory addressu ako nekad želimo možemo eksplicno da promenimo, tako što ćemo ovde reći da se ova sekcija smešta na neku drugu adresu et i je syntaxni element ovog opisa izlazne sekcije, po im kažemo, odde ona treba zahisa da se smesti. I mi sada ode možemo da kažemo da se ova smešta na neku skroz drugu lokaciju, na primer na adresu 7, 6, 5, 4, 7, 6, 5, 4, jak sadecimalno naravno. Ako bi smo sada ponovog izvršili povezivanje i ponovog generisali hexfile, videli bi smo da je vrednost ovog podatka i dalje ista 4, 4, 4, 4, 4, jer taj podatak ovdje traži adresu virtualnu i sve što radimo, s virtualnim tim adresama, koji opet ponavljam, nemoj nika kvese sa mehanizmem virtualizacije. Ali, ono što smo rekli, jeste da na kraju kada se sve radi sa tom virtualnom adresom želimo da se samo taj podatak smesti na neku drugu i to je ovaj 7, 6, 5, 4, 7, 6, 5, 4, ali i dalje su to četvorkje, što znači da je čitav naš program preveden sa adresom 4, 4, 4, 4, 4, ovdje će se u suštini dohvatiti podatak sa te adrese, sa adrese 4, 4, 4, 4, 4, i onda se dobija, bi trebalo da se dobije ovava vrednost, ali ako se ovde još nešto nuradi prenego što se izvrši ova instrukcija, to nešto je da se ovaj podatak sa adrese 7, 6, 5, 4, 7, 6, 5, 4, premesti nazad na pravu tu lokaciju vmea adresu dođiće do neizpravnog izvršavanja programa. Dakle, još jednom, vmea adresa, jeste adresa na koje bi trebalo svih podaci da se nalaze u vreme izvršavanja programa, a lma adresa jeste adresa na koji će inicijanno nešto biti smešteno. Tako da, na početku izvršavanja svakog programa svih podaci ili instrukcija, Dakle, sve stvari kojih postoji razlika između vmea i lma adrese moraju da budu prekopirani sa te njihove lma adrese na vm a adres. Zašto je ovo bitno i zašto je korisno, korisno je da, naprimer, ako imate neka kač sistem, da imate RAM i ROM memoriju, da je ROM memoria takva da je nonvolatel i čuva podatke koji su u nju smešteni nakon gubitka napajenja, vi biste onda morali da neke podatke koje imaju inicijan u vrednost, zaista smestite u ROM memoriju, da bi oni sačuvali te svoje inicijanne vrednosti koje treba da imaju na početku izvršavanja. Ali ako su to podaci kojima mogu da se menju u vrednosti, onda ne možete da ih držite u vreme izvršavanja u tom ROM-u, jer ROM ne možete da menjate. I ono, stvo bi ste u tom slučju uradili, stavili biste da je vm a adresa tog, ili tih podataka u RAM-u, ali bi lma bio u ROM-u, što nači da bi inicijanlo podaci bili u ROM-u, a na početku izvršavanja takog programa morali biste da ih sa lma adrese, odnosno iz ROMa, prekopirate na vm a adresu odnosno u RAM, jer je čitav program preveden i povezan u skladu sa vm a adresama, samo ono što lma adresa radi, jeste da na kraju kada se sve izvrši prevođenje i povezivanje u skladu sa vm a adresom, onda samo se možda neke stvari prebace na njihove lma adrese.