 tu koji je prosleđen, a ovaj je ovde metode izabuđenje. Dobro. Aha. Znači, ovo ovde može da se primenjuje u slučaju da naša uslovna promenjiva ima prioritetni red na kome može da se čeka prema zadatom intervalu. I kako je onda ovo short job next? Ovo ovde je relativno, vrlo jednostavno, short job. Oni ko traži manji interval, ima manju vrednost o ovog promenjive time, a ako se se sečete, uslovna promenjiva, na koji se neko za blokira, a ako ima manju vrednost, ima veći prioritet. Sa neko možda kaže, čekaj, a kako bi ja ovo ovde mogu da realizujem ako je kontra? A ako mi neko kaže što veća time, to mi veći prioritet, a ja imam obrnutu metodu wait. Kako to da napravim? To ne može da se napravim. Može. Potrebna vam je samo inversna funkcija. Znači, vi treba da napravite neku inversnu funkciju da oci to biti jedan kroz x ili jedan kroz 1 plus x ili neka vrednost kroz 1 plus x, zavisio da li prima tamo ovo ovde celobrenu veličinu, ili neprima celobrenu veličinu, nego prima veličinu koja tipa double ili tako nešto. Znači, treba da napravite samo odgovarajuću inversnu funkciju i dobit ćete mogućnost da iskoristite već goto u metodu wait. Dobro, a šta ako nema? Kako bi ovo ovde moglo da se realizuje za slučaj da mi nemo nemo u slučaju promenjuvu, kod koji imamo red-jackanja, prioritetni red-jackanja. E tu saveć nastane i u mali problemi. Zavisio toga, da li želimo da napravimo i koliko želimo da realizujemo neke performanse, znači koliko su nam performanse bitne. Najjednostavnije rešenje kod monitora kojima disciplinu signal and continu, bi bilo sledeće. Notify all. Znači svako kad dođe se ubaci svoje ID i vreme koje želi da čekam. A onda onaj što budi, kaže notify all, probudite se. Ti se probude i onda one koji ima najmanji interval čekanja, kaže, aha, ja sam prvi u tom redu zablokine, to nije red, to će biti lista koji ćemo mi održavati i ona će reći, okej, ja mogu da nastajim dalje da radima, svi ostali nek se slikaju. Či to je jedna od mogućih varianti koja je moguća kod discipline koja se naziva signal and continu. Naponajuš jednom kako izgleda ta disciplina signal and continu, a oddemo i probudimo save. Uskoro ćemo viditi da postoji jedna takva tehnika koja može da se primenjuje, ali nije baš preporučljiva za primenu. Zašto nije preporučljiva za primenu? Ako postoji veliki broj, procesa koji su zablokirani, veliki broj procesa, sviti oni biti probudjeni, koliko od tih procesa će moći da nastavi dalje? Jedan, znači samo jedan proces će u ovom ovde slučaju moći da nastavi dalje se svojim radom, što nije baš najbolje rešenje jer premalo, a izvršavanja će imati, a previše budjenja. Dobro, a što onda da radimo? Onda možemo probati da primenimo tehnike koje smo videli da mogu da se primenju. Čekaj, gde smo videli, kakvi tehnike? Teknika koja sam ja maločas opiso, probudi sve, probudi sve, pa nekone na vide koje prvi sledči koji ima najmenji broj. Tu tehniku ste veći videli, ako se svećete kada smo na početku semestara razmatrali algoritme, kada smo videli tiki talogoritm. To je u suštini, probudi sve, pa onaj, či id odgovara nextu, odnosno čitrn odgovara nextu, kad se ta dva poklupa, taj nastavlja dalje. To bi u suštini bila ista politika ovde. Dobro, a kako onda to da se razreši? Pa smo mi videli, još neki algoritm možda koji moši da nam garantuje redosled. Osim tiki talogoritmo. P je u tamo još dva algoritma koji su na tom nam omogućavala. Jedan je bio Andersenov algoritm, a drug je bio C LH algoritm. Andersenov algoritm je zahtevao postojanje jednog niza, i to postojanje niza vi ovdopet mošete napraviti. Znamoš, uznete jedan niz uslovnih promenjevih. I predpostojte, verovatno neće biti nikad zablakirano više od 5. A vi napravite ne iz dužine 6, gde ako se pojave, ostali njih gurate sve olamo. A onda ima to ovde još jedan niz tih promenjevih. Gde ćete pamititi kolko imaju tih koji su tu trenutno zablakirani. I no i ovde način, sad vi mošte napravite nešto što u suštini kao trick rade u javi. A to je ako nećete da garantuju redosled, ono je nećete da garantuju redosled za milion. A ne god će uzeti aproximaciju Andersenog algoritma. A to je ako ima do 10 fenomenalo. Ja ću pralaziti kroz listu, način ću minimalnu vrednost od tih vrednosti i probudit ću ono kog treba da probudim. A ako ima više od toga, ja ću onda imati još jednu ustunu promenjuvu koji ću su uštini zvati ostali. Pa onda ću tu morati ipak da radim noti faila, kažem, budete se svi gledajte koment od treba. Ali se nadamo da nikad neću doći do te situacije. Da ću sve uspeti da razrešim sa ovom statičkom fiksnom dužinom niza. To je za sluči da ne znam koliko ima niti. A ako bi znao koliko ima niti, onda mogu odmah da primenim a kompletan Andersenog algoritma uvek, uvek, čekam, ono provje sledaćo i idemo tako dalje. Znači nema nikakvih problema, a možemo uvek da garantujemo takav naš redosled. Pod uslovom da znamo koliko ima uslovnik promenji. Treba da imamo uslovnik promenji i to zavisio toga koliko ima niti. A ako to ne znamo, onda možemo napraviti je proksimaciju kao što sam malo čas ispričao. Imamo niz neke dužine sa uslovnim promenjem, gde ćemo moći da blokiramo sve one koje dolaze, dok se to ne napuni i još jednu uslovnu promenjem, gde će biti ostali. Pa ako dođe do desnicu, moći ćemo da budimo tačnu po fifu redosledu, čak i ako imamo disciplinu signal and continue. A ako imamo više od toga, ako nemo dovoljno mesta, onda ćemo te preostale, morate kažemo noti, fajol, budite se, jer tu već nemo neki rafiraniji mehanizam kad nekog možemo da budimo. Ako bi smo koristili nešto nalik na andresinu algorita, ali ako bi smo koristili nešto nalik na cel ha algorita, to bi smo potencijelno mogli da napravo da svaki otiku se zablokira dobi svoju uslovnu promenju. I sad je pitanje, je o to može ili ne može. Da li ja na proizvoljno mestu mogu da kažem nju kondišta? A ako bi to je jezik nedozvoljava, neki jezici možda nedozvoljava a neogranicim broj uslovnih promenjihoj, java dozvoljava. Znači u javi svakam možete izvucite velike broj tih uslovnih promenjihoj, tako da to nije problem, ali kod nekih jezika to možda može da biti problem, jer neki jezici nedozvoljava ju dinamićko pravljenje uslovnih promenjihoj. Nemanju, ne postoji taj operator, se mora biti statički definisano. A ako sve mora biti statički definisano, je onda imamo mali problem, jer nećemo moći da primjenimo cel ha algoritm u tom svojm osnovnom obliku i onda bi smo tu morali da prajimo slično jongliranje, kao što smo imali kod maločas opisane aproksimacije uzmo n, odnosno jednu listu, možemo pravimo dok le god imamo tih promenjih, kad nam ponestane, pa kažemo nema i za to preostate koje su preostali, uzmemo i napravimo opet i jednu uslovnu promenjihoj, gde ćemo raditi ono notify all, najsporije moguće variantu, ali koja će nam odraditi posao. A, sad ćemo viditi još nekoliko, da kažemo relativno jednostavnih synchronizacijunih problema. To su interval timer, sleeping barber i round the bound problem, da vidimo kako to sve može da se realizuje. Taj interval timer je ništa drugo, nego želite da realizujete metodu sleep. Znači želite da realizujete metodu sleep, i onda stavite interval. Kažete kuliko, jedinica vremena želite da se vaša nit zablokira, da ne koristi procesorsko vreme. Osob je relativno jednostavno realizuje, a potrebno je da to što hoćemo da bude jedna monitor i u tom jedno monitoru, šta mi računamo? Mi računamo, koliko to sada ima saati, to je ovdje tod, plus intervalo, koliko nam je neko rekao da treba da budemo zablokirani, i mi izračunamo, u kom trenutku dati proces treba da se probudi. I šta onda čekamo? Svaki od naših niti, svaka od naših niti,