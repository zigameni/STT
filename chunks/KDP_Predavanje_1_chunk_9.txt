 Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Ne znači da će se to tako izvršiti? Ne znači da će programski prevodilac prevesti moje program ovako kao što sam ja sad rekao. Da se prvo izvrši P11, pa onda P12. Znači to što sam ja zamislio da se to tako izvrši. To uopšte ne znači da tako mora da se izvrši. Programski prevodilac nama negarantuje. Među rezultate nama programski prevodilac garanto je rezultat sekvencijalnog izvršavanja jednog programa će biti isti kao rezultat sekvencijalnog izvršavanja tog istog programa. Sada sam sada rekao. Jedno prevođenje sekvencijalnog programa i drugo prevođenje sekvencijalnog programa, ovšta ne moraju da budu tako napravljene i da daju isti rezultat. Među rezultat, a nego samo na kraju. Tako da mi možemo ovde u stvari imati kao moguće kombinacije. Mnogo više nego što smo ovde sad krenali. P1,2 se može prvo desiti. Pa onda može da se desi P2,1. Na primer pa P1,1 pa P što mi je ostalo 2,2. I vidi to, da ćemo ovdje imati neki čudan rezultat. A X2 je jednako čemu? Kaj da kajšemo ovde? A ovde da bude čudan. X2 je jedno. A je baš dokranem. Bara da bude čudan redosled. Znači P2,1 smestio rezultat. A to je 2. A ovde će biti Y2 je jednako minus 1. Ovo je neka potpuno bezvizna kombinacija. Tako da čisto znate, to što ste vi napisali vaš program da izgleda da ova istrukcija dođe prva, pova, druga, pova, treća. Uvopšte ne znači da će se to stvarno izvršiti na vašem računaru. U debug režimu rada hoće. U release režimu rada. Ako ste se i kad pitali zašto kod mogu kompilera postoji debuger release. Debug je da bi vi mogli da pratite izvršavanje vaših programa da radite, da tražite, gledite korak po korak. Release. Uvopšte ne znači da će posao odraditi onako kako ste ga napisali. Vama garantuje rezultat. Release vama negarantuje sekvencu. A dosta često sam ja vidjel, a release konstatuje da to što mi izračunavano će ima neki silne for petlja. To neka statička vrednost. U ulas bio broj 3 znači na kraju da ispanje rezultat broj 7. Na primje računam faktorijelo. Pa nije ovaj blesav sad da pravi stop nekih noženja da ja to izračunam nešto. Majok, ode i samo napisli rezultat jednako 7 i kraj. Programski prevodjeci mogu doodrade, ako imate statičke neki izraze, da proračunaju šta je rezultat na kraju i da u rezultat buklavno ugrade šta radi funkcija. Franč je broj 7. Nije garantovan isti redostat, garantovan je isti rezultat na kraju. A za sekvencijalno izršavan. I na kraju procesa broj 1, kad dođemo do ovde imaćemo da se ovo se odradilo ne u kom rednostledu. I za proces 2 ćemo imati ovo ali ne u kom rednostledu. Ako uzmete sad gledate, mi ovo je malo veći broj koji koji kombinacije. Nije o njih 6 ima ih još. Ali ih ima još? Ima, ima još. Nije ovo samo što sam ja izpisalo da su ovo moguće varjante gde da sam moguće za mene meste. Ima još gomila. Kako ima gomila? Ima gomila. Iko ste zaboravili na arhitekturi računara, smo to možda radili gde na primer bilo 32 bitne, ili 16 bitne, promenjive se smeštaju byte po byte, gde više byte dođe na višu adresu, niši byte dođe na nižu adresu ili tako nešto miseli. Nam je programski prevodilac da bi pristupio, na primer ovo x je jednako 1. Možda to nećemoći da odradi u jednom pristupu memori i jednom instrukcijem. A možda ćemo za to biti potrebno više instrukcija koje mogu biti prekidan. Tako da ovo ovde x je jednako 1. To što sam ja napisao kao jedno nešto, to će se možda izvršiti kao 2 pristupa, pa će to možda postati p1 i p1 prim. I tako dalje. I sad, i al to ovaj sad, možda sada kao da kaže, čekaj dobro, to su nekih gluposti koji smo tamo ovedili na architektu računara. Ima to koj nekoliko konkretno gračunara ja sad da vidim. Ima to kojc vakog računara. Samo pitanje šta vama garantuje taj računar, na kojoj nivo o promenjive kojima možete pristupiti. I ako setite programskog jezika java, u programskom jeziku java, biše jedna ključna rečko i ne znam da ste koristili ili ako ste koristili da ste koristili u celom obimu. To je ključna reč volatile. Klučna reč volatile. Nama garantuje dve stvari. Sa tu vara dobro da se setite jave. Jedna stvar je jednu relaciju koja se zove happens before. Relacija happens before, a znači da ako sam ja postavio da svoje moje promenjive x i y, volatile u promenjive. A ovako kako sam napisao program, tako će se izvršiti i pristup do tih promenjivih. U programskom jeziku java, volatile nam obezbeđuje jednu relaciju koja se naziva happens before. Šta bilo pre, bilo je pre. Znači šta sam ja napisao pre u ovom kodu za pristup, kad se pristupa nekoj volataj promenjivi, se sigurno desilo pre trenutka kada sam ja pristupio toj promenjivi. Tako da ako bi smo imali da su x i y volatile promenjive, a onda ne bi mogla se dese ove blesavi slučevi da mi se izmeni redoslet koja ovde imam. Ali to nije jedina stvar, još jedna stvar kojimamo je da volatile promenjive u javim i garantuju pristup do malo većih promenjivih. Volatile u javim i garantuje nedeljiv pristup do 64 obitne promenjive, do promenjiva tipa long i promenjiva tipa double, dok je za 32 obitne promenjive u javim garantovan nedeljiv pristup. U slučaj da su nama, ovde promenjive bila 16 obitne, a da se memori pristupa na, kako se zove na nivou, jednog bajta, moguće rezultat ovde izršavanja bi mogu da bude x2 je jednako 255 ili tako nešto, to je moglo da se desi. Znači da sam slučano, ja upokovalo pristup do jedne takve promenjive. Znači moglo je to da se desi. Znači da x2 bude jednako 255 ili da y2 dobije neku isto tako čudnu vrednost. Ako nekoma možete pitaći, čekaj, kako je moglo se desi 255 ka toga niga dnM otima? Ovo ovde minus 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, i ako sam ja opisova prvo viši bajt, naču opiso sam u viši bajt sve nule, u nižim bajtu su mi ostale sve jedinice, to je broje 255 tako da je jedan od mogućih rezultate je da i ovdje imamo 255 ako smo slučano imali da se ovako nešto desilo u pozadini na našem računaru moguće da se i ovako nešto desi ovdje ćemo napraviti pauzu, ono što ćemo raditi posle pauze su dva osnovna koncepta koncepta to su koncepti međusobnog isključivanja i uslovne synchronizacije ovo su dva fundamentalna koncepta kao što smo malo čas imali deobu na konkurentno i distribuirano programiranje a ovdje ćemo na ti dva fundamentalna koncepta međusobno isključivanje i uslovna synchronizacija to ćemo koristiti i vidjet ćemo algoritme koje treba da nam moguće da ovo ovde sve radimo da li možete imati nekih pitanja ok, ako nema pitanja, pausa, posle pause, nastavak, koncept