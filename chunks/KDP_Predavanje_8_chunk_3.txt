 zablokirana dokle god. Te kuće vreme to ne postane jednako wake time. Kada se desi da se ta dva poklopio, odnosno da wake time postane veće od tod mi budimo datu našunit. Kaha, sada sam sam sada rekao, kako smedaj da postane veće? Pa može. Znači to što mi kažemo da neko treba da se probudi u to vreme, a to će sad neko može sada se da se neko mnogo se dobro vreme. To će se desiti da u baš u to vreme. To ako zmijete gledajte kašta nekom da vas probudi u 3, pa vam je sasim sjedno da će sve mi tako nešto postovatim. Ajdec, vratimo sad na naš primer interval timera šta mi ovdje imamo. A imamo jednu metodu u koji se zove delay ili slip, što bi odgovaralo o nome što ste sada koristili i imamo još nešto, a to još nešto je metoda koje kažete tik. Istekao je kvant vremena, pređina na redni kvant. Istekao je kvant vremena, znači dalje to 10 milisekundi, 50 milisekundi, 100 mikrosekundi ne vam pojba. Znači to je neki interval vremena koji nam je neko dodelio. I kada istekte taj kvant vremena, neko voć dogi ili neki sistemski časovnik okine ovu ovdje metodu tik, uveća se internetna semafora, ova promenjiva koji kažete koliko ima sati i probudi se kogo treba da se probudi. Ajde da probudimo koji ga treba probudimo. Vi redjimo prvi tehnika, to je tehnika kao ono me što sam malo čas opisao, idi probudi sve žive pa nekone vidi koliko ima sati. To je tehnika koja se naziva covering condition. Znači mi kažemo kada treba nešto da se desi i odemo i probudimo sve. Uavšta ne razmišlimo jer neko treba da se budi. Biš možemo malo da smanjimo taj interval, da primjer ako potencijalno mogli da se bude čitavci pisi, a onda budemo i čitavci pisi. A ako mogu se bude samo pisi, pa budemo samo pisi, ne treba pakt sve da budimo. To možemo da proverimo. Ali tehnika je generalno takva da se bude svih i neko kaže desila se promene idividilti ovo odgovara. A što je neko napravio ovak u bezviznu tehniku koja mora da probudi sve procese i čitavce naprimer i piste, što ne probudi samo čitavce, što oni ne samo ne proveravaju. Ako se setite jave koji ste slušali na objekteno orientisanom programiranju, gde imate ono ključ u rač synchronized, gde možete da se zablokirate, da vaš aniv može da se zablokira, super, ona može da se zablokira. Na čemu? Na objektu des u javi, ono je standardno javi koji ste koristili, postoji jedno jedino mesto na kome može da se zablokira neko. I to, taj neko može da se zablokira na lokalnoj promenjivi. Lokalna promenjiva, super koja je lokalna promenjiva, lokalna promenjiva, nema lokalna dis objektu. Zbog toga, su ljudi smisli o ovdje tehniku koja se zove covering condition, to je ako ne zmate koga treba da probudite jer u javi ne možemo da kažemo probudi čitaoci ili probudi piste. Ima jedna uslovna promenjima, nema dve, jedna začitaoci druga za piste. Mi možemo da kažemo samo probudi jednog ili probudi više. Ne možemo da kažemo od koje sorte treba da budu ti koji treba da se probude. Toga nema, jer u standardnoj javi da ponovim, postoji jedna, jedina uslovna promenjiva koja je zakličena, to je des, nema dve dis promenjiva, postoji samo jedna, ona nad koji udržimo dat i ključ. Pošto su ovi u javi konstatovali da programirili, pak ne umije baš najbolje da programiraju, oni bi dozimo o ono knjigu da vide gotovo rešenje da to prekucaju i da to radio u javi. Onda svipak od verzije 5 ili malo kasnije krenali da prave uslunu promenju u koja nije sistemska klasa nego je bibliotečka u suštini klasa koja radi isti taj posao kao što mi hoćemo i njih može biti više. Ali za sada hoćemo da vidimo kako se razrešava nešto koristići vrlo jednostavnu tekniku coloring condition. To je napišemo uslov i budimo sve kojima to može da bude od interesu i kažemo budite se, računajte, je lovo ovde vama treba. Kako onda izgleda? Ovo i naš interval timer. A kad nekod dođe, kaže wake time, dobro, je jednako tekuće vreme plus interval. I dok le ja čekam, dok le goda wake time ne postane veće ili jednako od 100. Odnosno dok le godi je to wake time je manj, već je od 100, a ja čekam. Kako čekam? Uslovno promenjiva tačka wait. Nemam ništo. Nemam ovde mogućnost da specificiram bilo koje prijuritet, jer to ga u ovom slučaju nema. U javi, u tom svojom osnovnom obliku, nema mogućnost da kažemo koliko nečega ja želim da čekam koliko jedinica vremena nema toga. Znači nema nikakvih prijuriteta. Dobro. I kako onda izgleda rešenje? Ovo i što uveća tekuće vreme, da se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako se nekako i onda ovoj svaki zablokirani treba da se probudi da vidi da li je ispunjen uslov, ako je ispunjen uslov nastavlja kad dobije ekskuzivno pravo, ako ne bude ispunjen uslov tada taj će se zablokirati i neće nastaviti taj ovo ovde rešenje i ako ispravno nije poživno da koristite osim kao poslednju mero ako ne znatite druga če je da napišete ako vaš monitor ima neku malo bolju tehniku koji može da vam pruži, onda koristite tu neku malo bolju tehniku, nemoj to ovako nešto, jer ovo ovde ako imate jednu nitu koje je zablokirano u stvari, ovo je ni toliko loše, mislim loše je, ali imaš da toliko baš, zašto je loše, ako je postoji čak jedna nitu zato što mi svaki put, kažemo signal o ovom, svaki put kad se promene interval vren i ovo ovde možete da posmatrate na sljedeći način a vi koćete da legnete da spavate, navijete budelik i kažete da treba budelik da vas probudi u osamujutru a budelik vas svaki minut pita, e, ili sa treba da ustaneš možete da posmatrate ovako jedno rešenje, gde budelik, neće da vas probudi u osamujutru, ne, nego će svaki minut da vas probudi, ja kažem, e, ili ti sa treba da ustaneš, znači, šaj da vidi, e, ništo od spavanja, u tom slučaju, previše resursa se troši na ojedno tako rešenje, ali ako nema bolje, pa to je to možda bi malo bolja varijanta ovog rešenja mogla da se napravi, ako bi smo imali neku listu, gde svaki put kad se neko zablokira, on ubaci taj svoj interval, kad treba da se probudi, i onda ove što radi, notify all, opat će morati da radi, notify all, radi samo to ako je to veće ili jednako od mean wake time, znači, vidite, i ovo ovde rešenje može malo da se ubrza, tako što bi ovaj ovde otišo i ubacio u listu, znači bilo bi listačka put, ilijat, kako da se zove metoda, wake time, a onda ovaj ovde što radi signal all, što bi radi, ovde treba piši lista, piši list, a ovaj ovde bi rekao if list touchkide size veći od nule, samo tada nekom budi, ali nije to dovoljno, i list touchkaged od nule, ako je to vreme manje ili jednako od tot, tada nekog treba da probudim, i ovaj ovde treba da kaže list touchka remove, taj taro, wake time, to što smo ubacio, to hoću da izbacimo ovde, i na ovaj način bi smo mi napravili nešto malo bolje rešenje, ne bi smo budili sve procese svaki put, nego ako postoji barem 1, ko treba da se probudi u datom trenutku, ide budi sve, ne znamu koji je, način kod ovoga covering condition,