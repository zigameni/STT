 Dobro, sad se snimamo. Tu je samlom i kolegnica Maja, kao i uvek. Čao. Čao Maja. Tako da ćemo zajedno podržati i ove časa vežbi, prvi par tehnickih informacija, odnosno imamo jedno pitanje već u četu. Kolega Mihajlo, da li možemo dokacimo prezentacije sa vežbi? Naravno da možemo. Mislim, dokacicemo prezentacije sa vežbi večeras i ono od prošle nevdlje i ono od danas. Jer prosto, ono od prošle nevdlje smo morali malo da doteramo, izmenimo neke sitnice koje smo videli tek posle i prosto dododamo najposlednji mod funkcionisanja koji ćemo videti danas. Tako da večeras će sticiti sve te prezentacije i snimci za ovu nedalju. Što se tiče tehnickih informacija sa naše strane, prosto za RTI smer i ostale smeru je u koliko neko sluša na RTI zaštitu, kolokvium je každo znate 24. Ako se ne varam, sledajce nedalju u svakom slučaju gradivo koje je vezano za vežbi koje vam dolezi na kolokvium je zaklično s onim što danas budemo prešli u prvom delu časa. Dakle, zaklično sa poslednjim modom funkcionisanja koje danas budemo raditi. To je čisto je to da znate što se veš biti iče. Nadam se da vam je Pavle rekao što dolazi od gradiva sa predavanja. Sam kolokvium će biti na računarima, sastoji se iz pitanja koja liče na sve ono, kako su izgledala i pitanja iz ovog predmeta do sada, to možete videti na sajtu predmeta, primera od predkonjih školskih godina. Tako da neće ništa specijalno biti drugačije konceptuolno, ali je to prosto radiće se na računaru. Dakle, tamo ćete i osim odgovora na gde treba našto domnesete, neku vrednost šifrovanu, desifrovanu što godili, odgovorite na neko pitanje, štiklirate, tačno ne tačno i tako dalje znate već kako mudlet funkcioniše. Osim toga će postojati naravno i ona da kažemo ss-ka pitanja, gde mi vama postojimo pitanje i prosto treba nešto da prosto treba da odgovorite na to pitanje malo opširnije u nekoliko rečenica. Dakle, i ta pitanja će postojati i ako ste radir na računaru, odnosno na mudlu, čisto da se ne prevarite pa da se zbunite tamo kada vidite takva pitanja. Što se tiče pitanja, gde treba nešto da skicirate s obzirom da i takva pitanja često dolaze za tako nešto ćemo vam dati formular, gde vi tu skicu crtate direktno na papiru i dodatno i to predajete na kraju pored sama mudlu testa koji treba na kraju predat, odnosno, završite. Tako da to je neka ideja što se tiče Kolokvima. I još jedan tehnik i detalj pa ću da vas pitanja da imate pitanja oko toga, sledeće nedalje kreću nadoknade. Nakle opet prvo za esi smera, onda one tamo nedalje za ostale smerove. Što se nadoknade tiče, rekli smo da je moguće nadoknaditi maksimulno dve laboratorijske vežbe, pri čemu smo rekli da se jedna plaća. U suštini, s obzirom i na celu ovo situaciju oko virusa u zemlji, i s obzirom na situaciju da smo prosto drugi treći labo održali u istom terminu, smatramo da ne bi bilo toliko korekno da ipak tražimo od vas da plaćate tu nadoknadu, tako da obe lab vežbe, okoliko želite nadoknadite, će biti besplatne. Dakle, dalje su to dve lab vežbe po izboru, dakle, nakle na koja niste i zašli, ali ne morate da donosite nikakvu priznanicu o ovo nadoknadizav. Te lab vežbe, naravno, to će stići zvanično preko maila, tako da je to ove neka informacija sada ovako direktno na času čisto da znate. Dabra, limate neko pitanje u vezi sa tim tehnickim stvarima? Dobro, poštu pitanje o njema, ja ću da podalim, hajma, u pitanje. I to dva pitanje. Prvo pitanje što se esija tiče, da li ćete se održati jedan ili oba kolokvjuma u kolokvjum s kojih nedelji? To još uvek nismo sigurni, ja nisam siguran da mi smemo da održimo oba kolokvjuma, ali jedan će se sigurno održati. Sad, da li će onda obuhvata celog okupnog radi, bo verovatno da hoće. Nismo još uvek pričali o to, koliko jasno. Naznam, majel ti znakom informaciju viša. Šulek, neismo donali odloknu nivog predmeta, u principu to je izbor pojedinačna na svakom predmetu, da li se omogućava polaganje jednog kolokvjuma, da to bude ili po nekom izboru. Jedno delag radeva ili drug, delag radeva ili se to nekako objedini, naravno se skalirani brojan pitanja, ali u svakom slučaju dakle čem budemo imali po informaciju i to što ospori obavestit ćemo vas da biste mogli da se organizujete na armi temat. Ali kolokvjuma će biti? A drugo pitanje, da možemo da koristimo kalkulatora sa ročunara na kolokvjumu, dakle kalkulatori će biti dozvoljeni u slučaju da imate neko pitanje za koje vam je potreban kalkulator. Tako da koliko smo pričali na predmetu dozvoljećemo kalkulatore za tene, ta neka pitanja. Ništa. Još neko pitanjem? Tako da bih li se uvijeko, da se uvijeko, da se uvijeko, da se uvijeko, da se uvijeko, da se uvijeko, da se uvijeko. Dobro, ko bude bilo pitanja, slobodno pitanje na pauzi. Mislim da upravosti idlo pitanje. Dalje će biti popravke kolokvjuma? Pa sigurno će neka vrsta nadokna, da je biti popravke organizovan u junu. Mislim da je to takođe neka obavez. Sad u kom vidu nismo još sigurni. Ništa. Dobro. Ja vidite ekran. Vidimo prezentaciju, dadam. E suber, vala. Dakle, sad ćemo ukratko da vidimo ponovom sve modele funkcionisanja, da ih se pocetimo, da bih smo se pocetili na kraju onog malo kompleksnjeg modele funkcionisanja, koji smo radili na kraju predkonog časa. I da vidimo još jedan nov mode funkcionisanja koje smo ovdje dodali u prezentaciju. To je mode funkcionisanja koja dosta liči idejno na poslednji moj mode funkcionisani sa predkonog časa. I da vidimo u simulatoru, kako prosto to izgleda čisto da bi nam nekako jasnije bilo, kako sve to funkcioniši i kako se svijoni silni podaci pakuju u neke blokove i tako dalje. Pa pošto ovi kompleksni modele funkcionisanja se zasnivaju na prosto ovim prostim modevima funkcionisanja, sad ćemo da pretrčimo kroz sve te modele funkcionisanja, imamo jedan komentar konkretno za jedan od ovih modeva funkcionisanja, tako da prosto želimo da naprimu taj neki kratak uvod. Rekli smo modevi funkcionisanja su prosto rešenje za korišćenje svih o nich blok algoritama u praksi, kada je potrebno prilagoditi ili blok algoritam nekoj aplikaciji ili prosto poruku koja proizvaljne veličine tom konkretnom blok algoritmu koji koristimo i postoje razni modevi funkcionisanja, mi smo ovde odradili njih set, odnosno odradili ćemo njih set. I onda smo videli za početak one neki najjednostavni mode funkcionisanja ECB, koji deli poruku odgovarajuće blokove, odgovarajuće veličine u zavisnosti od veličine koja je potrebna za ulazu samog enkrypcionog bloka, ili dekrypcionog bloka, tako da prosto našu dugačku poruku delimo na blokove te odgovarajuće neke veličine. Poslini blok eventualno pedujemo sa nekim vrednosti.
 s anulama da bi prosto popunili i taj poslenje blok do pune ve ličine. I onda ono što se dešava, jestli da se svaki prosto blok podataka provlači kroz algoritam i na taj način se dobija šifrova na poruka, odnosno u suprotnom nekom smeru se dobija dešifrova na poruka, odnosno naš plain text nasred. Naravno koristimo sve vreme jedan ključ za sve svaki ovaj algoritam. Isim to je sve jedan algoritama. Poruke pojedinočno prolaze kroz algoritam i dobijemo šifrovane blokove našeg plain texta. I rekli smo tu je prosto neki problem. Ukoliko je sad ovaj tekst dosta veliki i onda imamo veliki broj ovih blokova, gde možemo da vidimo neka, odnosno, dučijem uočimo neka ponavljanja u poruci ili ako naša poruka nebaš to liko velika ali sadrži neku strukturu koja se ponavlja. Onda prosto, ono što se dešava, jeste da se uvek isti blok šifruje u uvek isti blok praktično. Dakle uvek neko a u neko b. Bilo koji deo ten veće poruke to bila. Dakle, da praktično, ono što može da neku uradi kada uhvatio u našu šifra ovnu poruku, jeste da napravi neku kryptoanalizu i da na taj način nekako dođe do originalne poruke jer prosto uvek se blok koji imenujemo, naprim. a, će uvek da se šifruje u neki blok koji imenujemo b jer prosto oni se pojedinačno šifruj. I onda se ove mod funkcionisaniya koristi za siguran prenos nekih manjih pojedinačnih vrednosti kao što je naprim. ključ ili neki inicijelni vektor ili neka non srednost za neki od ovih drugih modova. Onda smo videli jedno rešenje predhodnog problema, datu u vidu cbc moda funkcionisanja koji funkcioniše na taj način da prosto svaki šifrovan i blok podataka koji dobijemo opet provlačenjem plain texta kroz neki enkrypcionel algoritam, ipak učestvu je u kreiranju sledećeg šifrovanog dela poruke, odnosno bloka podataka. Kako učestvo je pa tako što se kombinuje ksora operacijom sa plain text blokom podataka i onda taj rezultat dolazi na ulaz samog bloka algoritma i onda dobijemo novidej ov šifrovanog teksta i prosto to se sve ovako nekako čejnu je odnosno ulančava podateljima samog modu funkcionisanja. Da bi sve nekako bilo identično za svaku iteraciju i za prvu iteraciju imamo na ulazu enkrypcionog bloka rezultat ksora nekog plain texta i nečega što zovemo inicijomni vektor, to je prosto neka početna vrednost koja nas dodatno da kažem štiti i prosto koja nam omoguća da algoritam odnosno modu funkcionisanja iz iteraciju u iteraciju bude identiča. Naravno ta početna vrednost je potrebna i primavcu i ono ko šalje poruku, tako da prosto ona mora na neki siguran način da se prenese, naprimer baš oni mecije da je modom funkcionisanja i pošto ovaj blok za neki plain text a neće uveg dati blok šifrovan nekiho cyfer teksta b jer prosto svaki šifrovan i blok zavisi od svih predhodnih i šifrovanih i dašifrovanih delova. Same poruke prosto ovo može sad da se koristi za šifrovanje neke velike količine podataka, a i za autentikaciju. Dobro, onda smo videli neka dva bloka podataka koja u suštini radi sa nekim feedbackom odnosno šifruju naš tok podataka po uzoru na one stream algoritme gde prosto sam deo plain texta se samo ksoruje sa nečim da bi smo dobili prosto neki deo cyfer teksta i u slučaj u CFB odnosno cyfer feedback modom funkcionisanja prosto na ulaz ovog ksora dolazi neka ova struktura koji smo deterno prokomentari sali prošle nedalje da prosto na početku nemojmo neki inicijalni vektor koji provučemo kroz enkrypcioni algoritam dobimo neki blok podataka, ali pošto nam naši podaci odnosno naši delovi plain texta stižu u nekim bitima odnosno u nekoj količini bita, naprim. s mi od ovog šifrovanog dela podataka koristimo samo levih s bita da ksorujemo sa trenutnih s bita dolazite, da bi smo dobili s bita cyfer dela porukje. Samo ime nam govori da se sad taj cyfer del porukje koristi kao feedback za sledeću iteraciju, odnosno ovaj registar koji je na početku imao samo one inicijalni vektor u sebi, sada se šifto je u levo i ovih s bita, same šifrovane poruke nam dolazi sa desne strane, dakle prosto izgura nekih s bita ovog inicijalna vektora na levo i prosto ovdje imamo sad neku novu vrednost koja opet se šifruje, odbacuje se neki del samog tog šifrovanog dela, uzima se s bita i kombinoje se sa novih s bita našeg plain texta i tako se opet ulančava cela priča. I onda smo pričali da koj dekripsije prosto morate da vodite računa da ovaj ovdje gorenji deo koji se ksoruje uvek identičan sbog osobina ksoru operacije da ona inverzna sama sebi, pa se prosto uvek koristi enkripsijon i algoritam i u enkripsiji i u dekripsiji. A prosto ideja dekripsije veoma jednostavna, sada se cyfer deo šif odnosno ksoruje sa ovim delovima koje treba da ponovu izgnerišemo na isti način kao igore. Ida, kto ukratko bilo o CFB upocićanje, esad kot OFB, dakle kao što nam opet ime kaže razlika odnosno na CFB, jeste što nam je output sad taj koji nam predstavlja feedback za sljedeću iteraciju, odnosno nemamo, takažem, liniju od samog cyfer dela teksta za sljedeći blok podata ka ovde, nego nam je sam output enkripsijon i algoritma koji inače ulazi na ksoru operaciju sa plain textom, direktno feedback za sljedeću iteraciju. E sad nekada koje slušao predmijeg prošle godine, video je malo drugači u sliku ovog OFB moda funkcionisanja, to je prosto zato što ažuriranja moje prezentacije smo došli do zakvička da se nekada ove ovaj OFB mod funkcionisanja više koristi u stream algoritma, odnosno, puzuru na njih, sad da se prosto on koristi sa neke blokovske strane, odnosno sami ovi podaci plain texta koji nam dolaze, su na nivou neku bloka, odnosno, celog bloka podataka, po ovde nemamo reagistar koji se šiftuje, odnosno nemamo odsecaň o njih s-b bita koji odpadaju s-bita koji su dolaze, dovode na ulas ksora jer se dana so IFB prosto koristi na nivou bloka kao i oni predhodni modowi funkcionisanja, dakle to je prosto neki detalj, čisto za sve koji su gledali stare prezentacije ili staru verzi u knjige prosto, ili su slušali predmet prošle godine ili još ranije da vode računa ovame da se sada ova šeima prosto promenila, sad kako izgledala pre, pa izgledala isto kao ova cypher feedback šeima, samo što je prosto ova linija za sledeći literaciju kao feedback išla od aft, dakle ali ideje je praktično isto, dakle i ovde nam je feedback output samo što nemamo rad na nivou s-bita nego na nivou blokova, tako da nije neka pretrana razlika ni napravljena, čisto komentar za ono koji su videli na starim prezentacijama i tu staru šeima. I ono što je poslednje, ostalo da propomentarišemo prenego što ponovimo na i poslednji mod funkcionisanja, jeste counter mod funkcionisanja koja je dosta jednostavan i ličina OFB ali nema ona i feedback, on prosto kao ulaz e-encrypcionog algoritma ima neki brojač koji se po nečemu kreira i onda prosto izlostog e-encrypcionog algoritma dovodimo na ulaz ksor operaci sa blokojima plain texta koji se onda šifruju i dobijamo blokove cifr texta. Dakle, jako jednostavan mod, ali važ zato što je jednostavan je dosta etika, sani može paralelno da radi šifruvanje i dobar je za linkove sa velikom brzina. I to je sve ono što smo pričali ovim nekim osnovnim modovim funkcionisanja, i onda smo došli do CCM moda funkcionisanja, odnosno counter with cifr block chaining MAC moda funkcionisanja. Dakle, on sa jedne strane osim što bezbeđuje tajnosti, u bezbeđu je autentikaciju i baziran je na simetričnom bloko, blok algoritmu či je veličina bloka baš 128 bita za razlik od predhodnih koji su mogli da radi sa manjim blokovima. Sam ulazar algoritma videli smo da predstavlja razne neke podatke, tu su korisni podacij, to je naš plain text, pridruženi podacij koji služe za autentikaciju i neka početna non-svrednost kao dodatno nešto što pored ključa i jedna i druga strana treba da sdrže. Dobro.
 Prosto da vidimo sa šeme da se pocitimo kako izgleda generisanje samog maka, odnosno generisanje same šifrovane poruke, pa da vidimo prostu na primeru da nam se nekako tuupakuje u glavi kako funkcioniše. Dakle, pocitnik kaže da prosto se mak generiše tako što se koristi neki cbc mod funkcionisanja či algoritm naprim. as ili neki drugi algoritm sa 128 bita, a na ulaz tih algoritama po cbc modu funkcionisanja, naravno, poveki vam ovaj ksor pre samog ulaza, dovodimo neke blokove podataka, veličine 128 bita. I ti blokove podataka se napred računaju po nekim pravilima, da ovaj prvi, odnosno, nulti blok podataka prosto predstavlja, odnosno, sastoji se izprvo neku baita flagova, gde prosto smo pro komentarisali prošli put šta koji deo baita čemu služi, odnosno, ovaj aid data prosto govori da li imamo one dodatne podatke za autentikaciju ili nemo, onda imamo na širinio 3 bita enkodunu dužinu samog maka koju podešamo po algoritmu i onda enkodunu širinu predstave poruke koja se izračunava. Nakon tog jednog baita direktno idu non-svrednost, odnosno non-svrednost same ponu poruke i onda u zavisnosti koliko nam je ostalo od bloka, binar napredstava same dužine poruke prosto na toj neku iz širini koja nam je ostalo u zavisnosti od veličine non-svrednosti. To nam je blok nula, dakle on je nekako najkomplexni tu od najviše stvari se sastoji. Ovi ostali blokovih, prvih u blokova, odnosno u minus 1 ako one računamo ovaj nulti, se prosto sadrže odnosno sastoje iz pridružnih podataka, prećega ide na neki način enkodovan na veličina tih pridružnih podataka, zašto ona postoji pa da bi prosto sam algoritm znao dokog trenutka idu pridružnih podaci, a kada u kom trenutku prelazimo na blokove koristnih podataka koji se nalaze u ostalom delu ovih nekih ulaznih blokova, dakle n minus u plus 1. Tako da prosto ide niz blokova sa pridružnih podacima, pričemu u prvom takom blokvim ome enkodovonu viličinu tih pridružnih podataka, a onda blokove koristnih podataka, odnosno blokove same porike. I kada se sve to lepo šifro ovim cdc modom funkcionisanja, mi dobijemo neki blok od 128 bita, i uz avisnosti šta smo odabrali za veličinu maka, što nam je direktno enkodovonu nultom bloku, mi uzimamo najviših nekoliko biteva i prosto to nam predstavlja mak vredost. Šifrovanje poruke je jednostavno odnosno koristi prosto counter mod funkcionisanja, gde su ovi brojači opet nekako napred računaju, tako što se svaki sastoji iz jednog biteva opet nekih flagova, gdje imamo 5 bita koji su rezervisani pa su inica luna nuli, zbog reakih kasnih u napređenja ovog moda, a onda je enkodovono vrednost širine poruke. Nakon tog jednog biteva idu non s vrednosti i uz avisnosti opet koja veličina non salac, ostac je nam da dopunimo blok nečim i ta dopuna je prosto vrednost samog brojača od nula pana dalje, tako svaki sledeći brojačima vrednost za jedan veću. Prosto korišinjem tog counter moda funkcionisanja svi brojači se dovode na ulaze enkripsionu blokova, dobijemo neke izlaze, pričemu poslednjih n, svi osim ovog nultog se komkateniraju i od njih se uzima najvišći nekoliko biteva uz avisnosti u čirine same poruke koja je enkodovano v svakom brojaču i onda kada to smanjimo na čirinu same poruke, onda lepo možemo da ksorojemo samo poruku direktno sa time što smo dobili i prosto kada to ksorojemo dobijemo sejfer tekst. I pošto ovo može da se koristi, tako evo je mod funkcionisanja izar autentikaciju, potrebno je ovej mak nekako proslediti sa porukom, on se šifruje i doostavlja na kraj same poruke, tako što se ovej prvi brojač, odnosno njegov izlaz ksoroje sa samim makom naravno i on se iz njega se odceca najvišćih nekoliko biteva, da bude prosto veličina toga što smo dobili, istakva veličina maka da bi to moglo lepo da se ksoroje i to što smo dobili je prosto rezultat šifrovanja maka i lepi se na kraju za poruku. I sad ćemo da vidimo prosto jednu simulaciju. To je neki diplomski rad koji u sebi sodrži razne neki modove funkcioni, i sad mi smo rekli da prosto postoji ošmrogi modove funkcioni, znavo vidite ovdje oš neka četiri, neke ćete raditi na predavanjima koliko sam čuo od Pavla, možda ste veći radili, ako niste radit ćete, u svakom slučaju prosto treba da znate da ih imaju ošdosto, dakle nisu sve ošto smo pričali danas, nije toto, nego prosto da imate u vidu da postoje razni, pa koga zanima može dalje da istraži o ovaj tem. Dakle pokrenućemo taj CC modu, modu enkripsi, pošto dekripsija slična, samo nekako ide u nazad, gde prosto ovde treba sad unesemo neke ulazne podatke. Sećete se naši ulazni podaci su sam plain text, sam additional data, odnosno associated data koji može, ne mora da postoji, to ono što se koristi za dalje autentikaciju, te len je dužina taga, odnosno maka, same poruki u baitovima koje može da ide od 4 do 16 prosto, zato što je to maksimalna veličina bloka, tako da to je ono što biramo i to je ono što sećete se sa predkonog slijda, nosno u čega se izlači o njih najviših nekoliko baitova i ova non svednost od koji počinje ovih counteri, ako se koristi tamo u nekim bloku i maj ključ koji moraju da znaju i jedna i druga strana. Tako da ove sve stvari moraju da znaju jedna i druga strana, početni nonz, ključ, druga strana neće znaći plain text, znaći šifrovani text, ali mora od toga da generiša nazad plain text, prosto i maki, tako da je tome smo se pričali. Tako da, hajde da vidimo odprilike ti blokori kako izgledujemo, pa da malo promenimo ove neke vrednosti da vidimo kako će ti blokori da reagujemo. Kad kliknam Next, ovdje vidimo da se generisala neka 3 bloka podata. Dakle, to ono što minimalno, što možemo dima, ako već imamo podatke za autentikaći. I rekli smo sada ove prvi blok podata, ka vidite, sastoji se iz jednog baita flagova, da su ti flagovi baš dati na pretukunaj slici, a onda ide prosto ona neka nonz vrednost. Kako što vidimo, ovdje jedan bait flagova, pa onda nonz vrednost, a onda ide binar na predstava dužine poruke. I sad ne znam, alste zapamte, ali prosto naša poruka je na dužini od 4 baita, imalo neki 8 hexa cifara, mislim da je poruka 20, 21, 22, 23 hexa. Tako da ovde ostali hvori 8 baitove, ide prosto vrednost dužine poruke. Naravno, nakoliko će baitova da se kodira ova vrednost poruke, direktno zavisli od toga kolika je nonz vrednost. Tako da ako bi smo mi pokrenuli ovo opet i ovo nonz povećali za još dva baita, prosto će sama dužina poruke, odnosno maksimalna dužina poruke da bude direktno određena preostalim mogućim vrednostima koje mogu da se kodiraju ovih 6 baita koji su nam ostali kada smo nalepili ceo ovaj deo nonz vrednosti. Tako da prosto to je nešto što treba da imate uvijedu, što možda mi ste baš svatili sa same prezentacija, ali možda da svatite direktno iz simulatora. Naravno, ako povećamo poruku, prosto, i ovaj možemo da povećamo i dužinu samog taga, videćete da se ovde menja vrednost dužine poruke sa 4,8 baitova, a ovde se nekako menja 4F na 5F, jer je prosto dužina maka sada duplo veća. Pa imamo tog jednog jeca više. Tako da to je od prilik je kako nam reaguje blok 0 na naše izmene. Blok 1 i blok 2 su jednostavni. Dakle, blok 1 sadrži koliko je duga čak naš asosijetet data, on je 8 baitova pa se to kodira ovde. Ne kodira se uvek na 2 baita, dakle, nekada se kodira i na 4 baita, sada zavisi koliko je baš naš asosijetet data, i ovde ne možemo da napravimo taj primer, da vidite da to ide na 4 baita, da bi smo morali baš dosta vrednosti za taj adišan ovdaj data da namestimo. Svakom slučaju ovde na 2 baita prosto se navodi koliko naradnih baitova predstavlja te dodatne.
 podatke to nam je bitmer, prosto želim da znamo dokle su podaci koji koristimo, a kada ide ona i paddinga, kada kreće poruka. Tako da 0, 0, 0, 1 do 0, 7, tih 8 byte-ova su naši dodatni podaci i onda se sve peduje do nule. I sada su naši dodatni podaci bili veći, prosto imali bi smo više takvih blokova sa dodatnim podacima, direktno slepljeni jedni na druge. Nakon tih nekoliko blokova sa dodatni podacima idu blokowi sa samim plain textom, u ovom slučaju plain texti neka četiri byte-ova. Evo sad čisto da vidimo, možemo plain text 5 puta da povećamo, joj asosijetet data je ovo dva puta, čisto da vidite da sad imamo generisano više blokova, odnosno naš asosijetet data sad 10 hexa byte-ova, odnosno 16 byte-ova. Da vidite da ovde sad krećano i drugi deo 0 0 1 2 3 4 5 6 7 završava se ovde, onda se ove drugi blok peduje nulama. Nakon čega posla celog bloka ide blok sa podacima 20, 21, 22, 23, tako četiri puta je ovoj peti put i upao u četvrti blok, nakon čega idu opet ove neke nule, da bi se sve to dovelo do širine od celog jednog bloka. Prosto da vidite kako si generišu ti bloka, i ovana dalje je jednostavno. Dakle ovde sad se prosto kalkuliše mak vrednost pod cbc modu, vidite da su uvek ovaj neki izlas koji smo nazvali y, ksoru je sa sledećim ulazom i onda se to provlači kroz a, dakle ovo je direktno cbc mod funkcionisanja, nakraju dobijemo ovu neku y4, i u ovom slučer imamo četiri bloka od kojeg izlačimo najviših 32 bita i dobijemo mak, jer smo definisali da nam je mak dužine četiri bita. Sa druge strane, ovih counteri se generišu opet jednostavno, rekli smo, ide non s vrednost, nakon čega idu brojači, a ovo prva vrednost je opet vrednost, koja prestavljenku dovolu vrednost dužine poruke, što nam je bitno da bi smo ove znali koliko da odset samo od ovih konkatenacije i vidite da svaki brojač se razlikui samo u posljenjem bajtu, dakle skačemo s 0 na 1, sa 1 na 2 i to nam je to, dakle neamo više brojačer, broj brojačer direktno zavisi od toga koliko imamo ovih blokova podataka sa desne strane. Kada se dobiju ovih podaci s 0, s 1, s 2, rekli smo s 0 se koriste za šifrovanje maka, a s 1 i 2 se konkateniraju i onda se ksoruju sa plaintextom, ali pre toga se prosto izlači najviše, najviših, a ovdje 160 bajtava koliko je naš plaintext dugačak, da bi se prosto dobila tačno odgovarajuća verzia ciphertext, jer sečete se naš plaintext ako imao dva bloka podata ka drugi blok je bio dopunja 0, i zato ovaj es dosta već, zato treba to da se smanjeno odgovarajuće golečinu i tek onda da se ksoruje. Sa druge strane, a ovo je s 0 prosto se koristi direktno za šifrovanje maka, evo nam ga mak, dakle ovde se zove t kao tag, to ste valjili da su sad svatili, i prosto i ta je s 0 moramo da smanjimo na širinu samog maka, da bi smo ksoru operacijom dobili šifrovan u vrednost i onda dobijamo konkrata na rezultat šifrovanog teksta, gde posljednjih evo ovdje neki 8 bajtava, odnosno 4 bajta, predstavlja šifrovan u vrednost mak dela poruđe. Dobro, to je bilo odprilike neka simulacija, da li ste sad malo bolje razumeli ovoj algoritam? Odnosno, da vam je opšta ova simulacija značila i da imate neku pitanju? Dobro, ko nema pitanja idemo na kraju da vidimo i ovaj posljednji mod funkcionisanju, odpitanju je galo-accounter mod odnosno gcm mod funkcionisanja koji sada kada smo svatili sve predkone modove funkcionisanja ne bi trebalo da bude teško da i njega razumemo. On je u suštini designira jer je postojila potreba za nekim modom funkcionisanja koji će da pruži mogućnost maksimalne optimizacije i sa hardware sve strane i software sve strane u smislu šifrovanja tih poroka, a on takođe treba do bezbeda i tajnost i alterntikaciju kao i prethodnji mod funkcionisanja. Isto kao i prethodnji mod funkcionisanja i gcm mod funkcionisanja basiran na simetričnom blok algoritmu čije veličina bloka baš 128 bita pa za primjer uzimamo is i opet se tu koristi neki counter mod funkcionisanja kao i predhodnom primjero ali ona i cbc mod imamo na nekom drugom mesto. Counter mod funkcionisanja se ovde kao i malo prekoristi isključivo za šifrovanje pri čemu counter mod je malo modifikovan tako da radi na drugačin način. Vidjećemo kako radi konkretno na šemi, a što se autentikacije stiče kod nje se koristi cbc mod funkcionisanja kao i malo pre, pri čemu sam algoritam koraz koji bi smo propustili neki deo poruke koji treba da se šifro cbc mod funkcionisanja predstavlja prosto proizvod, matrični proizvod toga što dolazi na ulaz sa nekom univerzolnom hash funkcijom odnosno nekim hash ključom koji je automatki generisam negde pa prosto predstavlja neku univerzolnom hash funkciju nad binarnim konašnim poljom galo agf 1220, to osmirna mi to veličina bloka. Kako se generiše taj neki hash ključ i kako ovu funkcioniše to ćemo videti konkretno na šemi. Ono što je bitno jeste da ovaj mod funkcionisanja je dosto nakon modulara može da podrži proizvojnu dužinu podataka i samo g inicializacijonog vektora i veličinu svih ulaznih podataka koje ne moraju biti u napret poznate što nam dodatno lakšava sa strane inicializacijonog vektora ispunjenje zahteva za jedinstvenost i VR. Sečete se da inicializacijoni vektor ili non-sprednost što got koristili u tih stvari trebalo bi da se koristi sklučivo jednom prišifrovanju, ba da se odbac i virenost izabere nova. Kada fiksiramo dužinu tog nekog vektora ili nonsa, imamo manji broj mogućih vrednosti koji možemo da generišemo u odnosu na slučaj kada imamo proizvojnu dužinu te non-sprednosti ili tog početnog vektora. Tako dave, algoritm puža, pošto puža proizvojnu dužinu tih ulaznih podataka dodatno lakšava ta ispunjenja takvih zahteva u algoritima. Ulaz algoritma je istikao i za CCM. Imamo koristne podatke koji se autentikuju u šifruju, pridružene podatke koje se korise za autentikaciju, dakle to su oni neki dodatnih podaci, neki adišnog data. I tamo smo imali non-s vrednost, ovdje imamo isto neku početnu vrednost koji prosto nazivamo drugačije, to je neki početni vektor, odnosno inicializacijan vektor, ali u suštini stvari je ista, imamo nekoliko ulaznih podata. IGCM kao ICCM pruža dva moda funkcionisanja, to je autentikovan na enkrypcija, odnosno da se podaci enkryptu i autentikuju i autentikovan na dekrypcija, odnosno da se podaci decryptuju i na neki način verificu, koji dalje su stvarno došli od atle, odakle trebalo dodoću. I jedan i drugi mod kao i u CCM u koriste proces šifrovanja simetričnoj algoritma, zato iletnj kroz sve ovo jer je sve slično jako kao CCM samo šema za njancu drugačije. Što se tiče procesa šifrovanja, kažem za šifrovanja se koristi counter mod, gde prosto increment nije za 1, nego se nekoliko desnih s bitova incrementira po modulu, nekom 2 na s, vidjet ćemo u šema, autentikacija kažem se zastnivanu, da ne ubimo vreme svojnog obješnjavanja, vidjet ćemo sve naše. Što se tiče same dekrypcije, dakle dekrypcija je prosto slična kao enkrypcija, gde se counter mod prosto primjenju sa nad šifrovanim tekstom, anena nad originalnom porukom, jer opet ćemo imati neki xor, pa se dobija originalna poruka, a što se tiče taha, dakle ovdje ga zovemo tag, tamo smo zvali mak, taj tag koji se izgeneriše ponovno na strani prijema, se poredi sa onim dostavljenim tagom i uz avisnosti od, da kažem, povratne vrednosti tog povednja, u koliko je povratno vrednosti ču, onda prosto dalje desifrojmo poruku, jer znamo da ona stigla od akve trebalo da stigne, u koliko ta vrednost vraki false, odnosno tagovi se ne poklape, onda prosto algoritem izbaca neku fail vrednost, čisto da znamo da ne moramo dalje da desiframo poruku, jer tag nam se za početek nije poklape. Sama šema...
 je ovde sklopljena, dakle u jednu šemu, ali je jednostavno i dostaliči na ccm. Dakle, opet ovaj ovde gornji deo predstavlja prosto šifrovanje poruke, gde se koristi counter mod, gde opretijemo neke countere od 0 do n, gde opet neki counter i od 1 do n, n se koriste za direktno šifrovanje plain text, tako što prosto njih dovedimo 0-a zenkripsionog algoritma, pa izlas dovedimo na xor i tako dobijemo blokove šifrovanog teksta. I to je to što se tiče samog šifrovanja. Što se tiče generisanja, maka tu se koristi ovaj ceter 0 na neki način s ovom hash funcijom. U suštini sami counteri se u napred računaju na osnovu onog početnog vektora, slično kao i malo. Prosto početni counter je direktno jednak početnom vektoru, dakle neamo neke flagove, pa je ovaj algoritm od malo jednostavni, a svaki sledeći counter su dobija tako što prođe kroz ovu funkciju incrementa, gde smo rekli da se ne incrementira cijel brojačka od cijel blok podata, neko poslednjih s vita, tako da se increment radi po modulu 12, u nekom slučaju će krenuti sveda se ponavlja. Što se tiče samog generisanja maka, dakle šifrovan i tekst i jednostavan, za mak, za generisanje maka, odnosno taga se koriste i ovaj ceter 0, koji se nije koristio za šifrovanje i dodatni podacio, odnosno, adišan ovu authenticated data, ali sam šifrovan i tekst, tako da tak direktno zavisi od plain teksta, na osnovu kojeg smo dobili šifrovan i tekst, tako da tu je mala razlik odnosu na ccm i kako se to radi, pa evo ga dole cbc mod funkcionisanja, gde na ulaz ovog nekoga algoritma dolazi xor, cyfer teksta i prethodne iteraci, dakle, evo opet ovo ide dalje do ovdje u nekom trenutku prethodne iteracija, cyfer teksta, prethodne iteracije, tako dalje, našto druge. U svakom slučaju, ono što dolazi na ulaz svih ovih algoritama, je u glavnom cyfer tekst pri čemu prvih nekoliko blokova počinju sa dodatnim tim podacima, koliko godi imali ti blokova, dakle, imamo nekoliko blokova adišanog data, pa nekoliko blokova cyfer teksta i cbc mod funkcionisanja, ta ide ovoj moda se završava sa prosto jednim blokom koji predstavlja konkatenaciju dužina ovog dela podataka, dodatno odišanog autenticated data i dužine same šifrovane poruke, opet abismo mogli tačno da znamo koji ideo nam je bio a, a ideja koji ideo nam je bio cyfer teksta, ali prosto principu kojem funkcioniše cbc mod funkcionisanja, jedino što ovde neamo aes algoritm, nego imamo to množenje sa nekom, s nekim hash ključom, matrično množenje znate, jednostavno je prosto a hash ključ koji se koristi za to matrično množenje, se prosto dobija tako što niz odnosno ceo blok podata kači su svi elementi nula, a širine 128 bita se dovodi direktno na aes algoritm sa istim ovim ključom koji koristimo u celom algoritmu i na taj način dobijemo blok podata ka koji nazijamo hash ključ i taj hash ključ se koristi u svim ovim algoritmima koji prosto množi, dakle, ulaz algoritma kao presadnjim kao matricu sa hash ključom i sve naravno ugalo apolju da bi rezultat ponovog bio odgovarajućemo pse u mogućih vrenojstvih. Kada se sve lepo izmnoži po cbc modu funkcionisanja dobijemo posljenji rezultat, taj rezultat ksorujemo sa napokononim n-triptovanim ctr nula i prosto to nešto što dobijemo je taj tag koji onda dostavljamo direkno sa Cypher Texton na strani prijiva. Dobro, pošto je sad kraj časa simulacija će doći na početku sljedaćeg časa da li imate za sada neku pitanje? Dobro, ako nemate pitanja idemo na pauzu 15 minuta i onda prikazamo simulaciju u ovog modu funkcionisanja i prelazimo na nov delog radima, dakle na novu neku nastavnu celinu. Vidimo se posle pauze, pozdrav. Dali se čom, dali vidite ekran? Vidimo časa dobjegno. E dobro. Ne, ne, ono je kot. E dobro. Ništa sad ćemo ukratko da vidimo simulaciju ovog GC modu funkcionisanja. Dakle, ovde nam on traži slične podatke kao i malo. Treba donesemo neki plain text, treba donesemo neki additional authenticated data i treba donesemo is, ključ, onda mi ovde već to uneo i neki početni initializacijuniju vektor. Dobro, kada kliknemo na next, ono prosto prvo generiše, ono je hash ključ i rekli smo da se on generiše na veoma jednostavom načinu. Odnosno blok sa svih 128 bitanula, provlači kroz is koristit će is ključ koji nam je dostaljan da dobijemo taj hash ključ h. I taj hash ključ h nam je potreban prosto da kasnije kada budemo množili sve ove stvari da generišemo finlni tag. Što se tiče samog cyperteksta, rekli smo da njega dobijemo counter modum funcionisani, onda smo ovdje imamo neku funcju g counter, odnosno galoa counter koji prosto ovde ima samo jednu iteraciju, jer nam je veličina plain texta takva da, kao što vidite, stane u prosto jedan blok, a stane u manje od jednog bloka, tako što se peduje dalje sa nullama. Tako da ono što treba da uradimo, jesti da taj counter jedan provučemo kroz is blok koristit će is ključ i onda da dobijemo neki izlas, odnosno cyperedeo teksta, naravno koristimo samo ona ideo koji nam je odznačajat o ovih prvih, prva 4 byte. Kako dobijemo counter ako se sećemo, prosto, na predhodnom primeru, sada ne znam ga smo videli, smo dobili prvi brojač, to je c-0, ovde se zove j-0, tako što se non svednost prepiše, a onda prosto ostatak dela samog bloka se dopunjava counterom, odnosno ovej deo od 4 byte za counter nula kjec, dakle, vodite to o tome računa, za counter nula kjec, piša to negdana prezentacija, za counter jedan i onda dvojka i tako daj. Tako da ovej counter nula nam je prepisana non svednost, odnosno inicijalizacijuni vektor se ovde zove, taj i v, sa kjecom na kraju, a prosto ovde dalje za šifrovanje same poruke, sovzirom da jemo jedan brojač, se opet koristi, isti taj brojač od malo pre samo što je na kraju dvojka u mestu kjec, to kad se pravuče kroz i zdobijemo ovej blok i njega ksorojemo sa plain textom da bi smo dobili izlas. Ukoliko bi smo, naprimer, dakle, napravili novu simulaciju i stavili neki plain text 1,245678, pa ponovili ga malo više od četiri puta, čisto da bi to prašlo u peti blok, videli bi ste da bi se stvari malo promenile u broj ovih countera, dakle, opet ovaj hash ključ se isto generiše, ali sada imamo dva countera, prosto, odnosno opet jedan counter zaštjevanje, imamo dva countera, ovaj drugi counter prosto, odnosno ovaj drugi deo plain texta sadrži samo blok, čije su bitne stvari u prva četiri baita, a u ovom prvom counteru imamo prva četiri baita, odnosno četiri puta po četiri baita originovnog dela teksta. Sami counteri se generiše opet nisti način, imamo jedan claim of the...
 Trojku na kraju, ovaj drugi ima trojku na kraju, a ona i prosto prvi se koristi kažem za tago, on se opština koristi za generisanje šifrovane poruke. Tako da, cela šifrovana poruka se na kraju konkatenira i to je to, to nam je šifrovana poruka dobijen od plain texta, naravno od onih blokove izvučenih najviši nekoliko bita uširini samog plain texta. Što se tiče samog generisanja taga, dakle tu smo generisali prvo ovaj hash ključ, koji se generiše od onog bloka nula, a onda ono što treba da uradimo, jeste da odradimo ovu g hash fungciju koja prestavlja cbc mod funkcionisanja sa tim nožačem u hash ključ da dobijemo nešto odakle generišemo tago. I ovde vidite taj cbc mod funkcionisanja, dakle trenutni ulaz, ksoruje se sa prethudnim izlazom gde nam je x ulaz, a y izlaz, i to se manoži sa leve strane sa matricom h, tu je prestavlja hash ključ da bi se dobio nov i izlaz. I u svaku iteraciji taj nov izlaz se ksoruje sa trenutnim ulazom, noži se sa h da bi se dobio nov izlaz i tako dađ. Kako izgleda ceo taj naš ulaz? Pa rekli smo ono sa stoji iz nekoliko blokova. Prvih nekoliko blokova predstavljaju vrednost i adišunal data. Vidite, ovo nam je bio adišunal data, ceo taj blok je pedovan sa nulama, tako da jemo jedan blok za adišunal data, to je ovaj u ovde x i. U sledeću iteraciji, sledeća dva bloka su nam cifr tekst. Prvih čemu sečete se da je cifr tekst bio našrini od 5 puta 4 bytes, tako da ovaj prvi blok cifr teksta ima sve popunja, novaj drugi blok ima samo nej gorni deo i onda je svetopedovano nulama, a poslednji ulaz na u g-hash funciju, dakle na kraju svega olog, imamo kažemo konkatenira nevrednosti dužine adišunal data i dužine šifrovane poruke, da bi smo znali šta je od čega došlo, na širini od po 8 bytes i jedna i druga u okviru jedno blok. 20 hexa nam je bilo dužina adišunal data, a a nula nam je bilo u hexat cifarama ciframa prostu dužina sejker teksta, dakle 5 tonih nekih reći od po 4 bytes. Kada se sve to iznoži po cbc dobijemo neki izlaz i na kraju konačno taj izlaz prosto ksoru jemo sa onim što smo dobili na izlazu isa, kada smo koristili ctr nula, to kada ksoru jemo ta dva, prosto dobijemo ovde tag. Ovde opet možemo da vidimo da se prisetimo kako smo ginerisali ctr nula. Tako da tag koji se dobije se kači na poruku, tako da je naš prosto sajkver tekst ovo i naš tag ovo i oni se šalju na stranu prijema, od dakle kreće samo deshifrovanje. E sada što se tiče deshifrovanja, dakle ovde stvari je dosta jednostavna. Evo ga ovde na kraju imamo ovaj cifr tekst, ne znam da je mi lakš, da ja sam malo žvarljio. Cifr tekst od kojeg dobijemo plain tekst prosto ksorovanjem sa opet celim ovim ovde delom. Dakle prosto ksoro opet operacija i nvrzna sama sebi, tako da plain tekst direktno dobijemo ksorovanjem sajkver blokova sa ovim gore. Ovo gore možemo ponovno da ginerišemo na strani prijema samo na osnovu prosto ovog inicializacijunog vektora. Sa druge strane imak možemo da ginerišemo sajkver tekst. Već imamo adišnal data, moramo da znamo, ovdje dobijemo, da bi smo dobili ovde. Ginerišemo ovde i ovdje izlas, dobijemo tag i njega sad moramo da uporadimo sa tagom koji nam je pristiga u sporuku. Ako su oni jednaki, to znači da poruka jest stigla od kojoga trebalo da stigne i onda prosto verujemo tome ko da me poslala poruku, možemo onda da ginerišemo plain tekst. Pokoliko se to ne poklopi, dakle, ovo što smo dobili i ovo što smo izginerisali, onda prosto ništa ne radimo sa porukom. Dakle, nije od onog od kojeg smo misli, da će da bude i nećemo nida da je dashi frame. Dobro, time bi smo završili prezentaciju sa modovima funkcionisanja. Dalje imate nekih pitanja u ovom trenutku? Dobro, ako nemate pitanja, prelazimo na novu nastavnu jedinicu vezanu za PGP protoko koji će maja da izgriča tako da maja prepuštam reč. Na dalje izvoljimo. Hvala, laki. Dobro, dakle, kao što je kolega Adrijan Dekao, prelazimo na jednu novu oblast koje se odnosi na zaštitu elektronike pošte. I prvi protopol, odnosno šemu koji radimo u operu toga, je PGP, odnosno Pretty Good Privacy, šema. Ono čem ćemo pričati danas i sledeći pude, dok ne završimo ovu lekciju. Za početak nešto ukratko o zaštiti elektronike pošte i o radljčitim šemama koje ćemo pomenuti u okviru ovkursa. Ukratko ćemo proći kroz istoriju PGP, odnosno pre svega, kroz to zbog čega nam je PGP šema odznacija. Zašto je opšta radimo? Tako će, ukratko ćemo proći i kroz samu notaciju koji ćemo koristiti na šemama radi lakša obješnjavanja različitih servisa koja obezbeđuje PGP. Pa je to proslut da bi smo su upoznali sa tim. Zatim ćemo pričati o ključavima koji se koriste u okviru ova šeme. I na kraju, sve ćemo to integrisati u jednu široku sliku, gde ćemo pričati o tome, kako se zapravo generišu, ovo se ovo se opšta i ovo se opšta i ovo se opšta i ovo se opšta i ovo se opšta i ovo se opšta i ovo se opšta i ovo se opšta. Dobro, da sam početak ja smo ne vam potrebe da pričamo o tome s bučega nam je ova tema uokšte bitna, odgledam se bučega samu elektronska pošta bitna, zato što je to nešto što praktično svi koristimo. I u okviru, dakle, bilo kog protopola koji se uokšte bavi zaštitom elektronske pošte, naravno da je absolutni imperativ sa jedna strana obezbeđivanje autentikacije i obezbeđivanje tajnosti, zato što dakle želimo da obezbedimo da neka poruka može na siura način da se prenese, da bude zaštitja na odne autorizovanih koristika koji bi želi da pročitaju sadrežaj poruke, ili koji bi želili da poruku izmene i na neke način je podmetnu u toj komunikaciji. Dakle, zbog toga, dakle, absolutni imperativ i obezbeđivanje autentikacije i tajnosti. Mi ćemo se u okviru kursa baviti, od osto praktično pričećemo neke dve šteme, PGP šeima koji ćemo danas obrađivati i majim protopola koji ćemo krenuti sljedeći put. Gde je zapravo ideja da u toku danasnjih časa i na sljedećem času pričemo praktično nekim osnovama i u servicima koji implementiraju, dakle, zapučetak PGP, a naravno i bilo koji je ozbiljen protokol koji se bavi zaštitom elektronske bošte. A da onda sljedeći put, kad je pređemo na sami smajim, više pričemo o tome zapravo šta su razleke između ovih šema i dakle, da krenemo sa tom pričom da već poznajemo, dakle, koje su osnovu i šta je nešto što svaki od ovih protokola praktično mora implementirati. Dobro, što stiče samog PGP-a, dakle, videli smo da PGP pruža tajnosti i autentikaciju i to su neki od samo od service odnosno funkcionalnosti koje ove protokol pruža. Kastnije ćemo pričati i o drugim servicima koji su ovde takođe omogućeni, a izuzatno su naravno značeni za elektronsku pošta. Ono što je posebno značeno u okviru PGP-a i što je posebno dobra za nas kada pričemo ovim protokolima i je da mi ovde praktično pa da nećemo videti neke nove algoritme. Odnosno, čak je ako budemo videli neke algoritme u čije detalje nismo do sada ulazili, u što sviča, dakle, recimo, kriptografija, praktično to neće biti, dakle, neki novi algoritm koji je naprađen specificno za PGP. Veće, PGP-a je generalno integrisao različite algoritme koji su se prosto pokazali kao dobro za bilo koji je od ovih funkcionalisti koji on implementira kao protokol i prosto sigurno sam u PGP-a upravo se oslanja na tom skupu različitih algoritma koji su već postojili, koji su implementirani, koji su se pokazali kao dobro i kao sigurni i na taj način daju potporu zapravo ovom protokolu kojih sve zajedno integriša. Takođe, ono što je dobro je da je sam izvorni kod PGP za korišćenje praktično široko je dostupena, a da osim toga, dakle, postoji neka komercijalna verzi, koja s druge strane omogućava da postoji naravno podrška usmislu napređivanja softwarea i usmislu naravno rešavanja nekih potencijalnih problema.
 Da, PGB je izuzetno u neku šilu koju upotrebi koristi se i razlog za to je naravno što je do ostupa na razvečkim platformu, dakle nije zavisano, odnosno nije limitiran, dakle nekim operativnim sistemom, već prosto može da se koristi na razvečkim platformu. I kao što sam rekl, ono što je posebno značnjeno subina je da praktično integriše razne neke algoritme koji se dakle korista za realizaciju koji je dinočnih servisa kojima ćemo kastnije pričati. I na primer neke u tih algoritama su recimo RSA, DSS, Diffy-Hellman algoritm, zatim triple desi, ideja algoritmi dakle za simetrično šifrovanje, zatim dakle za formiranje HeSHA algoritm. I dakle, o principu, to su algoritmi koji su svaki zasebno prošli kojom prošli kroz mnogo testiranja, o kojima se diskutovalo, gde se prosto gledalo dakle koje su neke ranjivosti i prosto su odebrani od tako kao dobre algoritmi, iz toga su integrisani. Tako da ove prosto ne pričemo o nekim specificnim algoritmama koji su razvijan i za PGP, već sa te strane imaju absolutnu podršku koji oni i nače imaju i i ban PGP. Dobro, što se diče sami notacija, ove notacije nešto što nam je značeno u sklopu šema koji ćemo kasnije videti i u principu, o kojima se moji diskutovati u okvoru svaki od funcionalisti koji obezbeđuje PGP. Dakle, samo ćemo ukratku proći kroz to da bi smo čisto bili sve svi svišta i što je to što će sve biti komponenta ovi funkcionalisti. Te samim tim dakle imamo neke ključeve sesije koje će se koristiti u simetričnim algoritmima za šifrovanje. Osem toga, dakle, imamo i ključeve koji se koriste u asimetričnim algoritmima za šifrovanje što o znači privatni ključ ili javni ključ. Inače, dakle, privatni ključ nekada se označiva i kao tajni ključ, ali mi ćemo ga adresirati kao privatni prosto da ne bude zabune sa ključem sesije koji se koristi koci metričnom algoritmo, ako i je takođe naravno neka tajna vrednost koja prosto nije široko dostapljana. Dakle, jasno, imaćemo šifrovanje, odosno, dešifrovanje simetričnim algoritmom šifrovanje, odosno, dešifrovanje asimetričnim, dakle, javnim ključem. Takođe, dakle, pričaćemo o kešfunkcijama, zatim, imamo simbol za kunkatenaciju, gde ćemo, dakle, pominjati, prilikom procesu šifrovanja, odosno, bezbeđivanja, autentikacije, dakle, kada spajamo neke delove poruke, odosno, kunkateniramo i zatim pričaćemo i u algoritmima kompresije, pretažno, dakle, zip algoritmo koji se koristi u oktorom PGP-a. I na kraju, dakle, imamo i neki servis koji je bezbeđuje određenu konverziju, pa je oznočen kao R64, zato što se odnosi na neku radiks konverziju. Tako da, dakle, to su čisto simboli koje ćemo prosto primetiti na naravnim šemamo, pa i ovdje ih imamo nekako ukratko predstavljene, kako bi smo jasnije i jednostavnije mogli da se snađemo u šemama koje nam predstavajemo. Što su tiče samih servisar? Dakle, pomenuli smo već servis autentikacije i servis tajnosti, kao možda najznačajnije servis, odnosno, funkcionalnosti, gledano ovako iz aspekta koristika. Međutim, osim, ova dva servisa, ukretno, dakle, tu postoji još i servis kompresije, odnosno, funkcionalnu kompresije, zato što nam je naravno odznačaja da nekako smanjimo memorijsku za uzjeće same poroke. Osim, to da postoji nešto i što su zove email kompatibilnost i o tome ćemo kastnije pričati. I poslednji servis predstavlja podelu poruke na neke manje delove, uz avisnosti od toga, dali poruku kao i jedinstvenu celimom možemo tako da pošavljemo, ili je prosto potrebno da izvršimo, odnosno, primenimo funkcionalnost segmentacije, odnosno, podelo te poroke na neke manje celim. Prvi servis kojom se detaljnije babimo je proces autentikacija. Dakle, u samom procesu autentikacija, to našta autentikacija predstavlja, već smo pričali i pričali se o tome i na predalajima. I dakle, samo još jednom ukratku i kao pretrospektiva. Dakle, autentikacija je neki proces u kome mi prosto verificujemo koje pošeljalo same poruke i da poruka naravno nije mogla biti izmenjena od strane nekog trećeg lice. Dakle, prosto, vezuvajemo poruku za onoga koja tu poruku poslo. Ovo što može, dakle, ovdje, na ovom slajde, vidite prosto jednu šemu. I to je šemo koja nam i predstavlja kako izgleda obezbijivanje autentikacije, odnosno provera, dakle informacije koje se šalju u okviru tog servisa autentikacije, kako bi smo se zaista uverili da je pošeljala co na i za koga smatramo da to jest. I sada, kao što možete vidjeti, ova naše šema zapravo ima nekih one pojedinačne simbole, odnosno segmenta koje smo pomenuli malo preokviru one legende. Pa ćemo mi sada prosto detaljnije da pogledamo šta su to sve delovi i kako se to zapravo obezbiju je autentikacija u okviru PGB. Kao prvi korak pošeljala skrejera poruku i to je ovo što vidite, dakle, neka poruka odnočena sa M od mesiča. Nakon toga, naravno, mora da se krejera neki potpis za tu poruku na osnovu čegaj se prosto garantuje, ili tako vlasnictvo odnosno, da kažem, autorstvo nad tom poruku. Potpis se krejera na ostavu neku hješa koji je zapravo dakle neki 160, znači, zapravo hješa od 160 vita koji se krejera direktno na osnovu poruke, primjenom SH1 algoritm. Sam hješ, dakle, se nešelje tek takovec, nekako Encryptu je odnosno štiti se od toga da neka trest jo strana može da izmeni datihješ. I ta zaštita se praktično sprovodi ovde šifrovanje, gde se samo šifrovanje radi upotrebom RSA algoritma i to, dakle, specificučno korišćenjem privatnog ključa pošiljana. E, sada, dakle, RSA algoritm je jedanom algoritama asimetrično kriptovanje, što znači da se tokm šifrovanja, odnosno dešifrovanja koriste razvečiti ključeve. I vi ste već u tome pričali, međutim ja ću uklat po samo nakomenuti, da kod generala ovakve grupe algoritama govorimo nekom paru ključeva ili o parovima ključeva, gde je jedan ključ u tom parov privatni ključ, a drugi je javni ključ. Oni su nekako u nekoj korispodencii, tako da praktično ukoliko smo izvršili šifrovanje nekim privatnim ključom, onda tako poruka može da se dešifruje izključivo javnim ključom ili tako istog para. Odnosno, dakle, ukoliko smo izvršili šifrovanje javnim ključom istog para, poruka može da se dešifruje samu odkovaraćim privatnim ključom. U zavislu stvjetog koji je dola dva ključa smo koristili za šifrovanje, odnosno dešifrovanja. Mi smo obezbedili autentikaciju ili tajnost i o tomećemo više pričati u sklo plove i svedaće šene. Da, u principu, dakle, privatna vrednost, odnosno, privatni ključ istog para je nešto što je taj na vrednost i što, pod infoktu, dakle, sme upravo samo u blastnih ključa da ima. Dok javna vrednost, unosno, javni ključ i nešto što je prosto javno dostupno, s evima dakle koji prosto imaju tu vrednost, ali dakle to nije neka vrednost koja se učinija, a tako čul. I uz avisnosti od toga, dakle, mi obezbedujemo, odnosno, garantujemo neke stvari prilikom realizacije ovih pojedinočnih funkcionasti. E sada to nam je jako vizna da razumemo, zato što prosto nikada ne treba napomoc da učimo šta se čime šifruje, već u uzavisnosti od toga koju funkcionalnost želimo da obezbedujemo, mi ćemo naravno raditi šifrovanje ili privatnim ključom ili javnim ključom i to naravno prema nekom smislu. Tako da onda, dakle, dobijeni hješ koji smo opet dobilje tako primenom algoritma SH1 na nad samom porukom, kriptujemo i to privatnim ključom pošiljavca. Dakle, tako dobijeno u vrednu, sada zapravo predstavimo kao neki potpis same poruki. Taj potpis vezujemo za samu poruku i takvu poruku šajljava. Ovu što možete videti kao oznaku set što se nalazi ovde i za ove konkatenacije, zapravo označava kompresiju, odnosno zipovanja, međutim, nećemo ovom trnutku pričati u samom funkcionalnosti kompresije, o tome ćemo nešto kasnije. One samo naznačenu ovog šeme i zato što je to njena prirodna pozicija, ali pošto ćemo o tome kasnije pričati, dakle, nema potrebe sada da diskutuvamo taj ideo šeme, samo zipovanje ne utiče u ostvarivanju autentikacije. Dakle, autentikacije se postiže ovim delom koji smo do sada pomenuli, a do zipovanja. E sada jasno, dakle, na strani prijema nekako ovaj potpis mora da se verificuje, izbog toho kada pogledamo što smo mi tu zapravo dobili na strani prijema, to je poroka je o tako koja uze sebe ima ukravo, dakle, ovaj potpis. Sama poroka naravno nikako nije zaštičena, ona se može pročitati, zato što u okviru ovog ove šeme, sve što postižemo je autentikacija, tako da ovde ne pričemo o šifruvanju same poroke, već i stručivo pričemo o šifruvanju, a potpisa odnosno, heša same poroke. Dakle, ono što smo dobili je nekako šifruvanji heš poroke koji je šifruvan privatnim ključom onoga koja nama poslao u porom. I sada ono što je nama cilje da mi upravo deshifrujemo taj...
 i da provarimo dalje takav deshiprovanim hješu zapravo odgovara ove poroci koji smo dobili odaku. Kako ćemo to uraditi? Prosto ćemo primeniti deshiprovanje nad ovim šiprovanim hješom i sada kad razmišljemo čim ćemo mitu deshiprovatio ovako dobijeni podatak, pa kao što smo rekli odaku ako je dati podatak šiprovan odgovarijicim privatnim pljučom, onda on jasno mora biti deshiprovan odgovarijicim javnim pljučom iz istog pare. Tako da deshiprovanje upravo radimo javnim pljučom onog ako nam je ovu poruku poslo. I naravno na izlazu smo dobili neku vrext. Kako ćemo još doporidimo, da li je to baš ove podata koji trebao da dobio u noz? Dakle, odnosno da li je odgovara baš ove poroci. Pa, hash funkcija je nešto što je praktično one-way funkcija. Tako da mi ne možemo uraditi reverzno hješiranje, ali ono što možemo uraditi je primeniti identični proces hješiranja, odostno identični algoritm hješiranja na samom porukom. I to je upravo ovo što vidite. Kao segment algoritma mi zapravo ponovos provodimo hješiranje same poruke. I na izlazu smo tako dobili hash, one porukin koji smo dobili na strani prijem. Ostalo nam još samo doporidimo, da li takav hash zapravo odgovara onom deshiprovanom hashu koji smo dobili u procesu dekripsije i javnim ključom pošiljavca. I ako jeste mi kažemo dobro, dakle upravo ovo poruku smo dobili od tog pošiljavca od ko ga smo jočekivali u poruku. I dakle samo poruka nije promenjena tokom slanja. Čima mi garantujemo zapravo da to vaše? Pa garantujemo time što ove privatni ključ, koji mi je neku uradio zapravo podpisivanjanos na šifrovanje samo hješa, što što mora posleduva ti isključivo pošiljavca. Dakle samo korisnik A posleduje taj privatni ključ. Naravno ako je ključ kompromitovan, onda se ona ne smjeg koristiti, zato što jasno da više ne garantuje autentikaciju. Sa druvi strane, dakle, na strani prijema nama je javni ključ, ovo gvarić javni ključ ovo pošiljavca, dostupan i upravo ukoliko mi uspemo da deshiprojemo datih hash, uporedimo ga i vidimo da to jeste zapravo ta vrednost. Mi onda garantujemo da dati javni ključ, baš odgovara o onom privatnom ključu i time zapravo garantujemo da se radi upravo pošiljavcu, ili tako za koji smo ismatili da je poslalo ovu borku. Tako da, sa te strane, ovo šema nam upravo garantuje proces autentikacije. S druvi strane, sama autentikacija, možemo daljem, autentikacija zapravo sa oslanja, kao što smo retli i uvodu na algoritme koji se koriste za njenu implementaciju. Naravno, na osnovu svaku parcijalnog algoritma, koji nam ovde generiše sam hash, koji nam kriptuje taj hash, što su konkretno algoritme sh1 i eresa ovde koji je korišćen, ali, dakle, umesto, eresa može biti idej sa algoritem. Onoče što nama zapravo rada ovi algoritmi, pa oni svojom sigurnošću, odnosno svojom i očinom, upravo garantuju da je jedino one koji posuduje odgovariti privatnih ljuč mogao da generiše ovaj potpis, asa druge strane, dakle, samim generisanjem odgovariti hiash prednosti da nikodrugi nije mogao da generiše neku poruku, koja će imeti isti taj hash-code i koji će praktično moći da nam podmetne tako-taku poruku, kao da je ona zapravo inicijelno bila hiashira. Dakle, to smo postigli upotreba movih algoritma koji se smatriju kao jakij algoritmi i kao, dakle, algoritmi koji se bezpedno mogu koristiti radi sprovođenja autentikacija. Sa druge strane, naravno, ilku tipično, šaljemu ove potpise zajedno sa samom porukom u okvju Rošema, kako ste videli malo pre, potpise se takođe mogu čuvati i nezavisno od samih poruka, tako da oni se mogu negde skladištiti, i to je tipično u nekoliko use casesu, kad nam je, recimo, potrebno da čuvamo sve potpise nekih poruka, po prosto to logujemo, ili kad recimo koristimo, dakle, tako potpis da bi smo detektovili virus, ukoliko, dakle, čuvamo dati potpis u odvojenom file, u odnosu na samu poruku, onda prosto neka pogledamo da sam taj file neće biti kompromitovan neki maliciju z njim softwareom. Ili, napr. ukoliko je potpis ugnježdjenil, tako odnosno, postoji više nekih strana koje treba da potpisuju odgovareviću poruku, odnosno neki dokument, ukoliko prosto ne želimo da radimo ugnježdavanje takvih potpisa i kao neko vrepovadnje zapravo samih potpisa, onda prosto njih možemo ulančiti i čuvati ih odvojenom u odnosu na sam file. Tako da to je takođe nešto što je opcija u okviru sprovođenja ove autentikacije, međutim tipično, tako u okviru ove šeme koji smo sad objasnili, koja predstavlja najjednostavniju šemu za obezbeđivanje autentikacije. Mi i dakle u osnovnoj varianti pričamo o tome da predase sama poruka, šalje i generalno čuva sa hashom, ali odnosno sa samim potpisom, ali dakle potpis po svoj podrška i da se potpis nekako odvojenu, dakle čuva i skladišiću. Dobro, dali je jasna šema za obezbeđivanje autentikacije? Dali je jasno na koji način to postižemo i dali ove prosto imete nekih pitanja? Može piti? Može, može, naravno. Samo zašto se poruka prva hashira, pa se onda za to, znamnakom što se encryptite hashi također jedno doda, zašto se tada radi kompresija, ne je odmah kompresija poruke, pa hash tovo je tako da. Aha, pa u principu malo ćemo kasnije baš prinčiti o tome koji je neki preporučeni redosvat funkcionalisti. Ono što, naravno, je moguće za većinu funkcionalisti je primeniti i neki drugi redosvat, ali tipično se koristi neki predetinisani redosvat oji funkcionalisti, nekada je zato što je to zaista optimalnija, stvar odnosno bolje je na taj način čuvati poruke zbog useCase'ova, zbog toga na koji načini koje po daci nam zapravo trebao da ih nekada svadišćiva. A nekde zapravo postoje i limiti i o tome ćemo pričiti naško kasnije kada prvo vidimo u koji su to neki sve servici koji sobe svečuju, kako se implementiraju, pa ćemo onda preći na same detalje koji u pravo govora o tome koji je bolji, odnosno koji je neki usvojeni redosvat primenivanje ovih pojedinočnih operaciju. Hvala. Nema na čema. Gjeli ovo ješ neku pitanjem? Dakle, ako ne možemo dalje? Ok. Sledači servis, dakle nam je servis o bezbeđivanje tajnosti. E sada, dakle, ja smo kada pričamo o bezbeđivanju tajnosti, tu pre sve vam istemo na to da samo poruka se na neki način šikruja, ona je samim tim zaštićena od čitanja, odakvo, od strana nekog neautorizovanog koristika. I dakle, naravno postože se pitanje, kako se da se šifruva da je tako poruku kojim ključom ili tako kako ćemo distribuirati taj ključ, dakle tu postoji dosta nekih pitanja. U principu, glavna ideja da se samo šifruvanje poruke radi upotrebom nekih od simetričnih algoritama. Dakle, ovdje mi koristimo kas 128 ideja ili triple desa algoritama, ali ostavna ideja za prvo je da radimo tu encryipciju primjernom nekih od simetričnih algoritama. I dodatno, dakle, kao kombinacija u zadati algoritm poristi se CFB mod funkcionisani, videli smo u okveru predhodne prezendacije kako funkcioniš u ovim moduvi i kako se zapravo koriste zaino sa samim algoritmima. Najbolje da ovaj ideo prosto prođemo takođu prođemo šemu koja, dakle, potreće, na ovo što smo videli malo preali, naravno je specifično za ostvarivanje uprvo ovog servisa. I tu ćemo, dakle, videti sve ove segmente, kako se primenju izbog čega i šta je zapravo implicacija uprvo takođu obezveđivanja tajnisti. E ovo, ako znači, na početku ponevo imamo generisani same porike. I kao što vidite, tu opetimemo ovo kompresiju, ali kako je malo prezanemarite sad svu kompresiju, ovo ćemo pričiti nešto kasnije. Dakle, kompresija i ako može uticati na tajnost, ne predstavlja deo koji tipično ima namenu za ostvarivanje tajnosti, tako da ćemo to pomenuti nešto kasnije. A sad prelazimo na ovaj drugi deo šeme koji se zapravo odnosi na obezveđivanje tajnisti. A to pre svega predstavlja kriptovanje, dakle same porike. Što znači da potrebno da imamo neki ključ cesije i da uprvo tim ključem cesije, a u potrebom neku godonih algoritama za simetričnog šifrovanje, mi zapravo šifrujemo našu poruku. Sad na naravno, dakle, dati ključ cesije je najbolje izgenerisati na neki način i koristiti ga izključivo jednom za šifrovanje ove poruki. Razvok za to je naravno što, ostavim dobrah algoritama koji se koriste i čijom praktičnu sigurnošću se garantuje sigurnost pove funkcionaliste u okoru PGP-protokola, ono čo smo pričali na predkodnim časovima i je da je praktično za poboljšanje sigurnosti samo do algoritma uvek bolje imati novo izgenerisani ključ. Tako da mi ove zapravo svaki put, kaj ne rešimo neki novi ključ, kao neku slučojnu vrednost i koristimo dati ključ za simetričnošnog šifrovanje same poruč. Međutimo, onda naravno, ako svaki put generišimo neki novi ključ, jasno je da se postavlja svita, kako ćemo mi dati ključ.
 ljuče zaprevo distribuirati. Ka pa ćemo ga mislati o noj prijemnoj strani, ako već ne rjuzujemo taj ključ? Kada bi smo mi recimo uvijek koristili identično ljuče, li taj ključ nekako periodično menjali, onda naravno imelibismo i drugih načina da prosto distribuiramo ključ i to bi smo mogli do radimo nekako offline ili dakle prosto koji neke druge protokole slanja samih informacije. Međutim, ako ćemo za svako ovako šifrovanje, generisati novih ključ, onda se prirodno navoće ideja da zapravo samo iz generisanih ključku i će biti potriban za dešifrovanje ove poruke na strani prijama bude upokovan zajedno sa porukom i poslat na drugu stran. E sad jasno, absolutno nema nikakog smisla da mi dati ključku i koristimo, pošljemo kao plain text, jer u tom slučaju naravno što smo radili sa ovim šifronjem. Tako da ja sam da mi dati ključ takođe moramo nekako zaštititi i tako zaštićeni ključ poslati zajedno sa samom porukom na drugu stran. Međutim, na koji način ćemo mi u zapravo uraditi šifrovanje, odnosno bezbeđivanje tajnosti samog ključa. Pa jasno je da ne možemo upotreviti i ovdako sada simetračni algoritm jer opet čim ćemo šifrovati, odnosno koji ključ ćemo upotreviti u takvom šifrovanju. Dakle, siguro nećemo isti ključ, a opet nećemo li neku treću vrednosti i bi onda rekursivno morali da razmišlamo kako ćemo tako vrednosti distribuirati. Tako da ono zašta koristimo zapravo za šifrovanje, odnosno bezbeđivanje tajnosti samog ključa koji se koristi u ovom simetričnom šifrovanju je upravo, dakle, ponjero šema, uplat šema kryptovanja sa asimetričnim ključevima, odnosno sa parom javnog i privatnog ključa. Sada, dakle, postavio se pitanje, sa kojem to ključom i zapravo radimo šifrovanje. A ono što treba da obezbedimo, to je da isključivo, dakle, primalac, odnosno, one koristiku me smo mi namenili ovu poruku, bude u mogućnosti da dekriptuje dati ključa samim tim da uradi dekripsiju same porke. Što znači da on treba da dekriptuje naravno tu poruku, odnosno sam taj ključ, nekim svojim privatnim ključom, pošto poruku je od tako odnosno ključ, ne smedate dekripto je ni jednotreća lice. U tom slučaju, ako ključ treba da bude, odnosno, sessiski ključ, treba da bude dekriptovan, odgovarajući privatnim ključom nekoho koristnika, jasno je da ćemo mi je inkriptcije uraditi i odgovarajućim javnim ključom tog koristnika, koji pripada istom paru privatni i javni ključ. Znači datu kriptovanje sessisku ključa, mi uradimo primjenom neku algoritma za asimetrično kriptovanje, RSA algoritmo, recimo, i dakle, u potrebom javna ključa, odgovarajući koristnika, komensmo poruku na menje. Na taj način dati ključ i kriptovan, on je zaštičen i nićemo ga prosto spojiti sa šifrovanom porukom i tako šifrovanice o paketil, tako poslati na stranu prijem. Naravno, cilj na strani prijema je da se dešifruja sano poruka, a da bi poruka moralo da se dešifruja, mi prvo moramo dodođemo do datu ključa. Pošto je ključ takođe šifrovanje o tako, on mora da se dešifruja i videli smo o tako, to se radi i reverznim postupkom primjenom identičnog algoritma, što znači RSA algoritma, ali u potrebom sada privatnog ključa ovog koristnika, koji je tako poruku dobjaju. Kada dešifrujamo dati ključ, mi smo zapravo dobili sessiski ključ, koji ćemo al tako koristiti da bi smo dešifruvali sano poruku istim onim algoritmom koji je korišćem prilekom šifrovanja sanoj poruke, ali dakle to je neki simetrični algoritm. I na kraju mi smo dobili našo poruku. Zašto znamo da je ovo poruka, dakle, odnosno, zašto znamo, zašto smo sigurni u tajnost koje se bezbeđuje na ovakam načinu? Zato što smo sigurni u to kako smo distribuirali sam ključ, sigurni smo da, ukoliko zaista primalacije jedini koji posleduje odgovarijići privati ključ, ponovog kavoj mala presa oslanjamo na pouzdano samog RSA algoritma. I ukoliko on jeste jedini koji posleduje taj ključ, to znači da ni jedna druga strana nećemoći da dekriptuje sam sessiski ključ. Sa druge strane, ukoliko neho prosto nema sessiski ključ, čak i da je dozio do šifrovanje poruke na osnovu sigurnisti, koji obezbeđuju u algoritmi za simetrično šifrovanje, mi prosto garantujemo da takva poruka ne može biti dekriptovan, bez informacije o samim ključevima koji se zapravo ovdje koriste. Ovdje ponovog dakle, imamo neku reverznu kompresiju, odnosno, da je kompresiju, ali u tome ćemo opet nešto kasnije, kada budemo radili sam algoritm za kompresiju. Dobro, što se tiče nekih alternativa? Naravno, ovdje imamo alternativu za razmenu ključa. Dakle, kako mi razmenjujemo kogreta sessiski ključ, pa razmenjujemo ga tako što ga kryptujemo u potrebo meni sa algoritm. Međutim drugom mogućnostku u PGP ob mogućava je al tako i je da koristimo djipih helman algoritam za razmenu ključa. I ono što ste tipično mogli da vidite pod ovok protokola je da on generalno obezbeđuje primjenu različedih algoritama za svako ovu pojedinačno funkcionalist. Dakle, prosto ni za simetrično kryptovanje, ni za razmenu ključova, niste limitirani isključivo jednim algoritmom. Dakle, naravno, da ple možete izabrati onaj algoritm i u generalnu, da ple vidite, primene algoritmo koji vama najviša odkovera u konkretnu implementaciji svih ovih funkcionalisti, gde onda jedinu što, naravno, se podrazumeva je da mora postojat i dogor na strani slavanja poruke i prijema poruke. Zato što je jasno da, okoliko je poroka šifrovana nekim algoritmom, ona mora biti deštje provan, ti niste algoritmom, inače će to zapravo viti samo drugi vid šifrovanja i onda zapravo, naravno, takve informacije moraju negde biti u građena. Ok, ono što takođe je interesancno ili što zapravo se možda neki broj vas pita, zašto nismo za samo obezbeđivanje tajnosti poruke, odnosno šifrovanje same poruke, koristili već asimetrično ingričio i na taj način prosto nekako uštedeli na potrebi uopšte postojenja ovog sesijskoj ključa, koji se zatim i on šifruje pa distribuira. Ravog za to je što je upotreba, odnosno šifrovanje pomoću javnog ključa, skupki procesu odnosno na algoritme koji rade šifrovanje na osnovu sesijskoj ključa, odnosno simetričnoj ključa. Izbog toga, onšto je ideja da se praklicno algoritmi sa simetričnim ključajima koriste u slučajima šifrovanja većih podata, tako što tipično jeste polka, a da se prosto šifrovanje neke manje poličine podata, ka što je, recimo, šifrovanje, odnosno bezbezivanje tajnosti samog ključa, radi upravo algoritmima sa asimetričnim šifrovanjem. Na taj način prosto imate brže obezbezivanje tajnosti, je finije obezbezivanje tajnosti, a opet, dakle, je tamo gde imate manji podatak, od kog je ključno obezbediti tajno što je upravo šifrovanje samog ključa, se iskog koji se kasnije koristi, viste dakle iskoristili, ovo da ka tako kažem skuplje, šifrovanja. Takođe, ono što je još jedan doba raspak TGP protokola, je da za ovaj pojedinačne algoritme zaštite obezbeđuje takođe različit nivosigurnosti, bar što se tiče obezbezivanja obsega veličine ključa, tako da je takođe pruža različite mogućnosti za definistanje veličine ključa koji će se koristiti u nekim algoritm. I na sljedećoj šemi imamo prosto integriseno kako izgleda proces obezbeđivanja tajnosti i autentikacije, gde zapravo dakle sam u operu jedna šeme možete vidati ovo če vam smo pričali sada u operu pojedinačnih šemu za obezbeđivanja tajnosti i autentikacije. Tako da ćemo samo ukretko kroz to proći, nemo potrebi da se naravno zadržavamo na detaljima, jer smo o tome pričali. Gde, kao što vidite, dakle, na ovom donju šemi. Prvo svojro koje se obezbeđuju sami porutci i je obezbeđivanje dakle autentikacije, odnosno krajera se hash i zatim se taj hash kriptuje privatnim ključom koristika. Poruka i hash se nekako okonka te nidaju, zatim se primenjuje ola zipu koji vidite, okome ćemo košto reko kasnije pričati i nakon toga se obezbeđuje sama tajst. Što znači generiša se neki sesijski ključ, šiprove se poruka upotrebom simetričnog algoritma i tog sesijskog ključa. I naravno dati sesijski ključ se enkriptuje odakv o upotrebom nekoga simetričnog algoritma, RSA algoritma ili se distribuira dakle na odgovarajući nakče. I to šiprovanje se radi naravno sada upotrebom javnog ključa privaca i zatim se dakle sveti sviti podaci konkateniraj. Znači ono što imamo sada je konkatenirana šifrovana poruka, šifrovani ključ sesije i dakle u okviru naravno ove sami šifrovane poruke nalazi se i sam hješo, odnosno potpisku i generisam zadatno poruka. Na stani prijama jasno, svi ovi procesi se moraju nekako reverzno uraditi i odnosno rade se supratnim redosledom, što znači prvo se mora desiprovat i samog poruka, a da bi se to uradilo, naravno desiplo se ključ koji je korišćen za šifrovanje same poruke. Tako da sada se ovo radi, a dakle desiprovanje upotrebom privatnog ključa koristnika koji je primiju tu poruku, na osnovu toga se dobija...
 desiprovaniji sesijski ključ i takav sesijski ključ sa sada poristi prilikom ovoksimetričnog desiprovanja zapravo same porke. Kada se porukha desipruje, u koliko je bilo komprimovan na prolezi kroz proces dekompresije, i onda naravno sve što još potrebno je verificovađa i tako poruku, odnosno verificovađa i njen podpis. Što znači, dokvatamo generisani potpis, desiprujemo dati hash i pošto hash bio šiprovan privotim ključom pošiljavca, sada se naravno desiproje jabom ključom pošiljavca. I još, dakle, tako desiprovanji hash se mora uporediti sa hashom koji se dobija na osnovu primljene poruke koje sada desiprovana i dakle izgenerešene se hash na identična način primjenom identične funkcije za formiranji hasha i takve dve vrednosti se upored. Ukoliko smo naravno dobili pohlapanje, odnosno, autentikovali smo zapravo sam poruku, onda naravno tako desiprovanju poruku iskoristimo već na podrozumevani način. I ovdje što možete primjetiti je dakle naša šema za obezvizivanje tajnosti i autentikacije koje, naravno, uspuk kao što vidite, obezbeđuje i kompresiju, ali o tome više nešto kasnije. Sada, ovaj u principu neki reduz da doparacija koji žalimo da primjenjujemo, gde u ovom trnutku bez samog disputovanja kompresije, dakle, pričamo o reduz sledu, gde da ka prvo obezbeđujemo potpis, pa te konda obezbeđujemo šiprovanje samog poruke. I u principu baš ovakav reduz ladiramo, zato što tipično dakle kada dobijemo neku poruku, ono što želimo je da čuvamo taku poruku. I sa druge strane naravno da imamo potpis gde možemo u bilom kom trnutku i nekada kasnije, da prosto verificujemo dati potpise za samog poruku. Videli ste već neke use case-ove, gde mi prosto želimo da čuvamo da dati potpise same poruke. Z druge strane, ako bi smo prvo radili šiprovanje, pa te konda potpisivanje, onda jasno je da bi smo imali hash kriptovanje poruke, te sa te strane ili bi smo morali da čuvamo samo kriptovanu poruku i njem potpis ili bi smo morali da radimo dakle ponovog proces kriptovanje. Što znači ne želimo je o tako nešto da urodimo, okoliko kasnije želimo da prodarimo sam potpis, a čuvamo recimo čistu poruku, ali potpis je vezan za enkriptovanu poruku, onda bi jasno bilo da bi svaki put morali da radimo ponovog kriptovanje poruke, izbog toga da bi smo prosto izbeglili režijske potrebe, odnosno režijske troškovi da hlavi dodatnik operacija, zbog toga što želimo dočuvamo, dakle tipično uprvo usvojamo ovakav redoslado operacija, odnosno dakle prvo radimo potpisivanje same poruke, a nakon toga te kradimo enkriptio. Odnosno je od tako prilikom prijamo poruke, u obrnutom poretku primenjujemo ove dve operacije. Ok, a nakon što smo videli ovo šemu koje nam pokazio je kako se implementiraju tajnosti i obstetikacije, recite mi da imate nekih pitanja. Ielimo ne? Aha rec. Zvijem se, pa sam se pitan zašto se ne koristije AAS s orde, nego CAS te ide na zbom šta su uke. Da, pa mi nismo radili detalje ovih algoritama, a prosto iz razvuga što naramo nikada ne možemo uraditi detalje svih algoritama, ono što nam cilj na prosto ovom kursu je da vas uvedemo u neke ostove da razumete kako funkcionišu ovi protokoli, da naravno, svatite da u taj neki box, da kažemo ovde se može uglopiti neki blockovski algoritm, prosto znaće da se može ubaciti neki drugi algoritm. I naravno, detalje svih algoritama ne radimo i iz razvuga što ćete vi jednog dana isto to ako se budete badeli ovim koristiti u ovom koristitivu neke ubljatega, koristiti već neku gotovoj implementaciju ili svakako imate i mogućno da se uputvite u neku konkretnu implementaciju. Sa druge strane, prosto ovaj protokol definiše neki skup algoritama koji se koristi. To je tako odlučeno i izabrano za sam protokol i kao implikaciju naravno podrozumeva da košta sam već rekla nekde da ta informacija mora bići uključena, o tome ćemo nešto kasnije pričati u tog kursa već na sledećem iljonom tamo čama. Dakle gdje se specificira zapravo koji algoritem se koristi da bi tako algoritama mogu da se primenju i na stanit prijem. Ali tako protokol je nešto što prosto odlučuje, odnosno nešto što u oferu čega je napravljen skup odgovarajućih algoritama za svakod ovih funkcionalnosti, da je svaki te algoritem prosto ocenjen kao dobar za taj protokol. Mi ne ulezimo u detalje svih ovih algoritama i ako se oni koriste dakle Ivan samo o ovog protokola, jer kao što sam rekla, dakle nisu specificni za njega, mogu se koristiti Ivan Tok. Nešto malo više o ovom prvom algoritmu koji do sada nismo videli, dakle ćemo pominjati na sledećem času koje da budemo upravo pričali u generisanju samih ključova, tako da je to, tada možda postane jasnije zašto, recimo, koristimo taj algoritem u skupu PGP. OK, nema na čemu. OK, nema na čemu. Da li imamo još neko pitanje? Ima našto u četku. Aha, pa što se više kolokujemo, dakle mi smo rekli, odnosno kolega Adrijen je rekla ono početku časa, šta je planirano dođe od samog gradijoga za kolokujem, što se više vežbi. E sada, naravno, okuvom znači informacija koja vidila integrisana i završba i za predavanja, svakako, dakle, možemo poslati tu informaciju kutem elegiast. OK, vaš, da li vam da ćemo postati? Da vro, recite mi, da li imete još neko pitanje? OK, ako nemojte više pitanje, onda možemo stati sa PGP-om za danas, prosto nastavljamo sljedeći put sa preostalim semstionalstima i integrisanjem, ključevima i već sve što ste videli u okvjoru samog uvoda, odnosno sadržaja ove prezentacije, tako da je to, da te sljedeći put, završavamo PGP i počinjamo S-Mine. Hvala na pažnji, vidimo se onda sljedeće ne deljem. Cao svima. Mose, ljudi, zdravo.
