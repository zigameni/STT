 Prvi će biti in, drugi string, treći bullion, četvrti rekord, pet i double. I to automatiki asocira na onu torku kojoj smo vi maloče stavili tamo. Ali da li ćemo dovoljići tu torku ili ne, to možemo da specificiramo još i vrednostima. Da kažemo ne samo što smo specificirali tipove, to je kao da smo stavili ver. Hako smo rekli gde ima pet tipova, prvi je taj tip, drugi je taj, treći je taj, četvrti je taj. Možemo da kažemo još da prvi ima vrednost 3. Ne samo što možemo da naznačimo koje tipove. Želimo da pretražujemo u toj torki, u tim torkama, pošto ih može biti puno, nego možemo za svaki od tih tipova da kažemo koju vrednost želimo da nađemo na tom pođu. I ako nađemo tako nešto, mi to preuzmemo iz prostora torki. Ne može tog objekta tamo nema, uzeli smo ga, nije više deljen, nema ga. Aha, dobro. Ili mojoš nešto od metoda? Ima, pošto je metoda rid. Metoda rid radi ističnu stvar kao je metoda in, koru identičnu stvar kao metoda in. Nije baš identičnu, malo se razlikuju. Metoda in nađe objekat u prostoru torki. Doga ne nađe čeka, ka ganađe pokupiga. Metoda rid ga pročita ali ga ne preuzme iz prostora torki. Znače, kad kažete in, vi ste uzeli, nema ga više tamo. Kad kažete rid, samo ste pročitali vrednost koja zadovoljava šablon koji ste zadali. Ove metode su blokirejeće. IN i RID čekaju dok legoce to ne pojavi u prostoru torke. Pored ovog ovde IN i RID postoje njihovi neblokirejeći parnjaci. To su INP i RIDP. INP, idem ja da vidim, je sada postoji torka koja mi treba. Sada trašim. Ako sada postoji super, preuzećuje. Ako sada ne postoji, vratiću da ne postoji torka i neću se blokirati. Peto da RID, P, idem da proverim. Sada postoji pročitati i vratiću da je pročita. Ako sada ne postoji, vratiću false i neću ništa pročitati. Pjet metoda. Imoješ jednu metodu kojemnom sluči za pokretanje procesa niti. To je metoda eval. Ovo je ovde eval, pokreni data u niti, dati proces. Pa sad je nitel proces. Ne znam. Ako sam rekao eval, a da će biti to pokrenuto kao nit u moj madresnom prostoru. Ili će to biti pokrenuto kao proces na u mojm računaru. Ili će to biti pokrenuto kao proces na nekom drugom računaru. Ja nema poima. Pokreni gde god da postoje slobodni resursi. Uopšte ne ulazimo u to gde, na kojom računaru postoje slobodni resursi. Da tam je to da eval može da se izvrši. Ili se se ne ulazimo u pozadni, ne nađe, te vi treba računar gde će ovdje da trči. Dobro i onda nađe neki računar gde će to da se pokrene. To može biti isti računar na kome se nalazi ovaj roditiski program. Ali uopšte ne mora biti taj. To može da se izvrši u, kažem, u Kini. I ajde da vidimo još jednom. Šta su ove torke? Šta rademo to da je in i auto? Torka je data.tap. I to je neki objekat koji ima veći broj polja, gde svaki polje ima vrednost i tip. I evo ovde i jednot primera, tag kao tekst. I najčeći će nama kod ovih torki koji bi budemo stavljili u taj zajednički prostor torki. Biti sistem realizovan tako da je prvi argument tipa string. Da tačno možemo da kažemo, kao da smo odradili selekciju. Daj mi sve one torke koji označavaju evo ovde tag. Imajno, da imaju prvo polje koja ima vrednost, fiksno vrednost. Kada ovako nešto postavimo, to je fiksna vrednost i je tag, string smo ustavili kao literal. A ovo ovde veđu i jedan do veđu, jedno smo pročiteli najverovatni neke promenjive. Odnosno to su bilo neke promenjive. Mi upisujemo kopiju. Šta sam sam sada rekao? Ove prostor torki. Use upisuje kopija naših objekat. Da se možemo da prosladimo nešto po referenci. Da tu mi bacimo pokazivač, a da ona druga strana dohvati pokazivač i da nešto raditi s tim pokazivačem. To neće da rati. Razlog, pokazivač u jednom adresnom prostoru pokazuje na nešto. Prokazivač na tuđem adresnom prostoru takavisti ko zna našta pokazuje. Či dalje je to smisne, no da pokazivanje ili je potpunno besmisleno pokazivanje, to ne znamo. Ovi objekti se realizuju i takvi objekti se prosleduju dalje. Oni drugi strani se prosleduju objekti po vrednosti. Iskopiraju se i prosledaju se u prostor torki. Ajde da vidimo kako se ovo ovde koristimo. Kako možemo da iskoristimo in? Primer, zjednu in metodu. Imat ćemo in i prvo će biti polje string. To smo stavili ovde vrednost. Drugo će biti nešto što će o mi smestiti u našem promenivu a. Ove vidite stoji a, dve tačke temi. Nećemo koristiti ovu ovde oznaku sa dve tačke, njegod ćemo koristiti ovu malo drugačiju oznaku sa znakom pitanja. Vi ćemo ovde staviti znak pitanja a. Kaže, meni je sasvim sve jedno koja se tu vrednost nalazi. Ja želim da pročitam tu vrednost, ali je bitno da bude istog tipa kao a. Či a ovde specificiram projekciju jednu koju želim. Znači mora da se pogodi po broju argumenta, mora da se pogodi po tipu argumenta i mora da se pogodi po vrednosti argumenta za one vredno argumente koje smo navjeli. Znači ovaj ovde smo navjeli tačnu vrednost. Za ovaj ovde smo navjeli tačnu vrednost. Za ovaj ovde smo navjeli tačnu vrednost. Ovde nismo rekli tačnu vrednost, ovde smo rekli šta gode da je pročita i upiši u promenjivu ka. Če to su dva, da kažemo, ista načina za predstavljanje. Sad ovde se koristi a i ka, a može da se koristi i ovo, što ćete češće naći u biblioteci za programski jezik, c, amperson. Ve kažete tačno tu smesti nešto. To će biti pokazivać da će nešto biti smešteno. Či torke koje želite da dovlačite moraju da budu usklađene sa torkama koja se nalaze tamo, moraju da se poklopem po broju argumenta, po tipa argumenta i po vrednosti argumenta oni koje ste specificirali. Ono što niste specificirali, vi će pročitano iz prostora torki. Znači taj šablon pretražujete. Kažete, ja ovo tražim, dok ne nadžem, ja ne idem danje. Pa sam rekao sad, rekao sam da se radi o blokirajućoj metodi. Či metoda in ne može da pređe na nareni korak dok legodne ne promlađe šablon koji zahtjeva. To je da se poklopimo po broju argumenta, po tipa argumenta i po vrednosti argumenta za onje za koje bilo navedno, a po navedno na njihova vrednost, tamo gde nije bilo navedno na vrednost, tamo će biti popunjena u lokale promeljive. Top. I to je to. Kako možemo da napravimo neku, da kažemo, jednostavnu barijeru? Jednostavnu barijera koristići ovo ovde, je na početku pre početka rada ubacimo u prostor torki out barrier 1-ko 0. To je objekat, odnosno torka, da imamo koju vrednost ima. Ta torka ima 2 argumenta, 2 polja, 1 polja string, 2 polja integer, 1 polja ima vrednost barijer, 2 ima vrednost 0. To rani svaki od ovih naših procesa, kad dođe na ovak u jednu barijer. On kaže in, kaže daj, koji ću da preuzmem objekat iz prostor torki. OK, šta preuzimam? Objekat koji ima 2 polja, 1. polje je tipa string, ima vrednost barijer, 2. polje je tipa integer. I ne zanivam je koju vrednost ima, ja želim da pročitam tu vrednost. Označi ovo znak pitanja. Šta onda radim? Kajšem, out, barrier i count plus 1. Kao da sam pristupio, ovo ovde sad ako uzmete posmotrete, se ponaša kao da sam pristupio promenjivi koji se izove barrier i dohvatja sam sa in i izbacio sam je nazad u taj prostor torki sa out. Kajšte da se ovde ponaša i kao neka hash fungcia, odnosno da imamo ki value store. Možemo da kažemo da je ki value samo što ovde može da bude multiple. I šestruka vrednost. I šta čekamo još na kraju barijere? Kajšemo read, šta kaže read? Read kaže ja čekam, dok le god se nedasi sledacija stvar, to je da