 ako su lma adresa eksplicitno navedene i razlikuju se od VMA adresa. Drugi način da se navede lma adresa, jest opet preko regiona, moguće da ode definišamo taj treći region, koji bi bio naprimer, njakato bude isto ovaj adresa 7654, prekopirećemo nju, ovdje možemo da uklonimo ili da zakomentarišemo kako god. Drugi način je da se kaže et pa onda region treći. Dakle, ovi smo rekli vemeja adresa, jeste u drugom regionu, to je počevo dove adrese, ali lma adresa, da je ovo zaista fizički na kraju treba da se smesti, jeste region treći i to je ovdje lokaciju. U suštini k sada ovo kad prevedemo, dobit ćemo istu stvar kao i malo pre. Evo je ta adresa lma, ali na njoj se nalazi podatak u skladu sa VMA adresu. Informacije o vrednostime za VMA i lma adresu se naravno čuvaju i u okviru samog izvršnog fila, to je ovaj elf fil, koji mi koristimo da bi smo dobili heks, i one se mogu vidjeti ako se pokrene obaj je dump nad elf filom i ako tražimo pregled seksija, dakle minus h i kažemo lma elf, vidjet ćemo, dakle, da je za izlznu seksiju program VMA adresa 2220, a da je lma adresa takođe 2210, dok je za izlznu seksiju podaci VMA seksija, VMA adresa te sekcije 44444, a da je lma adresa 76547654. Ono što još jeste bitno i nije loše da se pogleda, jeste sam disassemble ovog programa koji smo mi napisali. Dakle, ako pogledamo izlznu seksiju program, u njoj se nalazi LRR, R0, pa u onosu na PC relativno adresiranje sa offsetom 0 se uzima neki podatak. Dakle, rekli smo da ARM nemoj mogućnost da u ova dva byte-a, koliko je u lika veličina jedne tam instrukcije, ne može da se upiše sama adresa ovog ovde podatak. I ono što ja sam vljerozda uradio kad je prevodio ovaj kod, je ste da je bodao, 44444, što je vrednost ovog simbola podatak i to je adresa koje se nalazi sama ova vrednost. I onda je do tog podatka došlo sa offsetom 0, zato što kod ARM zbog piplina od 3 stepena postoji tradicionalni offset, u pisine pokazuje na narenu instrukciju, nego na dve narene, a pošto je veličina u tam dva byte, onda je to, u suštini, 4 byte-o onosu na tekuću instrukciju. A kodemo, plus 4 byte, to bi bilo u onosu na ovo, ovde bi bilo plus 1, plus 2, plus 3, plus 4 i odade bi se dohvatio podatak. Što nači da će ovo ovde instrukcija dohvati upravo, ovde što i bilo neoponno da se dohvati. Ono što je jeste bitno da se primjeti, to je da je ovde na ovom mestu upisa na vrednost 4, 4, 4, 4, 4, 4, 4 i ako je to biće smesteno zbog lmaa adrese na 7, 6, 5, 4, 7, 6, 5, 4. Dakle, lmaa adresa igra u lugu samo u ovom posljenjem koraku, kada se pravi hex file. Sve ostalo, dakle, ovde generisanje koda, generisanje podataka sve se odnosi na vm.a adresu. Samo na kraju kada se vrši smeštanje, onda u lugu igra load, memory adresa smeštanje je load, a ovom apriranje podataka je su stvari koje se veziu za vm.a. Šta je još možda koristna stvar u okurulinkerski scripte? To je definisanje simbola koje onda možemo koristiti u drugim delu ima koda i ovde sada možemo da definišemo na primer vm.a. Onosno, izlazna sekcija po datci, njen početak, po pitanju vm.a adres. I ovde možemo da koristimo internu funkciju linkera, to je adader, da je možemo da kažemo daj nam vm.a adresu od simbola is podaci. A možemo da definišemo još jedan simbol koji se nazivaju is podaci, start ali lm.a, a za to ćemo koristi funkciju koji se naziva load adader, isto ćemo proslediti is podaci. Ove sad simbole, mi onda možemo da koristimo u drugim fileima, ako su nam neokonili da dohvatimo njihove vrednosti. Slično stvari je mogu da bude i ovde, da je ovo bude neki start vm.a. Da je bismo rekli da je ovo u suštini tekuće alokacija na koji se ovo smešta. Da ne bi, možemo da ovo je bolje da nazovemo vm.a.1, a ovde neka bude vm.a.2. I ako sad izvršimo povezivanje u Hex file, naravno se njišta neće promeniti, ono sto još samo možemo dujemno, jeste tabela simbola u ovom ovde elfu. Kako što vidite, vm.a.1 ima vrednost 4444, vm.a.2 isto ima vrednost 4444, dok lm.a., koji smo dobili sa ovom funkcijom, ima očekivanu vrednost 76547654. Ovime je završena druga lekcija. Pozdrav do sledećeg slušanja.