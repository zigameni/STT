 Evo dobro dan svima je še jednom, ja mogu samo prenego što krenem čas, standardno nekod na mi potvrdi na četu, dalje se čuvemo i dalje vidite ekran koji deli. Evo zvafadljujem odmah koleginici na brzom odgoru. Ako se nevaram, prejedog sam državao ako čas, sodvjero da smo sada danas ovdje spojeni si i ljudi sa SIA i ljudi sa IER, vidim da ima i ljudi koji esu sa sovcištvom inžinještva. Ako neko slučajno budi, ima problema sa četom da ga ne vidi, pa da ne može rekuca poruk, i slobodno možete meni na tim, da šaljete privatnu poruku koja u kvali os nešto bude zanimalo, a kažem da taj čet eventualno može da ne vidi, tjera znam da prijeste bilo neki problema sa tim. Prvno, prejena, košto krjem na danasni čas, ilte za danas nam reko da nam je po planu da radimo onu četvrtu fazu ili te generisani koda. Prvno, košto krjem, imamo neki pitanja zove do sada, bilo štao kovezno na organizaciji, kursa i slično. Vrlo, idej, eventuvalno, ako neko nješto smisli, neko kutsa može da su uključi laje. Ajde, ja su na nastavima ovako. Dakle, prvo, samo danas ćemo malo duži čas imati, pošto u danas kažem tu četvrtu fazu bih završio skroz da sad ne cepkamo to na dva odzola na časa. Tako da imam dosta da vam izprijedno oko tih instrukcija koje postoje i samete organizacije naše virtualne mašine koji smo napregli za projekt, kde im vji koristite. Onda od narednog časa ja prelazim na gradigo koje više nema veze sa vašim projektnim zadatkom i to će staviti već na slajicim času nekako i različete reprezentacije bytec-coda. Da ćemo tu imati, videte ćete, već sad ne prikazivaćemo tamo najakove trojke, četvorki, nekako ja, cyklične graf, syntax na stavla i slično. Dakle, bagiču se nečom što više nema veze konkretno sa onim što vi radite u samom projektom zadatku. Onda nadaljite ćemo raditi tamo nekako generisa nx86 koda pa četirite i malo će vas raditi na prvu godino, vidite ćete čak i neki paska ili slično. Tako da je tu da znate danas, ja zvršavam se što je vama potrebno da li možete reklenete da radite projekati i bukvom da danas završamo gradivo da cel projekat zapravljava za. Košto, pitanja, nema, ajmo mi, onda po laku, redno moj laku. Dakle, reko sam danas treba da vam predstavim tu micro-a-virtualnu mašinu, kada pričemo koda dok je zanimacila vas kako izgleda organizacije te micro-a-virtualnu mašinu i zanimacila vas kako izgleda instrukcije koja ona to podržala. Ako da ćemo krenati prvosa, memorijski mobilastima, pošto ih ima par, pa sad objasnimo što tu sveko stoji i kako se među sveno organizala. Dakle, ajmo odni bi prikazamo, pa ćemo da jednu po jednu da objašnjavamo. Što se tiče memorijskih oblasti micro-a-virtualnu mašinu ima ovih pet različitih oblasti. Dakle, imate kod statik data, hip, ovej netokal stek procedure i netokal stek izras. Pa sad, ajmo ovako odnos u prikazani svih pet, ali jedan po jedan pa ćemo detaljno svaku od ovih, ovako da opišamo čemu koje od njih služi od ovih oblasti. Dakle, kao prvoj oblasti, javljena se ova kod oblasti ovdje i ona je ovdje vidite, nam je namalno preinacretno uža u odnosu nove ostale, zato što ova oblast ove će biti različitati u odnosu na predkodne, u odracu samo na trutak na predkodni slajt. Dakle, se ova ostale oblasti će zapravo imati jedan zapis, izuzimati jednu reč, celu iliti četiri baita, samo će ova kod oblasti ovdje biti restavljena u baitorima. Dakle, jedan zapis će biti jedan bait. Ja imam rednom što ima u to i kod oblasti ovdje. Dakle, ta kod oblasti će nam sadržati u stvari zapravo taj nekakav bait-code. Dakle, to je onaj bait-code koji naša micro-a-virtualna mašina u nekom trnutku treba da izvršavaj. Dalje imamo vidit ovdje nacrta nje ove registar PC, taj registar PC već si i navikli novi predkodni kursavima koji ti slušali, pokazuje na trenavnu instrukciju koja naša virtualna mašina to tako izvršavaju. Zatim imaćemo registar main PC i vidićete do projektu, će biti potrebno da vi kada zalošite tu čatvrtu fazusla sa generisanim koda, potrebno je da postavite ovaj registar main PC da pokazuje gdje su ovaj nekakvo i kod oblasti od dakle od koja je vrsta vrsta vrsta vrsta. Vaš main metod. Ovo je, stvarno, dakle bi trebalo da počekne i otakvo izvršavanje tog nekakog vaših programa. Taj main PC ovdje nije označen, ali im dobro da napisamo da je potrebno da je postavite. I otakvo iz ovdje ovdje oblasti će virtualna mašina naša da čita instrukcija i redom i da ih izvršavaju. Ovdje sam opret po novio, sam još jednom, dakle niz bitova je ona obvezna i vidjet ćemo posled, kada budem pokazival kako izgleduje klasični zadac i koji dobijete iz ovdje oblasti koji na nas budem radi, vidjet ćete tamo da je dostal važno, zove to niz bitova i onda ćemo čak i pratiti koliko je instrukcija za uzima bitova, i tova koliki treba da budu tamo neka pis kako vi izgledi. Kova sveća oblast, sad je dosnu jednostavno oblast nećemo dugo o njoj, to je statik data oblast i ovdje oblast će nam služiti da u njoj čuvamo statičke podatke u tako glavnog programa i kažem ovdje i globalne podatke. Dakle vidjet, tamo smo vić videli na predkodnom času da ona na naša mikrojala ima nekakove globalne promeljive, tako da te globalne promeljive koje nisu tako vezane za nekakve metode ili na primer polja, ona su vezane za nekakve klasi, i za to je objekte nekakvih klasa, sve to što je globalno, dakle nema vezan, nisa metoda nisa klasom, to ćemo čuvati ovdje oblast i ovdje statik data. I pored ti globalnih promeljivi, ovdje ćemo čuvati još podatke, pa ćemo vidjeti kastnji da ćemo ovu statik data oblast, smestati čak i sve noše informacije o klasama, poni nekakve tabele, virtali funkcija i svečno. To će sve biti smestu na ovdje i vidite da nema nikakvih pokazivača, dakle to će sve biti ovdje nagoramo redom, u pitanju zustvario, dakle ovdje celo je nekakve reči, tako da ništa nikakva pokazivač, svema ovog data pokazivača, ovaj data pokazivač samu pokazuje gde sa ovom oblast statik data zapravo nalazi tamo nekde u memori. Dakle, prestavljaj da nisih promeljivih, to je svakal tako promeljivaći zuzimati jednu reči, u tih 32 bita i adresiratel tako ovog statik data oblast, kada kažemo dva, mislim u svarin na drugu reči, u svarin ne na drugi bajt. To se tiča ovog hipa. Taj hip će nam služiti za alakaćuju, ovdako kada budemo pravili nove objikte ili nove nizove, dakle oni će svešti biti svešta dinamički alocirano i u jaziku mikrojala, sve to će se nalaziti u tako novom hipu ovde, ima to i pokazivač free. Ja imam redom šta kažemo odda za njega, da te, a ovo što sam i rekao, dakle tu su objekti i nizove, alociraju se sequencijalno, dakle koliko ste tamo negde naoperati na sistemima, vas slučajno radili, kako se radi taj memory management, to je skak u sve to može da se pakodil u memoriju, to ovde neprimenjamo, dakle ovde memoriju alociramo sequencijalno redom, alo i pokazivač free, će se pokazivati na početak slobodno dela, al tako gde je... ...brostur. Što se tiče oslabađenja prostora, memorijsku koji je alociran, to ovde ne postoji, dakle koliko mikrojave ovde ne postoji, to se kupnije džubrta, nego jednostavno nalociramo brostur da ga imamo i okoliko bi ste eventolno pokušali da alocirate sam prostoru, tako u nekom tronku, bija eventolno vaš program pokovo. Tako da, natekad je budete testirali eventolno, to je program i nemojite alocirati neke ogromne količine memorie, zato što ovde ovako nismo impazitirali, to se kupnije džubrta, da ne bi smo još dalje komplikovali se tip. Marano, okoliko kao što se malo prerekoval, sako poljicu izuzima ti jednu reči, li ti 32 bita. Dalje kaže, nizovim, ajmo odmah i to da spomenemo, dakle nizovim, ukoliko se radi o nizovima koji su tipa inti, svično, dakle oni ću izuzima ti celu reč, međutim, ukoliko se radi o nizovima elementata tipa char, oni će biti u stvari nizovim bitov. E, sad ukoliko vi ovocirate niz koji je dužine 5, naravno morate ćete da, to je 5 nekakvih čarova, naravno morate ćete da zaozmete dve reči, tako da morate ćete da ovocirate ipak 8 bitova, ali da znate kada budete koristili to u projektu, ja ću to i kasnije malo naglasiti, imamo podpunodvajen set izrupcija za rad sa nizovima koji su nizovim bitova i za rad sa nizovima koji su nizovim nekih celih reći. Pokazivači su, naravno, ovde biti to osviti, vidite ćemo i to posle, e, i ovde još naglašeno samo da znate za objekti tipa niz, za počinju nekakvom nevidljivom rečiu koja sadrži dužinu niz. Sad, to vam je ono stvarno kao što imate realizovanu jeziku java, znate tamo da svaki niz imamo nekako po svoje polje length koje vi, naravno, mošte samo da pročitate, ne možete da menjete, je tako smo i ovde u jeziku mikrojava isto im zamentirali, dakle svaki niz će u stvari imati to nekako nevidljivo polje koji se nalaziti odmah, tako na početku niza u ovu memori, ili tako delu memori, nekako nekako u hipu, a vi onda kada budete indeksirali niz, videte ćete da ćete tu već preskakatio, tako to neko po polje. To je već im zamentirano u ovu naše mikrojavi, znači postoja instrukcije koje znaju da se u tovnuto polju u stari upisa natraje dužina niza, znači čisto da znate i kako preizvala, ali bi se prikašili, da se nije oš kasnije. Što se tiče oks teka sa procedurama, njega ćemo služiti da redom pakvom monokalšnosti navikli nekakve aktivacijone zapise metoda koje zove.
 Pa sada ovde već vidite, o tako da se pojavljuju nekakve r a kao povratna adresa i ovdje je o tako dynamic link, već ste naviti u temo, o rotna neka naziv fp frame pointer, ali ste stvarništo stoji, da kao je iz tek procedura, standupno kao i rustat u stavu što ste imali, ovdje redno na njega ćemo pakovati u tako povratna adresu, da znamo gde treba da se vratimo iz tek uće funkcije, pakovat ćemo tako stariji frame pointer, da znamo gde se ono nalazi to i natepno, ovdje to je ovo ka dynamic reza. I naravno ovdje u tom teku procedura će se nalaziti argumenti plus lokalne promeljivete neka metodi koji smo poznali i onda da bi smo znali gde se to se nalazi, imamo joj ovdje u tako neka stek pointer koji će panjiti, dok smo trenutno alocirali u tako prostor na tom neka formu. Pa ćemo sada poslijediti kako sada naše instrukcije koje budemo imali, utiču na ove sve registri i kako se to se pakove, ja se potruduju da ovde sad ponovno napravim neka ta animacija, da vam tako to bude jednostavnije. A ovdje vam je još tako naglašam da svaki novolociran i zapis se odmah inicializvuju jednog lana, a je točit ukliko to bude trebal da znate, da će lokalne promeljivu i imati nute vrednosti ukliko ih ne postavite. I za kraje rekli smo da imamo neto ka stek izraza, taj tu stek izraza će mohu svariji koristiti i tako za sladistenje operada i rezultatne instrukcije. Pa je na primer tamo smo negde već možda se pominili, kako se nešto ročuna, možda i mi smo, dakle, ukliko hoćete se tamo napraviti, da je nekda absurzbe u programu, ono što je potrebno dobrodite, jeste da prvo to a učitamo na neka voj naše expressno stek, zatim učitamo to b na ve expressno stek i onda ćemo izvršiti neka konstrukciju. Dakle sve sva izračunavanje su svare rade preko ovog nekakog expressno steka i on mora da bude prazn po se svaki mikrojavan instrukcije. Dakle, za vreme izvašavanje jedne instrukcije, nešto se nalazi na steku i ta instrukcija nakon izvašavanja trebal tako dao stek prazna. A ćemo to posledi vidjeti kako izvedu primerima. Jedin izuzeta kojih ovdje će biti prilikom pozivar nekakih metoda, dakle, kad pozivate nekakog metoda, vićete zapravo sve njeni argumente pakovati na ovaj stek, a zatim ćete ih ovom enter instrukcijom, vidjet ćemo posle skloniti sa expressno steka i staviti na one steku procedura. I još jedan izuzeta će biti da ovaj stek ovdje isto koristimo, da bi smo vratili na primer povrata vrednost iz nekakve metode. Sad, ja ovde napričam sva što je ovo je nekakve razlučite oblastite. A majimo mi redan, pa sad vidimo još kako sad tu, evo ga, patsetnik malik, dakle šta tu sve postoji, ali ovo se će vam biti dosta jasniji, sad kada je krenam ukroz sveove primere instrukcija da vidite u stvari šta koja je jedna instrukcija radi u kod ovih ovde od oblastiti. Tako da, prećećemo sad ov tako da vidimo koja to sve instrukcije mikrojava podržava što se tiče samih tih instrukcija. Sve te instrukcije imate u onom jednom dodatku, koji smo vam dalje imali u dodatek za jezik mikrojava, gdje je data njegova kompletna specifikacija i za svaku u tiši instrukcija imate naznačeno i koliko je njena veličina ovdak u baitovima, dalje ona zahteva nekakav operandu u sebe, šta ona radi sa nekakim stekom tamo, t.e. šta treba da se nalazi pre izvršavanje te instrukcije na steku i šta će ona zapravo uroditi sa tim vrednostima koje se nalazi na steku, dalje će našto spinuti, dalje će našto dodati i plus, sa stranevam je tamo naznačeno i šta zapravo u svog uvijete sveg o togoga imate tamo, pa kad krenete da rajete tu pasbu gdje nerešanje kod, da morate da provočete o te vredne instrukcije, a ja što danas zajedno se vam oproči redom kroz veći de od tih instrukcija koja tamo negde postoje. Ja ću hodit na nas podeliti u nekakove oblasti, pa ćete videte da imam razvičite nekakvostvari grupa o tako tih instrukcija i onda ćemo odmah za početak odraditi kaži instrukcija za load distor lokalnih promenjitih. Pa ćemo odmah spomeniti instrukciju, kao prvu na primer instrukcija load b. Oddaj ćemo zada odnačavati videte, dakle uvek ću je novoditi koja je to instrukcija, pa na primer ovaj load, a ovo b će odnačavati da ta instrukcija zaktiva jedan operant i to taj operant je jedan byte. Dakle, b će nam odnačavati byte. Kada budemo opisali s, to će biti short i to će biti dva byte, i kada budemo opisali v, to je duplo v, to će biti kao takva nekakva reči, i onda će izvucimati petri byte. Bine ćemo opositi zašto nam je važno, koliko je to instrukcija za uzjeme. Onda sad kažemo load b i to instrukcija koja kažemo da se koristi za stavljenje lokalnih promenjitih na stack, pri njihovom korištenju kažu od tjelu funkcija. Dakle, ukliko počete sada neku nullstu lokalno promenji uunutir funkcija da učitate na naj stack, da biste je naprimer sabrali sa nekom drugom ideštavećih, kakog odna koristite, potrebno da izvršite ovu instrukciju load b. I sad vidite, ovdje ovdje ovo load, samo ovaj hod instrukcije load, bide ćemo ona posetno ima neku uvrednost, ono je ovo trunutku nije važno koju, ono zauzima jedan byte, da bismo mi rekti da je to instrukcija load. A pored tog jednog byte i za ovako toga load, treba da sledi sledeći byte koji će kaja je to po redu lokalna promenjiva, koja joj želim u tom trunutku da učitam na stack. I sad ovdje naglašimo dole ispod, da vidite da to ovo zauzimo uklupno dva byte. Međutim, jako često, ovdako mi koristimo te lokalne promenjile, je pogotovo ovdje koja imaju indexe 0, 1, 2 i 3. Prejdko kad nam nekakva funkcija ima više od 3 argumenta i lokalne promenjive, pa da je nepotrebno nešto četvrto u nizu. I onda smo za potrebe toga ovdje uvijeli posebne kodove instrukcija. Tako da postoji posebne instrukcije koja se zove load do necrpta 0, load do necrpta 1, 2 i 3. I sad ako pogledate, na primer ako vam treba prva lokalna promenjiva da je učitate na tako nej stack izraza, li ćete izvršati instrukciju load 1, s ovom doňom crtom dole, čo to znači da samo to dozime u stvari samo 1 byte. Nemam potrebe da dozimate 1 byte instrukcijom load i plus 1 byte da kažete da vam treba u stvari prva. Ode na osnovu ola moš da odmoda zatučite i da postoji jedno ogranišenje u jeziku microjava, čin koristim 1 byte samo da bih indexirao te lokalne promenjile, to znači da u mogući broj lokalnih promenjivih argumenta ovopr u jedne funkcije ili metode s 256, naavno od tako nekoliko mogu da izvari. Da, znači da 250-ta je bilo tako bilo posljednja varianta. Što radi ovi instrukcije? Imate expression stack, u sada kažete ovde ovo je espel, to je u stvari stack pointer koji koristimo opirog expression stacka. Ovako izgledajte taj session stack pre, kada izvršete instrukciju load b, ona će vam zaaprav na ove expression stack učitati tu nekakvog vrednost, koji je o takosti pražati da su učitati. Pa i da pogodam, odmah ja ću za svakom instrukciju odmah, imaće ovo jedan veliki program koji ću poristiti srvenicima, u tako uveko ideo koji se odmasi na tu nekakvom instrukciju. Kaže primver, učitavamo lokalnu promenljivu x. Dakle vidite da se ona ovdo sada... Dakle to je lokalna promenljiva x ovde, to je 0-ta lokalna promenljiva, vidite da ovde treba da izkoristim sad, jer ću krenuti da je sabiram sa nečim, da bih to u radio tako tu potrebno da je izglošim instrukciju load 0. I sad to možete pisati ovako. Ovo bi bilo ova prva varijanta osnovna varijanta koja je postoji, to je o tako da imamo jedan byte koristimo za kod instrukciju load i jedan byte da kažemo da je to 0-ta lokalna promenljiva ili skraćeno i bolje, ono što će buvijek i koristiti, jeste ovako load 0 da kažem da se o tako to zuzima samo jedan byte. Ovo modnu instrukcijom ja ću na ovaj ekspresni stek vrijednost ove lokalne promenljivi x, o tako učitati to ću se pojaviti kao ovde vlada. S3. Analogno tome kao što imate instrukciju load b tako ćemo imati instrukciju store b. I ta instrukcija store b naravno ide samo suprotan smer, samo tako nešto ćemo smještati u nekakvu lokalnu promenljivu. Isto tako koji malo priima ćemo skraćeno ove instrukcije store 0, 1, 2 i 3. Ako da što radi instrukcija store? E ona sad očekuje da na ekspresni steku već postoji nekakav izraz, dakle već postoji nešto izračeno, to vidite? I što ona radi, ono u stvari pokupi to sa ekspresni steka, i u pišaj u to nekakvu lokalnu promenljivu sa indexom d. Konkretnom primer kao malo prišlo ste videli, li je te sad ove, imamo ovo nekakvo kao, što je druga, tako indiksiranju već kreću od nulje, tako da x će biti nul, tam nis će biti prva, ka će biti druga lokalna promenljiva i kada ja ovdje budem rekao kao i jednako nečemu, za sad je nebitno šta će biti to nešto, dakle nešto treba da se smjesti u ka, to tu vidite ćemo ovde sada izgršavano instrukcijom store 2. Dakle, ovu vrednost koja se nalazi na steku što goto bilo, skini sa steka, dakle, ESP se pomerajo gore i to nešto u piši u drugu poredu lokalnu promenljivu. Kračinom bih smo to napisali ovak, dakle store 2. Za ovaj ga kažem index je 0, 1, 2, 3, imamo ove skračene variante, za one ostale bih smo morali da pišem ovde store pa naprim. 7 ako vam treba, oboje znamora store pa sedmica da idem otvoriti. To su bilo tako glede instrukcije v lokalnu store koje služe za lokalne promenljivi. Esad, imamo isto tako instrukcije koje služe za lov distor ali globalnih promenljivih i nihćemo odvojeno tako totalno obraživati posebne su instrukcije. Izbog toga smo na prošnom času kada smo radili tabelu simbola, obovezno tamo vodili računa kada pantim u tabeli simbola nekakvu promenljivu, dalje otaku imali smo na polje level, pa smo pantili dalje to lokalne ili je globalna nekakva promenljiva. Panom je važno bilo zbog ovog, kad ali ću koristiti lov, kad li budemo čitavo ili ću koristiti vidite ovde sada get static. Oto instrukcija za globalne promenljive su zove get static i vidimo da ona ovde sada nemamo b, nego ima s. Znači, reko sam ona ovde sada tako zahtajava još dva baita izle se get static, pa idel tako dva baita izle koja značava i koja po redu tu namag globalna promenljiva trepa. Čim stoji to? s zapiju, čuvajte, da ogranjitrenje postoji u jeziku mikrojava, da tamo postoji 2 na 16 maksimovno tako tih negativ globalnih promenljivih, to je veli čino na static data je u sada i 2 na 16. Emo, reko sam već čemu služi ova instrukcija, šta ona radi i radi isto što jo ona malo predakla. Ekspresno stack je prazna, li kažete get static nula i ona na primjeru uzme nultu globalnu promenljivu i učitava mi je na stack.
 One što je važno samo ovdje primetite, ovdje kod getstatik i vidjet ćemo kastnije druga instrukcija se zove putstatik kao što ono histor bioanalog njem. Ne postoje ove skraćine variante, dakle ne postoje varianta getstatik donja crta 0,1,2 i slično, zato što što se tiče globalnih krameljivih njih koristimo, tako nije kao da su jako popularne tesa 0,1,2 njih ima gomile, tako da zbog toga nemo tu nekako optimizaciju. Kako će izgledati primer, pa je opogledajte sada ovdje, da dvijem gore nekako globalnu krameljivu koja se zove u takom mat, i dole sada koristim to nekako mat u izrazu, da bih to mat tu kada je go koristimo u izrazu nekako tako bacio na ovaj naš expression stack, koristimo stvari instrukciju getstatik i onda kažem odvojenu tako 0, zato je 0 tada globalna krameljiva, i ona će se pojaviti u stvari na ovom nekakoom stack. Mecim rekovo kao što po stoji getstatik analogno tome imaćemo i put static es, put static ćemo koristiti da nekako u vrednosti sa expressem stack'a smestimo u nekako globalnu krameljivu, dakle vrednost se već nalazi na stack'u, vi je skinete sa stack'a i smestite u tu globalnu krameljivu, i to je na primjer evo ga ovde, ovde kada opet jemo tu globalnu krameljivu max, kada kažemo max je jednako 1, ovde da bih nešto smestio u što max pozvaću u stvari instrukciju put static. Dakle ovde neću se zdežavate, ovaj loadstore i put static i getstatik su u stvari dosta sliči. Kao preče grupa instrukcija, javljenja se instrukcija za loadstore polja objekt. Dakle, u koviku imate nekakog klasu, napraviti objeka te klasi treba, u koji ćete nešto da smestite ili dohvatite iz polja objekt. Imo prvo instrukciju koji ćemo obraditi, i ona se zove getfields, pa instrukcija nam služi da dohvatimo tako neko polje s nekog zadatog tamo objekt. Dakle, instrukcija getfields treba da označi koje to polje po redu u okviru klasi koje vi želite, izbog toga smo tomo da tamo kada smo praviliti tabelo si bola i pamti, ili za svaku polje koje njegu vindeks al tako unutapte nekake klasi. Ovde odmah čin, kažemo s, kažemo to su stvari nekakva dva baita, što znači da u microjavil tako postoje u gredičenje, da svaka klasa onda može imati opet dva na 16 tako negativ polje. E, medjuti, kako sad ovo getfield desfuncioniši? Ne, ovde sad ćemo malo da krenemo da komplikuemo, pa sad nek expression teku, vi morate da neko se javlja slobodno, ali možete sukličiti kolega. Ili je neko slučajno klikno, dobro, sluća se. Ako neko nešto kojići slobodno možete rekucati da pišete, kako gada. E, šta se je dješao svojim getfield? Dakle, na expression teku morate da postavite adresu objekta. Dakle, gde se nalazi, nego u referensu, tako gde se taj objekt nalazi na hiput, to već morate da se nalazi na expression teku. Zatim, ozivate ovom instrukciju getfield des, i toom instrukcijem tu kažete ovaj virtelno masini. Skinite sa stacka tu adresu, a zatim dofati polje koja je označeno tako ovim indexom of des i to polje će onda biti vračinu stvari na ovaj expression teku. Dakle, vidite, expression stack 3 će imati adresu postavljeno ovde, a natvon toga će imati vrednost u stvari tog nekako polje ovde. Ajmo, odmah primer možda bude lakši. Dakle, vidite, ovdje imamo klasu k, imamo njenu polje f, to je otakvo nekako tamo, otakvo prvo ovde polje koje postoji, i dole kada budem koristio k.f. Kako će sad da izgledati učitavanje toga nečega na stacka? Pa kažemo ovde na expression stacku morate da se nalazi adresa tog nekakvog objekta, kaj je polje mi doflatamo, adres u objekta ću učitati sa load2. Dakle, ovo k se nalazi kao druga lokalna promijeljiva i ovde ako pričam objektima i onizavima, mi u svariji pančimo njihova adresa. Dakle, ovdje ovo kada ovo lokalna promijeljiva kada čuva adresu objekta k i da bih ja nje ustavio na stack, ja pozivam instruciju load2, osmom malo prevideli kako su bitali u lokalne promijeljine. Kad kada imam adresu tog k na ovom expression stacku, treba da doflatim njegovog polje f i zatim izvršavam instruciju getfield1. Dakle, ovo f ovde možda ćete pomislići da je nultopolje, ali nije, danas sam reko da ću naglasiti na ovom času, dakle, za svaku klasu svaki njen obikat, kao nultopolje će čuvati onaj pokazivač nekakam na tabelu virtualnih functija i tu otpomećemo pripusti posled, dakle, samo zatatite da se polja klasa uvekl tako indeksiraju od jedinic. Dakle, ovo f ovde ustvari prvo polje i na ovaj način je osvori njegu učite u ono stack. Dakle, prvo sam ovajem load 2 učita ovo k, a zatim getfield1 u stvari ste da sa stacka tu adresu tog kka i na stacku ostavljio stvari na vrednosti tog polja koja je oznočeno indeksom get. Isto važi kao i za put static i get static, dakle, nemamo ne skraćene variante getfield pa da za 0, 1, 2 i 3, dakle, uvek morate da kucate, povjeste da generišite instruciju getfield i za nje obavizno idu nekakva dva byte. E. Kao što njemo getfield, njemo doslično tome i instruciju putfields i ta instrucija putfields će biti zadužan da sada upiše nešto u neko polje nekad pogo objekta. E, sad, šta ona sad zahteva na stacku? Koj nje je sad malo kompleksnije, dakle, expression stack, prizvašavanje ovoj instrucije treba da izgleda ovako. I na expression stack treba da stavite adres u tog objekta, a zatim i za njega obavizno mora tim redu slobno se navodi. Dakle, prvo je da adresa objekta u koji se nešte smešta, zatim ide vrednost koja se smešta u tako, u neko polje tog objekta. I teka da ove dve stvari imate nek expression stacku, teka onda pozivate instruciju putfield i kažete u koje redu polje tog objekta treba da se upiše sa nekakva vrednost. Dakle, da šta će ovoj instrucije putfielde su raditi, skino će ove vrednosti se steka, dakle, stek će ostati nakon ove instrucije prazan. Ove ove vrednosti skidamo da vde. I u ovaj ovdje objekat na njegovu polje s upisaće se tako ove vrednosti ovdje balo. Najvupr, znamo kako je izla, dakle vidite sada ovdje kako je poristim, kažem k.f je jednako nečemno. Šta je potrebno da bi se ovdje, da bi se tako nešto upisao u ovom polje s? Dakle, potrebno je redom da smestim prvo adresu tog objekta na stack. Adres objekta ide kao što smo videli malo pre instrucijom load2. Dakle, load2 će staviti tu adresu na stack. Zatim je potrebno nekako vrednost sada se smesti, da je sada ta vrednost je nekako racuna, tako da za sad mi nije vavno, u ovkom su tri tačke te značavaju, da ću nekako ovde sada nekim instrukcijama smestiti tu nekako u vrednost na stack i tako da imam i adresu i vrednost, tako koji je potrebno smestiti, tako nakon toga pozivam instrukciju putfield i opet, kažem, jedan od tako isti razlog kao i malo. Dakle što se tiče putfield, da je še jednom kažem, zahteva adresu objekta i vrednost, pa tek onda kažete putfield i kažete u tako u koje polje treba to našto da se upiše. Potom ću mi raditi zadatki za sveve ovo, tako da ćemo kroz svemi instrukcije proloziti i koristiti ih ponova, ali ja sad koću samo rednom jednu pojedu do pobrojim, da vidimo primer upotrebete instrukcije i da vidimo šta ona radi sa kojemu stack-u, i kojemu da ovih memorijskih oklas. Sleća instrukcija će biti instrukcije za load-constantip i ta instrukcija zvači se const i vidite da ona prijima sada ovde duplove, to je spriima čitavu jednu reč, tako da koristite koliko 1 byte ide za konstantu i još 4 byte izda da se kaže koja je to konstanta koja je potrebno smestiti na stack. Ono što je primjećeno i otel, tako da dosta čestno koristimo te nekakve konstante sa niskim grovjema kao što su 0, 1, 2, 3, 4, 5 i eventualno minus 1, vasko zgub togo uveli i posebne instrukcije, dakle imate posebne instrukcije koje se zovu constant donija crta 0, 1, 2, 3, 4, 5 i m1 kao minus 1, tako da njih možete koristiti za te neke male brojeve. Za veće brojeve morate da koristite ovu varijantu ovde koja zuzimo u kupno ako pogledate 5 byte-ova, dakle 1 da se kaže da je ovak constant i 4 za ovom vanu. Za ove male brojeve, napim. kudiko pa ćete broji 3 dokupitete na stack koristite constant 3 i ovim ovde zuzimate samo 1 byte. Zavradi instrukcija constant, pa da to je nisak, imate brazan stack i ona će vam samo u nove expresson stack smestiti tu nekakvu vrednost. Te, ono što ćemo ovdje odmog da spomenemo, jeste slajecisar. Prosi čas, prisetit ćemo se kada smo radili tabelu simbolo. Kada bi smo najišli na ovako nešto gore na ovu deklaraciju constant n je jednako dva. Tamo nekdo tabeli simbola mi smo zapantili, da, ali tako postoje neka konstanta koja se zove n da je tipe int i odmah ako se sečete u onom polju address smo čuvali koja je njena vrednost. To jest, ovu dvojku bi smo tamo opisali. Zbog čega. Zato što? Ove konstante ovde neće postaviti njih u jednoj od ovih nemorijskih oblasti, virtuone mašina, o tako naše mikrojave. Već radimo šta dalje je dole kada govodite generizali kod. Kada kažete napim, roda i te pisa new int od n. Da bi ste odi iskoristili to nekako n. To n ne postoje njegde u nemori, nego ćete tu odmah direktno koristiti samo ovako nekako instrukciju u constant 2 ili stračeno još bolje bi bilo da koristiti od tako instrukciju ovog, od tako constant do nja trta 2. Dakle, sama konstanta kao konstanta nećemo nikde u svariji fantasy da je postojala, nego ćemo sam odmah kada je koristimo ovde u onom vašom generaturu kod da u toj faziji lići su svariji samo isto bile se bola pročitati koja je o vrijednosti te konstante i samo izgeneritati instrukciju constant. To je sve susitite constant. Dobro, idemo dalje. Peta grupa instrukcija će biti aritmetičke instrukcije i ovaj vam mi ćemo ode prikazati na primer instrukciju ed koju imamo u ovom nekakom primeru, ali isto tako imate instrukcije sub, mull, din, rem i ostale na brojđemo i poste koja se je potoje da se ostale aritmetičke operacije koji imate. Kako ana radi, to sam već možda malo pristomeno da kod liko hoćete da se beljeti nekakvo ib, ono što je potrebno jeste na ekspresn steku već postoje te nekakve dve vrijednosti i tek onda izvršavate instrukciju ed. Kada izvršate instrukciju ed, ona će vam zapravo sa ekspresn steka skinuti jednu i drugu vrijednost, sabrati i hir izvukta to ostaviti opet naravno na to...
 nekakom expressnsteck. Eko distrukcije, et nije ni važan redostvet, ali pazite samo kada budete radiili neznam sub i neznam div, tu vam je naprimer remisto, tu vam je važno kojim redom pakujete ove operande, tako da obratite pažne da je ovu ovde kao rezultat ostavljeno a plus b, ako je ne b plus a nego a plus b, ali kada se bude skidalo s sek, vidite da ovde se skida prvo b, znači prvo je stavljeno a pa onda stavljeno d. To mi značilo da na ove expressnsteck treba da ređete operande tih aretmetičkih instrukcija, onako kako ih joćekujete, ako kojićete a plus d prvo a stavljete na steck. Dobro, ajmo primjer, evo ga od, da imamo osabirani ovde ovoga x plus 1, kako ćemo za to izgenerisaći u svariji kod, pa da bih učit o x na steck potrebno da izrašim koji instrukciju, to smo gledali malo pre to je instrukcija load nulla, da bih smo učitali jedinicu na steck i to smo bitali malo pre to je instrukcija const 1 i da bih onda te dve vrednosti zapravo sabrao samo tako izgenerišemo instrukciju et i ta instrukcija će zapravo te dve vrednosti skinuti, sabrati i ostaviti njihov razlup na steck. Doži, i sad analog na tome se je vrlo stala instrukcija što sviče s abiranja, to jestu deljenja, ne znam ostatak pri deljenju od uzimene svično, a one radene isti način, tako da naravno nećemo sad pokazirati jedno po jednu. Kaj će i grupna instrukcija će biti instrukcija za deljenjučku alokaciju memorije, da vidimo sad kako su to memorije alocira, pa ćemo prvo prikazati instrukciju nu s. I ako pogledate ovdje instrukcija nu treba da alociru stvari neka ka noviji objekt. Koliko je velik taj objekt, to će govoriti ovo s, to je u broju bitova ćemo reći ove šor to ovdje, ta dva bita koja svedi iz ovog koda nju, će reći koliko to bitova treba alocirati i ova instrukcija ovdje će u stvari alocirati taj prostor na onam našem tamo nekadkom hipu, a kao rezultat i za izdašavanje ove nekadko instrukcije na expression specuće se u stvari kojaviti adre sa na hipu gdje smo mi to zapravo alocirali taj nekadka prostruč. Prima, ovako nečegob bi bio od, da karite sad da imamo ovdje poziva sa ovom nju k, ono što je potrebno vi do uredite jeste sada da iz one vaše tabele simbola tamo, pogledate za klasu k, koliko ona to polja ima i na osnovu toga koliko ona polja ima, pošto će svaku polja od klasu uvedu uzima ti svi stavu reć, vi na osnovu toga al tako zokličujete koliko je prostoro potrebno da alocirati. E sad ovdje, ajmo opet da se pocetimo toga, a ovna glasiću opet, ova klasa k ima jedno polje, ovo polje f, međutim uved kažem svaki obikat mora da ima i taj nekad skriveni pokazivač na tabelu biti unifuncija koji izuzima još jednu reći, tako da jedna reć za ovo polje f i jedna reć za taj nekad skriveni pokazivač, to su dve reći iliti osam bitova, tako da pozivam instrukciju nju osam i ona će mi u stvari na speku, kažemo, ostaviti adresu gde je taj prostor koji ona alocirala na hip. To je ono, stvam ja ovdje, ako se setite kad sam radio instrukciju u stvor 2, ja sam tol som nešta u ovog kao u stvari, a to je u stvari rezultat ovoga. Dakle, još jednom ponadne kada budemo pričali o nizovima i objektima nekad tim, nilet pričam u stvari o njihojim adresama, gde sa oni nalaze tamo negde na nekad pomoć. Preća instrukcija koji ćemo pričamo kada, tako imamo, sad ovdje ove ideo ako dinamićke alokacije, će biti instrukcija njuarej i on instrukcija, kao što je kažel tako sama reć, nam služi za alokaciju negapih nizova. I sad pogledajte ovdje, ovdje, doskak elektristično ovde, dakle njuarej b, ovde se zahteva jedan byte izam, međutim, ovaj, jedan byte, ovo b, možete ima samo vrednosti 0 i 1, sve ostalo bi bilo nevalidno, a tim rednostima 0 ili 1, kao što je ovdje naglašeno, kažete da li hoćete da vam se alocira niz byteva ili niz reći. Ako kažete njuarej 0, timeste reke da hoćete niz byteva, ako kažete njuarej 1, timeste reke da hoćete niz reći. I čao ne dajvo da sam reko, da se razlikuju nizove čarova, naprim. nizove bulova i naprim. nizove intova koji su kvali nizove deli preći. Pa radi ta instrukcija? Dakle, koliko je velik taj niz, dužinu niza, počekuje da ste recmestili na nekakav ekspresijan steka. Dakle, koliko je velik taj niz, to taj broj je viskreba da se nalazi da je tako na on ekspresijan steka, a ona će uraviti šta? Ino će taj broj sa steka, alociraći u stvari niz, pa sada dali byteva ili reći uzavljivstvio doga b koje ste zadali ovde, a zatim adresno niz za tamo gdje ga alocirala na hipu, će vam ostaviti u stvari ovte na on nekakvom ekspresijan steka. E sad ovde, ljudi dosta često se izgubve, dosta često ljudi dođu čakim na odbranu projektata pa ne razumevi, naprimer, ako nekako se stvari kad ne nijim bude, nijim nijim nijim. I tamo, tamo na odbrani, ali sad, evo, zbog čega ovde, naprimer, dužina niza mora da ide preko ovog nekakvog ekspresijan steka. Ja vas modim da pravite razlik u izmjude koji je kod sekcija. Ovo je ovda instrukcija u RAB, to je instrukcija koja će se nalaziti i tamo nekdo ove kod sekcija, tamo gde se nalazi neka kao naš kod. Mi kada generišu ma neka kao kod, to jestu kad pravimo taj program koji treba da se izvršava, ne možemo nikako znati koliko će sad taj neka kao nijim zbiti velika, kad na primer za dužinu niza, kad da ne odno odma da prikajšem primjer ovde, tako ovde sad pise NewIntN. I ovde sad ne koristim Constant 2, pa naprimer znam koliko će nijim zbiti velika, ali ako bi nekod ne pisalo NewIntX. I ne možete u vrijeme prerozinje programa znati koja će biti grednosti premenljive X, tako da upravo to i jest razlog, dok čegak ne možete tu dužinu nijih zapakovati odmah u byte kod, nego je to nešto što se nalazi na ovom nekakom ekspresnom steku za vrijeme izvršavanje programa. Tako, za vrijeme izvršavanja programa ja live čitam otak u kojoj rednost do premenljive X i onda otak izvršavam instrukciju u RAB, a ona samo koristi to nešto što se nalazi na ekspresnom steku. Tako da, molim vas zapazite i da tako pokušete da razlometel zakvo koja je razvika izmjeđu to compile-time-dela i runtime-dela. Dakle šta ja to znam za vrijeme prevozinje programa, a šta ću znac u steku kada program krene da se izvršavam. Ovo da New RAB je, o konkretno, zove primer ovde, kako ćemo izvršati ovde? O dakle, na ekspresnom steku treba da stavim koja je dužina niza, to tako radimo instrukcijom konc, zva u ovom konkretnom primeru ovde i zatim otak u izvršavamo instrukciju New RAB 1. Ona će da skiner tu dvojku sa steka, to je tu dužina niza, ali oci ra će nista maleg da na hipu i ostavit će meni adres u tako ovom pođu. Ja sad pa kažem opet da je ovde pisao da New Int x u ovim, al tako uglastim zagradama, onda bih mora da radimo load nula, dakle od load nula da se to je x, stavi na stek, pa tek onda ovo New RAB 1 i ne bih znao u svaru koja je tu dužina niza. Bila bi dužina niza ona koja je se otakleti sve u ovom x za vrijem izvršavanjem programa. Dobro, a ima da. Svećnji grupa instrukcija će biti instrukcija za load i stor element sa niz. A imam sad ako smo videli kako smo niza locirali, ajmo da vidimo kako ćemo učitati neki element niza sa odmastek. Kaža instrukcija a load. Ode dola je naglašavno odmast, tako zastavit se ta instrukcija koristi i odmast smo naglasili da postoji posebna instrukcija za rad sa nizovima byte-ola, koja se zove b a load, dakle ovo b ispred kao byte. Kada sada pokazati samo kako ovo a load radi, ovo b a load radi na sliča, naprećem samo što ste vam zelo tako dokatiti vrednosti iz a byte-ola. Šta je potrebno da spakujete na ovaj ekspresno stack da bi ste iskoristili instrukciju a load? Treba da spakujete adresu niza, da kažete gde se nalazi taj neko ka v niz i index niza koji želite, tako koji element zapravo želite, na kom indexu se nalazi taj neko ka velement. Dakle kada smestim adresu i index pozivam instrukciju a load, ona skida i jedno i drugo sa stacka, i nas deku meni ostavlja u stvari vrednosti kog elementa niza. Konkretnom primer je ovdje, dakle imam neka ka v nizu ovde, reko sam ovaj nizu ovde ću se čuvati po adresi na hipu i kada koristim dole i kažem nizu od jedan treba ote neko ko da suvacim stack, to ja zapravo ode sad radim, dakle prvo treba da smestim adresu tako na stack, to ću raditi instrukcijom load 1, pošto ovaj nizu ovde neko ka lokalna promedliva, datim treba da kažem koji je to index, koji želim da pročitam, kada imam, kada imam, kada imam jedno i drugo sad ospakovan na stack, pozivam instrukciju a load i ova instrukcija a load će mi zapravo dohvatiti tako taj neka ka element niza. E, slično, ovo je ovo instrukciju a store, koja sad o tako jedna od vrednikih instrukcija koja će od vas tražiti da vi na stack spakujete čak 3 stvari. E, ovo je da vidite, naravno, kao imamo malo posebno instrukciju da a store. I sad koja je 3 stvari pakujete na stack? Ako počete nešto da smestite u nekih element niza, na stacku mora i da se nalaze adre sa niza, index elemento koji želimo to nešto da upišemo i vrednost koji upisujemo. Tek, kada sve 3 se nalaze na stacku, tek onda pozivam instrukciju a store. Stobi za konkretan primer, naravno, ta instrukcija a store će se to dopokupi sa stacka ispraznit će opak uskrodite. Pogledajte ovdje sada primer, kaže niz od nula je jedna konecamu. Dakle, šta ja sad vredovom ovdje možemo da radim? Prvo može da se nađe adre sa tog niza na stack. Dakle, index niza to je konc u nula, zatim vrednost. Ja ću staviti ovde 3 tačkice, jer to znači sad oddala tako da celo izdrazovamo mora da se izračunila koji njegova vrednost da ostane na ovom ekspresnom stacku i tek kad se sva 3 nalaze, tek onda tako pozivimo ovde a store. I ovim a store ja zapravo upisunem našto u taj neka element niza. Dakle, ovaj a store je najkomplex niješ zahto jeba 3 stvari, da je to da je u njega konc u njega konc u njega na stacku, da je to da je u njega konc u njega konc u stacku. Dakle, ovaj a store je najkomplex niješ zahto jeba 3 stvari, da mu li pripremite već na to mneka konc stacku. Ajmo, da jel' jel' jimu što još imao, da stignem akr do završenju do kraja časa sve instrukcije koje pospoje pa ćemo da zavratimo zadatke. Kaže, instrukcije za rat sa funkcijem. Jel' jemo sada instrukciju call koja služi za pozivu tako nekakvih globalnih funkcija i to obrati ćemo bažnu instrukciju call ćemo koristiti samo za globalne funkcije za metode klasa jemo posebnu instrukciju. A ovo s ode će oznacavati pomere. Dakle, u odnosu na tekući PC gde se nalazi u tako ta nekakva naša funkcija koji hoćemo do...
 da pozovem, dakle koliki je pomera i uunutarone nekakve kodsekcije. Ove sad da, pošto pričamo pozivu u funkcija, ne crtam više expression stack, nego ću ovdje sad da crtati ovdje kodsekciju i ovdje stack procedura. E, kada vi pozivate ovdje call s, šta se tu sad da zapravo dešava? Povratna adresa mora prvo da se tako upiše na ovdje stack procedura, dakle ona se tako zapiša sa prvom gdje se vi treba to naziv. Da je strenutna vrednost ovog pisija ovdje ovdje, tako iskod sekcije, gdje ste trenutno stali se izvašavanim, to su pisuje nove stack procedura, ako krećete da pravite te nekakav aktivacijoni zapis. E, naravno, tako ovaj nekakav stack pointer se preselio tako dole i onda šta se dešava, onda ovaj PC pomerate za ovaj pomera i ovdje s. Dakle prvo zapam, tim gdje je taj PC bio, gdje treba da se vratim, a tek onda ovdje tako pomerate za pisi. Kada ga primjer neki, način, imamo ovdje nekakvu funkciju put, pozivamo ovu funkciju put, ono što morate pažite, jestli da se tako prvo i nekakvi argumenti spakuju na stack, ove dve instrukcije će draditi to, tako, dakle prenego što pozivite instrukciju call, naravno prvo se se spakuju njeni argumenti kada bude pozivao, kako će spakovati k.f, to smo viš videli malo, predakle load 2 da učitamo ovo k i zaten getfield 1 do dobjem k.f, a zati, nakon što imate sve argumenti na stacku, pozivate instrukciju call. Ito pozivate call, sad ovdje u konkretnom primjeru, ja nisam račomo, poslicemo se bavite time, dakle ovdje sam sam napisao call, pa neki pomere, ovdje u odnosu naputu tako, kodima iznažil, tako i generisanih nekadnih instrukcija. Kada se veš vada, dakle, niste ovde, a imamo samo sa vratim viš jednom, dakle sve argumenti prilikom poziva, nekad da je funkcija, ste spakovali na naje expression stack. Kada onda to znači, ja sam u ovom instrukcijom call sam o pomerio pisim, nisam ništa ovdje u pisiva na ovaj stack procedura, oni se i dalje svi ti argumenti nalaze na alzako onom expression stack. E, to je važno ovde sada, je ovo te sledeće svar ide, a to je instrukcija enter. Instrukcija enter je instrukcija kojićemo generisati prilikom ulaska u svaku funkciju iliti metodu sredu. Tako, ovo je obavezno prva instrukcija svake funkcije iliti svake metode, izleda ovak. Enter kaže b1 i b2, da te ovi indexi 1 i 2 služi samo da bi smo ih razlikali, da ti instrukcija enter izde sebe zahtjeva i još dva byte. Ova dva byte ovdje b1 će nam govoriti koliko argumenta ima ova funkciju koji smo treba odnušli, a b2 treba da nam odnati broje argumenta i broj lokalnih promeninima. Zasto je ovo važno, zašto ova dva broja ovdje imamo, dakle pomoću ovo broja b1, ćemo mi zapravo znati koliko to ima nekakvih, nekakvih, tako, poletaka koji su smešteni na expression stack, koji su argumenti tekuće metode i onda njih sa expression stack treba da prebacimo nove stack procedura, a ova i b2 će nam dodatno reći koliko to lokalnih promeninivi i još puste argumente mi imamo, da bi smo znali koliko treba prostora da ostavimo malo ciran od na ton stack proceduri. Pa sada ovako smo se zustavili malo pre tamo tako, osvana instrukcija call, dakle posta instrukcija call samo sa ovama povratna adresa ovdje navazim. Zatim, sada vi uđete u metodu i zvašite ovo instrukciju enter, pa će ona da radi. Prva stvar koju radi, jeste pakove ltakove ove naša stari ltakove frame pointer, dakle, pravi ona i dynamic link, pametimo gdje je bije ltakove nekakav frame pointer, dakle, zapam te ltakove, da je se to navazilo. Zatim, sve argumente sa onog expression stack'a ću prebaciti ovamo nove ltakove stack procedura i skinuću ih, naravno, sa ovog ltakove expression stack'a. Dakle, znao, ne više ovamo ne postoje, prebacio sam ih na ovaj stack procedura i zatim onda ostavljam prostoru na ovom stack procedura i za lokalne promeljile, nakon toga, al tako, naravno, tu sve vreme se ažuriraju ovoj stack pointer i ovoj frame pointer. Dakle, se loku pa nove dosao oko pančinja starog frame pointera, oko prebacivanja argumenta sa expression stack'a na stack procedura, oko alokacije prostora za lokalne promeljile uunutara procedure, ažuriraju na stack pointera i frame pointera pražnije, onog expression stack'a, sve to radi instrukcija entaš i nju obovesno tako pozivate svaki put preningušta krenite da generišite kod nekakve funkcije ili metode. Ove ovde grednosti, naravno, čitamo istabelaj simbola. Dakle, koliko ulaziti u nekakvu funkciju, vi tamo imati u tabelaj simbolo zapančeno tako onom polju level, koliko ono tu ima argumentata i kada ov tako treba da generišiti ovu instrukciju, ovo je jedan odličit, se zapravo samo pračitati istabelaj simbola i rećite tamo, ok, imam tri argumenta i to upišete u ovog b1. Ovo b2 ovde kako ćete znati koliko je, pa svakame to da tamo videli ste da smo imali dole njenu ono lokal, da smo sreo ne njenu tako lokalne promeljile, argumenta panctili u one neko koji kolekciji, tako da samo pogledamo koliko je viličina te kolekcije i upišemo u ovog b2. Paj ovo je posao ovdje u tako kotumbanja, expression stack'a i stack'a procedura, sve to odradi ova instrukcija sama za vas. Ovo da pogledajte ovdje, sve što je potrebno ovdje da bi ja ušao u ovu funkciju put, jesno da izgnevišem instrukciju enter1-2. Zašto 1-2, pa posklo i jedan argument sam ove metode, a kada gledatel tako ove drugi, ovo b2 treba da označalo ukuplnno koliko prostora se zuzima, to je skoliko ima ukuplno i argumenta i lokalnih promeljivih, to je stvari dva. I ovako, ovaj virtualno masinaće za vas udraviti, sve to, dakle, vi ne morate ništa da brijete. Istat, naravno, tu stav ginerišete celokupno telo te nekakve funkcije, a na kraju pozivate instrukciju, obvezno, idu dve instrukcije, obvezno, na kraju svaki funkcije, prvod njih će biti instrukcija exit i ona će biti zadužena da oslobod je ovo prostor koji se locirali za ove argumente i lokalne promeljivih i da restauriraj, ona je nekakakva frame point. Dakle, njen posao će biti da skloni ovo lokal sa ovog steka procedura, zatim će skloniti i one nekakve argumente, vrati će ovo i naš frame pointer gore gde je pokazivalo ovo nekakvo dl, skloniće i tako tu staru urednost frame pointer koji bilo sačuvana i naravno, ove stek pointer će otakvo premestiti da pokazuje skroz gore. Dakle, ovoj instrukcija exit će se baviti i otakva, o nim delom šta je u radnom instrukcija enter, to će instrukcija exit u stvari da poništi. Dakle, njih dve uveki do paketu enter na početku, funkcija exit na kraju funkcija i odako exit samo poništa ovo na što enter uradio, dojde šta je sve spakova na vej steko. Vživite, ovde sad da kada treba da izveđemo tako iz ovog ovde, samo ću pozvatio ovo exit. Nakon tog exit, obavizma mora da ide sledeća instrukcija koji ćemo ovo da prikazati je to instrukcija retran. Ova instrukcija retran će da poništi ovo što je uradila instrukcija koju u stvari, to je ona sad treba dohradi u koliko sad mi imamo ovde, vidite sad šta našta pokazuje stejk pointer ovaj ovde da je ovom pokazuje na povratnu adresu. Sad je nek ko treba da se vratim iz ove funkcije tamo gde sam bio, kako ću znati da je sam bio, tako što ću tako skinuti sa ovog teka procedura otvariti u nekakvog povratnu adresu i zatim tu povratnu adresu ću pisati u PC i ove PC da su stvari ovako vratiti tamo negde doleg dve je već i bio. Tako da uveki imate u paketo, to moš da zaplantite, imate u paketo instrukcija enter i exit i u paketo jedna instrukcija koliko je poziva nekako otakovu funkciju, iskal tako menja vrednost PC da spoči u tu funkciju i ova funkcija return koja se grači u stvari sve nekakva funkcija samog gde ste zapravo i bio. Evo konkretno, na ovom delu ovde, na primeru programa kada imamo ovo return x, to je zapravo treba da izginerišim, kako vratimo povratnu vrednostu, tako što je samo osta ima na expression step. Zato uvratim samo load nula, pošto ovo sam na primeru multa ovde premenljivo u okulove funkcije put i zatim pozavljajte exit i return i to je sve što je ovde potrebno uvratiti što se piče ovak. Eko da nekog budete ovde koristi povratnu vrednost ovde funkcije ona će ostati na tom expression stepu. Tako da njol' tako dole samo pokupite i koristite dalje kao da je u neku učitona bilo koji drugi način. Dalje, evo, odmah ćemo prikazati ovde i imamo funkciju koja se zove i load virtual, o tako to će nam biti funkcija koji ćemo koristiti za poziv metoda neke klasse i ona je malo kompleksnija sad ovde. To je nije ništa kompliko, ona nego je odradina na malo kompleksni način i sada verovalo da ne znam da se sika zapitali kako očite funkcioniše kolimorfizem da ovdje se neko dva sika da igrao sa time, ali ovako konkretno ovo možda pomisli se kao, ok, ovaj sad da glup urađeno ovde koji dnjih, ali ovo nisti ovo je način funkcioniš zapravo i u jeziku ja. I evo kako zapravo taj kolimorfizem u pozivnih razic. Vi kada koćete da pozovajte nekakvom metodu m, poziva se čak i na kažem i na jeziku java ovo ovakva funkcija, a ona izgleda kako, da ima svoju ključnu reču, i govog virtual, i onda i za toga slede reči, vidite ovdje označno sledije 1, 2, itd. Lede reči koja zapravo od povde nosi sam naziv te nekota metode koji pozivajte. E, dakle vidite postup primer u kudiko koji ćete pozoviti metodu n ili neznam metoda se zove m, et ch, dakle od idu slova m, et ch, kako su zove u svaritav metoda koji pozivati. I to se ugrađuje zapravo u kot. Naravno na kraju da biste znali, sada pošto ovo se se pakuje onu kod sektiu, kako ja da znam, da je kraj naziva te metode, se upisuje vrednost minus 1, da se znalo tako da se došlo do kraju. Zapravo, ovo sad da radite. Dakle, ovo ovde očekuje, ovo istrukcija i evoq virtual, ovo očekuje da vi na onom expression stacku ostavite njoj adrestu, ov tako ane tabele virštelnih funkcija za tu nekakvu plasu. Anju ućemo naravno učitavati z onog nulltog polja, dakle svaki objekat u sedi nosi kao nulltog polje pokazivačna tabelu virštelnih funkcija njegove klase. E to nulltog polje je potrebno učitati i ostaviti na expression stacku, a zatim pozivate ovu metodno evoq virtual. I ona će doredni šta, skinu će o tako to našto sa expression stackom, ostavite no kao
 i na ovna istrukcija call, povratno adresu će zapamtiti o tako na steku procedura i pis i će tako predbaciti tamo negde gde treba, ali će ona zapravo u pozadini odlučiti koji će to metodu pozvati, jer će tu u stvari uraditi polimorce. Posto ćemo imati primer na kojem ćemo tako demonstrirati i kako ona to odluči koju metodu treba pozvati, to je zdije njena adresa, ali levo za sad, tako samo da znate da ona odrde ovaj posao, osačula star ovu adresu gde treba da se vrati i postavi pis i na tu nekakom nogu adresu. Da bih ja ove pozvao na primer, evo ga primer metodu m oza ovo je obi ko to vdajo tako k, šta je potrebno da uradimo, dakle rekli smo prvo idemo load2, o tako to kao ovdaj, je sad ovdajom ponovolowlod2, ajmo sad ovo sad malo kompleksno zbog čegla, dakle ova metoda m ovdaj zapamtite da svaka metoda ima ona iskriveni argument pis i onda smo njega i crtali u tabeli simbola predkodni put, tako da rekli smo da argumente metode treba smestiti na ekspresno stek, prenego što pozovete nekakog metoda. Tako da ovo dis, u stvari za ovu metodu n, u stvari biti ovo nekakog k. Tako da smo ovim prvim load2 u stvari učitali to dis na stek. A sad da rekli smo prenego što izvršimo ovom evoq virčol, rekli smo da treba na ovaj ekspresno stek da stajemo pokazivačna tabelu virčalni funkcija za tu nekakog klasu. Taj pokazivač na tabelu virčalni funkcija se nalazi kao nultopolje, tako da ponovu uradim load2 i da smo smestili vstvari na taj nekog ekspresno stek. Kada sam sve to uradio, pozivam ov tako vidite instrukciju i ovog virčal i onda kažem redom naziv te instrukcije ide kao karakter ko karakter za uzima celu red stor i ja sam odreplako pozivam metodu n tako da stoji samo n na kraju u svih tihl tako slova koja značavaju naziv te metode ide ovo minus 1 da se odmačila tako da smo došli do kraju. Tako da to je buklavac i lokuplna magija koja stoja izgleda tog podimorfizma kada se pozove ovog virčal koja će to metode biti da imamo kasnije u nekom od zarate. Zatim sam ovog. I ja sam ovdak prigozim nekakvih instrukcija pa ćemo pauzu da imate standardna instrukcija u pot ta instrukcija tu koliko se neka vrednost na olazina steku će samo tako skinutiti tu nekakva urednost sa stekar kada budete radili ispiti nemojte zaboravljati da će biti potrebno na primeru u jednoj situaciji kada budete radili projekat ali jedna situacija definitivno da to je napr. ovako nešto da niko mi ne brani da pozoveme ovu funkciju put i ako on ima povratnu vrednost da ja tu povratnu vrednost nikako ne izkoristim kako to ste radili sigurno bez gori puta do sada međutim morate da pazite da će ta metoda put ostaliti svoju povratnu vrednost na expression stack sad vi ako je nekoristite ovdje uopšne obavizno morate vi uručno da ugranite instrukciju pop koja ćete skinuti to našto sa expression stack zamislite dovolj ovdje put ja sada pozivam u nekoj petlji 10 000 pute ili koliko već ako i tracim petlje po jedna reć će ostati satsovan na novom expression stack i u koliko to nikada ne budete skidali 10 000 seltak od ovaj expression stack povratnu vrednost ima povratnu vrednost ali se povratnu vrednost ne koristite naravno nije greška tako s tog expression stacka uručno ovom instrukcijem pop da li je imate instrukciju dup koja će vam zapravo vstvari duplirati trenutnu vrednost koja se nalazi na stacku, tako da ona u stvari šta radi imate jednu vrednost koja se nalazi na stacku, a ona vam zapravo samo duplirati u istu vrednost da se tako ta ista vrednost na stavu vrednost na stavu povijeli još jednoj ovdje sam samo nabrejo da postoje još nekakve variante dup2, dupx1 i dupx2 njih ćete pogledati šta vam je radi i verovatno će vam uzavisiti da sam u stvari u stvari u vrednost tako da imate u stvari u vrednost ja ću samo pokazati šta radi ovo s dupliranjem da se samo u tako duplira nekakve vrednost gdje možemo da iskoristimo nju pa vidureste malo pre da sam 2 puta radi o dup2 pa dup2 ono što mogu duredem i jeste da ovdje koja sam u tako pozivam o metodu m do dup2 i da onda pozajem dup samo kažemo tako duplire mi to naso na stvari u vrednosti, a mi treba još jedno na primer bi bio primar kada vam tako nešto treba a videte ćete veći zatreba da u stvari u vrednosti budete radili projekt pa ćete onda opaku baciti pogled na onu specifikaciji videti šta ove instrukcije radi i što ste tiče s kokola da je da porudamo još i njih pa ćemo sa njima polako završavati o ideo oko svih tih instrukcija da sam nambecali smo ih milijona osaćemo kroz zadatki kažemo s njih proći ponukovati s tvojstviče s kokola imamo instrukciju jump koja je bezrusno niskog i mi kažemo hajde pomeri PC o tako taj PC pomeriti za taj neki zadati pomeri s koliko sadat u vama treba taj jump da bi smo njega ilustro prikazali smo sada ovdje tako neki drugi primar dakle ovdje sada u koliko se nalazite izgenericilo iz tovo x je jednako 1 i sada treba da preskočite nekako ovo znate da bezrusno treba da preskočite cjela kod koji se nalazi u else gran jer on ne treba da se izvršava je onda zapravo da kažete constant 1 100 rmula da pe jedinicu pisujemo ovo nekako x a zatim kažem bezrusno jump i onda nekakav pomere pa sad vidite ćemo posat kako ćemo da računamo taj pomere da bi skočio i za ovdje else gran da preskočim da se izvrši ovo x je jednako 2 to ćete videti poslu primaru dakle jump i instrupcija na služit za bezrusno niskog ništa ne očekuje da se nalazi na steku ništa ne ostavlja na steku dakle nema veza s onim expressom stekom nego samo menje vrednost a druga instrupcija koja se korite se zaradi se s koliko ima bici je otaku ovde jasno prikazali instrukciju jump i call ali ovde sam mi naglasila otaku analog na ovom instrukciju imate instrukcije jump not equal less equal greater than greater equal dakle se mogući variante poređena, e pista instrukcija kao i jump dakle radi skok sa nekakvim pomerem ali uz uslo i sad konkretno ovoj instrukcija jump i call sve one sve one zapravo čekuju da se na nekom expressom steku nalaze nekakva dva podatka koja je potrebno uporediti a sad da se ne jednako stveće i jednako šta već, tako da je ta dva podatka se nalazi na expressom steku i šta on da ove instrukcije radi se nima, skida oba ta podatka sa expressom steka proverava taj nekakav uslo i ukoliko je uslo ispunjen ali sam ukoliko je ispunjen, otaku uvrši otaku prombenenje, otaku pisija za ovaj zada tipom are om te f ma biste ovde, na primer šta radili, biti to ovdje sad kaže if n je jednako nula, trebal tako da se skoči nešto u suprotom treba da se odmah skočim na else, tako da kako ću izgenerisati kod za ovu ove ja ću reći n je uzakom konc dva, nula je konc nula i onda kažem ovdje u stvari ako je ovo jednako, tako da preveravam kontra uslo, tako ovdje kaže ako nije jednako onda izvrši ovo, a ja onda ovdje kažem ukoliko n jeste i jednako nula je onda treba da preskočiš celo ovod den gravno i do skočiš na else kao što ovdje i biti, djutim, ovdje ne pisete na else i nekako kao pomere, koji je to pomere to ćemo sad već kroz neke zdatke malo da sigeramo da vidimo kako se računili tje pomere i kako su za to sve rati. I sad ovdje ja sam pobriju sad još da imate u stvari koja još instrukcija postojila u jeziku mikrojava to su nekoje instrukcije, read and print koje će biti vezane za učitavanje ispisivanje načega na konzolu, imate instrukciju za negaci, imate pomeračke instrukcije kao shift left, shift right imate instrukciju int za incrementiranje za dokatanje dužine, nije za postojin instrukcija reinvent i tamo nekaj postojin nekoja instrukcija trap za vidjeti u te nekako generisani run time dresaka ovdje sam mi samo prikazala da znate da još i on je postoje i sve ove koje sam ja izpricavate sve one zajedno i ne zapravo tu mikrojava virtualno masin. I ja imam još jednom, pa tešta je mikrojava virtualno masina, ono u stvari predstavlja ovih 5 nekojih sekcija koja smo objastili većemo koja služi i plus sve ove instrukcije koja se mogu nalaziti o tako ka beove koje seksije, tohje instrukcije koje zapravo one izgrša a ovde sam ih i pobrujeve sad kod i kojih već posponili. Za svaku od njih, ja sam sad da o tako redomo veš neava o šta ona radi se kojem od oblasti naravno nićete na ispitu, kao i prošli počle sam odlasio za tabelu simbola i za ovdje će odmah reći, ićete da za svaku od ovih instrukcija dobiti pocetnika kako ona izgleda, dakle uz ispita, na drugoj strani ispita će su uvek nalaziti pocetnik ovih instrukcija, u koliko budemo tako naravno dali ovaj zadatak, a zadatak će izgledati kako, pa zadatak izgledaju u svari ozilatak 1 ja ću go samo prikazati, pa ćemo naprijediti malo pauzne, da ćemo ga raditi, dakle uvek je zadatak da li za neki dati programski kod ispišet u svari bytekod koji biste dobili, kada biste to propustili kroz neki mikrojava kompajter, što je s koji bi to bytekod bio izgledali se. Ja sam ovde ove zadatke, namirno nove u bacije od ove godine, pa ćemo imati neki 4-5 zadataka i svaki će pokrivatiti po nešto, dakle zadatak je jedan će mi pokristi samo osnovnu obradu od tako nizova, konstanti nekakak različite, aritmetičke operacije učitavanje i smještanje, i to je ono što u stvari ljudi radim za nigo A zadatak ću u zadatku 2 pokazati šta se dešao, koliko imamo sada i nizove i polja klasa i svašta nešto još tubače, pa nekakakaj složene izraze. U zadatku 3 mislim da ćemo si dvaviti kontrolne instrukturama, dakle ifovi, ma for petnima vile petnima i tada vidite kako se to generiše i onda se kraj ćemo imati i jedan zadatak koji se zaprav ba da generisanim koda za klasa. O tako šta se se dešao oko to polimorfizma, kako da izgeneriše se lopno neone tabele virtuoli funkcija, kako da polimortno pozovete nekakom metodu i slično, tako da imacimo 4 zadatka, svaki će pokrivatiti po jednu od oblasti, ali kajšan a imamo to posle palusi. Evo, ogromna mala priča oko srga oga, ili ima neko neko pitanje, sada moždu ovom prutu.
 Ako našto budete imali, pišite slobodno u četru, a ajde, sad poštu imam dosta tog da pričam, ajmo 5 minuta pause pa da nastavimo u 1.20. Ja si idinjam što zadržavam ovako, ali nogo mi lakše dobrodim na jednom času, pa tako da to ne moram sletit, neće te ponovno da vas pocećam da sve ovodajde sad koliko, toliko bar sveši. Ajde, onda nastavljamo jo za 5 minuta, ako našto budete imali slobodno kucite na četru. Ako se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi, da se nalazi da se nalazi, da se nalazi, da se nalazi, da se nalazi, dollara' košétaitep' beli nee, finishing Ajmo samo da vidim, njom i neku živog, možda nekodom i potvrdi samo da se čujemo. Čujemo sako, ne znam, ne vidim čet. Kako? Ne vidim čet, tako da niku nije napisao, čuvajemo, vidimo. Ah, jeste, jeste, upravo sad. Dobro, hvala, hvala svima. Dobro, ajmo, ajmo onda redom sad ovako. Dakle, vidim se za data kod zestavite iz svaj vreme i sad treba da imamo svar i kako ćemo sad zegenerišimo kod. Sačem mi redom, kroz dole sve instrukcije malo pri kod se mi ja spomenjala, dakle, sad ćemo redom proći krasete kroz dole zadaata kod. Koji ću ja sad dođu redom, liniju po liniju ovog koda, prikazivati koju stvari byte kod, taj nekako ko će i od izgeneristiti. Idemo redom, samo trenutak. Kaja, oddaj, dakle prva linija ovog mikrojala kod dole kaže g je jednako n. Dakle, ovog g imate kala nekako u gore globalnu promenljivu, a ovo n će nam biti neka konstant. I onda smo rektim treba prvo da bi smo smestili nešto u tu globalnu promenljivu, da to je nešto učitamo na stack. To je to neeksprešan stack. Kako će ovo n učitati neeksprešan stack? Pa, evo gole stvari, potrećemo doda tako sve rjeme, kako te eksprešan stack je izljeda. Tako ono je ovom trenutku, sada nešto ima na njemu, da li ima neznamo, pretpostavljamo da je prazen. Kažemo, ovdje treba da učitamo stvari ovo n. To n učitava vam instrukcija u konstant 2 i ona ću stvari u dvojku, nestiti na eksprešan stack. Sada kada imate tu dvojku na eksprešan stack, u treba to da smestimo u tako ovog g gore, todna će samo pozvatiti instrukciju, koj su se radi o nekoj globalnu promenljivu i pozvatiti instrukciju u put statik 0. I ovoj instrukciju, ako je satek 0, će skinuti tu dvojku i ov je eksprešan stack će ponovat tako ostati pras. Da preto to je primjert, da imamo sad kako ćemo smestamo nešto tako globalne promenljivu. Tite narene vini je koda. Ode sada smestamo nekako u konstantu daš koje je upisano ovdje u kod 53, smestamo je u tako lokalnu promenljivu. Ode sad prasan eksprešan stack. U kod 53, međutimo, brate te bažno, sad pošto je velika nekako po konstanta, ne možemo nam skraćeno variantom to da odrodimo, nego sada morate da je kao posedna cela reć iz ovo koda instrukcije i kont, da ide ovo u 53. A zatim to treba da smestimo u lokalnu promenljivu. Bledate ovamo i psilom se nalazi kao prva poredu lokalnu promenljivu u notarove metode main, što znači da ću izgeneristati u stvari instrukciju 100 i 1. I ova instrukcija 100 i 1 će pokupiti to u 53 i smestiti u tako u y. Ode naravno vidite, sad premetite da je 100 do neca taj 1, dakle koristimo ne skraćene variante instrukcija kada god mogu naravno. Dakle, ovo sad čisto prolazimo kroz vrlo sada što smo razilili koji preizdatak neme samo za grevanje. Kaže G plus plus, Gen je nekakva globalna promenljiva i sad ja sad doma naznačio da postoje instrukcija za incrementiranje koje se zada inc, neću te posliću je tek pokazati, nju nemogu u ovom konkretnom sluču i ovde da iskoristim, nego ću morate ovo G plus plus da realizujem tako što su samo ovo G sabrati sa 1. Alajmo sad da imamo što je potrebno dobro dobro. Eksprešan tek je prazan. Prvo ću instrukciju on G statik nula učitati o tako nove eksprešan tek to nekakvo G, a zatim to G želim da sberem sa 1, dakle učitat ću 1, konstantu 1, instrukciju on consti 1. Kada imam i G je 1 na steku, onda mogu da izvršim instrukciju et koja će mi zapravo skinuti te dve vrednosti sa ovog eksprešan steka, i izbjer njihovići u stvari ostaviti na ovom eksprešan steku. I tek sad, kada sam izračun o tog G plus 1, pozivati instrukciju u put statik nula koja će to skinuti sa steka i ponovovratiti u tako u lobalnom kromedljivu G. Dakle potrebno su nam čak Petri u ovom slučaju o tako instrukcije mikrojavi da bi smo odradili ovu nekako G plus plus. Ako imate neko pitanje, zlobno napišite i suključujte ako treba nekdo nešto dodatno doobjesni, bo slobno nije problem nito. Ajmo sad ove veliki izraz doli koji imamo, kaže x je jednako minus y plus G puta n. Dakle, oledo sad neki malo služen i izraz da imamo kako se sve redom pakove po ovom, tako u nekom našem eksprešan steku, šta će se tu dešavati. Imate redom, dakle krećam redom da parsiram taj izraz, treba to nešto da upišam u x. Međutim, rekli smo to radimo instrukcijem u stvari tek, onda kada imamo vrednost već neeksprešan steku. Znači, da tek treba da izračunam vrednost, pa onda ću pozivati da tako ono stvari instrukciju do to smestite.
 Šta sad imamo retom? Kažem, ovdje na expression stack prvo ću učitati instrukcije u load 1, ovo y. Tako i to će se pojaviti na ovom stacku od tiju. Kada se to y nalazi na expression stacku nismo malo prespomenuli kako funkcioniši instrukcije, ali ovdje ćemo odmah i prikazati, postoje instrukcija nek koja ću crinegirati onu vrednost koja se nalazi na stacku, tako da sad u mesta ovoga y na expression stacku se nalazi odakon minus y. Zatim idem dalje, učitavam ovo g, g ću učitati tako što ću pozvatiti instrukciju g statik nula i to će tako i ispod učitati ponovol tako i ovo g, ali ispod ovoga minus y. Zatim to g treba da se množio tako sa n, to je sa dvojkom, pošto operacija množenje prioritetnje od operacija sabiranja, dakle ponovol će ovo tako sad odrajiti constant 2, dakle učitavam i dvojku, ne radimo ovo sabiranje, jer prvo tako treba da odrajiti množenje, tako da se i dvojka učitava sada na stack instrukciju constant 2 i u ovom trenutku pozivam instrukciju mul, instrukciju mul će skinuti g i 2 i odako njihoj proizvod će smestiti na stack, to je z g puta 2, a zatim pozivam instrukciju add koja će sad da skine ovo minus y i ovo g puta 2 i na expression stacku se o tako ostaviti u konočnu vrednost, kada imamo tu sada vrednost, i da se sada mogu da pozorimo u tako instrukciju store kojem ću sad sve ovo tako što sam izračano, dakle s loku pan taj izračan utizraz, smestiti u stvari ovo x, što je u stvari nuta lokalna promediva operolera metodemeni. Dakle da sam u stvari koristio u tako instrukciju store nullat i je on al tako naravno prazni ove expression stack. Dakle ja sad namernom ovo prije on zdatku ovde sreana prikazam je taj expression stack, da biste videli da je on na početku i na kraju izrašavanja al tako neka fenaredbe u jeziku mikrojava mora da bude prazno, tako videli kada izrašam jednu liniju koda, na početku i na kraju ovde mora da bude jedna, pročo je sve nisu nisu da ostane, sve malo tako vidićemo poslika da budemo opozivali neka kada je funkcija. Ajmo sada imamo kako izvao osve nizove, ima dole malo resultaku igranje, kaže sad niz je jednako nju int od n, dakle treba da lothram neka kam niz i da smestimo tako taj rezultat u ovo neka ko n. Da bih smestio bilo što ovo niz ovde, ovo tako ovo je malo prizava ovo x, to njegovat adresa koja se smestila u to niz, ona već mora da se nalazi na onu x stekla. E sad rekli smo, alokacija niza se vrši tako što pozivamo ono instrukciju njua rei, mjegi ću ti da bih pozvalo tu instrukciju njua rei, ono što je potrebno jese da se prvo dužina niza već nalazi na tom x stekla. Tako da prvo što radimo jeste konc 2, ovo n učitavamo to je dužinu niza, učitavamo na x stekla i to je ovo dvojka koja će se sada ovde pojaviti. Kada imamo tu dvojku na x stekla, pozivamo instrukciju njua rei 1 i rekli smo ova jedinica, če u instrukciju njua rei govoriti da treba da alociraju stvari niz, reči a nebajtova, ta instrukcija njua rei 1 će skinuti dužinu niza sa steka, to je sve ovu dvojku, alocirat će taj niz na onu hipu našem tamo negde i adresu gde je taj niz alocirat će, u stvari ostaviti opet na ovom x stekla. Sad kada imamo al tako tu adresu na x steklu, e u ovom tronutku ovde ja pozivam instrukciju tor 2, jer ovaj nizi je ovde druga po redu lokalna promenljiva, tako da u staklu instrukciju tor 2 skidam tu adresu i vidite, zapravo adresu na hipu koji sam dobio ovom instrukciju njua rei smeštam zapravo u ovu promenljivu ovde niz. Tako da ove trej instrukcije ovde bi odgovarili ovoj linii i lofte. Zatim, kaže ovde niz od nula je jednako niz do x plus y, onda kada sad treba da imamo kako radi sa donu učitavanje i smeštanje od tako elementa niza, što smo rekli? Prvo što se tiče smeštanje, da bi smo smestili nešto u nekakav element niza, tamo sam pokazala, u instrukciju imamo tako instrukcije a, stor i a, load. Instrukcija a, stor nam pluže za smeštanje, a a, load za čitanje elementa niza. Međutim, da bi smo nešto smestili, reki smo da treba da se nalazi adresa, pa index, pa vrednost. A kada učitavam, treba nam adresa i index i instrukcija a, load nam u stvari učita koja je to sad vredna. I sad kako treba da izvada kod koji će da generiše ovo ovde, pa idemo redom prazanje, ekspresno steki i mi se sad da spremamo za opisivanje u nullti element ovog nekakog niza. Kako se spremam, kažem, load 2, dakle prvo mora na ekspresno steku da se nalazi adresa to ov nekakog niza. Znači učitavli smo adresu. Sad na zanima koji je index, u koji index koji ho niza želim na nešto da upišamo, kaže const nulla, dakle, nullti element niza želim na nešto da upišam, pa ćemo tu nullu u staku staviti nasdek. I sad ovde treba da se pojavi i vrednosti sad da koji je potrebno upisati na stajel, tako nullti index i onda bi smo mogli da pozavimo instrukciju a, stor. Već u tim da bih ja dobio tu vrednost, ja moram da izvršim celo ovu desnu stranu, ovu, tako i tiza, ovo je jedna, koja se nalazi da se desni stranje. Sad se nalazi da se desni stranje, to je s kojo to vrednost koja se upisuje u ovaj multi index, idemo redom, kako u staku, znači, treba da dohvatim sada ovaj element, dakle, ponovno, radimo load tva. Dakle, ponovno se adresa ovog niza, međutno je sada zbogove desne strane postavljene na expression stack. E, da bih pozavimo instrukciju a load, košto je ovo nekako indexiranje niza ovdje, reklismo da na expression stack u mora da se nađe adresa niza, tako to smo već stavili, i treba da se pojavi o tako index koji mi to o tako element želim da učitam. Index dobijamo kao x plus y, dakle, radimo ovde sada load nula, x se pojavljio na ovom expression stacku, datim, radimo load 1, y se pojavljio na expression stacku, i vidite sada šta smo sve napakavali ove na expression stack. E, sada kada imam x i y, mogu da izvršimo ovo sebiranje ovdje, rekl, pozivimo instrukciju add, ona će skinuti to x i y, on njih ov zbir će ostati na expression stacku. I kako pogledate, evo je go sada, došli smo situaciju da imam zapakovan expression stack, imamo tako adresuniza, imamo index niza koji nam je potrebant, i ovom trenutku ovdje izvršavam instrukciju all out. Instrukcijon all out skidam adresu i index i zapravo dohvatam da tako taj neka vela menci niza koji mi je bio potrebant. Dakle, to je tek trenuta kada mogu da pozivam instrukciju all out. Sada kada sam dobio šta se to nalazi na indexu x plus y, ovo adresi, to je na to adresi u okolivog niza, pogledaš sada šta je ostalo na expression stacku, dakle, imam adresuniza, imam index niza i imam vrednost koji želim da smestim tako u taj index niza. Ako je to troje, napakavano na stack team redos kako smo go tako naveli, onda smo spremni da pozivamo instrukciju all out. Instrukcija all out skidam sve trevi vrednosti s taj expression stacka i smestel tako ovu treću vrednost u tako ovdje smo zadali nulti element ovog niza koji se nalazi na adresi koja je zadatali prvom vrednošću koji smo stavili na stack. Sve tri vrednosti se skidaju i vidite da nakaj u linije nam je opetove expression stacko ste prasi. Dobio bilo šta se tiče od tako ove linije u ovde i ajmo sad pose do liniju da imamo kako ćemo da incrementiram, stvari ovde našto dole, ažem nizu djezan plus plus, tako treba da se incrementira prvi element niz. Šta radimo? Tako sada treba nešto da se, kako ćemo ovde raditi, opet ne mogu niza ovo vidjet ćete da koristim instrukciju za incrementiranje, nego ovde moram da realizno kao da je pisalo nizu djezan i jednako nizu djezan plus s jedanom, da se viranje se jedan. Pa radimo dakle prvo, u tako smetremamo se da nešto smestimo u ovaj nizu djezan tako učita vam load 2, adresno niza i konstant u jedan, kao i malo pre, jedne vrednosti da se nalaze na steku. Esatim, da bih smestio nešto ov tako u ta element niza, potrebna mi je ovde da se pojavi na steku, tako nek sprešno steku, kao treća vrednost i vrednosti koju hoću da ubacim na ta element niza. Esatim, tu vrednosti moram prvode izračunati. Kako ću izračunati tu vrednosti? Tako što ću otaku učitati ta element, to ću ajti ponova sa ovim load 2 i consti 1, onda ću pozvatiti ovoj instrukciju a load da učitam ta element niza i ovdako to ću nekako sabrati sa konstantom 1. Tako da sad ovdako pogledate, meni je ponovopotrebno ovdako ovo niz i jedan na steku i ja ću ovdje sad da iskoristiti, ako ovdako malo pre nismo pokazali kako se, sad otvari radi ta instrukcija, ali ovdako bi će vam intuitivno poprilično da ta instrukcija je dupt 2 i ona će zapravo na eksprešan steku duplirati dve vrednosti koja se nalaze na vrhu tog steka. Tako ako ste na steku imali niz 1, ona ću stvari o toga napretiti niz 1 i opretu dole ispot niz 1. Tu sam iskoristio ovdako ovdako dupt 2, bacite pogledatamo na specificitikaciu da vidite kako stvari svetna instrukcija, to jest koja se postoji šta ne se radi. Kada imam ovo niz i jedan, dakli imam adresu i imam index niza, ja sam spremljano da izvršam instrukciju a load i ta instrukcija koji će mi učitati u stvari taj prvi element stog niz, i ovoga ostaviti na eksprešan steku. E sad ja njega želim da saberem al tako sa 1, tako da učitavamo konstantu 1 na ovaj eksprešan stek, izvršavam kao i malo preinstrukciju et, ta instrukcija et će skinuti ov tako, ta element niza je u vjedinicu i u stvari će ovdako uvećati ovdako, ta element niza za 1 i beto u vrednosti će ostaviti na ovom eksprešan steku, a pogledate sada sve mi je spako ono kako treba, dakli imam adresu niza, imam index niza i imam vrednost koja treba da se upiša i spremljano samo da izvašimo tako instrukciju a stor koja će ove sve 3 vrednosti iskinuti i opet na kraju ostaviti ovaj eksprešan stek raz. E što bi bila instrukcija koja je potrebno generisati ovdako za svako dovih linija ovdje i to su one bazačne svar i koje će teraliti na nivou a, dakle kako bude radio nivou a, ovdako pokrili smo ovim dodatkom, ovdje je dobar dela instrukcija koja je tamo potrebno imponentirati, naravno ovde sad imamo samo samosobiranje i množenje, ćete imati još neke aritmate preparacije, tamo pa ćete vić vidjeti šta sve. Ono što mi je važno, samo jeste, dakle, ovako nekada zadatak očekujete, naravno na ispitu da možete dobijete da vi ispišete i tamo obje ove znotražim od vas, dakle to je pisalo i postacio ovdje zadatka ovde, molim vas da te svari ne ignorišete kada govimo tamo napisali, ja pogodno te svih i boldujamo, dakle za svaku od linija ovdje koda morate značiti konkreta,
 kod instrukcije se odmose na to. Zašto? Zato što je biljak, ako bi ste i samo napisali jednih zp. kao što većina vas to odradi, ja ne mogu znaati šta je gde je tu granice izmeđuju, napr. ove linije ovdje i ove linije ovdje. A ne dješala se nekada je moguće da ste to nekako preklapa, tako da vam uvek tražimo da jasno naznačite koji del o takvom instrukcije ste napisali za koju linju izvornog koda. A ovo je još jednom, da ga ja ću prikazati. Kako to izla, g je jednog koja n je imalo ove instrukcije, y je jednog koja 53. Ove, g plus plus, tako ove i to zna svaku od ovih instrukcija je ovdje imate na jednom slajbu i izgledno sada koje su to, koje su to instrukcije koje smo mi generisali. I sad kada bi ste vidi, u stvari ovako nekako mikrojava uzvali tako izvorni program, pustili kroz kompajler, bi ste zapravo kao izlost dobili ov. Dakle, ov ove ovde sekvencijalno zapisano u ono i neko koji tamo kod sekcije. To su te instrukcije u stvari koji izlašavaju ovde što je napisano. Narod nemora to ovako, ali ovako nešto ovako očekujemo i od vas na ispitu da nam ovako naznačite tako koji del koda pripada koja linja. To je bio zarata kjeden i ovako kažem to su bile negakve osnovne svarče. E sad u zadatku dva, ćemo se malo sad da pozabaviti kako tako nizorima, to je kako sad da pristupamo elementima nizorima i poljima nekakvih klasa. Pa sad ako baćete pogledo ovde, imamo klasu a koja ima nekako polje i, imamo klasu b koja kako svoje polje ima niz objekta klasa a, a onda imate klasu c koja kako svoje polje ima tako objekta klasa b. I onda još menu doli imam napravlj nekakavi niz i nekako nekako objekte klasa c i klasa a, pa sad ajmo redom linju u polinju da vidimo kako ćemo svarje ovo sad radimo, da sad ćemo malo s igrima svojim instrukcijem getfield i putfield. Ajmo redom, prvodajmo ovde, dakle imate ovde ko... tako lokalnu promeljivu objekat klasa a, klasa a ima nekako svoje polje i koja je nekako ka vintager, a, tačka i je jednako pet. Dakle da biš nešto upisao u polje nekako objekta, rektim smo da koristimo instrukciju putfield. Instrukcija putfield od nas traži da se na expression stack u nalazi već adresa tog nekakog objekta i vrednost koji još evo da im da upišem. A zatim, da tako izvršavam instrukciju putfield kojem samo kažem u kojoj polje po redu tog nekakog objekta treba da se upiše ta nekakog vrednost koja se na vzim expression stack. To odnacida ovo ovde, ajmo ponovno dolnako, pratimo expression stack kako izleda i onda kažem, da bih na expression stack stavio adres u tog nekakog objekta, objekat a, ako da njegovo adres ustavljen koju će u instrukciju load2 i vidite ovo a, da plja ću ovde pisati a, ali sve vreme podreznumavam da su tu zako nalazi adresa tog nekakog objekta. Nakon oga load2 izvršavam instrukciju const5 kojem ću staviti tako vrednost koju želim da upišem u to nekakog polje i kada imamo tako adres u objekta vrednost koju želim da upišem, izvršavam instrukciju putfield, ovde opet kažem jedinice, jer nultopoli će biti rezervisano za pokazivašan tabelu virtuoni funkcija, tako da opet kažem ovde jedan i ovde putfield jedan ću zapravo skinuti ove dve vrednosti i ostaviti expression stack prazen, ali tako ovo polje iću pisati u ovom vrednosti. Tako da na delu da vidimo kako u stvari izleda o smešanje, al tako vrednosti te nekakve u lo neko polje. Zatim kao je malo preo ovde, sad obacili smo jedno indeksiranje, kaže a, i plus plus. Dakle, hoćemo da incrementiram u polje ove klasse od. Opet kažem instrukcija, inds je posebno može da se koristi samo za lokalne promenjive, tako da ovde ne ne možemo da je se koristimo, nego ovo ovdje ćemo opet realizovati kao da piše a, i je jednako a, i plus jedan, pa radimo onda sledeći. Load 2 će na expression stack, u tako da mi učita, u tako adresu ovoga a. I sad meni ovde da bih izvršim instrukciju putfield, to je treba nekako da promenim vrednost ovoga a. i, da bih izvršim putfield, meni je potrebna adresa i vrednost i onda mogu da izvršimo tako to neko po putfield. Adresu sam smestio, sad treba da je zakonom koja je to vrednost koja je treba da smestim u ovo a. i. Vrednost koji treba da smestim ću dobiti tako što ću sad bilo pročitam, to a. i, i zago uvećam za jedan. Dakle, ponovat ću izvršiti load 2, da još jednom dobijem to nekako a. I zatim sad kada imam to a ovde, reklismo getfield instrukcija i instrukcija koja nam služi za vltaku učitavanje polja nekako go objekta, pošto adres u objekta, već imam vltaku na ovom expressom steku. Ja instrukcijam getfield 1, radim šta, skidam vltaku adresu togo objekta od atle i tražim da mi se na expressom steku učita njegovo prvo polje. To je što ću ovom slučaju biti a. i. Zdaj, skidam a i smestam a. i. E sa to a. i treba da seberem sa jedan, tako da ide o tako konsti jedan instrukcija, da bih jedini slučitav na expressom stek i ide o tako instrukcija et koja skidam ovo a. i. i. jedan, zbiri o stavljanje expressom steku. I ako pogledajte sada, dakle, imam adres u objekta, imam vrednost koji je potrebno tako da smestimo neko njegovo polje, samo izlušim instrukciju putfield i kažemo tako u kojoj polje želim tu nekako u vrednosti da osat ću. Dakle, u konkretnom slučaju me je treba putfield 1 i tako opet, na kraju linije expressom steku ostaje prase. Eče to bi bilo što stiča ovog delota. E sad, majmo malo da za komplikom od dole, pa da vidimo samo sad, šta rajiti, kad je dobijete ovako neko koja velik izvira, dakle, ovaj ovdje će, voli tako što stiče projekta, rajiti samo ljudi koji bude radili za nivo c, a opet kažem što stiče ispitno delo, to možete očekivati si da ćete dobiti ovako nešto. Naravno mi što stiče ispita i stepkam, o tako taj zadatak, tako da za svakoga iman, po nešto, tako ne, nesta ima samo stvari koje su za nivo c, pa da je ispanet do projektu, to niste radili. Kleće linije, ovdje kaže c.b.aeno 1.i je jednako 2, da se sad ćemo malo se šetamo po im poljemo, mjudešte, kad je pogledat, sad kad budemo generi se likot, to neće biti u obšte nešto preterano, nešto preterano komplekski. Dakle, taj ja sad radim, pojedešte, nešto da upišemo, neko po polje ovo i, međutim, a jedno reču. Kajemo, tako za, ovaj ovdje objekta c. Taj objekta c je u stvari je prval, tako po redu, ovakal napromeljivo u nutar ovog mejn, tako da s ovim load 1 ja dostvartam, na stvari, adresu tog nekako koji c i postavljamo na ovaj ekspresni steka. E, sad što što hoću? Sad to c, u nutar klasse c, imamo to neko po polje b. Ja želim da pristupim ton polju b, adres u objekta c već imam, tako da samo opozivam istrukciju get field 1. Istrukcija get field 1 skidal tako se ekspresno steka adresu objekta i dofata njegovo prvo polje i ostavljal tako njegovo prvo polje, tako da na steku sad na konovi istrukcije naozite c.b. E, sad to b je u stvari, vidite, ako pogledamo klasse c, to b je u stvari tipa klasse b i sad vidite, da ovdje stoji tačka a na, kao tako niz objekta klasse a, a to a, na je u stvari prvo polje u nutar klasse b, sad da tako da, ja ovdje ponovno izvršavam get field 1, tako sad da za ovaj objekat koji se naozi, adres al tako objekta koji se naozi na vrku steka, a je objekat tipa klasse b i ovim get field 1 tražim da se sad na njegovo prvo polje učita na steka, a to je u stvari ove niz koji se otakla ovo ovo očišlite. Jedan sad će skoniti ovo c.b sa steka, a na steku će ostaviti cb, al tako adres u ovog niza, dakle ovde se i dalje čulo neka pa adres. E sad meni treba prvi element sto ovdje neka pa niza, pa da bih izvrši ovoj instrukciju al ovoj koji vrši učitavanje elementa niza, potrebno mi je adresan izan, njoveć imam i index mi je potreban, tako da ću samo konstant u 1 još ubaciti na ovaj stek ovde i izvršavam instrukciju al ovoj, instrukcija al ovoj dve vrednosti i dofatal tako taj prvi element ovog neka pa niza. E sad ako smo indiksirali ove niz a n ovde, vidite da smo sad na ekspresno steku u stvari ostavili neka pa objekat koji se nalazi ov tako na tom indexu broj 1, a taj objekat je tipa klasse a. Dakle imamo tip, al tako klasse a, su nače smo došli u situaciju kao što je bilo u prvoj lini, dakle sad zamislite da ovo celo ovde c, b, a, n od 1, to tu smo zamenili da ov tako neka pa nekratim objektom klasse a. I sad želimo da u njegovo kolje i ubacimo dvojp. Dakle adres u objekta već imamo na steku, vrednost koji želimo da upišamo u neku polje tog objekta stajemo na stek na toj ovo dvojka, dakle kvansom zva. I kada imamo i adres u objekta i vrednost koji želimo da upišamo samo izvršimo izvršimo instrukciju putfield i kažemo u koje polje želimo to doupišamo, košto upišamo u polje i to je polje, tako sa indexom 1, tako da izvršamo instrukciju putfield 1. I ono ovo sve skine za steka i završili smo timi i ovu lini. Dakle pogledajte, delo je oga ogromno ove neka vi izvraza, ako pogledajte instrukcije, ako pogledajte stek, dakle nije uopštno, to liko strašno, koliko možda na prvi pogledajte izvršamo. I nemo na sveču u ovu poslednju linju ovdje koja je sada tako biće malo i oš kompleksnije. Dakle ovdje sada imamo neko kamni iz objekata klasse C, pa ja prvo njega indexiram, dofvatam ili tako treći element koji će biti u svariji tipa ovoga C, pa zatim tonovo ovo b pa an kao malo pre i onda indexiram to an sa 4 i to u svariji smeštam u lokalnu promeljivu ovdje a. Dakle i oš viš samo ga komplikovali, a imamo redom. Šta treba da se desi? Prešno se neki prazan, ja treba nešto da upišam u ovo a, košto je lokalna promeljiva, dakle tu ću samo na kraju, kada budem, imamo tu vrednost koju opisujem i zvršiti instrukciju stoš. Niđutim prvo je potrebno da vidim šta to treba da upišamo tako u to nekako a. Pa idemo redom. Dokatim ove nije za ovdje Cn, instrukcijom load nula, i to je anuta lokalna promeljiva i na ekspresno steku se nalazi to Cn. Ja stođerim da dofati mjegu treći element, dakle da instrukcijom konstri, dakle u bacinu trojipo na stek i rekli smo sad da imamo adresu, imam index, izvršamo instrukciju a.
 load koja će nam učitati il sada treći element ovog nekako guzniza cn i ostavit će nam osvako njega na expression stack. O tako a load i sad da učitalo i na expression stack ostavila objekt klasse c. Mi treba da dokvati ima njegovu polje b. Bakle adres u objekta već imamo, samo izvršim instructorju getField i ona će nam otvati i prvo polje do objekta tu, a to je ovo b. Tako da se nastekla sad da nalazi cn od 3.b. Šta je to što je nastekla? To je objekt klasse b. Treba da dokvatimo tako ove nizle ovde a n. On je opet u tako prvo polje gore tako da ponov izvršim getField1 kao malo prej dobijemo ovo a n. Nalje šta treba da uredim, treba sad da učitam četvrti element tog nekako guzniza. Kažemo, konc 4, evo ga. Dakle imamo adres u nizle, to je ovo a n gore, imam index niza, to je 4, ugradim a load koa a load će mi učitati taj četvrti element. Sve što mi je bilo potrebno se tako izračunalo i na kraju samo izvašavam instrukciju s Tor2 da to smestimo saku ovu lokalnu promeljivu. I kažemo, opet, ove ekspresne stekla mnoste prasa. Dakle, ovaj drugi zadatak se bavio samo tim nekakim malo kompleksnim svarima sa nizelima i sa poljima nekakvih klasa da vidite sada kako izleda taj dras. Sve će se baviti sada ovi našim kontrolnim strukturama. Dakle, ja sam ovde sada navio za početak 1 gifls, zato imamo 1 for petlu, zato imamo 1 wild petlu i onda dole sam navio nekopa 3 ifa sa nekim malo složenim uslolima. Ove se svariji ljudi koji budu raditi projekat za njivo a neće raditi uopce, dakle, ovo će se paivljivati u te u njivo b, a ovde sam namjerno svarba stavio tako da budu forbati, i wild petle, zato što njih nemate u projektu, tako da će, ja ću od sada pokazati kako bi ste implementirali for i wild petlu, a bi u projektu imate namjerno do wild petle, pa ćete analogno omešla čuvjetu ovde zapravo raditi u projektu, a tako dosta slične stvari. Ajmo reno sada, dakle, ovde sad pričamo ove nekakvim skokovima, dakle, kako ćemo sada realizovati te nekopa skokove, u ovako ovo što smo već videli do sada. Dakle, neću se baviti nikako ovi uloskom u funkciju, nego samo konkretno za ove delove koji su vezani za ove prikazane kontrolnosti. Kažali gore, if x je jednako 1, onda treba se izvršio ovo y nekog 2, a else treba y da se postavi na 3. Tako nije važno što ćemo rajte, stavio se neko po proste vrednosti, čisto samo da vidite sad kako ćemo izginerisati ovaj nekakvih else. Ne, zapotrebe ovoga, a i zapotrebe naše ispita, ovdje, dakle, od teku od ovog dodatka 3, ja ću uvesti da sve vreme pratim zapravo, koja je adresa trenutna, na kojoj agenerišem ovaj nekakvog kota. To jest, pratit ćemo ono i kod sekciji, gde se mi to trenutno navazimo, i ja ću naravno krenuti ovde od nekakve adrese 0. Dakle, ovdje ću sada, nećemo više pratiti ove ekspresno ste, jer ništa neće ne nemu sotapu specifljamo navaziti, nego ćemo sada gledati, ok, ovo je instrukcija low 0, a ovo 0, 2, će oznacavati na koje adresi se navazi ova instrukcija unutar kod sekcija. I ja ću krenuti naravno da adresi 0 i real, tako ovde ni nemo ništa preloge metode main. Dakle, na adresi 0 se navazi instrukcija low 0. Kodiko baito razluzima ta instrukcija low 0, razluzima tako samo 1 byte, tako da će slijedeći instrukcije se navaziti ovdje na adresi 1, a šta je zapravo, koji će ovim ovdje sada, pa da bi smo tako odravili ovo poređenje x jednako 1, šta će ova zapravo dovraditi? Dakle, učita ću x na stek, učita ću ovu konstantu 1 na stek, a zatim ću reći, u kodiko ovdje nije jednako, dakle te zve vrednosti videli smo tamo da postojan i nekot u uslovni skokov, i onda ću odmah spočiti na ovu else graf. Dakle, ja sad kažem, učita, x to je ovo low do 0, dakle, na adresi 1 će se navaziti slijedeća instrukcija, a to je instrukcija koja ću učitati u jedinicu na stek, to je instrukcija const 1. Instrukcija const 1, dakle imamo posebno instrukciju, rekli smo za oniš prvih 5 vrednosti od 0 do 6 vrednosti od 0, 5 i za minus 1, tako da ovdje zauzima i dalje 1 byte, tako da sljedeća instrukcija, kažem, se, nalazi na instrukciji, na tako adresi 2. E sad koja je to instrukcija, rekli smo, koji ću da spočim negde, ukuliko ovodvoje nije jednako. Tako da to će biti instrukcija jump, not equal, i ja sad oddaj koji ću da spočim negde, oddaj sa namernou, beleže ovo u pitnicime, ja u ovom trenutku sad oddaj ne znam, gde hoću da spočim, ne znam adresu na koji hoću da spočim. A adresa treba da bude else gran, tako da ću samo s edvise strane zabeležiti, da ovaj skok oddaj ugleda s ova tri upitnika, treba da spočim na else gran. I to će vi raditi u projektu, dakle važ datak će biti da tam negde pantite, ubacivajte neka kvala bela i onda ćete u stvari generisati kot i kada pojete generisali konkretno ovdje ovu instrukciju jump, not equal. Nakaj, vi ne zate kol koji pomere, i treba da bude odnosno tekući pis. Tekkući pis u ovom trenutku bi bio tako dva, aga ja ne znam da je da spočim, i onda samo sa strane na redeserbi zabeležim. Ok, ovdje kastnije kada budem saoznao od desem na ozio ova else gran, treba da prepravim i da izračunam koji je to nekakak vana. Ovim ovom instrukcijem ću ja preskočiti celu ovu den granu u koliko x nije jednako 1. Međutim, u koliko x jeste jednako 1, ova instrukcija ovdje neće imati nikakav vesekat na pis, nego će pis samo nastaviti dalje od sledši instrukcije. Sledši instrukcije treba da budel tako to telo samog tifa, tako da ja u svariji zvašam ovo y i jednako 2. Dakle, ovde sada kreće den granu ako ovdje naše gifels. I ja onda kažem ovdje u stvari i da instrukcija konc dva. Primetite odmah da ovoj instrukcija se nalazi na adresi 5. Zabok čega na adresi 5, zato što smo prej toga imali instrukciju Jump Not Equal. Ta instrukcija Jump Not Equal zauzima 3 baita. Dakle, jedan baita za ovaj kod Jump Not Equal i plus dva baita za ovaj nekakak pomeraju ovdje. Znači vam biti dato, kažem u tom nekom pocitniku, nećete to morate znaći na primet, ali pazite kada ubujete radili na ispitu. Dakle, ovo zluzima 3 baita, tako da ovo se nalazi na petici. Kažem, konc dva zluzima 1 baita i ov tako smiješ tam u tu dvojku y, onda smo videli malo, da te instrukcija to rijet. Esta, kad sam završio telo ovog gifa ovdje, nakon ovoga bi sada trebala se nalazi na instrukcije ove els granemi. Tama sam negdje pokazala, meni sada ovdje treba zbjedan bezuslovan skok, da ja preskočim ce ovaj els i da nastavim dalje. Što značiraju ovdje, kao instrukciju na adresi 7, izginerisati bezuslovni skok, koji opet sada ne zna gde treba da skoči, da treba da skoči izza elsa, ali to ćemo teka kasnije otak odraditi, tako da ću samo sebi zabeležiti ovdje da ovaj jump treba da skoči izza els granel, tako skroz. Dečetno biti, vidite ćemo posle, pa ćemo da prepravimo ove upitniki. Ove opet ovaj jump ovdje nosi 3 baita, tako da se slijeće instrukcija, a to je u stvari početak sada els grane nalazi na adresi 10. I to će biti instrukcije, konc 3, historijet. E sada ovo izad nakon toga, kada završimo i pislan 1 u 3, sve ove instrukcije koje se budu nalazi lovda ispod, to je našto se nalazi izza elsa, to je sluči sada krenuti ovoa for petlja od adresi 12, i sada ja ne znam šta se tu konkretno dalje nalazi, nećemo dalje, nego ćemo se ovom trunutku ove zustaviti. Nakon što sam ovo sve, ovo sve, ovo isparciro, ja sada znam ove upitnike ovdje da prepravim kakovalja. Dakle sada ako pogledajte ovdje, jump noti kolje trebalo da skoči na els granu, pogledam, a els gran je kreće od adresi 10, ako smo se nalazili na p, si u 2, da bih skočio na 10, ovdje pomere treba da bude 8. A ovdje ovdje ovdje tako jump, kaže treba da skoči izza els grane, dakle ja sam nalazim na adresi 7, koji ću da skočim na adresu 12, dakle treba mi pomere 5. I ovve u stvari, tako, taj nek bite code koji nama treba. Dakle da ljudi koji budu radili nivog b, ću da prvom morati da krpe, tako malo ovaj svoj code. Dakle generišu, ostavljio nešto prazno, pom da kasnije, kada saznije, vrati samo nekde pa popravio, tako te neke pomere koje te kasnije, saznaju. Ne, ajmo do dalje, dakle jemo sada ovdje do tako 4.5.1, pa da imamo sada što se dješava sa 4.5. Ajmo sada čisto, verno da ne moramo da vas potičem, a da imamo redom, prvi dio 4.5 se izvršava odmah. Zatim se odmah provera ovo je uslovo odmate, u koliko je u uslovo nije ispunjen, izlazim odmah, preskačemo celu 4.5 i nastavljamo dalje, u koliko je uslovo ispunjen, treba da se izvršava redom ovom ovom sada, na primer ovdje datu printx. Nakon oga printx se izvršava ove treći del od gore koji je dat i onda ponovu prelazimo na izvršavanje ovog uslovova. Pa imamo redom, kažem, 4.5 ide od adresu 12, konstant 0 i stor 0, dakle u te ovo x je nakon 0, to se izvršava tu. Zatim ove sada, ja sam znači, da ću ovde sada krenuti proveravanje tog nekakog uslova od adrese 14. Kako proveravam uslovo, isto kova je malo prekudifat, dakle treba da učiti x i 3 na ovaj steg, to je load 0 i const 3, dakle sve ovu instrukcije nosa samo 1 byte. I sad šta treba da uredim, treba da proverim kontra uslovo, dakle ako uklik ovo je uslovo nije ispunjen, već je ili jednako u tako doove trojike, dakle instrukcija jump greater equal, i onda skačem 1 ove 4.5. I dalje ne znam gdje, samo ću sebi zabeležiti, da je ovo izlozak iz 4.5 ovde ostavljam u tako upitnik, pa ćemo poslito da prepravimo. Rekli smo, okoliko uslovo je ispunjen, onda će ovo svi samo nastaviti ovde dalje dole, nezaboravljamo tako da ove jump, tako ovde nosi 3 byte, tako da je on svežnja instrukcija, tako ide na adresu 19. I ovaj je samo telo, te nekakve petrini. Preba da ispisamo tako ovdje kovo x, najvo prikazaćemo i kako se to radi, dakle učitamo to nekako x, znuta lokalna premengiva, datelog 0, je sad potrebno aj prengust izvijed pozoljetom u instrukciju print da je kažete i na kojoj širini treba da ispisamo u konzoliju dakle ko to neko pox, načinu ono ne bitno, ja sam ovde samo stavio u konzoliju 3, i onda pozolim instrukciju print, ona će da vam ispisav u konzoliju. Nakon što smo izvršili, to je celokupno u svariji telo, te neko tefor petrini, nakon toga ide ovaj al tako neka pakcija.
 nakon svaki iteracije koja se izrašala, to je ovo nekako hodite x plus plus. Tak, to ovdje smo sad da prikazali, tu možemo da iskoristimo instrukciju int. Instrukcija int radi tako što, u stvari, kažemo od njih imamo dva nekako al tako operant, u tohje argumenta, kažemo koju lokalno promenivu i za koliko treba da incrementira. Dakle, možete da incrementirate o koji hoćete izavisati. U stvari, tako, u stvari, značite, u stvari, bilo, kono promenivaju pisem nula i hoću da je uvećam za jedan, ovdje sam da upisete jedan. I naravno ovdje će zuzimati 3 bytes, dakle, jedan zakod instrukcija i po jedan byte da ovaj u tako narjedne dve stvari koja sam navio. Tako da to tb usje navazi PDF2022 na PDF2025 nakon toga x plus plus, čta treba da se desi? Ja bezuslovno treba da skočim ponovno u prover u uslova. na adresi 25. Ako skavčemo na prover u uslova, ja onak znam u ovdje to da upišam, dakle to je našto su sam već prošao i pišem ovdje junk minus 11. Dakle, sa 25 da bih se vratio na 14, on mere je minus 11, dakle vrati se tako gore skroz. Nakon ovoga oddjel, tako to je bilo tako povratak na prover u uslova, nakon toga sledil tako na, košto ovo opet nosi 3 byte, na adresi 28 sledi nešto što je nakon, u tako ovaj horror pet ve ovde, tri tačke ko to će biti u stvari ovaj nekakav vile, ali ovim ja sam završio od cijego kod koji mi je potrebno za ovu vile pet vlutu, to je za horror pet u ovde božem. Što nama mi je ostalo, ko nismo odredili? Na ovdje ovdje ovdje ovdje ovdje ovdje na adresi 16 smo imali nekakav uslova, kojim treba da se iskoči iz horror pet vlutu skroz, ostavili smo upitnike, dakle, sada ovdje smo zakličili da se i za horror pet na ozinstrukcija na adresi 28, znači, value bilo na 16, da bi skočio na 28, potrebno da ovdje sam upišemo tako povrediti 12. E, tako da kažem, ovdje moraćete da vodite na ispitu računa ovim adresama, al tako koja su da bi smo ovdje znali da upisujemo te pomere koji su nam odgovariti. Ajmo dalje, kažemo u wild petju, sad ovdje ima dostav od koda, pa ćemo ovo malo po malo, vidjutim da pogledam samo koliko ima sastvij, dobro, je miš par minuto da kraja, tako da, ajdem, završit ću danas još ovaj zadatak 3, a možda mi je vlasa ajdipak da oni zadatak 4 koji su odnosili na klasse, osvajemo za sljedeći čas, dakle, a ovo da smo je zadržavam prevište danas, pošto ću još malo potrejati da vam se malo na primer ovoslegne, pa da onda sljedeći čas još malo pocitimo ovog generisanja koda sa tim nekakim zadatkom oko klasse i polimorfizma, onda ćemo nasliti dalje sljedeći put gradi u kojoj budemo imali, kažemo, evo danas da završimo sa ovim kontronnim strukturama. Ajmo, nima ovaj wild ovdje, kako sadarati, tako, sad imate nekakaj wild koji ću u sebi imati i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, idam ovdje što je ove četvorke, onda ću škočiti gde, ovdje objedežavam sebi da ovo treba da skoči i za petlje, tako treba da, iskoči iz pove petlje ovdje vajervo. Haja seđu nja. Imate sad obje delo tako dalje, sad analizimo ovde na telove naši vajerva petlje, je sad, u telu petlje, kret ćete da izvršavate ovaj neko ko v ovde if. if treba da provjeri, da li je x tako jednako jedan, tako da ovdje na znači ću, tako da je to nekakav if, staratim dalje, na adresi 33 imate load nula i ovdje tako const 1. Dakle, to su ovo dva, ovo dva, tako operanda ovde koje treba da su u porede i to je zada zapravo telo te naša nekakva ilpe. Šta ću raditi? Pa isto kao ima lopret. Dakle, ovdje sada ukoliko x nije jednako ovome jedan, ja treba da skoćem na neku drugu granu tako sad ovde da liste. Dakle, ovdje sada je kažem jump not equal, dakle, ako x nije jednako ovome jedan i naznačim sve bi gdje ću to zapravo skakam. Pa da to treba da se skoće na ovaj drugi, u tako dole na ovaj drugi lc. E, gdje je on za sad ne zna? E, polik u uškom nijednog. Izvojte. Samo pitanje jedno, u ovom vajelu sami imali na primje nešto int z. Kako bi se to gledalo, u smivu, slovo load nula i jedan, i kvalo lokalno formeljima, ali bi se gledala kao sami bi se novi brovi na i int ipsi u lm, pa bi lov dva ili kako? Ne, ne, ne, to sam prošli put na glasiju. Dakle, sve lokalne promeljive unutar nekakve funkcije se moraju specificirati pre samog tela. Dakle, mikrojava ne podržava u opšte da postoji unutar tela nekakva promeljiva definisati. Aha, dobro, dobro, našto. E, to vam je ogrinčenja. A inače u ovim ostalim prokvenstvim jezicima, ako biste pogleda, neprim, kako java to rešava, tako što zapravo sve te lokalne promeljive koje imate dole i dalje se one koriste samo na neki malo specificni i način. Tako što, na primer, one njih izlače. Seći se možda na primer kada stradili c, c je za teva, na primer da sve lokalne promeljive definišete odmah u startu pa te konda da ih koristite. Ali ovde ko nasta mikrojavi, nije tražimo da obavezno, na primer sve bude... Odziv tako da... U kvaliti funkcije, sve še će biti u lokalno formeljima da mora u deklaraciji. Tako da, sve se mora da buda u deklaricu, na primer košta otvrite, ove vidite, če se zagrda od ide te loke. Način, na to. Išta. Dakle, hode. Ajmo, sad da se vratimo naziv. Ovo smo rekli da ide neka vskoka koji ćemo mi preskočiti te lovo gifa ovde ukliko ovaj uslov ili tako nije izpunjen. Međutim, ukliko je uslov izpunja, na to je da x je jednako jedan, treba da se izvaši narib, da continu. Da sve narib, da continu treba dura di šta. Da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, da se narib, je os grana će reći da u y se upiša nula, dakle, konst nula i stor jed. I to bi bilo tako, bilo sve. E sad, ovo dolel tako što se nalazi nakon ovoga, to ću stvari biti ovi instrukcije koji se i dalje nalazi uunutar pecle, to je ovo y jednoko y2, dakle, učitamo tako y, ubacimo konstant u 2, uradimo instrukciju u rem, instrukcija rem ćemo tako raconati ostatak predeljanju, i to tu smestimo tako u ljipsilom, to je u prvu lokamu promenjima. Nakon što smo to izračunili, kada završite dole telo wild petlje, šta treba da uradim ja sada ovde, da se bezoslovno vratimo tako gore ponovno u novu iteraciju, tako da na instrukciji 55 se nalazi jedan jump koji kaže gde se vraćem, pa skroz na početak ovog wilda i gore, to je bilo na 28, a ovdje je na 55, dakle, imamo jump minus 27, to je sve vraćem se vratimo tako skroz gore i nere sada li ovako, i smo je ovde sada na prezentaciji tek na kraju, pokunjavam ove upitnike, vićite kada budete radili projekt, naravno odmah ovde sada na primer, kada smo ustavili ovde upitnike, i rekli smo da ovde treba da skoče na el-sif, viće da odmah čim najizjeti na taj del tu, kada dođete do tog el-sif, odmah zako zakrpiti taj del ko da gore. Šta treba ovde sve da pokrpim, pa dakle imamo na četvim mesta upitnike, ovde kada treba se skoči i za petlje, kroz i za petlje će se nalazite, prigazat ćemo na adresi 58, dakle ovde treba da se skoči sa 30 na 58, dakle pomere će biti 28. Ovde treba da skočim na el-sif, dakle sa 35 na 41 treba da bude pomere s 6, ovde treba da skočim na el-s, dakle sa 43 na 49 opet pomere s 6, i ovde treba da skoči i za petlje sa 46 na 58, dakle biće pomere 12. I ovoga kao sam mi reko sada, dakle te sve pomere samo na kraju, ove koje mi sam znao samo ih zakratimo. A je to kako bih zleda jedna ovaj ogromov vajl sa nekome nifove, ima elstvenima, continui, break na redbama u tako šta tu treba da se desi. Evo, da držete, ga oskažem još, nao da prikazam samo još ovaj...
 pa ćemo da i dostaviti taj deosaklasan na zadan sljedeći čas. Ojdea ovdje sad da, da ja ću sad prikazati kako je mogući isgenerizati kod. Što se tiče ovog delu ovdje, vidi u projektu to možete uvrajiti kako god više. Al it je samo ono što zna glasam, odmah jeste da morate da pazite na sljedećeg. A to je kako u svariji programski jezice, to je kako compiler generiše kod za ovo i kako su ovo zapravo izvršalo. Ako imate nekakakav složeg uslo kao što ovdje piše, kaže if x je već od nula i y manje od 2 pa onda nešto treba da se desi. Dakle šta važi? Ukoliko vi izračunate ovod, da li x već od nula i ovdje zatvričete da to nije tačno, nema potrebe da si izvršalo ovo y manje od 2. Jer odmah znamo da ovaj ceo izraz ovdje naprimer nije tačno. Isto tako ovdje toli ispod kada dođemo na ovom if x već idi jednakod nula ili y manji ili jednakod 2. Čim zatvričem, naprimer da x već idi jednakod nule, ja opet ne moram da izvršavam ove drugi deo, jer znam da će ovo ovde sigurno biti tačno. Tako da tu nazovimo optimizaciju, obavezno morate svi da implementirate kova jeć bude radio nivoz, behi nivoz cel, tako za projekt. Najmone pa gledamo kako bi trebalo da izgleda izgnearistan i byte pot za, na primer ovdje prvi ovdje if. Dakle, primetite se samo da se ovo 3 odvoje na ifa. Ne manje nikakakakav els između njih, tako potpun u 3 odvoje na ifa i samo pod ovim osloom odvesi izvršava ovo x je jednakod 2. Staranimo, dakle, započinjem if, ti kažem, majmo redom, load 0 i const 0 tohce x i 0 i šta ću ja sad ovde raditi? Dakle, učite osam x i 0 i proveraavam, odmah, sad ću je proverim ovde kontra uslov. Ukoliko ovo nije tačno, ja treba odmah da skočim nge dole ov tako i za tog nepakog ifa. I onda ću u stvari reći šta, košto u uklav bio da je ovo već je, ja proveraavam kontra uslov, a to je da je manji ili jednako, iliti jump less equal, i kažem, skoči nad 3 nekog upitnika, kažem, i za den grane, dakle, skroz i za ovog ifa treba da skoči. Prespoči tu den gramu nemu i da izvršiš to što je ov tako uslovno ovo im neka primizda. Međutim, ukoliko ovo x jeste već od nulo, onda ću samo nastaviti od adreste 63 i ovde će se sad pojavljivati ovdje tako drugi uslov, a drugi uslov je da je y manji od 2. I sad i njega izbašavam ovde, na adreste 63 imam load 1, const 2 i sad kada smo tako bacili y i 2, sad ću opet treći štak. Pa sad proveri opet kontra uslov i ukoliko ovo sad da nije zadovoljeno, opet skoči i za den grane. Košto proverao, onda li y manji od 2, meni da je uslov veći ili jednako, dakle to je kontra uslov, i onda kažem jump greater or equal, opet ako to nije ispunjeno, onda skoči i za den grane. Dakle, i za 1 i za drugi uslov, ja sam rekao, ukoliko nisi ispunjen, preskočio tako ovu den gramu ovog ifa. E sad, ako smo prošli i jedno i drugo, ako ni na 60, ni na 65, ni jedan od ova dva jumpa nije zapravo skočio i pomerio pis, mi onda tako ulazimo ovo telov, tako to nekoho ifa, u kojem se deshava ovo x i jednako 2, dakle konce, 20 o rnulom, ništa kompleksna. A zatim, ovo izda den grane se javlja na adreste 70. I onda ovdje tako te kada se se to isparcirova, da vi sada znate, u stvari je da treba ovde da ažurira tove vrednosti, to je odde na 60 će biti pomere 10 da bi došao do 70, a na adreste 65 mi treba pomere 5 da bih preskočio tako ovu den gramu ovdje ovog ifa. Sada ovde, ajde, nije bilo našto preterno teško. I ovdje, pošto smo imali ovdje operator i, međutim, ajmo sada vam imam, šta će nam se desiti u zadatku, likujemo operator ili izmeću. Ono sad što treba da važi, jeste sve jeće. Dakle, ja dolazim do ifa, imam x i nulu i opet prvo učitam, ovdje tako x i učitam nulu, kada imam ta dva sada tunel, tako na x presom steku. Ja ću sada, šta treba da uvradi? U koliko je ovdje ovde, tako, ja odmah treba da skočim na telo tog nekako gifa i uopšte da ne izvršavam ovoj drugi izrazovate. Što značile, ću sada proveravati baš taj uslog koji je jesta na vede, a to je, da li je ovo već ili jednako? Tako da vidite, proveram da je li je već ili jednako i treba da skočim odmah ku telo tog nekako gifa. Dakle, skacam odmah na den granu da izvršim to, šta je ov tako uslog. Iđutim, u koliko taj uslog nije ispunit, ja ću samo nastaviti ovde dalje, što značile će ovde sada iće ove drugi uslog, a to je da y manje od dva. I ja od al tako radim šta. Pa učitam y i dva, šta sad koji ću da izvedem? Sad poštimam y i dva, sad ću proveriti opet kontra uslog, i onda ću reći sad ako y nije osako manje ili jednako od dva, ako y već je od dva, je sad preskočio ovo. Dakle vidite, sad ubacujem instruciju John Grater, dakle ako y već je od dva, onda treba da preskočiš ovu den granu. Dakle, kad sam pode menjate malo logiku kad je u pitanju ovo ili, mislim, možete vi sada onda ponovod radite skok na i, al onda bi ste morali dubacujete neko pebezostom na skokove i tada probajte ku kući sada ovkada se završi časli, da ćete bojete gleda gleda ovo i snimak, dakle probajte sami da se poigrate s ovim, može ovo da su uredo na milion različivih način, al ovo je jedan od otimalnih način, tako dobro izvedeno. Dakle, kažem, ovde sad y manje ili jednako od dva, ja proverim, da je to nije tačno, i ako to nije tačno, to će značiti da ni prvi deo, ni drugi, ni da je tačno, tada treba da spočiti izda den granu, ja ne treba uopćete izvrši možstvih na ozili. Kod iko sam prošao ovo, ovde isto nije bio ispunješu, znači da y je ste manje ili jednog od dva i den gran se izvršao, a u den granu imamo const 3,100, što je ovdo svar i x je znakon. I za den gran je onda u svaru sveće instrukcije se nalazi na adresi 82. I sad kako treba da zakrpimo tako u ovog orešna, nam je ostalo, nekako nismo odle specificirali, da ovo je pomiraje. Ovo je kaže, na adresi 72 treba da skočimo na den gran. Den gran počinja na adresi 80, tako da od 72 do 80 ovde treba pomaraje 8, a ovde treba da skočimo izda den gran, to je o tako na adresi 80, 20, 70, 70, 82 ovo ću svarijići pomaraje 5. Ovde 5, a gore 8. Primjetite da jedno skrače na den gran odrugoskače izda den gran i da smo obezbedili ono što sam rekao, da u kliku je prvi izdra stačan da se ovoj drugi ne izvršava. Isto koji malo prešlo smo obezbedili da ako je prvi nije, tačan da se onda ni ovoj drugi ne preverovi da se ovoj den gran uočen nije ne izvršava. I ja imam da zekraj danočnih časa, ovo je još kompleksni izdra skraže ako x različi do 0 i ako je y veći u 2 ili je x jednaku 1, onda treba nešto tako ovde sada se izdači. Ode sad prisetit ćemo se samo prioriteta operatora dakle ovo i će na biti ovde prioritetnije tako da gledamo ova dva ovde i sad ovde će sad bude dosat komplektno ovde tako da kažem dosat će vremena ljudi koji budu raditi pekat za nivog b potrošiti na ovo ali je to kažem koji te imali problema možete odorganiti u mej neke konflutacije pa da je to za jedno predizgut, imamo nešto vezano za to. Ja ću sad pokazati kako bi bilo idealo da se kod generiše ove situacije ovde naravno vi ne morate to raditi tako možete oslobno da bude malo komplikovanje. Evo. Najmo ove, dakle šta preveva sada je sve desiti prvo što ćemo proveriti je ste ovo ove dakle da li x različi do 0? Šta treba da zakličimo? Ko li ko taj uslov ovo y je veće od 2, su uopštimim ne proveravali tako, zato što ovo i ovde nikako ne može da bude tačno ukliko je prvi deofolts. Tako da ukliko x je jednako 0 dakle ako nji ispunje na ovo uslobko je zadat, ja odmah treba da skočim na provera ovom drugu usloba da je x jednako 1. Dalje, ukliko ovo ovde jeste tačno dakle x je različit od 0, ali sad proveravam ovo y neće od 2. Ukliko zatičite da y je ste veće od 2, odmah al tako skačemo na ovo ismršavanje ovo x je jednako 4, izvršavam ovo ili gram. Međutimo, ukliko zakučim da ovdo y nije već od 2, je ovdje tek izvršavam ovo ili gram. Tako da sad sve možete možete razmišiti to našto, da sve sada iznali kad ste kucali od tako nekoje programe, samo sad razmišiti sve, znao višta nekoj compiler, ako je sada do toga treba disgeneriti nekoj uskut. Treći it, učitavate x i učitavate 0, dakle 0 i kvamst 0. I sad što sam rekla, ukliko da je u slav nije ispunjen, a to ćete proveriti tako što ste pitati, da li ovo jednako, dakle ovde pitate, da li nije jednako, a ja proveravam kontra uskut, dakle da li jeste jednako, ako jeste jednako ja kažem, skočim na grugi deo ovoga ili, tohce na ovo proveru x je jednako jedan, dakle ovdje preskočete ovoj prvi deo ideo, zato što oni kako nemože da bude tačno, ako ovoj prvi ovoj izvršavam, da nije tako. Međutimo, ako prvi deo jeste tačan, e, onda imamo tako drugi uslovo tako ovoga i, a to je da y je već i od 2. Dakle učitam y i dvojku, i onda sad kažem, ako je i jedno, i drugo ovo ovde bilo tačno, ovo ili će sigurno biti tačno, ako je c ovoj prvi izrastačan, tako da ću onda proveravati baš ov je uslovo jedan, da li y je već i od 2. I onda kažem, da je tako, da li je veći greater den, kažem, ako je to ispunjenost kači odmah na den, granu, preskoči izvašavanje ovoga, to je x1 ko 1. E sad ako to tu nije bilo ispunjeno i onda nastavljam ovde doli ispot i ovde doli ispot će biti u svariji ovoli drugi devo ovoga ili, to je provera da li x1 ko 1. Na provera izgleda ovako, dakle imamo učitama x1 i sad ovde, šta smo rekli, ako smo došli do ovoga ili, to znači da ovaj prvi devo nije bio tačan, da ozbog prvog ili drugog dela nije važno, dakle ja sam došlo proveravam da li x1 ko 1 i ovo ćemo se voditi opet onom logikom, pošto smo došli do ovoga ifa, tamo ću reći u koliko ovu x nije jednako 1 preskoči na primer ceva ifa. I onda kažem proveravam kontra uslovnak, koliko je uslov nije tačan, uslov je da je jednako, ja proveravam da li nije jednako, ako nije jednako, ja kažem definitivno treba da skočiš i za den grane zato što ovaj uslov u notar ifa nije ispunje. Zatim ovde se nalazi den grana koja x je jednako 4 a to je konce 4 stor 0 i za den grane se nalazi nešto što je na dresi 99, to sa namnije nivажno što je. Tako da, kako ja osnadkrpim ovog ovdje, ovdje jump equal na dresi 84, treba da skoči na drugi deo ovoga ili, na 92, da te odličići pamere 8.
 Ovo ovdje na 89 treba ovaj usluv da skoči na den granu, takle sa 89 na 97, tu će napiti opet 8, a ovaj na 94 ovdje treba da skoči izda den granu, to jest, sa 94 na 99, to je u stvari 5. I evo lih u stvari kako izgledaju i neka pitom. Zadnožio sam ovom, kaj smo iskratili pauzve, ovdje 15 minuto duže. Kaj sam, ovo sada dosta sam ja ovoga danasa ovdje pričao, naravno sam ćam ovo sve pomoći, da ja sam nisam jobila, stvaka u gubio tu vliko vremena. Mislim da sam ljepo, tako sve ovaj prezentacij, da mošte redno da vidite gde se šta nalazi, tako da on to sve ne bude samo napaceno. Pa kaj da sad kažem, da nebos je dobro potrealo baš dosta dugo ovaj čas, kaj da ostavite, čas da završim taj deo, da prikazite odmaka u izladu datak 4. Dakle, imamo tu neka zadata, kako tu ćemo raditi, kako se pozivaju funkcije, kako sa tako doklataju te povratne drebnosti, značite ih nekakvog di funkcija, ovdje ću prikazati ovom zadaatku u 4 i kako se generiše tabele virtuoli funkcija, kako se alociraju noviji objigti, kako se pozivaju metode, kako se mislim što će podima arhizam. I ostavu, tako da kažem, ajde, ostavite ćemo to za sveći čas, a za sad ajde da zadošimo onda samo sa ovim što smo imali do satom. Dakle, ovo do sat, još nam falo ove funkcije, ove da imamo kompletan nivol B za generisanje koda, i na sljedećem čas odrdimo i ovo što imamo s plasama, i imamo kompletan nivol C. Eto, onda to bi bilo toliko za danas, pa onda se družimo sljedeći četvrta je ponovu od 2, nezdo 2. Jel ima neko neko pitanje ili ćemo da privodimo kraju? Držaš. Ako budete nešto imali, u među vremenu, pisite mi slobodno, i mogu vas opet sam primjetio u slučinu, nas omušao preneki dan, dakle nemojte mi pisati samo na one mail, at online etfrs, pisite mi samo na one et etfrs mail, što gozoma bude potrebno, pa onda do sljedećeg časa. Kozdr, s imam. Dobro, zdravo si ima, od obrdošene je še dan čas, i ovaj može samo neko prenego što nastavim, standardno samo da mi potvrdi, dali se čuvamo i dali vidite ekran koji je. Dobro, zdravo si ima, od obrdošene je še dan čas, i ovaj može samo neko prenego što nastavim, standardno samo da mi potvrdi, od obrdošene je še dan čas, i ovaj može samo neko prenego što nastavim, standardno samo da mi potvrdi, sve neko prenego što nastavim, stavimo i dali vidite ekran koji je. Zafvaljujem na brzom odgoru. Dobro, ništa videli se proči čas, ako što bili s nama ovde na vežbama, dakle ja sam što se tiče o generisanja koda, odradi ona prva tri zadatka, preošli smo sve mogući instrukcije mikrojave, videli kako zledaju sve memorijske oblasti, i osvali na mjena redu još, kako ćemo biti poturno za nivoce i opet kažemo i za ispite naravno. A kako je u stvari, kako ćemo sada generisati kod za klasse, to je metoda je klasa, i kako ćemo u pozadini generisati one tabele virtuolnih funkcija i pozivanje tih metoda polimorfa. Pa, kaj da pogledamo, taj zadatak možda sam ga čak i prikazala na prezgodnom času, dakle taj zadatak je izgledao ovako. Ja ću, delo po delu ovog zadatka, da radim došlo dugaček za ratak, tako da ću dobro delo u prvog časa da nam ode na to, a onda na drugom času ćemo krenuti pa dofrestignamo sa obložću predstavnjenja različete go tako medju koda. Radit ćemo neka rekače različete reprezentacije medju koda, kako su ono se o tako može predstavljati da bi se o tako lakše prenosio i svično. Ili imate možda neko pitanje do mene prenego što počnem, ili da krećemo odmah sa zadatkom broj četnjiče. Kona što gude trebalo pišiti s labudnu četu, a ja ću ovako polako retom. Dakle, kada sada imamo klasse ovde, ono što ćemo prvo raditi, jeste ja sada prolazim kao što ćete gaj raditi u projektu, prolazim redom svojim kompajlerom nekim, ovdje kroz ovaj kod i ovdje tako naravno kod generišemo samo za tela nekakvih funkcija i metoda. Dakle, dolazim ovdje do prve metode u ovom programu koji je prikazam sa desne strane, a to je ova metoda M. Kajmo pregošto, krejamo samo da generišemo kod, dakle, da osvarnamo samo na to što mi je u svari zapravo ovdje imamo, imamo ovu klasu C-calk, ono ima jedno svoje polje, nju smo videli tamo, kada smo crtali tabelu simbolom, malo sam ja sam u modifikovalo sada ovde i imamo u sebi dve nekakve metode, jedno koje se zove M i drugu koje se zove F. Zatim smo iz nje izveli nekakvu drugu klasu A-T-calk i u njoj smo samo odradili o tako pre-definiciju ove metode M-ort. Zatim šta te metode zapravo rade, to ovom trunutku zapravo i nije važno. Važno mi samo tako da vidimo da ovaklas A-T-calk zapravo je izvedena, ovdje zove gore i samo će raditi pre-definiciju njeva. I onda kasnije, u menu šta imamo, kao jednu lokalnu promendigu, imamo ovde referenciu na obikat klasu T-calk, međutim dole ako pogledate u kodu šta radimo s tom referenciom, pa ja je ovde zapravo inicializujem na ovo A-T-calk. I onda pozivamo njenu metodu N-tok, i treba sada vidimo kako su svarili to u pozivnih obezbedi da bude pozvano ovo metodo ovde, a ne ovo metodo ovde gore ovo tako bez obzira što je tipove referenci objev u stvari ovo T-calk. Buk toga, tako šta ono inicializovan na ovo A-T-calk. Epa, ajmo red, da vidimo sada. Ova metoda N, kred ćete redom da generišate kod i odšlat sa strane ovde pancti tih adrese gdje se sada nalaze ove neke moje metode. Tako da poštu još ništa nismo izgeneriti, da se nalaze ovo metode, i sada se nalaze ove neke moje metode. Tako da poštu još ništa nismo izgeneriti, ali metoda M, ove klasi T-calk, u koji ćete nalaziti na adres i null. I sad kako ona izgleda, reklj smo svaka funkcija i svaka metoda, kada se generiša kod z nju, treba da počne instrukcijem ENTER. Instrukcija ENTER, potretit ćemo se sada svega što smo pričali na predkonom času, dakle, instrukcija ENTER će ovako izgledat ću konkretno slučili, biće ENTER 2-2, i reklj smo ta instrukcija, zauzima pored ovog koda instrukcija ENTER koji zauzima 1 byte, zauzima još 2 dodatna byte iza, a tada 2 dodatna byte treba da nam kažu koliko to je argumenta, ova nekakva metoda ili funkcija ima, to je ovaj prvi argument, i drugi argument treba da nam kažu koliko ukupno i argumenta i lokalnih promeljivih posloji u unutar te nekakve metode ili funkcija. E sad, u konkretnom slučaju ovde kod mene, stoji ENTER 2-2, zbog čega, pa ne smemo da zaborajemo tako da sada vidite ovde kod mene, stoji ga već krećem do učitavom u load nula, ovo load nula se neće odnositi na ovo i nego će se odnositi na na iskriveni argument disc koji sam već pominjala na prekornom slučaju. Kako da pazite samo u koliko se radi o metodama nekakve klase, bez obzira što vidite samo jedan argument, uvek se podrozumeva do ovde kao nuti argument, postoji argument disc koji je tipo, svarite nekakve naše klase. ENTER 2-2 Dakle, 1 byte zuzima ovo, 1 byte zuzima ovo, 1 byte zuzima ovo, ukupno 3 byte, slučajće instrukcija na ozice na address hit 3. I sad, tom instrukcijem tu, ja treba sada ovom polju text ovde da postajem u tako vrednost i. Tu piše text i jednako i, međutim, repismo da za postavljenje u tako vrednosti poljima nekakve klase koristimo na instrukcije, to je da postavljenje i dohvatanje i koristimo instrukcije get filled i put filled. Međutim, ovde, ono što treba da primetimo samo jeste da ovo text i jednako i je isto kao da smo ovde napisali, disc.txt je jednako i. Narodno, to disc tačka ne morate pisati, čak njim u mikrojavi ovde, ali se to podrozumela. Tako da ja, ukoliko želim da smestim nešto u polje nekakog objekta, reklismo da treba na nekakav expression stack da učitam address u togo objekta i vrednost koju smestam, a zatip pozivam instrukciju put filled i samo kažem u koje poljete klasije, ja želim da smestim tu nekakog vrednost. Addressa o objekta u koji smestam nešto se nalazi, o tako to u svaru koji je to objekat stoje objekat disc i on je u svaru taj neka nullti argument, njegova addressa u tom nulltom argumentu i to radimo pomoću o oga load nulla, dakle to nam je u svari taj disc. Zatim reklismo da bi smo pozvali put filled, treba nakon addressa objekta da smestimo vrednost koja se otaku stavlja u taj objekat, a to je ovo i, dakle ovo je naš argument ovde, on se sadal tako dis na nulltoj poziciji, on se nalazi na poziciji broji 1. Tako da s ovim load 1 otaku učitavamo i to i na stack i primetite da ovi instrukcije reklismo da imamo skracine variante load nulla i load 1, dakle ovo je kod te instrukcije i to zuzima samo jedan byte tako da bi te ovde nakon trojke sledilo 4 i sada ću slediti instrukcije na addressi broji 5. E, dalje, reklismo ako smo smestili addressu, ako smo smestili vrednost, premismo da pozvalimo instrukciju put filled i to instrukciju put filled i za tako ovo i za prvog byte, toh zato i za koda te instrukcije, kod otaku put filled treba da smestimo u svaru još dva byte i to kojima ćemo reći, koji je to po redu polje unutar te nekakme naše klasi, toh zato unutar to objektav koji mi želimo da upišamo tu nekakvu vrednost. Mi upisamo nešto, ovo teks ovde, međutim, početit ćemo se još jednom kao nullto polje, svakog objekta neke klasi ujev će se pojaviti onej neka pokazivač na tabelu virtualni funkcije koji ćemo baš danas i videti u ovom zadatku ovde, premo, fuzi i kako se postavlja, ali za sada samo da će sva polje u svaru je biti indexirano od jedan, jer nulltu oziciju čuvamo, ali tako za taj nekakav pokazivač. Tako da kažemo kako ga put pil do jedan i ovdje vam je naznačeno da je tol tako nullto polje rezervis. E sad, to je celokupan kod ove metode, ovde, dakle teks jedna koji je jedino što smo imali ovdje jedinu naredbu, tako da reći smo na kraju svakje metode i funkcije, slede dve nekakve alzako instrukcije koje obavezno generišama, to su exit i return i tamo smo na predkonom času i pokazali šta te dve instrukcije rade, tako u slučaju samo i zapamčite da je tol tako obavezno i do na kraju. Kao što na počet po obavezno imamo enter, tako na kraju obavezno imamo exit i return. I primjetite ove, dakle put pil je zauzela jedan byte i za toga su sledila dva byte ove, dakle to su u kopno 3.
 3 byte s leči instrukcija na adresi 8, exit i return nemaj nika koja te operande, tako da zuzimaju samo po 1 byte, tako samo taj nekako pod instrukcije. Ako je return na adresi broj 9, znači da će se slijedeća atak o instrukcije koji generisama nalaziti na adresi broj 10, a ovdje što treba otvoriti, to je celokup na ova metoda m. Tako da ja, kada pređem na sada generisanje koda za ovu metodu f, odmah sredim mogu dobrobeležim, da se ta metoda f nalazi na adresi 10 u toj kod seksiji tam, to je samogde smešnamo stakla taj kod koji generiša. Nastavljemo dalje, dakle ta metoda f, kuliko ima argumenata, pa 5 isto kao i ovog ore, al tako 2, 2, tako da će na adresi 10 biti isto ova instrukcija enter 2, 2, ako pogledate ona nema, al tako prazno je te ovo, nismo sa te li ovdje je komplik, kojemo, kako izgledaju, kako izgledaju te ovo metode, šta se u njemu može desiti, to smo pokazali u zadatku 1, 2 i 3, ovdje sam akcena, sada vidimo, al tako, kako ćemo obaviti ovaj deos vrstvar klasana. Dakle, odmah ovdje izvršavam exit return i, al tako, na adresi 14 nalazi kraj, svarite naše fungje f. Sada, pokoliko smo završili, da fungcijam f, sve jeći kod koji ovdje potrebno generisati je u svariji ova metoda m. Dje ćete se nalaziti ta metoda m, pa ako je na 14, al tako, bilo ovo return, to znači, da ćete se ona nalaziti sada na adresi 15. Ako se nalazi na adresi 15, možemo odmog da krenu miniju da generišamo. Dakle, šta je njoj sada potrebno, ispreko je ovima gore, mi u stvari, radimo redefiniciju te metode m, tako da u vlozaku, u tu metodu će biti isprečitno ovde, jedino što bi moglo da se promenije, je ste da ova metoda m, sad, na primjero, izvedenoj klasiji, nesme da meni, okoliko radite redefiniciju, nesme da meni broje argumentata, ali bi moglo da doda na primjero neke lokalne promenjive. Tako da na primjero, ovo i drugi broj bi moglo da se promenije. Ona ispratamo, nekde vam je verovatno i naglašano, u tekstu zadatka prorančili, projekranca zadatka, naravno, Naglašano je da mikrojavan je podržavao tako preklapanje imena ovih naših metoda, tako da ili se radio redefiniciji ili ćemo reći da je to nešto grešak. Tako nije doznano da sad imate nekako u klasiji dve metode m, koje se sad razlikuji po broj argumenta. Tako nešto, tako, u batilijeno ogranjicenju da to ne podržavao. Nakon aoga Enter 2 2, ako pogledajte šta je telo sad ove metode m, ona sad ove poziva funkciju f i prostređaju kao argument ovo i. Ovdje ćemo sad odmah na ovom mestu videti kako zapravo izgleda sad to pozivanje, to je polimorčno pozivanje nekakve metode, ali kasnije ću to detaljno objasniti, ali sad moramo tako da izgledajte ovo. Biće nam jasnije kada dođemo posled dole u meni, kada budemo videli kako se to u carija alocira, nekakav objekad pa onda tako postavlja ovo i njegu pokazivašan te delu virtilni funkcije izlično. Tako slučaj ja sam napretkanom času pokazal kako se poziva ona instrukcija u njegu u prirčovo, sad ćemo to vidjeti i ovdje u primer. E sad, kada vidite da pozivate u stvari nekakvom metodu, kao što na primer ova metoda ovde f, ono što morate odmah da se setite, je ono što je trebalo da se setite kada se gjenisali kodzou metodu f, je se da se kao nuti argument obavljazno javljate od is. E sad, od is se neće pojaviti nekom magijom tu, nego je potrebno da ga vi zapravo ubacite tu kada budete pozivali tu metodu f. Ove ako pogledajte šta je u stvari dis ovdje, pa pozivam f od is, a ako pogledajte to je isto kao da ste nepisali ovdje dis.f od is. Ako da u stvari vi ovdje nuti argument ove metode n, to od is koristite kao dis i zapoziv ovaj funkcije ovde f. I otak u učitalom, o prvo to load nula i to je ta argument dis. Zato je ono se nalazi kao skriveni argument, ovdje se indekso nula u ofiru metode n. E sad, nakon toga argumenta dis, znači prvo što radimo kada pozivamo nekakvą metodu, e isto važi za funkcije, je ste da treba da spakvamo na onaj expression stack prenjen argument. Dakle učitali smo argument dis, dale ova funkcija f ima neki argument, ima to je ovo i, tako da o tako moramo i to i da učitamo na stack i to radimo po moću instrukcijo tako load 1. Ajmo da ne žurim nogo, dakle load 1 će učitati to nekako i. A ako su sada argumenti c koji su nam potrebni za poziv nekakvom metode, spremni na stacku, već je što treba da uradimo, je ste da na onaj naša expression stack stavimo adresu tabele virtualni funkcija za to u nekakvog klasu, za koju metodu sada posivanu. To je staj konkreta objekat mora da ima u sebi, rekli smo u onom null ton polju, pokazivač na tabelu virtualni funkcija. Ako pogleda to ovde gore, vidite da smo to ovako i naznačili. Ajmo sad mi taj pokazivač na tabelu virtualni funkcija, treba da učitamo na onaj expression stack, nakon argumentata, a prepozivanu oni instrukciji i invokeviru. Ideo sada? Ako se radi, izvijente. Ašto? Samo da vas pitanu, da limate nekde prezentaciju po koju radite, pošto meni z neku razloga se da vas screen share ne vidi, korim tu prezentaciju pa da pratim, jer ovako, tamo vas čujem ništa ne mogu da... Ali imate nekdo okačenu prezentaciju, pošto nizim našanom sajtu? Ne imam joj okačenu, ili ima još nako problema, možda da ne vidi prezentaciji i vidi... Ovom drugi nisu, kod nek sam pijet, da oni još imali samo izgleda meni, zna kogu radila razloga, nije će poziviti se, okimate nekdo okačenu prezentaciju, ako ne mi ništa. Ako moš da mi se javite na team, pa ću vam poslati private prezentaciju. Vražem, vražem. Avo ja se izvinjam, ostalima, ajmo samo da bi kolega koji nam se ovodanas pri druži ovde mogao sa nama ovo da prati, evo samo da ja njemu prosledim prezentaciju. Ajte, prvno da prano samo možda do ovoga problemu, samo trenutak. Ajde da probamo ovako, pošto sam danas koristio opciju da ševravim samo da tako prozor ste prezentacije, da li ćete videti, ako uradim ov. Ja vidi kolegamo ekra. E, ne, sam vidim. Ne, ja vidi, to onda ako sad ovo upalim. Ne, sad vidim, koji vam? E, onda lakšam, ne mi je tako. Dobro, evo izvinjam, se sada ovada sam se ovdana sam povstredili, samo da imam dok se mi ja stala. Dobro, da smo došli otakom. Dobro, dakle, pakove lih margumenti na stek? I reti smo da nam treba to nullto polje, otakom taj pokazivaršna tabela u virtualni funkcija, da treba njega sad da učitamo na taj expression stack. Kako dofatemo njega? Dakle treba da dofatimo nullto polje to pokazivacu disk. Pa onda što aradimo? Get field nulla, otakom. To get field nulla, otom polju nulla, tog al tako našeg objekta će se nalaziti zapravo taj pokazivaršna tabela u virtualni funkcija. A kažem, opet, ja ću posljati u menu i prikazati kako ćemo mi to zapravo i postaviti. Neće se to samo ni otakom ni postaviti, nego će to biti u svariji nažno, dakle da mi odradimo taj del poslj. Ne, ajmo sada ovako dajte. Ano, trenutak, dobro. Ako imamo otakom i argumente, zapozivte nekakve metode i taj pokazivaršna tabela u virtualni funkcija na express na steku, onda smo spremni da pozavimo instrukciju u invoke u určole i njoj smo rekli da prosleđujemo naziv funkcije koji pozivamo, a to je funkcija F. Dakle da ova funkcija ovdje se sada zove na primer fun, vi biste zapravo ovde stavili karakter F, pa karakter U, pa karakter N i onda tako kada izvređete se karakter i kako se zove svarita nekada pro funkcija, onda ide na kraju, otakom ovo minus 1 da je tu taj nazivate F ovo funkciji koji hoćete da pozove. E, sada, koliko će ovo da zove mesta, ide sve vreme, ovde ja se strane pratim jer ovi će nam sada biti važne ovdje adrese, zove sve instrukcije da sad smo videli, ovo evo kvirče okoliko zuzima mesta. Pa ako pogledamo sad, jedan baj će zuzimati koo dove instrukcije, ovdje je karakter F i onda će zuzimati celu jednu reša, to je otakor 4 bita i ovo minus 1 ovdje će zauzeti istot, tako dovolo sve ovde zuzimo okoliko puno 9 bitova istveće, to imamo, tako to je exitiriturnic koji se pojavite na adresi 33 i 35. Dakle, ide, ovde sad ja sam to prikazalo, ali ide, kastnije u menu, se možemo fokutirati malo više na ovaj pozival, tako i kako su svariti osvera. Za sad, ide smo do adresi 33, tu smo zovršili, tako da nastavak ide od adrese 35. Šta se nalaze na adrese 35? Pa sledać je otakor, sledeći kod koji treba da generišamo to funkcija otakor fun ovde, zapam ti ćemo izdanju da je ona sad, tako na nekoj tamo adresi 35, tako izlanjeno teli. Ona njel tako malo jednostavnija, dakle ovde sad imamo, i ako ona ima argument, ovde sad da pogledajte enter 1 1, zato što nema otakor onog skrivenog disk, to je nekako globalna funkcija koja se zove fun, ne pripada nikakvog klasi, tako da disk nema samo jedan argument. Sa radi monitor te funkcije, kažemo argument, da je naš, treba da pomnožimo sam, da go padriramo u svariji, nači učitamo ga jedno na steku, učitamo ga drugi put na steku, kada imamo rg i arg na steku, pozivamo instrukciju MULD, instrukcija MULD će otakor izluta tvoj ostaviti na istom tome expressom steku, i to je ona što nam je treba, to je način kako su svariji vraće u argumenti iz nekakve funkcije, samo ih ostavimo na expressom steku, kastnije ćemo u menu vidjetil, tako da tu zapravo vredno ćemo minan na neki način tipoku. Narodno, ovdje exit i return, tako, i to je te loko na ta naša funkcija. E, način, što svi tiče globalni funkcija, samo jedino što razvijek u odnoštenu što vam pokazano na predkonji čas, jeste da sada ovdje ćemo imati ovol, tako enter i exit i return, to nismo videli, te loko pa nova ideja, ovako, računan je izdar za to, sve viš pokazano na predkonu. I ovde sada ovo zimo dojo jednog o tako zanimljimo u momentu, a to je momenta da mi sada treba da pređemo na ovaj main, ovdje. I četim, prej neko što pređemo na main, ono što ja preporucuje, nije obvezno, sami ćete izabrati, ukliko budete radili projekt na nivo c, kako ćete to raditi, alaj, o čista preporuka. I ja ću za datima, ovdje, tako, to raditi, tako, opet, kažem, na ispitu, vi isto možete izabratiti kako gođelite, samo da to radi. A što će ja zapravo ovde sada raditi, u onočne od kog ovde pre maina, ja ću ubaciti kod, koji će zapravo izgenerisati tabele virtualni funkcija kod tu, koji radi inicializacije tih tabele virtualni funkcija, treba da se izvaši preo...
 prvih uvijednog našeg maina. Dakle, prema što se pokrenili program, vi treba di inicijali zvijete svete svoje klaset tamo i njihove tabele, pa te konda pokrećite ovoj main. I onda vam je mnogo lakše da pred tako generisanje koda za ovu funciju main ubacite u stvari taj kod koji zapravo tako generiši tabelu virconni funkcija i onda zapravo se tako program samo dalje prirodno nastavi na ovaj vaš main. Znači da imam što je zapravo sad ozirati. Dakle, prvih ćemo generisati od tako kod koji će tamo nemožete u to i kod oblasti praviti tabelu virconni funkcija za klasu tekal. Odi sad treba da sad razgranićemo tamo prošliča svoj pričali u različitim imorijskim oblastima. Pa sad, meni treba neka kod da na neki način. U ovnu oblastu tamo static data gde smo reklji da će se nalaziti globalne promenljive, kao što je napr. ovog ore koja imamo u programu x i y. Treba mi način da u tolj tako imorijsku oblastu, da su to static data, smestim sve kodatke od svim metodama za sve moje klasi. Dakle, za sve klase koje imam, treba da smestim kodatke koje su to metode koje imam i na kojima adresama se one nalaze. I to je zapravo u svariji ta nekako vaša tabela virconni funkcija. E sad, gde ja sad smeštam, na pr. ovog za klasu tekal? Vida ćemo kasnije sad ako smeštam, ali me upr. odvidimo gde. Reklismo da su ono oblast static data sastoji u tako od reći nekakvih telih koje se samo indeksiraju počer si od 0. E sad ako se te reći indeksiraju počer si od 0 i u koliko tu ja treba da ugradim sad ovo tabelu virconni funkcija, odakle će krenuti ta tabela virconni funkcija za klasu tekal? Pa pogljavajte, dakle ovo x će biti il tako na 0, ovo y će biti na 1, tako da će tabela virconni funkcija za klasu tekal biti u stvari na od indexa 2, pa sad vidjet ćemo tako koliko ćemo na mesta tu zaozima. Potred će ćemo ćeš jednom, dakle, ove gore globalne promeljive koristimo tako što kažemo get static ili put static, ostane instrupcije koje se koriste. Tako da iste instrukcije ću sad da kor�iti i da generišem to v nekakvu tabelu virconni funkcija. I to od odako adrese 2 unutar te nekakve naša static data oblastne. Šta je zva pravo sad da to radil? Pa krenemo redomo ovako, zapram vrthy lismo da od, tako, indexa 2 u to i oblasti static data se nalazi tabela virconni funkcija klasu tekal, i onda kažemo redom. Vama ja generišem kod i uspod pričom što se tu dašala. Dakle, kažem, konc 109-ta konc 109 nije ništa drugo nego aski kod u tako ovog našeg slova m. Zašlo slovo m, zato što hoću da kažem da ova klasa t kalk, či je al tako ta belaviptonni funkcija tu nekde sada kreće, njivo sada generišemo, ona ima nekaku metodu koja se zove m. I onda kažem to tu u baci put statik na dva, da tako, košto krećemo tako od dvojki. E sad, da se ovo metode ode zove druga čije, da se zove m, e, ja bih onda ovde sad u baci jednu konstantu koja bih repla da tu sada ide slovo e, pa na to, na put statik 3. I ovako, redom sada ređem naziv te svoje metode u ovol tako statik data oblast ponući ovih instrukcija put statika. Kada dođem do kraja, kao što sada već je sann, u baci minus 1. Dakle, vrednost minus 1 će mi uznočavati da sam došla do kraja naziva te jedne metode te svoje klase. I to minus 1 ovdak u bacu uem, sada je redom, bređete, dakle, dva, tri, če tri, sad ćemo to pakovati u tu statik data oblast. Padažem put statik 3 minus 1. Nakon što se spakovali sve karakteri koji određuju naziv te metode i u bacili to minus 1, sredba sada da kažete na kojoj adresi se ta metoda nalazi. I ako pogledate za klasu t-calk metoda m, nalazi se na adresi nula, tako da ću reći konc nula, se otvario tako ta adresa njena i postavljam na sleditve lokacije, opoje lokacija set. E, nakon toga, nakon što se spakovali jednu metodu, pakujete dalje i sledeću metodu. Dakle, sledeću metodu, komutorove klasići biti metoda f, tako da kažem, konc, 100, 200 je karakter f, sadžem, spako i na odako sada redom, vidite, 2, 3, 4, 5, oni će ići redom, će se rećati ovdje, spako i to na adresu 5. Zatim, pošto je kraj naziva odako te nekatno metode tu, samo se zove odako f, pakvo imamo opet minus 1, da naznačimo da je došlo do kraja, to ide na sledeću lokacije na 6. I sada treba da kažem, pošto sam odako spakovali naziv, i ovo minus 1, gdje se nalazi ta metoda f, naoče se nalazi kao što vidite ovdje na adresi, 10, tako da kažem, konstanta 10, njog spakuju tako na sledeću lokacije, to je lokacija 7. Dakle, danes je tabela virtualni funkcija šta je zapravo u stvari, to je samo jedan segment, ono i statik data oblasti, i u tom segmentu mi redom pakvo imamo naziv na metode, dakle karakter je jedan po jedan, da dođemo do kraja naziva, stavimo minus 1 i kažemo gdje se nalazi ta metoda. Nakon što spakojemo sve metode neke klasi koji imamo, kao što sam ja sada došao do kraja za ovu klasu p-kalk, ubacujemo konstantu minus 2, i tom konstantu minus 2 označavamo da je tu kraj tabela virtualni funkcija za tu nekaku klasu, i njog stavljemo tako sada na adresu os. Kako se kasnije vrši u stvari te neki polimor sam povziv, vidjet ćemo da su stvari zapravo koristi ovo. Dakle, vi kada kasnije pozovete nekaku metodu, naprim. se zove n, i kažete da tako dnje na tabela virtualni funkcija za taj nekakav objekata je na ozina adresi 2, šta vi u stvari radite? Rozite kroz onu statik data oblat i tražite da li nekada postoji metode koja se zove samo n. Ako postoji, citate od atle koja adresa gdje se na metode nalazi i skačete na tu adresu. Ako dođete do ovoga minus 2 ovde, zaključujete da se doši do kraja te tabela virtualni funkcija i da tam nekakva klasa to je taj objekat ne možete pozatio u stari tu nekakvu metodu u tako zataj neki objekat, a ona napim. nine postoji, to bi bila nekakva grešak. E, pogledate, sad izgenericili smo tako tu tabela virtualni funkcija za klasu taj kalk i ona kreće od dvojki. Dokle smo stigli, stigli smo do osmice tako da slijeća vrednost koja bi su bacivala, te su baciti na al tako adresu 9. To znači da ja sada kada krenem slijeću klasu, a to je klasa a taj kalk i odmuzanju za beležim da sada nije na tabela virtualni funkcija će se nalaziti od atresi 9, to jest od indexa 9 u noj oblasti statik data. Tako generišam, monijenu tabela virtualni funkcija napotpuno isti način. I sad ja neću prikazivati jednu po jednu, to jest jednu po jednu ovo instrukciju, kako generišam. Zašto? Zato što ona klasa a taj kalk će imati istom metodu m i imaći istom metodu f. Dakle, postruktura ovoga ovdje će biti ista, tako da ću samo sa strane prikazati istol, tako taj kod, kako će izgledati. Narodno, ako pogledate, samo se meni ovo da ovo išlo od adrese 2, 3, 4, 5, 4, 7, 8, ovo dalje nastavljio tako da adrese 9, 10, 2 na dalje, otakvo, da smešnam u onu statik data oblast. A šta smeštam? Pogledate gore, dakle metoda m, ide minus 1. I sad pazite ovdje gdje se nalazi metoda m za klasu at kalk, nalazi se na adresi 15. Tako da ovdje pogledate levo, slavim slojima za klasu at kalk, smo rekli da se metoda m nalazi na adresi nula, a crvenim slojim ovdje sad da se kažemo, da se adresa metode m za klasu at kalk nalazi na 15. I to je u stvari tada kažemo nekakva magija o pozavljenje i kako vi zapravo za neki objekt na kraju odredite, koji metodu je potrebno pozvatiti. Tako da što, kastnije, zna primjer da ovaj objekt ovde objeju, u koliko za njega, ako ga inicijali, znamo sa nju at kalk, kao što smo u ovom primjeru ovde, mi ćemo njemu postaviti u null topolje da se njegola tabela virtualni funkcija nalazi da adresi 9. I kada vam bude traži da pozove metodu m, mi ćemo ovde dođi, nacit ćemo metodu m i zaključitimo da treba pozvatiti metodu koja se nalazi na adresi 15. Međutimo, koliko taj objekt ka tiniicijali zvijete sa nju t kalk, njemu će ovdje u null topolju stajati dvojka za pokazivaš na tabelu virtualni funkcija i kada budete tam u toj tabeli tražiti metodu m, zaključite se ta adresa metode m nalazi, a to je za metoda m smešta na ovdje adresi nula. I to je u stvari kako tako taj polimafizom reći. Ako pogledate se se tiče funkcije f, naravno i za kva su a t kalk moramo navesti u funkciju f, jer je ona nasleđuja, tako da ove naša klas je bolja osnovne. Ako pogledate, isto smo genericili kod za f, međutim, koja je adresa za a t kalk f, 10. Isto kao što je 10 iz ovstunnu klasu. Dakle, objekt klasi će imati vrednost 10 i ovdje potpunno nebitno dolst ovo obje i onda alocirali da pokazuje na a t kalki ili na t kalk, ako pozavete f i u jednom i drugom šlučnice sklače na adrešu 10, da se zapravo nalazi ta metoda f. Dakle, ovo je del koda koji je potrebno da u projektu ljudi koji budu radili nivod c, da je odako izgenerišu. Ovo je, da morate vina kraju kad prođete kroz sve klase, da ovako nekakva koda izgenerišu i da se popunete nekakve tabele. Na ispitu, naravno, okoliko dobijete zadatak neki koji u sebi bude imao klasi i metode, ovako nećemo naravno tražiti od vas da kucate ovaj kod koji im su tako inicijali izviju te tabele. Dakle, to ovaj k magla se ima da nije potrebno uopšte pisati. E sada ako imamo te tabele, zapantili smo ovdje, odako gdje se nalaze te tabele, virtualni funkcija za ove klase, Kako ćemo sada u Main? Šta se sada dešava sa Main? Kako je Main, sada nasadete tamo nekdje meke adrese 139, jer smo mnogo memorijali od tako dosta kod da smo potrošili na ovo generisanje tabela virtualni funkcija. Od adrese 139 kažemo Main enter 0 1. Dakle, Main nema argumente tako da ide ovde 0, ali ima jednu lokalnu premenljivu tako da je ovdje ovdje ovo jedinje. Ulazite o tako Main funkciju, kako i u svaku drugu funkciju. Ja imam sad prvo dvimo kako izgloba ovo što povazili nekakve globalne funkcije. Dakle šta treba dobro dvradića? Argument je te funkcije da spakujete na stack. Ako je globalna funkcija, ono ga skrivenog disk na radno nemna, tako da kažete samo koncij 3 i pozivate funkciju fund. Kako pozivamo funkciju? Rekli smo ako su argumenti spremljene na ekspresno stack, u samo se nakon njih pozivanja instrukcija call. Instrukcija call se daje pomero i odnosno na tek u cipisi. Treba da skočete na adresu 35, zato sam ovdje zapam tje ovdje se malo fund, dakle na 35, a trenutno ste na adresi 143, dakle 35-143 treba mi pomere i minus 108, da bih došao tako da kodak desne nalazi ova funkcija fund. Tako da ovdje ide call minus 108 i ovdje se tu sada prebacujete na funkciju fund. Nakon što se vratite, a vratite se ovdje od adresi 146, rekli smo ovaj rezultat, ovo je naše funkcije fund, je ostavljen veći na onom ekspresnom stacku, tako da sam se tu veći nalazi, treba samo da ga iskoristimo, sad želim odvradićimo se nim. Oddje smo rekli, treba da smestimo,
 u toho u ovo našu x, to x je tako neka pa globalna promenjiva, tako da koristimo u tako ovoput statik nula. I to je tako ovde posljednja instrukcija. Ovo je samo da naglasim, dakle jednu svartu je isto da znate, dakle ovo fun ovde bez obzira, što naprimer biste mogli da ga iskoristite i bez da dodeljete ovo x, morate nekako da skinete taj tu vrednost njegovog povratnost, sa onog ispresnog steka. Tako da je zato ovde pozvali samo fun od 4, mislim da se po morze čak je pokazano pretkodno plastu, da ne piše i c jednogu fun od 3, nego da piše samo fun od 3, to tako funkcija će ostaviti svoju vrednost, tako da i za ovo ga call, bista onda ugradili jednu ručnu instrukciju u tako pop, koja vam biste v svariji skinuli tu vrednost, nekako sam svarteka. Ovo dolazimo od ovog ključnog momentu ovog četvrtaog zadatka, a to je kako sada pravimo ovaj objikat ovo. Dakle, tađemo, obje je jednogu nu atk. Da je uklisimo da bi se napreve neki objikat, koristimo instrukciju u nju i njoj kažemo koliko biteva je potrebno na nekom hipu tamo, tako rezervis. Koliko biteva nam treba, pa gledamo koliko polja ima ova klasa AT-calc, to je samo ovo jedno polje ovdje teks, plus ne zaboravljamo takvo nikako da imamo i ovoj pokazivaršnata belu virčan i funkcija kao nullto polje, tako da 4 plus 4 uklupno 8 bitevam je potrebno ide instrukcija nu os. Nakon toga, ovo nu osam će vam braciti adres na hipu, gde se nalazi taj alocirani prostor i mi to treba da smestimo u ovu našu ovdje lokalnu promeljivu koja je ovdje tako sa indepstom nulla, dakle stor nulla radi. Ali nakon što smestite adres u gde se to nalazi tamo, treba da inicializujete odmah za taj objikat koji ste alocirali njegovom nullto polje. Nullto polje togo objekta treba da pokazu da je na tabelu virčan i funkcija za tu klasu el tako koje je zapravo alocirana. Dakle, ovdje alocirano tekalk ili AT-calc, koji je el tako taj nekakav dinamički tip sad je tip i naravno ovog gore tekalk. Šta onda ja zapravo radim? A koji u nullto polje da upišem o tako taj pokazivač da bi smo nešto upisali, rektismo da na steku treba opišeno dokonogim da se nalazi adres al objekta, to je alo tako ovo naše load nulla, dakle ovo objije, treba da se nalazi vrednost koji upisujemo i zatim radimo putfield i kažemo u kojoj polje upisujemo. Kojih vrednost ja želim da upišem ovdje? Košto se radi u klasi AT-calc, dakle alociranje objikat klasi AT-calc i ja želim da upišem da zako ovog 9 kod. Dakle 9 je u stvari adres da tabela virtuoli funkcija za tu klasu, tako da kažem ovdje konc 9 i kažem onda putfield nulla. To tu al tako će u stvari nehtiti u nullto polje od tako ovog našeg objika ovdje tabelu virtuoli funkcija, dva klasu AT-calc. I sad ako vidite ovdje, dakle ja sam to ovom objiktu objije postavio ton nullto polje na 9, a gledajte sad kada budemo pozivali ovu metodu m dole šta se desava. Dakle pozivamo metodu m i sada treba ili tako za ovaj objikat ovdje objije. Šta nije oj treba da bude? Prvo pakvamo sada argumente. Ako pakvamo argumente, prvo treba da smestimo tako argument dis. Argument dis će biti u stvari load nulla. To je ovdje objije. Dakle to je dis u toj metodi. Zadimo tako pakvamo sleći argument, to je ova četvorka. Spakovali smo sve argumente. Sada treba na ekspresnost, ekko još da se nalazi pokazivač na tabelu virtuoli funkcija za taj objikat koji ili tako pozivamo. Dakle radimo load nulla i u stvari radimo get field nulla. Dakle dok vratate u stvari null to polja to je u stvari taj nekakapokazivač na tabelu virtuoli funkcija. Ako imate sve argumente, dakle ovdje ovod dis imamo četvorku, imate tako pokazivač na tabelu virtuoli funkcija sve vam je to spakovala na stack. Premisle tako onda da izvršite ono instrukciju i imu u piščov. Izvršamo tako tu instrukciju, ovdje ide, tako zove se metoda m i za toga minus 1. Oko da, to vidite. Da, lociramo nekakakav objikat. Dakle, ovavno mi ručno postavimo taj pokazivač na tabelu virtuoli funkcija a kasnije samo kada pozivate ovo inluvku piču o tako koristite u stvari. Koristite tu u vrenu s koju se spakovala da je to ova 9. Dakle, ova 9 kada u stvari ključni moment, kak u stvari polimorfizom radi. Da smo ovdje stavili dvojku, što bi bila tabela virtuoli funkcija klaset T-calke. Kada u stvari pozivamo ovdje m se pozivala ovada gore metoda, a ne, ovada ovdje dole. Da ovdje imate samo exeteritorn i time smo došli ovdje do kraju ovog telog našeg propova. Nakon ovoga svega trebalo bi sad na nam iliasno kako ovo se radi, i evo imamo sad neko pitanje ili možemo da nastavljamo dajte. Dakle, ovajime smo završili celokupnu tu obložu, što se tiče generisanja koda i ovim ovdje sad za datkom, ako dalje pitanje nikakvih uvezi se ovim nema, ovim ovdje sam ja završio i celokupno gradivo koje vam je potrebno za praje. Dakle, s koleginecama imam se tamo radili prve dve faze, sam nosno, da radili druge dve faze, što je ona neka pasematička analiza kroz ono naša tabelu sybola i tako ne naša atributima u translata negramatike, i ovdje tako kroz generisanje koda tu četvog faza.
