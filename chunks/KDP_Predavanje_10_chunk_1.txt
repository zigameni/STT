 Dovor dan, dobrodošli napredavanje na predmetu konkurentno i distribuirano programiranje. Izvimito opet za ovdje kašnjenje oko početka čas. Tema, ovog sad što radimo i što ćemo raditi na redne dve nedilje distribuirano programiranje. Šta beše distribuirano programiranje? Eli to mora na jednom računaru, nesme na jednom računaru, mora na više računara, a kod distribuirano programiranja? Uopšte nije pitanje, da li se izvršava na jednom računaru ili na više računara, nego na koji način se uspostavlja komunikacija izneđu onih koji komuniciraju. Dali podstoji delje na memoria kroz koji komuniciraju ili komuniciraju razmenom poruk? To su dva potpuno odvojena načina komunikacije. A kod distribuiranoj programiranja može se desiti da su svi procesi na istom računaru. Na primer kada vi raditi razvoj neki web aplikacije, a vi podignete na lokal hostu web server i onda pristupate i to razvijate. I stupodignete server base podataka na tom istom računaru. Oni su na istom računaru i web server, i server base podataka, i vaš aplikacija, i kome godi još da pristupate, i vaš debugger, vaš okruženje. Svi su na istom računaru. Ali način na koji oni komuniciraju nije koristit ći deljenu memori tog računara, nego razmenu poruka između tih računara. To je velika, velika razlika. Ono što smo radili prethodni put je, ajde da vidimo kako oni mogu biti povezani, kakva komunikacija može biti. Videli smo da komunikacija može biti synchrona i asinkrona. Nismo za sada razmatrali samo asinkronu komunikaciju, kod koje u naš komunikacijoni kanal možemo da upišemo poruku i zaboravimo na nju. Poruka će sigurno biti isporučena. Ko dobog ovde naših sistema mi ne razmatramo šta se desi ako poruka ne stane. To se razmatra možda na prednetima gde se obavlja fault tolerance, znači sistemi koji se odporne i na odkaza i postoji jedan konkurentni synchronizacijuni problem i tu, a on se naziva business in general problem, problem izantijski generala. Šta se radi ako neka poruka koja se pošalje može da se zagubi? Ovde kod nas poruke ne mogu da se zagube, poruke se garantovanu isporučujem barem za sada. I šta još imamo? Ako jedan te isti šalje više poruka, poruke će biti isporučene u onom redosledu kako su poslate. Ali to što sam, što sam rekao? Ako jedan šalje poruke, poruke će biti isporučene u onom redosledu kako su poslate. Ali ako više procesa šalje poruke u isti komunikacijoni kanal, odnosno u istopoštansko samnoče, mi blaje veze nemo da li kako se te poruke učešljavati u tom, u čestnih, u čestnih. Ako se se se se se zavisila u komunikacijonom kanalu, to je komunikacijoni kanal. Vi u suštini možete da zamislite kao jedan buffer kod producer-consumer-problema. A poruka će nekako, si jednog računara da otrči na drugi računar. Kako? Nemam pojma. Koristit će se neki od komunikacijonih protokola koji, pa to zavisi gdje je taj drugi, da li to ovšte drugi računar? Da ponaj mi ješ jednom, ovu ovšta je nemora da bude komunikacija na više računara i na primjer ako budete slušali prednet programiranje mobilnih uređaja. Tamo ćete vidjeti da komunikacija između nekih programa ne može da se obavlja, ako su na istom mobilnom uređaju. Da se obavlja razmenom poruka koristići nešto što se zove inter-process communication. Znači u suštini poruka se zapakuje i pošljajte se na isti način kao što mi sada šaljemo poruku, stavimo kome poruka namenjena i šta go od već treba da odde. A taj neko preozme poruku kako god znaju me. Prošli pod smo videli dva načina komunikacije. Prvi je bio koristići komunikacijone kanale gde je svaki proces mogu odima veći broj ulaznih i izlaznih kanala, da je to sada nekako dolazili i prolazili kroz sve te čorove. I onda smo videli da se to nazivaju filterske mreše. Videli smo nekoliko jednostavnih algoritama, primjer traženje maksimuma, minimuma neka vrednosti, sortiranje, neko gniza. Za to su pogodne ovakve mreše. Mreže mogu malo komplikovanje da se povežu, tako da one mogu da čine protočnu obradu da se neka malo služenija obrada tu obavlja. Primjer traženje prostih brojeva, množenje matrica ili nekakvih slič obrada slike. Može da se obavlja u takvim matricama, znači samo lepo pravimno napravite strukturu i u svakoj teraciji neko radi obradu nekog elementa, a oni drugi čvorovi u tom sistemu radi obradu nekog narednog elementa. Ali treba lepo da se osmislit topologije jedne takve mreše. Na vežbom, kad gudite obređivali deo, koji se bude odnosio na programski jezik CSP, viditećete jedan na način povezivanje o ovakvih filterskih procesa, a kad budete radili množenje matrica nekim vektorom koji dolazi. Znači, al to neki neprikidni vektor koji dolazi i treba da se u svakoj teraciji izbacipo jedan rezultat. Druga stvar koja smo mikranuli da razmatram prošli put, je klijen server architektura. Klijen server architektura, kde klijen tu put izakvih serveru, server nešto odradi i vrati odkovor. I ono što smo mi prošli put razmatrali, je bio server koji imao jednu operaciju, gde nešto treba da se odradi i klijen koji je slao zaakvih i prima odkovor. Klijen server ima jedan server i više klijenata. Veći broj klijenata može da uputi zaakvih. Da bih server znao kome treba da vrati odkovor, a onda unutar tog zaakteva mora da se naći i identifikator onoga koja zaakteva uputio. Na primjer, klijent taj taj uputio zaaktev taj taj. To mora da se sve lepo upakuje da bi otišlo da onu drugu stranu. Da bih server posle kada bude odgovara, znao aha, taj taj klijent mi uputio zaakte, znao, ja ću ima baš tom klijentu da posledim odko. A serveri se tako prave da oni u suštini imaju jedan port, jedan prikljčak, preko koga nešto osluškuju, jedan taj komunikacijonikan, preko kog primjev zaakteve koje kasnije mogu dobrađuju. Mi sad da želimo da vidimo, kako izgledaju ti serverski procesi, ako imaju veći broj zaakteva koje mogu dobrađuju i ako je te zaaktevi išli potrebno synchronizovati dodatno. Hodjemo da vidimo jedan poseban na način distribuiranog programiranja koji se naziva aktivni monitor. Prošli put smo napravili paralelu između semafora i razmene poroka. Kako možemo u ovim našim sistemima za razmeno poroka da naparimo nešto što bi simuliralo postojanje jednog semafora. Sada želimo da naparimo nešto što bi simuliralo postojanje jednog monitora. Jednog pasivnog objekta. Sada želimo to nekako da naparimo distribuiranog. Pošto je to distribuiranog krženje, ne možemo da pristupimo pasivnom objektu, nego moramo da pristupimo aktivnom objektu. Aktivni objekat je nit. Dobro, a sad ajde da naparimo to. Šta su neke osobine ovih naših aktivnih monitora koji ćemo razmatrati? Prvo osobina je da postoj jedan tok kontrole na serveru. Jedan tok kontrole znači nit ne sme da se zablokira. Tačka. Znači naša nit ne sme nikada da se zablokira osim ako ne možete da radi. Ako ne možete da radi, onda se zablokira dok ne primi neki narjedni posao koji treba da radi. Drugi blokiranja nema, niti smeda bude. I još jedna stvar koja ovdje postoji, postoji jedan ulazni kanal preko kog mi možemo da primimo podatke koje možemo da primimo i dobrađujemo na servereskoj strani. I to je to. Znači nekako sad ovo treba da iskoristimo, da razrešimo sve što nam je potrebno za synchronizacijom. Sad da vidimo, kako ćemo napraviti deopoddeo, kako ćemo napraviti stavne promenjive kojina ćemo imamo kod monitora. A to će biti lokalne promenjive ovog našeg serveriskog procesa. Ovo što se nekad zvalo poziv procedure. Poziv procedure lokalnoj objekt, to je vrlo jednostavno, znači stavite argumente na stek i pozovite što treba da se pozove. Ovde je to malo komplikovanije, jer je ovo ovde objekt, koji se nalazi sad potencijno na nekom drugom računaru. I kako se to realizuje, tako što se to upakuju po oroku i odradi se send request. Znači pošalje se poruka o noj drugoj strani, ta poruka treba da sadrži. Ko upućuje zahte? Šta je zahtev koji se traži i šta su argumenti zahteva? A onda će se server da to nešto smućka, da bi ova klijenska strana mogla da očekuje odgovor na poslati zahtev. A tako da vidite, ovo može da se realizuje vrlo...