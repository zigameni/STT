 U ovaj lekciju poznaćamo se sa ulogom funcjama i strukturom tabela simbola u kompajleru. Tabela simbola je mehanizam koji omugućava pamćenje različitih informacijama identifikatorima i deljenje tih informacijama među fazama kompajera. Svaki put kad se identifikator deklariši ili koristi, tabela simbola omugućava pristup prikupljanim informacijama o tom identifikatoru. Tabela simbola se najviše koristi do komprovere tipova, to je semanitivne analize, ali takođe i druge faze kompajlera koriste za pamćenje i kasnije preuzimanje informacija o tipovima, promenivama, procedurama i drugim programskim konstruktima. Kada se razmatrio identifikator i to jest i mena u programu, značenih pojmovi su OPSEG važenja i mena i pravila vidljivosti i mena u programu. OPSEG važenja i mena je del listinga programu u kojoj je neko ime vezana za određenu deklaraciju, a u vreme izvašavanja programu za određenu memorijsku lokaciju. Bilo koja linija koda sadrži se u nutar jedne programski jedinic, ili više programskih jedinica koje definiš o OPSEG važenja i mena. Većina savrevenih jezika je blokovski strukturirana, što znači da dozvoljava da OPSEG važenja i mena budu ugnješdeni jedan u drugu. Tekući OPSEG važenja i OPSEG važenja i mena definišan trenutnim najdubljim ugnježdenjem. Otvoreni OPSEG zi su tekući OPSEG važenja i svi OPSEG koje okružuju tekući u linju koda. Zatvoreni OPSEG su OPSEG važenja i mena definisajeni bilo kojemu programskom jedinicom koja ne okružuje posmatranu linju izgornog koda. Znači Tekući OPSEG važenja nije fiksar vece menja dinamički zavisno o tačke posmatranja. Ovo ova slika ilustruje ugnježdavanje OPSEG u odnosu na tekuću linju koda. Svaki OPSEG važenja i početak je pre Tekuća linje, a završetak posle Tekuća linje je otvorena. Najugnježdenje je od tih OPSEGA koji neposredno okružuje Tekuću linju za ove se Tekući OPSEG. OPSEZI koji se i početak i kraj nalaze ili oba pre ili oba posle Tekuća linje koda su zatvoreni OPSEZI. Pravila vidljivosti i mena definišu načina koja se neka određena upotreba imena povezuje sa nekom o definicija toga imena. Većina savravanji programskih jezika koristi statička pravila vidljivosti i mena koja su poznata svakom programmeru. I ovde ih opravljam ukratko. Prvo u bilo koje tački izvašao programa, pristuparša su samo imena deklarisana u Tekućem OPSEG uvaženje i u otvorenim OPSEZIMA važenja koji sa drža Tekući OPSEG važenje. Drugo ako ime deklarisan uviša od jednog OPSEGA važenje za interpretaciju tog imena koristi se deklaracija či je dubina najveća i najbliža tačke obraćenja. Tri nove deklaracije se zazvojavaju samo u Tekućem OPSEG uvaženje. Očigledna posljica ovih pravila je da pri zatvaranju nekog OPSEGA sve deklaracije zadate u njemu postaju nepristupačne. Prikazani primer pse u dokoda sadrži tri OPSEGA sa deklaracijama. Znači ova i spoljni big inend, ova i prvi ugneždeni gde su deklarisan xy i ova i drugi ugneždeni gde su deklarisani acima. U odnosu na Tekuću poziciju otvorenje spoljni OPSEG i drugi unutrašnji OPSEG. Na ovo mestu gde je Tekuća pozicija u programu su vidljiva sredneće imena acim znakovnog tipa i h il celobrenog tipa. Nisu vidljevi xy i ova i drugi unutrašnji OPSEGA. A iz ove ovde deklaracije sakriva ovo spoljno a koje nije vidljivo. Za razliku statičkih pravila vidljivosti gde su u vidomu listim programa može otkriti veza imena sa deklaracijom, postoje i dinamička pravila vidljivosti imena gde toki zvršavanja programa određuje vezivanje upotrebe promenjive sa deklaracijom. Koo dinamičkih pravila važi da se ime vezuje za najsvežiju aktivnu deklaraciju u remi izvršavanja programa. Ovo dinamička pravila nisu toliko rasprostranja na samo neki dialekti lispa, perla imaju ovakova pravila, svi ostali savreni programski jezici koriste statička pravila. Način mi se tim dinamičkim pravilim o kursu i njihovom realizacijom nećemo unopaviti, ali jevo jedan primer koji prosto i ustore koncept. Ovaj programski kod sadrži dve rališite deklaracije promenjive A. Jedna je globalna, a druga je lokalna za proceduru sekund. Procedura first sadrži upotrebu A u dodelu i postavlja se pitanje na koju deklaraciju se odnosi ta upotreba A. Izvršavanje programa daje različit rezultat u koliko prempostavimo dinamička pravila vidljivosti u odnosu na slučaj kada važe statička pravila vidljivosti. Šta se dešava ako su dinamička pravila vidljivosti? Znači izvršavanje počinje od glavnog programa dodela A1-2 odnosi se na globalno A, koje u tom trenutku jedino vidljivo u glavnom programu. Zatim se izvršava poziv sekund koji aktivira lokalno deklaraciju A i zatim sledi poziv first koji menja to lokalno A, koje je trenutno aktivno. Popovratku iz first to second, a zatim iz second u glavni program izvršava se, znači kada se vratimo u second još uvek je aktivno lokalno, međutim kada se vratimo i second u glavni program deaktivira se, znači lokalna deklaracija A i ostaje aktivna samo globalna deklaracija A, tako da ovaj ispis se odnosi na globalno A, koje nije bilo promenjenu ovom dodelom i zato se ispisuje dvojik. Šta se dešava u slučaju ove u običene statičke vidljivosti i mena, tu se već iz listinga programa vidi da je obraćanje iz procedure first ovom A, znači iz listinga program uvek se može utvrditi da je to spojno A, to jest globalno A, bez obdira znači u konkontekstu se poziva procedura first, tako da izvršavanje teče tako što prvo globalnom A dodelim o dva, zatim pozovemo proceduru second, u proceduri second se, naravno aktivira lokalna deklaracija, ali kada pozovemo first i dešava se dodale A jednako 1, znači ta dodala je fiksno vezana za globalno A, tako da se menja globalno A, kada se vratimo iz first to second, zatim se vratimo iz second u glavni program, ispisuje se znači u rednos globalno ga, koja je promenjena odnosne ispisuje se 1. Razmotri će bo rašte moguće variante intern organizacije tabele simbola kao strukture podataka, ili komnjenog dizainiranja implementacije, postoji nekoliko dizajnerskih alternativa i to u odnosu na obsege važenja imena i u odnosu na vrstu kolekcije koja se koristi za pamćenje imena u nutar jednog ili većeg broja obsega. Uz avisnosti od obsega važenja postoje dva pristupa realizaciji tabele simbola. Prvi pristup je da imamo pojedinačnu tabelu simbola za svaki obseg važenja, a drugi pristup je da za sve obsege važenja imamo jednu jedinstvenu tabelu simbola. Kod pojedinačni tabela simbola za svaki obseg važenja, stek mehanizam je pogodan za realizaciju. Pri otvaranju novog obsega stavljose tabela simbola na stek, a po zatvaranju obsega skida se sa steka. Sve što se u datom trenutku nalazi na steku su aktivna imena, to jest aktivne tabele simbola. U mestu cele tabele može se koristi samo ukazate na tabelu. U narjednoj prezentaciji imamo detaljno učiti ovu orientu sa lokalnim pojedinačnim tabelama simbola. Ove pristup ima pored toga što je pogodan izgodan za realizaciju i intuitivan neke nedostatke. Malo je sporije pretreživanje simbola. Ako želimo da pristupimo nekom ne lokalnom imenu, moramo pristupati veće broj tabela simbola, pogoto ako želimo da pristupimo nekom globalnom imenu. Preteživanje uve krene od tekućeg obsega i onda ako ne nađemo tekućegu, u obsegu prelazimo na prvi, okružujući, ako ne nađemo njemu prelazimo na sredneći i tako dalje. Drugo, ako su tabele realizovanje kao hešta-bele, za svaki obseg važenja se rezervljise memorijski prostar za tabelu simbola na duboku ugraždenju. Nimo ima malo imena, gubitak prostora je najveć, pošto hešta-bele imaju neki podrazumevanje za uzeće memorije bez obzirana to koliko smo realno simbola ubacili u nutra, međutim to njih je danas veliki problem, pošto rečunari imaju puno memorije. Ove probleme se najavljav ako su tabele organizovanje u vidu binarnog stabla, pošto binarno stablo nemataj overhead kao hešta-bele. Malo ćemo razmotriti ova i način organizacije, kada za sve obseg je koristimo jedinstvenu tabelu. Sva imena koja se pojava u toku prevođenju se smestaju naču jedinstvenu tabelu simbola, pošto se može desiti da uražiti u obsezima važenje i imamo ista imena. Svakom imenu se dodatno pridruži obseg važenja za koji je to ime definisano. Recimo, možemo imati posimno globalnu promenju, u koja broji obsege, način krementiramo je pri svakom otvaranju obsega, da bi svakom obsegu dodelili jedno začer identificator. Na slici je prikazan primer, gde je za tabelu simbola iskorišćenja heš funcija sa kolizio njim lancima. Sa stanu i što tabele simbola važni događa i tokom procesiranja programa su otvaranja obsega, zatvarađa obsega, deklarisanja identificatora i upotreba identificatora. Privkom otvaranja obsega, obseg u se dodelio i jedinstveni celobrojni index. Identificator se pririkom obrade deklaracije. Evo ovom primeru, nači imamo neke obsege i svaki obseg ima svoju deklaraciju. Znači identificator se pririkom obrade deklaracije.
 Hesh Funcion preslikava u index u hash tabeli i vezuje za početa klanca colinzje. Uz identifikator se pamti i index programmskog obsega u kome deklarisan različite deklaracije istog identifikatora, naprim. a iz prvog obsega, to je ova index 1, i iz drugog ugneždenog obsega, znači to je ovaj obseg i index 2 je u ovom primeru dodeljen, biće za beležen ug u okviru jednog istog lanca colizije, i to tako da se na početku lanca colizije nalazi deklaracije iz najugneždenijeg obsega. Pri korišćenju identifikatora, indexiranjem hash tabele, pristupa se odgovarajućem lancu colizije. Dovoljno je pretražiti lanc od početka do pojave prvog zapisa koji se drži tražen identifikator. Zauzdabilibismo se već na ovom manu, ne bi smo išli do ovoga druga. Prilikom zatvaranja obsega potrebno je proći kroz sve lance coliziji u hash tabeli i sa njihovih početaka ukloniti zapise koji se odnose na tekuće obsega, koji se upravo zatvara, način kad se zatvori ovaj drugi u nutršnji obsegu, uklonili bismo o a2 i m2 istna belega. Prednosti hash tabele simbola su da je brži pristup simbolir, se pretražuje samo jedna tabela, i obično su ti traženi simboli na početku lanaca. Manje je važno, znači da je memorijski prostoru sučaju korišćenja te jedinstvene tabele, efikastne i skorišćenje, jer imamo samo jedno zaglavlja hash tabele, ali je taj dobitak umanjen za to što u svako ime moramo dodati prostoru za pamćenja obsega važenja tog imena. Sledači način realidacije koje može da se razmotrije jedinstvena tabela simbola u skorišćenje binarnog leksikografski uređenog stabla. Leksikografski uređenog stabla znači da kada posmatramo neki čor stabla, čorove u njegovom levom podstablu imaju u abecendnom redu sredu manja imena, a čorove u desnom podstablu abecendno veće imena. Opet koristujemo jedno znače numeričke identifikatore za svaki obseg koje pamtimu čorovema stabilu iz imena. I sad razmotrimo situaciju kada ubacujemo novo ime u stablo pri obradi deklaracije, ako u ovom primjeru smo obradili ovej spoljni obseg i pošto smo došli do ovoga drugog obsega, recimo da tek obradujemo ovej drugi ugneždeni obseg, onda ovi čvorove A2, C2 i M2 još ne bi bili prisutni u stablu, znači stablo bi se sastalo samo od ova tri gornja čvora. I recimo sada kada trebu ubaciti A iz togo obsega 2, kret ćemo od korenog čvora, pošto je A ispred M u abecednom hredosledu, prelazimo na levo pod stablo, uporedžujemo znači A sa naravno sadaržem postojećeg čvora koji je isto A. Znači radi so istom imenu, ali različito i deklaracije, pa moramo napraviti novih čvora. Možemo znači usvojiti konvenciju da idemo u levo pod stablo, kada ime manje. Pošto je A1 bio list stabla, dodat ćemo A2 kao novih čvoru stabla i to levi sim čvora A1. Dakle, generonog ledon identificatori najugneždenije gov' obsega, daleze se u listovima stabla ili blizu njih. Zbog toga kada pri korišćenju i nekog imena vršimo prolas kroz stablo počev od korena, ne možemo se zaustaviti u prvom čvoru gde dolazi do poklapanja imena i ščvora satrađeni imenom, nego treba nastaviti pretragu kroz stablo sve dok ne dođemo do lista stabla. To znači čini pretragu za nijan sumanje efikasno. Kada zatvaramo obseg moramo proći kroz celo stablo i ukloniti iz njega sve čvorove u listovima stabla ili blizu njih, koji odgovaraju i menime istog obsega. Znači, recimo, kad bi smo zatvorili ovaj drugi ugreždeni obseg morali, bismo ukloniti ove čvorove A2, C2 i M2. Ko dovolj načina realizacije tabele simbola kao binarnog leksikografsku i uređenog stabla, svi simboli formilaju stabla u bacivanje novi simbola pri otvaranju novog obsega važenje i izbacivanju simbola pri zatvaranju obsega važenju zahtave pretraživanje stabla do listova, pa nije toliko efikasno. Binarno stablo se može koristiti kada imamo pojedinačne tabele za svaki obseg važenje. I još jedno od mogućih realizacija dinsvene tabele simbola je u vidu jednog steka, znači Last in First Out kolekcije simbolo. U ovom slučaju na vrhu steka se nalaze simboli i stekućego obsega važenja i razdvojenoj su od simboli ispretunog obsega važenja markerom. Kada sa obseg zatvara sve što se nalaze na steku izdan, markera se skida sa steka. Pretraživanje imena kada treba da nađima neku imu tabeli simbole, i da je redom počeo od vrha steka na niže za ustavljamo se kod prvo poklapanja. U nekim ranim vrzijama kompajlera korišće na ovaj relativno jednostavna struktura podatak. U ovom lekciji razmatrićemo kako se sa stanovišta kompajlerske obrade realizuju neki koncepti objekto-orientisanih jezika. Kao što ste već naučili u objekto-orientisanom programiranju, važni koncepti ove vrste programiranja su klase objekti, abstrakcija, inkapsulacija, nasljeđivanje i polimorfiza. Kratko ćemo se podsetiti ovi karakteristika, pa ćemo potom videti kako se ovi koncepti realizuju u programskim prevodiocima. U java programu možemo definisati klasu u ovom primjeru klasu vekl vozilo. Klasa može da ima polja i metode. Klasa može proširiti odnosno naslediti drugu klasu. U ovom primjeru klasa kar proširuje klasu vekl. Kar nasledjuje polje position i metod move, a doda je, sobstveno, polje passengers i metod await. Koji odgovara nekakom sačekivanju drugog vozila ažuriranjem njegove pozicije. U obsegu imena metoda await, vidljive su promenjive passengers, jer predstavlja polje klasa kar, position je predstavlja nasledjeno polje klasa kar, v kao formalni parametar metoda await i takođe dis kao implicitni formalni parametar metoda await. Klasa track takođe proširuje klasu vekl nasledjujući polje position i metod move, međutim track pruža sobstvenu implementaciju metoda move. Taj način on redefinishe ili overrideuje nasleđeni metod. Nastavljujući ovaj primer u metodu main, imamo upotrebove klasa koje smo u predhodnim slajdovima definisali, znači instanciraju se objekti t klasa track i c klasa kar. Ovi objekti mogu da se upotrebe i na mestu gde se očekuje objekat opštije klasa vekl. Naprimer u pozivu c vejt od t objekat t se prosledžuje na mestu formalnog parametra ve. Kada se u ovom vejt metodu klasa kar pozove ve.move, to je znači poziv, ovaj move se odnosi na redefinisani move iz klasa track, a ne na originalni move iz klasa vekl. To je zato što java pamti dinamički tip objekta ve, dakle u vreme izvršenja koji se razlika od statičkog tipa sa kojim je ve deklarisana. Znači ve je deklarisana sa statičkim tipom vekl, a u ovom pozivu znači ve ima dinamič sam objekat je tipa track. Poziv standardno godnostno dinamičkog metoda klasa se razrešava gledajući dinamički tip objekta. Klučni problemi koje u kompajlerskog obradi treba razrešiti su kako pristupiti poljima objekta uključujći nasljeđena i polja tekućeg objekta, a takođe kako pristupiti programskom kodu metoda, ako tekuće klasa nema definiciju metoda, kako stiči do nasljeđena u metoda i kako se obrađuje redefinicija metoda, ono, ove radovanja. Hierarchija klasa predstavlja grafički prikaz relacija nasljeđivanja među klasama programa za ona i naš predhodni primer. Imali smo klasa u vijekle. Ako u pitanju standarda na java sve klase u javi proširuju u građenu klasa object, u mikrojavi toga nema klasa reprezentacalnog sebe. Ivali smo naravno klasu car koja nasljeđuje iz vijekle i klasu track koja takođe nasljeđuje iz vijekle. Ako postoji samo jednostruko nasljeđivanje kao ovom primeru, grafi o blika stavla, a u jeziku sa više strukim nasljeđivanjem, kao što je na primer C++ ili python, grafija aci klički, to je jedna klasa može imati više klasa iz kojih nasljeđuje. Više struko nasljeđivanje nešto služenije za implementaciju od jednostrukog nasljeđivanja. Sve se tiče memorijske reprezentacije objekata kod jednostrukog nasljeđivanja, objektim odgovaraju zapisi u memori. Svaka i promenljiva ima polje u zapisu, a pristup polju zapisa, na primer V, je tu je glavni problem što V može u runtime ukazivati ili na osnovu klasu vijekl, ili na nekod izvedeni klasa car ili track. U ovom primeru namerno instanciramo track i car i onda pozivom metodom, metoda await prosledžimo, znači bilo koji od objekata, ovdje u trenutku kada se im zvašava ovaj del.
 Isti mašinski kod mora funkcioniti kada znamo statički tip objekta v, to je recimo vijekl, ali ne znamo njegov dinamički tip. Znači compiler ne zna šta će u runtimeu na ovom mestu doći kao objekat. Znači mogu biti u ovom primjeru vijekl car ili track. Positivno je da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da je vrlo pozijštno, da jenih odostenom s tearedom,io nam se nah boardinga, i može stoja mu ove Vanara tjena da se imane kolike do katevi, i kao bom je umičila applications,ícia se priyašt edit bar, poce rational,Spike iway pre ourselves u polja pozišana. E sad koju konstantu treba uzeti ta konstanta mora, ta i pomera je mora biti isti bez obzira da li ve ukazoje na kart, track ili vijeklo. Način raspored polja u zapisima koji reprezentuje kolakam i ona i vozila mora biti sriča. Vredno svakog objekta u vreme izvašavanja predstavljena je zapisom u memori i sa poljima zapisom za svakog polja u klasi. Ovseti tih polja su konstanti, to jest poznati kompajleru pri prevođenju programa. U slučaju jednostru kog naslijivanja jednostavna tehnika proširivanja na desno. To jestika višim memorijskim lokacijama rešava problem pristupa poljima objekta. Način prvo se u zapisu objekta naredžaju polja koja se naslijuju iz nadklase u istom redosledu kao i u nadklasi, a teko onda sopstve na polja podklase. Pogledajmo i jedan primer koji ilustruje koncet proširivanja. Na desno, imamo četiri klasa. Klasa A, zasadne razmatramome tode samo polja, klasa A ima polje A, klasa B proširuje A i osim naslijivanja polja malo A doda je sopstvona polja B i C. Klasa C takođe proširuje klasu A i pored naslijeno polja malog A doda je svoje polje D. Klasa D konačno proširuje klasu B, značino sleduju sve što B ima od polja i doda je sopstveno polje E. Kako izgleda memorijski layout objekata ovih klasa, znači u runtimeu u operativnoj memoriji racunara. Za objekat klasa A imaćemo jedan ovakav zapis. U zapisima objekata, uvek stoji destritor klasa, znači da se zna kojoj klasi objekat. To je dynamic runtime klasa objekta. Zatim ostatak zapisa čine vrednosti polja objekata. Ode što piša A, to je samo simbolički označeno da je u pitanju polje A. U runtimeu stoji na celobroj na vrednosti. Esad znači, kako izgleda zapis objekta B, ima svoj identifikator klasa. Početu komponentu zapisa, a zatim vredom idu vrednosti. Polja je važno da je dođe na sređeno polje A na istoj mesta u zapisu. Zatim je objekta A, a zatim je svoj na polje B i C. Svično tome klasa C koje isto nasleđuje A, mora imati na 1 mesta A, a zatim je svoj na polje D. I konačno klasa D koja nasleđuje klasu B, mora imati svečno naredjeno u svojom zapisu. Na sređena polje u istom redosedu, na istim offsetima A, B i C. I zatim do D je svoj na polje E. Kako se realizuje prevođenje, poziva metoda klasa. Kako statičkih metoda tako i dinamičkih. Resultat prevođenja metoda je mašinski kod na određenoj memorijskoj adresi. Na mestu pozivanja metoda moramo odrediti na koju adresu treba izvršiti skok. Java znači ima statičke i dinamičke metode. Za rezarašavanje poziva statički metoda dovoljno odrediti statički tip objekta či se metod poziva, a za rezarašavanje poziva dinamičkih metoda treba poznavati dinamički tip pozvanog objekta. Detalje ćemo videti razmatrejući primjere. Ako deklaracija metoda sadrži statički, onda mašinski kod koji realizuje poziv metoda, na primjer c.fu, zavisi o tipa sa kojim je promeljiva c deklarisana, a ne o tipa objekta koji je referisan sa ce u vreme izvršenja. Na primjer vidimo da u klasi a imamo statički metod fu i statički metod bar, a klasa b koja proširuje a, takođe ima statički metod fu. Nemožemo reći ovom slučaju da ovaj fu ovaj raiduje kredefiniše ovaj gornji fu, jer ovde pri statički metodima ne funcjoniše polimorfljene vehanizem, nego pravilno je reći da ovaj fu u kontekstu klase b sakriva ovaj ovde gornji fu u kontekstu klasa, znači sve se razrešava statički u vreme prevođenja i vidi izlistinga programa. U ovom primjeru a, tako da bih smo znali koje fu se poziva, dovoljno je pogledati statički tip promenjiva a, tako je poziva se fu klasa a. Ovde vidimo da promenjima b ima statički tip a, a dinamici objekati u sluštini b, međutim poziv b, tako da se opet poziva uve krazrešava koristeći statički tip, tako da se opet poziva uve krazrešava koristeći objekati klasa b, poziva se fu iz klasa a. I konačno promenjiva c ima i statički dinamici tip isti objekta b, tako da teku ovo me c.fu poziva se ovu fu iz klasa b. Znači, generalno da bih prevojava o poziv statičkog metoda, tokom semantičke analize, prevodila co određuje statički tip objekta, či se metod poziva i naravno listu metoda koji su prisutni u svakoj klasi. Zatim utvrđuje najbližji metod nagore u hierarehji i klasa sa datim imenom, način krenao tekuće klase, pako nemo tako kluće klasi krene do klasa iz koja ona neposredno nasleđuje i tako dalje. I zatim ubacuje neposredan poziv utvrđenog metoda. Predkodno opisa na tehnika nije primenjiva na dinamičke metode. Evo pogledajmo sličan primer, sad je izostavljena ključna reć statiki i java podrazumevano metodi koji se definišu okviru neke klasa su dinamičke. Znači sada su fur i par iz klasa a i takođe ove i drugi fur iz klasa b dinamičke metodi i ovaj fur košto klasa b proširuje klasa a slično kao u predkodnom primeru, ovaj fur redefinišu, odnosno ovaj ride uje, ovaj fur iz klasa a. Vidimo da u glavnom programu instanciramo jedan objekat klasa a, jedan objekat klasa b i takođe koristimo ferencu c koja je statičkog tipa a, znači osnovne klase, ali se dinamičke, i to je ovdje simbolizala novim iflong and tricky computation, da se kaže da compiler nina koji način ne može da utvrdi, nači ce u može da se dodeli ili u runtime u objekat a, da ukazuje na a ili da ukazuje na objekat b. A compiler nina koji način ne može da zna, na ovom mestu, da li ce ukazuje na a ili na b, to se tekurant imu određuje i postavlja se pitanje, znači ovaj poziv c.fu kako se razrešava. Betot koji se poziva, zavisio dinamičkog tipa objeka, ta i ne mora biti poznat i u opšnjem slučaju, i nije tokom semantička analizu u compileru. E sad u vreme izvršavanja programa mora se odrediti gde će se skočiti. Dok toga, znači treba u vreme izvršavanja programa postoji podrška za to odlučivanje, koja je realizowana tako što objekat ima pokazivač na tabelu svojih metoda, tako zvana v tabela ili virtualna tabela, osim što ima vrednosti svojih pođa. U vreme prevođenja generiše se kod koji će u runtime upretražiti tuve tabelu objekta, pronaći lokaciju metoda u tabeli i izvršiti skok na početak tela metoda. Evo da vidimo na konkretnom primjeru kako je to realizovano, ovaj primer, odnosi se na jednostruko nasljedivanje, ima definisane četiri klasa a, b, c i d. I u ovom primjeru poved pođa imamo dodate svakoj klasi i određene metode. Klasa a ima pođa malo a i metod f, klasa b proširuje klasu a i dodaje sobstveni metod g, klasa c proširuje klasu b i overajduje metod g, sve metodi su dinamici, klasa d proširuje klasu c, nasledjuje polje a još iz klasa a i takođe metod f iz klasa a nasledjuje, ali ga redefinishe, overajduje i takođe nasledjuje iz klasa c, njegovo ovaj metod g. Kako je to sve u memori i tokom izvašavanja programa reprezentovanu?
 Znači, imamo objekat klasse A koji ima ona i svoj identifikator, odnosno deskriptor. Klasse i vrednosti polja. Znači, ovo je objekat klasse A. Dodatno, imamo dodatnu strukturu koja ne mora da se pamti na istom mesto u memori. Važno je notirati da svaka instanca klasse A, svaki objekat ima jedan zapis o ovoga tipa i oni se tipično nalaze u dinamičkoj memori, u nam delu memorie koji u vreme i došanja programa može slobodno da se alocira ideja alocira. A, ova V tabela određene klasse, znači dovolj na jedna instanca na nivou klasse. I svi objekti te klasse dele ovu ovde instancu, znači svakog objekta ukaziva čide na ovo istom mesto i zato ovo može biti u nekoj drugoj vrsti delu memori u toku došanja programa, to je tipično statička memoria. Znači za klaso A njena virtualna tabela sadrži pokazivač na početak implementacije ovoga metoda F. Zatim objekat klasse B ima polje za ovom nasleđeno A na istom mesto u osnovnoj klasi i u virtualnoj tabeli ima dva pokazivača, znači prvi pokazivač mora da bude na istom mesto kao u osnovnoj klasi, znači ovaj AF, a zatim pro se naredžaju svi nasleđeni metodi, a zatim se dodaju sobstveni metodi, znači pokazivač na metod G definisan u okviru klasse B. Objekat klasse C ima nasleđeno polje A i u svojj virtualnoj tabeli nasleđuje metod F iz klasse A, A ove rajdu je G iz klasse B, tako da na istom mesto gde je u klasi B bio pokazivač na G, ovde imamo pokazivač na ove rajdovani metod C. I konačno klasa D nasleđuje A, potom dodaje sobstveno B, a u svoje virtualnoj tabeli ima sobstveno ovaj dovanu verziu metoda F na istom indexu, gde je metod F iz klasse A i nasleđuje direktno bez ovaj dovananja metod G iz klasse C. Ovde sam navjerno nacrto još jedan objekat klasse D, znači oni se naravinstanciraju sa nju de u runtime, tako da vidimo da svaki objekat ima sobstveni zapis avrednostima polja, ali znači svi oni dele jednu ovu V tabel. Više struko nasleđivanje je složenije za implementaciju jednostrukoj, jer za objekte pod klasa proširenja na desno ne funkcionišera. Recimo ako neka klasa C nasleđuje i od klasse A i od klasse B ne možemo na istom mesto na početku zapisa togo objekta staviti i promenjive klasse A i promenjive klasse B. Za predstavljanje objekta u kontekstu više struko g nasleđivanja neofodna je globalna analiza, odnosno moraju se uzeti u obzinu. Sve postojeće klas. Razmotrimo to na sledećem primjeru. Primer sadrži definicije klasa A, B, C i D i zasta da razmatramo samo polja, znači klasa A ima polje malo A, klasa B ima polja malo B i malo C. Klasa C proširuje klasa A, znači nasleđuje polje malo A doda je svoje polje D, a klasa D je jedina koja više struko nasleđuje znači i iz klasse A i iz klasse B i iz klasse C i doda je još sopstveno polje E. Kako izgledaju memorijski zapisi objekata? Za objekat klasa A imamo samo vrednost polja malo A, za objekat klasa B imamo polja B i C, za objekat klasa C imamo nasleđeno A i doda to sopstveno polje D i konačno objekat klasa D nasleđuje sva polja ovih predhodnih klasa. Znači mora da ima naredjeno A, B, C, D i sopstveno polje E. Ovde je naravno zanimljivo, to su uvek razrešava posebno u semantici tih jezika sa više strukima sredjivanjem, što na primer klasa A i klasa C imaju polje A i onda se postavlja pitanje u klasi D, dali to treba da se pamte odvojeno te vrednosti ili da postoji samo jedna vrednost kao što je ovde naznačeno. Druga stvar, zašto je potreno globalna analiza, zato što vidimo da layout memorijski raspored polja objekta D određuje i rasporede polja ovih drugih objekata. Znači da bi polja u objektu D dobila jednoznačne pozice, pomeraje koji odgovaraju i nasnači koji su isti kao i nasleđena polja. Moramo u objektima drugih klasa konkretno B i C ostaviti rupe, znači neiskorišćene ove slotove, da bi moglo svako polje objekta D dobiti svoj jednoznačan index. Kako razrešiti ovu vrstu kojim algoritmom se u suštini određuju i ovih pomera i polja u svakom objektu? Memorijskoj prestanja objekata može se odrediti algoritmom bojenja grafa, poznati matematičkim algoritmom. Čvorovi to grafa po jedan čvor se formira za svako posebno ime polja, zatim čvorove povezujemo granama za polja koja koji izistiraju u istoj klasi, znači putem nasleđivanja ili na neki drugi način. I kada pustimo algoritme i dobijemo rešenje, cilj algoritma je da čvorovi koji su međusobno povezani granama ne budu obojeni istom bojom, odnosno konkretno, kad to interpretirano na naš problem, to znači da polja koja koji izistiraju istoj klasi, sva koja dobije svoj jedinstveni pomeraj. I u suštini znači ti pomeraju zapisu, su rešenje algoritma, to znači oni odgovaraju bojama grafa. Problem sa ovim pristupom je potencional ostavljanje prazno prostora u sred objekata, pošto se ne može uvek obezbediti da ojef seti n polja uvek pokrivoju prvih n pozicije u zapisu. Znači u konkretnom primeru zbog klase d imamo rupe u objektima b i c, i ako te dve klase nemaju nikakodirektnu povezanost. Znači to je problem interne fragmentacije memoria programa. Jedno od rešenja za taj problem je znači da bi se eliminisala prazna mesta u objektu, možemo spakovat i vredno spolja objekta neposredno jednu za drugom, a delegirati deskriptor u klase da sa opštava gdese koje polja nalazi, da pam ti ofsete polja. Ofseti polja u savom deskriptoru klase određuju se kao i ranije metodom bojenja grafa. Na ovaj način prazam prosto preselio su deskriptor klase, što je poboljšanje jer svaka klasa ima samo jedan deskriptor, a potencilno veliki broj instanci. Vidimo u primeru da smo u deskriptor klase ubacili index polja. Recimo objekat B koji je ranije imao rupu izveđu B i odnosno ta rupa je bilo pre-B. Sači ta rupa prosređuje u deskriptor klase koji je jedana nivou klase, a u samom objektu je skorišćen direktno prostor i u deskriptor pisao ofseti kako doći do realnih vrednosti polja. Znači sad ne iskorišćem prostor ostaj na nivou klasem. Ovo je memorijski bolje, zato što deskriptora klasa ima neki određen broj, koliko ima klasa u programu, a potencialno objekata u programu može biti neuporedivo više. Upisem manje memorije. Međutim cena koji uplačemo je nešto sporiji pristu polju klase. Zato zahteva da prvo pročitamo pokazivač na deskriptor klase iz objekta, znači pratim ovaj pointer, zatim pročitamo vrednost pomeraja iz polja deskriptora i kao trećem pročitamo ili upišemo podatak na taj pomeraj. U prvoj variant dovoljno je bila samo jedna naredva da se pristupi polju objekta kad znamo adresum objekta. Dodatam problem je, što u modernim jezicima globalna analiza pravi dodatne probleme. Mnog je aplikacije koriste dinamički povezane bibliotekje. To je situacija, compiler ne zna sve klase u programu, tako da ne može lako da izvrši globalnu analizu, tako da neki jezici pribjegavaju naravno jednostrukonosljivanju kao jednostavnej varianti. Mnog je neki anegdotalna priča da je Microsoft imao veliki problema da u svoj c++ compiler u baci više struko nasljivanje. Tako da je c++ Microsoft jedno vreme jedini imao jednostruko nasljivanje, a Microsoft u istrušnjacci subeđivali. Ljude pisali članke, da je više struko nasljivanje štetno. Tako dalje doknaravno i oni da bi saobrazili svoju variantu c++a standardu. Na kraju su i oni morali da implementiraju više struko nasljivanje. Na rao ako želimo više struko nasljivanje a da izbegdemo globalnu analizu poznavanje svih klasa u programu možemo upotrebiti hashing u pristupu poljima objekta. Na čume sto globalno bojenja grafa u svaki deskutot klasa ide hash ta bela koja mapira imena polja u FZ i imena metoda naravno jer za metode mora da se primeni sliča mehanizam u adrese instanci metoda i onda se izbegava globalna analiza. Detali ovo gresenja sa hashingom mogu se naći u knjizi.
 prof. Appela koju sam navel na uvodnom slajdu. Takođe objekto je orientisan i jezicima i još neke specificnosti koje mi samo pominjemu mikrojava to nema, mogu naravno određenim mehanizmima u prehođenju, izvošavanju i oni da se raješe. Znači radi enkapsulaciji lokalak stanja objekta, java ima kvalificatore Private Protected i Public. Znamo da privatni metod i polja ne mogu biti korišćeni izvan klasek, da su definisani, Protected mogu biti korišćeni samo u klasi i njenim nasljedjenim klasama i takođe. Podoška za ovo je relativno laka i svodi se na semanitivnu analizu. Ove informace treba čuvati u tabeli simbola i proverati u semanitivnu analizu. Zatim objekto je orientisan i jezicima imaju operatore proveretipa u runtimeu. U javi začimamo Instance Off koji ispituje, da li je neki objekat X, instanca klase C ili neke njene podklase, a u C++ ako je uključen mehanizam, znači čuvanja informaciju tipu u toku runtimea, tako zvoni RTTI runtime type identification, pošto to u Ceo može da se pira. Uključeno u compiler ili ne, postoji sličan type ID operator. Obekto orientisani jezicima imaju mehanizam sigurne konverazije tipa. U nekadnamu programiranju imamo znači promenjivu koja je statičke klase C, a sam objekatu runtimeu u stvari neke klase D koja je izvedena iz C. I nekad nam treba baš da iskoristimo, specifično se obično naravno mi koristimo X i onda koristimo ono što je definisano na nivo u C. Međutim, kad treba da iskoristimo nešto što je specifično, kad mi znamo da je X određen izvedene klasa i kad očemo da baš pristupimo specifično sadrežaju te izvedene klasa, to inoče nije dobar stil u objekto orientisanom programiranju, ali nekad zatreba, onda znači treba uraditi konverziju tipa, znači, cast u javi napišamo ovako u zagradi D ispred X, tako nešto možemo napisati u C++, ali onda bi se radilo o nesigurno i konverziji, za koju kompajler bi slepo da kažem primenio veravao nama da je X sigurno u runtimeu tipa D što može, ali ne mora biti izpunjeno. Međutim, ako želimo sigurno konverziju koja, znači, prvo proverava, da li je X zaista odgovarovićeg tipa, pa te konda radi ovo što treba, znači, imamo ovaj dynamic cast i navodi se dinamička klasa. Znači, potrebno je poznavanje tipa objekto u runtimeu da bi se ovakvi operatori implementirali. Evo, recimo, možemo razmotriti implementaciju ovoj instance of operatora, odnosno, proveri tipa, pošto svaki objekat pokazuje na svoji deskritor klasa, adresa deskritora klasa može služiti iz identificaciju tipa. Međutim, ako je X instanca klasa D, a D proširuje C, onda X takođe instanca klasa C. Znači, kako može da izgleda implementacija instance of operatora? Znači, ovaj kod koji se izvršava, koji kompajler treba, naravno, da prevede u mašinski kod koji se onda izvršava u runtimeu na mestu, gde je upotrebljen ovoj instance of operatora. Znači, krene se od deskritora objekta X, i sada se ispituje, da li je taj deskritor upravo tipa C, ako jeste, onda smo završili, znači, posao i vraćamo True. Međutim, ako znači, ne dolazi do poklapanja u deskritoru klasa objekta X, za koji ne znamo da kažem koja je klasa, to je sturan, mora da postoji polje super, znači, koje ukazuje na nadklasu kod jednostrugo nasleđivanja, znači, ovo super će ili biti nul vrednost, ili će postojati jedinstvena ta nadklasa, ubacujemo u T1, da sad ukazuje na tu nadklasu, ako naravno ne postoji nadklasa, vraćamo false, znači, da X nije instancac, e, sada ako je, znači, T1, nešto što nije, Nil, vraćemo se na ovu proveru da nismo sad praćenjem, znači, to pokazivača ka nadklasi došli do klasa C, ako je smo vraćemo trvo, ako nismo, ugljedamo da li postoji još neka nadklasa i za tu klasu, ako postoji, opet se vraćemo na ispitivanja dalje to C, i tako dalje, znači, ili ćemo u nekom trenutku, izrači na ovom mesto ili ćemo, izrači na ovom mesto. Pričamo o konstrukciji tabele simbolat za mikrojavu, i ova lekcija odnosi se na programska objekta i obseg je. U posebnoj lekciji pričajemo o predstavljanju tipova i proveritipa. Struktura lekcija, sasto i s oduvodnog dela, gde se pocećemo na ulogu tabele simbola u kompajleru, zatim ćemo razmotriti način organizacije, strukture podataka koji možemo predstaviti tabelu simbola, zatim ćemo videti kako predstaviti informacije o programskim objektima, to su konstante promenjive metodi, parametri metoda, gde ćemo kako predstaviti informacije o obsezima imena i definisat ćemo kako se tačno realizuju osnovne operacije na tabelom simbola. Rekli smo da tabela simbola u kompajleru suži za pamćenje informacije o svim deklarisanim objektima. Informacije zavise od vrste objekata, znači sve vrste objekata imaju ime tip, zatim konstante imaju rednost, promenjive metode imaju memorijsku adresu na kojem se pamte, parametri mogu imati tip broj parametara i tako dalje. Tabela simbola služi za naleženje informacije o korišenim objektima, što se svodi na asociativni pristup, odnosno ime se mapira u ostale atribute objekta, kao što su tip rednost, atresa i tako dalje. Pošto postoje programski obsezito, nije jednostavno linarno mapiranje imena, ali o tome ćemo posebno govoriti u nastavku. Najosnovni interface tabele simbola prema drugim delovima kompailera mora da ima metode za ubacivanje informacija o objektu tabelu simbola, to je ove metode insert, gde se zadaje ime objekta i ove tri tačke simboli izvuju još neke atribute objekta, a tabela simbola vraća u slučaju uspeha ove operacije insert, zapis o objektu, gde mogu dalje da se postavljaju i čitaju atributi. Nakradno za već postojeće objekte, pri njihovoj upotrebi metod find, na osnovu imena, vraća postojeći zapis, iz koga mogu da se onda čitaju atributi. Interno organizacija tabele simbola u svoj osov jedna koleksija, dinamiška struktura, podataka skup objeknih strukturni, zapisa i zapisa o obsezima. Objektne zapise u kontekstu ove mikrojavata tabela simbola biće instance klasse obajl, čuvaju informaciju o deklarisanim imenima, strukturni zapisi, instance klasse struct, čuvaju informaciju o tipovima u programu i na njih u suštini ukazaju objektni zapisi o klasse struct pričaćemo u posebnoj lekciji. Instance klasse scope čuvaju informaciju o aktivimim obsezima imena u programu. Nekaj moguće strukture podataka za organizovanje tabele simbola bi bila jednostruko ulančana neuređena lista, binarni lekcijski uređeno stavlo ili heštabela. Ako iskoristimo jednostruko ulančane liste, onda imamo primjer za njih zod nekoliko deklaracija, jedno je konstanta, drugo je nekakva klasa, treće su promenjive celobnohti pab i c i metod m u tabeli simbola, znači formirale bi sedna jednostruko ulančana lista gde bi svaki novi element bi ododavan na kraj liste i vidimo imamo znači niz objekni zapisa koji imaju kao svoje komponente ime, vrstu objekta i još neke parametre koji nisu tu prikazani. Prednost korišćenja jednostruko ulančana liste kao strukture podataka je u jednostavnosti realizacije, takođe zapamćenja redosled deklarisanja imena. To je ponekat potrebno ako specifikacije jezika, recimo, zahtava alokaciju objekta u memori i onim redom kojim su deklarisani. Nedostatak ovog načina organizacije je sporo s pretrage, znamo da nje red složeno sti funkcije pretrage u jednostru koji ne uređano i listi, n polak, d, n dužina liste, načeku i ono go imena to je relativno sporo. Zbog svoje jednostavnosti mi ćemo u nastavku ovog predavanja podrazumevati ovaj način organizacije tabelesim vola. Inacče u realnoj tabelesim vola koji vi dobijate, objekto orientisani mehanizmima je potpuno enkapsulirana na organizacije tabelesim vola, tako da vama nije znacajno da li je to lista ili neka druga način interface, kako koristite potpuno nezavisi od toga. Međutim kada se ovdje reprezentuju primeri ili kod određenih metoda, tabelesim vola najlakše to prikazate ako su u svoju organizacije. Alternativna struktura podataka za realizacije tabelesim vola su binarno-veksikografski uređena stavla, imamo isti ovaj primjersa nekoliko objekata, bi mogo da rezultuje u jednom ovakom stavlu, znači kada god dolazi neka nova deklaracija, operacije ubacivanja novog objekta u tabelu simbola uve kreće od korena, uporedimo ime zaprančenu u korenu se imenom kojim ubacujemo, ako ime koje ubacujemo, leksikografski dolazi i za ovog imenom.
 na učoru, idemo na desno podstablo, ako leksikograski dolazi preimena učoru, idemo na levo podstablo i tako dalje, celu stvar ponavljamo sad s ledećim čorom, da bi ubacili novo ime, ono uvek mora doći kao novih list stabla, nači moramo se spustiti skroz do nego poestojeg lista i onda kao njegovog levo gili desna ksina ubaciti novih list. U nekom opštom slučaju pretraga je brža, nači ona je red funkcija služenosti i logaritam broja deklaracija, podrezumeva se naravno da je raspodela imena neka kva slučajna, međutim ako su imena paš sortirana na određeni način, onda će se ovo stavno degradirati u linjarno listu, ali statistiški gledano ko dneke slučajne raspodele identificatora dobija se ova vrednost, naravno nešto je veća potrošnja prostora i vremena prida i ažuriranju i originali redosle deklaracije izgubljena čako nam treba redosle, to moramo uvesti poseban atribut u ovim zapisima koji čuva taj podatk. Tabela si volu u vidu hash tabele, realizovan je tako što definišemo hash funkciju kojoj mapiramo ime u neki celobrojni index, uvodimo jedan hash vector koji ima nis pokazivača znači za svaki od ti hash indexa na kolizivnu listu, određeno ime se mapira u određeni index i onda se ulančava na kraj ili na početak, kako se definiša su da će po ovom primjeru ulančavamo na kraj ovog lansa kolizija, znači pri kasnijoj pretrazi mi opet izračunavamo hash index određeno gimena, pristupamo određenom slotu ovoga hash vektora i onda pretražujemo ovoj lana kolizija da nađemo odgovarajući zapis. Znači ovo je praktično u slojima velike količine imena, možda na i prža varijanta i ovde se takođeg ubi redosle deklaracija, ova komplikovanost je relativna ako se koriste gotove biblioteke, standardne kolekcija, da nam nije toliko sve jedno nam je da ćemo uzeti hash ili stavlo i tako dalje, ovo je vrlo često koristjena znači struktura podataka za ove namene. Kako pamptimo informacije objektu tabeli simbola? svako deklarisano ime se pampti u jednom objektom zapisu. Možda možda znači okomo joj vrsti objekata se radi, tako da ugodimo kroz niz simbolički konstanti, znači svaku za različitu vrstu objekta za konstante programske promenjive tipove, znači koristnaški definisane tipove kao što su imena klasa, metode i polja klasa. Nekje informacije nezavisno sa od vrste objekata, tada sve vrste objekate imaju sve ime, imaju tu informacije o koji vrste objekate reči i znači imaju tip programski. I takođe pošto smo u svojili organizacije vidu jednostri kvunčan liste poslojči pokazivašno srednji zapis. Nekje informacije su specifično za određeno vrstu objekta, rećimo za konstante to je vredno za promenjive, to je adresa u memori u kojem ću u vrema izvršavanja, znači vredno s promenjivem očinu se nađe. Nivode klarisnosti, dalji su u pitanju lokalne, promenjive metode ili globalne promenjive programa. Za polja klasa pitanje pomera i u zapisu klas objekta u runtimeu, gde može da se određeno polje nađe. Za metode, znači pamitimo početno adresu gde se nalazi mašinski kod prevedenoog metoda, pamitimo broji parametara metoda, takođe vide ćemo da formalne parametre pamitimo u listi objekata i takođe moramo imati listu lokalnih objekata metoda. Što se tiče adresa, kao vrste tipu informacije koji se pamiti za neke vrste objekata, kratkog pregleda tipova adresa u mikrojavi. Što se tiče globalnih promenjivi, u mikrojava virtualnošinu koje ćemo nakrano više reći, sad ćemo reći samo toliko da se globalne promenjive čuvaju u posebnoj oblasti globalnih podataka i svaka mikrojava promenjiva zauzima po jedume morisku reča, adrese promenjiveh su relativno u odnosu na početak oblasti globalnih podataka i adrese se dodelju sukcesivno. Uprostili smo stvar u mikrojavi, da promenjive nemaju različitom memorisko za uzeće, nego uveki fiksno po jedna memoriska reča, tako da ako imamo nijegi glopalnih objekata promenjivi, znači njihovi relativnih adresetos u stvari indexi globalnej taerija niz idu prostos sukcesivno jedno za drugo. Što se tiče lokalnih promenjivi, u mikrojava virtualnošinu one se čuvaju na programskom steku, steku pooziva u okviru metoda. Znači, na steku se formira jedan zapis, koji se zove ima dva imena ili aktivacijelni zapis ili okvir određenog metoda. Znači, u trenutku, kada se metod pozove, na vrh steka pooziva stavlja se formira se taj okvir metoda. U runtimeu, da bi smo znali gde se taj okvir metoda nalazi, njega ograničavaju u s jedne strane stek pointer, to je vrh steka, znači, ako koga je pokazano, stek raste nanižne, tako da je vrh steka steka pointer, a drug granicu okviru metoda, čini poseba register koji se zove pokaziva čokvir, odnosno frame pointer, da bi se pristupilo nekoj lokalnih promenjivi, adresa se formira tako što se na trenutnu uvrednost frame pointera doda poznati pomera. Znači, ovaj pomera je konstanta koja je poznata kompajler u vrijeme prevođenja programa i on samo o tome treba da brine. Ovoj frame pointer su runtimeu formira, tako da kompajler ne zna njega uvrednost, ali on zna ovaj pomere. Tako da sada koja ona istina iz deklaracija sa odnosno lokalne promenjive, opet ćemo sukce, pošto svaka mi kreava promina za uzima po enu memorijsku reč i adrese promenjive su relativno odnosno pokaziva čokvirato s frame pointer, dodelju se sukce, znači, prosto ćemo redomim dole deliti te relativne adrese. Pošto smo rekli, da deo atributa objekta zavisi od vrste objekta, postavlja se pitanje, koji ćemo strukturu podata kao u javi iskoristiti za beleženje pamćenje objekta. Objektorientisanom projektovanju bi odgovaralo, da ona i zajednički deo atributa objekta kao što su ime vrsta za beležimo u ostom raja nekoj klasi oboj, a zatim tu klasu proširujemo za svaku posebnu vrstu objekta, tako da imamo posebni izvedene klasi za konstante, za promenjive polja i metode. U implementaciji koji vi dobijate, diskutujem, nije primenjan o to rešenje. Ovo rešenje koje je primenjeno da formiramo samo i jednu klasu oboj i da sve vrste informacije o svakoj vrsti objekta pamptimo u toj jednoj klasi. Ovo nije preporučeno sasnaništa objektorentisanom projektovanja ali druge strane u praksi možete naići na takove stvari. Ovdje emotiv bio taj da opet se uprasti kod koji kastije diskutujemo za implementaciji u pojedinih metode i tako dalje. Ima klasu oboj, imamo definisane o ne konstante koje predstavljaju vrstu objekta. Vrsta objekta pampti se upolju kind i ona dobija vrednost neke od ovih konstanti. Zatim za objekac je pampti ime i pampti se tip programski tip objekta to je objekat klase struct, u kome ćemo nakradno pričati i to, ova tri podatka kind name i typesu zajednički za sve vrste objekata. Sad sledi polja koja neke vrste objekata poriste. Odnosno, još jedno zajedničko polje je next, to je pokazivač to jest referenci na sledeći zapis u jednostru kuglančanoj listi koja odgovara odredjenom tekućemo obsegu. Zatim slede te specificne atributi. Adr je ako je objekat vrste konstanta predstavlja vrednost konstante a ako je objekat vrste promenjiva polje klase ili metod predstavlja adresa kako smo maločo diskutovali razljiste vrste adresa sledeće polje level za promenjive pampti nivode klaristanosti da li su lokalne ili globalne a za metode se u tom polju pampti broj njihovih formalnih parametara. I konačno imamo listu pokazivačna listu i objekata koja je koristi metod za svoje formalne parametre i lokalne promenjive oni se zajedničku ulačavaju listu pa ovo polje levelu stvari kaže koliko članovaliste sa odnosina formalne parametre a ostatak su lokalne promenjive. Kao što rekoh ovo je jedan priječno ružan stil kogotov da se isto polje u različitim vrstam objekata koristi za razne namene ali realno gledano to se mnogo češće pri pojavlju na programima nego što bi trebalo. Ja sam samo reka u odbranu ovog dizajnerskog rješenja da uprošćava ovdje prikaz nekih fragmenata na predavanju. I sad kad znamo struktur u objekta, kako izgleda deo struktur koji se pampti u tabeli simbola za ovaj niz deklaracija način imaćemo za svako ime koje se ovdje pomije pojedan i instancu klasa oboje i popunjena su odgovarajuće polja prema vrsti objekta način ovdje navedena vrsta objekta, ovdje navedeno ime pokazivačno sljedeći zapis poslednji objekatima krajliste. Adresa za konstante predstavlja vrednost konstante za promenjive to je sve zavisi, vidimo ponivo da su ove 3 promenjive globalne promenjive, imaju level 0 ovo je oblasti globalne podata relativna adresa u adresa kde je preveden kod metoda
 čuvaju se u posebno, moj krajava virtual machine u posebnom delu memorije, programskom kodu to je poseban vektor, posebno delu memorije. Level polje metoda oznacava da ovaj metod M ima jedan formalni parametar i znači ova lokalnjska lista ukazuje znači na taj jedan objekat koji reprezentuje formalni parametar metoda M, to je znači X, on je isto vrste promenjiva i ima lokalnu adresu onom okviru metoda 0 i nivo je jedan što znači da nije globalna promenjiva nego lokalna. Na početku prevođenja tabela simbola nije prazna, nego sadrži već neka tako zvana predeklarisana imena. Ta imena važe u celom programu. Ta imena odnosuje se na standardne tipove, o tipove ima ćemo pričati u posebnoj lekciji, zatim odnosuje se na standardne metode. Metod ORT služi za konverziju znakovnog tipa u celobrojni, znači da je kod određenog znaka, metod CR obrnuto znači za određeni kod, da je njemu odgovarajući znak, metod LEN da je dužinu nekog niza vektora u mikrojava program, znači broj njegovih elemenata i konačno postoji Konstantanal, slično kao u javi, znači kad deklarišete uvedete promenivu tipa, recimo neke klase, dok ne instancirate objekat klase, vrednoste promenive je null. Kako izgledaju strukture podatak u tabeli simbola za ta predeklarisana imena? Evo vidimo znači nije iz objeknih zapisa za svaki od ovih pomenutih pomenute stvari. Mogu samo reći da ovo još nije kompletna slika, da ove fale informacije od tipovima i takođe fale informacije o obsezima, obsek predeklarisanih imena, inače naziva se Univerz u mikrojavi i on je stavno aktivan kao najkrajni spoljnji obsek, nad njim nema nikakog drugog obsega. Ovde vidimo još jednu pribelešku, a to je da za ove redefinisanih stvari teorijski može i na drugi način da se reši njihovo korišćenje, a to je da se oni ne pamte u tabeli simbola kao predefinisane imena, nego da recimo na nivo u grammatike uvedemo posebne ključe reći i posebne smene koje obradjuju sve ove objekte sa specialnim značenjima. To bi dosta komplikovalo stvari uvelo nijegih specialnih slučeva i pri pretraživanju i komplikovanju u grammatiku i takođe, tako da je ovo u suštini mnogo elegantnije rešenje da se ova imena stave u tabelu simbola. Zanimljivo je da u mikroj javi, još s to da pomenem, način ključne reći, to su ove reći sa specialnim predefinisanim značenjem, na primer kao što je int. Nisu ujedno i rezervisane reći, znači često se u literaturiju progrenskih jezici međi zjednačala značenje ključne reći i rezervisane reće, ali postoji znači subtil na razlika, znači ključna reć je neka reć sa nekim predefinisanim, specialnim značenjem kao što je to ovde recimo int ili konstantanal, rezervisana reć, znači reć koja njen označenje njen označenje njeno značenje ne smedase redefinishe, znači ima neko određeno značenje i ono je konstant. Međutim zanimljivo je da u mikroj javi ključne reći nisu ujedno i rezervisane, odnosno nije sprečeno da programmer uvede na primer svoju promenjivu koje bi nazvao baš int. Kakav bi to onda imalo posledice pa u tom obsegu gde on uvede promenjivu int, on više ne bi mogao da deklariše nije jedno celobrojenu promenju, jer bi prosto promenio značenje ove reći int, znači to može da bude korisno, ali ne, i u principu zato neki jezici to ograničavaju. Saćemo videti kako se u tabeli simboljene pante i obrađim informacije o obsezima imena. U programu blog struktureranim jezicima, kao što smo videli, a to spada i mikroj java, postoji hierarchija obsega imena. Znači na najvišam nivou hierarchije je obsek predeklarisanih imena, tako zvan i universe, zatim dolaze globalne imena, koja naravno važa u celom programu. Znači ako deklarišete na nivou programa neku promenju, to je globalna promenjiva i njeno ime će stviti vidljivu celom programu, zatim ako uvedete, deklarišete neku klasu, vi u stvari otvarate noviju obsek, tako da sva polja klasa i metodi te klase pripadaju obsek u te klase i konačno kada se deklariše neki metod, parametri i lokalne imena imaju obsek metoda. U svojana je realizacija sa lokalnim pamćenjem tih kolekcija objeka, tonosno svaki obsek ima svoju posebnu kolekciju listu, onih oboj je zapisa. Za samu reprezentaciju nekog obsega uvodi se zapis scope. Njegove komponente su pokazivač na spojlni obsek, tako da preko tih pokazivača se ovi objekti u tokurada kompajlaro ulančavaju u jednostru u ulančanu listu, koja kreće od te kućego obsega, pa ide kao onom spojljnom obsegu, znači na kraju liste je uvek univerz. Zatim imamo pokazivač na listu objekata, koji pripadaju ovom obsegu, znači koji su deklarisani u posmatranom obsegu i imamo broji, promenjivih broji ovih objekata, koji su deklarisani u obsegu. Vrednost ovog polja se zgodno koristi za alokaciju adreser, videli smo da su štini za sve vrste objekata, koji zahtevoj je adres, u adreser prosto, pošto svakavrste objekta uvek zauzima po jednu memorisku reč, da prosto samo sekvencijalno dodeljujemo te adrese i za to uvek možemo iskoristiti, znači ovu envars promenjivu, znači kad ubacujemo novi objekat, mi ga ulančamo u ovu listu i iskoristimo, znači uvećavamo ovo envars, pridružimo objektu tu, ažurirano vrednost envars. I, pored ovi scope objekata, imamo jednu promenjivu top scope, koja ukazuje na početak, pošto sam rekao da su u toku rada kompajlera svi ovih obsezi ulančavaju u jednu listu, koja pokazuje aktivne obsege, na početak te liste ukazuje ovoj top scope. Pokazivač koji je atribut cjeletabele simbol, i to ostupanje i ostapu kumpajlera kroz te interface-tabele simbola. Znači obsedi se, kao što sam rekao, ulančavaju kolekciju tipa stack. Evo kako to izgleda na primeru, znači ovaj primer ima neka program, sad taj deo, koda nije prikazana, ovdje bi u mikrojavi pisao program, ime programa i onda bi te kišle, evento nekihlovo nepromenjive, i onda deklaracija klasu. Ako je trenutna te kućerinija posmatrađa, dokle kumpajler doša uunutar ovojga metoda M. U tom trenutku izgled tabele simbola bit će sledaći. Ovde su prikazani ovih scopi, objektni čvorove fale, samo oni strakt čvorove o tipovima, pošto oni možete nismo pričali, ali znači u trenutku kada počinje kumpajlerad formirat će se samo ovaj jedan scope i top scope bi ukazival samo na ovaj jedan čan, i to je scope univerz, odnosno prede finisan imena. U trenutku kada se naiđe na ovde nedostajuću deklaraciju program ime programa, otvara se opsek programa i sve što je globalno, recimo, ovde je ime ove klase k, ide u opsek programa. Znači u trenutku kada se neke opsek otvara na vrhovo skop steka, to da je se novi zapis i onda ovaj top scope znači ukazuje umesto na ovaj, sad ukazuje na ovaj, a ovaj ukazuje na ovaj univerz. U trenutku kada naiđemo na deklaraciju klase k, znači još ovo ime kase, upacio u program skop steka, neposredno imena se otvara način ovih opsek klase k, znači formira se novi scope zapis i tako u lancavu listo ovih aktivnih opsega da je na početku liste i tada znači u opseku klase k su polja klase k i ime metoda m. U trenutku kada projde znači ime metoda m, otvara se lokalni opseg metoda m i onda ovaj formalni parametar metoda m kao i lokalne promenjive bc u lancavaju se u lokalni opseg metoda m. Razmotrićemo kako se sa usvojunom organizacijom tabele simbola obavjaju osnovne operacije u tabeli simbol. Pretraga imena u tabeli simbola pri likom svakog korištjenja realizuje se metodom find, znači to je del interfejsa tabele simbola prema imenu, pretraga ide kroz listu aktivnih opsega kreće se od prvog elementalista na koju kazuje top scope i sada kone nađemo u toj listi objekata prelazimo na outer preko onog 4-buta u zapisu scope dolazimo do okružujićeg opsega i onda pretražemo u njegu ovaj listi i tako dalje, da će ovdje je prikazan kod implementacija find metoda znači krene so top scope, pa sve dok postoji znači aktivan opseg ako naravno u tekući tracine nađemo ime prelazi se na sredeći okružujiće opsega sada u nutri jednog opsega ide se kroz onu lokal z listu dogod kostoj elementi i prosto se poredi znači zadato ime sa imenom objekta zapančeno u listi dođe do poklapanja, vraća se pronađeni objekat e sad šta se deša u slučaju da i zađemo skroz, prođemo kroz sve opsega i ne nađemo traženo ime znači treba prijaviti grešku da ime nije nađeno znači to je greška u programu i vraća se posebna vredno znači pošto treba vratiti zapis
 tj. objekat. Kako obječu kio da ako ne nađemo ništa vratimo nao, konstantu međutim, ne vraćamo nao, nego vraćamo posemu vrsto zapisa koja se zove no object. Ona je ist jedna vrsta predeklarisanog objekta, koji nije ulančan u ove skupove postojeće jer ga nećemo tražiti po imenu, nego ćemo ga vraćati samo u slučaju greške. Kao što vidite, on je određeno da je vrste promenjive i da ima neko svoje specijalno ime. E sad zašto vratiti ovakav poseban objekat greške, a ne prosto navu vrednost, pa logika je slična kao kod, nadam ste pričali, kaj ste pričali o i triple i standardu brojeva u pokretom zarazu. I tamo se pričalo o timaritmetičkim operacijama nad brojevom u pokretom zarazu koje nekad mogu da rezulti u grešci, naprimer deljenje sa nulo. I da postoji dva načina obrade greške, jedanje da se odma signalizuje greška, a drugo je ona i tako zvanih silan tihi režim, kada recimo, konisti se vrednost koja se zove not a number, znači neka operacija prostak od ođer do greške neće signalizovati grešku, ali će kao svoj rezultat vratiti tu specijalno vrednost not a number. Ako nije iz operacija izvodimo, znači u nekih složeni izvodimo nije iz alitmetičke operacije, ako sad sveća alitmetičke operacije, znači ako ne je ispitujemo, posle svake operacije da je došlo do greške, nego tek na kraju kada izraču nam o vrednost celog izraza, znači ako sveća operacija na ulaz u dobije not a number, ona će prosto samo na izlas proslediti opet not a number, znači neće se raditi nekak operacije. I na te način je omogućeno da izvedemo nije iz nekih operacija i tek na kraju ispitamo eksplice da je došlo do greške, znači da je rezultat neki validan ili jednot a number. I ovo je znači slična ta logika, mi možemo nekoliko stvari da uradimo na tabelom simula i tek na kraju ispitamo šta je objeka, tako što videmo sami metodi, tabele simula imaju ugrađenu diagnostiku, znači ako se koja je neka greška, inicijela će prijavu greške krajnjem koristiku. Sledneća operacija na tabelom simula je insert, to jest u bacivanje neku gimena u tabelu simula, znači insert ima tri parametra, to su upravo oni zajednički atributi bez obzira na vrst objekta, znači ima objekta njegova vrsta i tip objekta instanca klasestraktu koji ćemo nakranopričati. Šta radi, šta treba da uradi insert, znači on treba da proveri, da li već postoji objekatistog imena u aktivnom obsego, a to je ona je obsek na koju ukazuje topskog. Ako već postoji objekatistog imena, onda je rečo grešci, ne može dva pu da se deklarišu u jednom obsegu isto ime, bez obzira da je ta druga deklaracija iste vrst ili nije. Naravno ako nije došlo do greške, kreira će se novi ovej instanca klase objekac, ovim zadatim, znači bi će popunjeni ovi atributi koji su zadati polja, koja su zadate, bi ćemo dodeljena prva slobodna adresa, zašto si koristio najen varzi scope zapisa, automatki se isto dodeljuje nivo deklaracije za promenjive, dar je glopalna ili lokalna, pošto to tabela može preko to tih scope ova da proveri. I znači sam objekac se dodeljuje na kraju, one lista objekata koja se pamti u topskou plokals, znači tu je talista objekata i na njen kraj se dodaje promenjila. Postavlja se pitanje gde se u ostatku parsera pozivaju ovi metodi find insert i tako dalje. Naravno oni se pozivaju kao posledica sintaksno upravljanog prevođenja, odnosno semantičke analize programa i u krajnje linii parserije odgovoran za njihovo iniciranje. Ovde kako sam ja prikazal, podrazumeva se semantička obrada putem akcioni simbola grammatike. Druga varianta semantičke obrada je da parser izgradi sintaksno stavlo programa, a onda da se posebni mehanizmima, to je vizitor Shablon u objekto linii sanoprogramiranog, prolazi kroz stavlo i na određeni mesima inicira određena obrada. Ovo je obrada ako direkto ugrađujemo akcije u grammatike smere i onda bi u principu parser već pri parsiranju programa sprovodio ove akcije. Vaš projeka domaći zadatak nekad je koristio ovu ovaj način semantičke obrade, a sada se koristi putem izgradnje i obilaska abstraknog sintaksnog stavla, to može vrlo lako da se jedan način pretaba u drugi način, više ćete na vežbama slušati o semantičko obrada putem posjećivanja čvorova stavla. E sada vidimo u nutar smene, gde može da se inicira u bacivanje objektu tabelu simbola, u deklaraciji promenjive, čim prođe ime promenjive, treba pozvatnivacivanje korasta je objekta je promenjiva, ime se dobija kao atribut iz leksičke analize kao atribut ovog terminala ident, a tip se dobija kao atribut ovog grammatičkog simbola type, zato je za type postoje opet posebne smene koje će da razreše tip i koje će vratiti, znači jedan strukturni zapis preko ovoga atributa koji ćemo mi ovdje iskoristiti u pozivu. I ovdje je prikazana smena u konceptu olanje primer, smena je prikazana u proširenoj BNF notaci, znači deklaracija promenjiva, recimo može da ima tip int, pa onda ide nizimena x, arizipsan, zarestet, znači ovaj del opisuje ta dodatna imena i za svakog imena treba pozvati na isti način ovot app insert. Ustositiča obrade obsega, znači tabela simbola treba da ima metod za otvaranje obsega i za zatvaranje obsega. Za otvaranje obsega je ove metode open scope, treba da se napravi nova instanca ovog scope objekta i da se u lanča u listu aktivnih obsega na početak telist. Njega treba parser da poziva ove metode kada se naidila na početak obsega, odnosno to je početak programa ili čim prođe ime klasse ili čim prođe ime metoda. Za zatvaranje obsega koristi se metod close scope koji izlančava tekući obseg iz listu aktivnih obsega, tako što prosto top scope namesti da pokazuje na sredeći u listi. Ovo je metod poziva kada parser naidila na kraju obsega, a to su situacije kraja programa završne vitiča ste zagradu od klasse ili od metoda. Primer sa dramatiskim smenama, znači imamo smenu za deklaraciju metoda, gde ta smena se stoji od povratnog tipa metoda koja ima uvej atribut strukturni čvorn type, zatim ime metoda, znači to je token sa atributom stringom imena. Čim prođe ime metoda, potrebno je ubaciti to ime metoda u trenutno aktivnih scope, a posle toga otvoriti lokalni scope metoda. Dosta je važno redos poziva ove dve metode se ne uvradi obram. Ovdje ide deo smene koji nije prikazane, spoljkazane sa 3 tačke koji se odnosi na dramatiske smene za samo telometoda lokalne deklaracije i na izvršnji deo. Znači nije iznaredbi i konačno smena za deklaraciju metoda zavašava se za vašno viti često na zagradom. Na samom kraju te smene potrebno je zatvoriti lokalnih obseg metoda, ali pre zatvaranja obsega da ne bi nam nestali lokalnih načinalista lokalnih objekata metoda koja se stoji od formalnih parametari lokalnih promenjivi. Potrebno je zapamtiti metod je objekti zapis za tekući metod koji je formiran pri ovom pozivu insert. To treba da zapamtiti u nekoj pomoćaj promenjivi, pa u njenom polju lokalstreba zapamtiti tu listu iz tekućeg lokalnih obsega pre nego što se on zatvore. I evo animirano znači kako to u suštini izgleda ako ovo neka početna situacija kada dolazi telometoda M, onda se u onom predhodnom, to je bio globalni, obseg koji govora glavnom programu znači bilo je ubačano ime metoda M, a posle otvaranja obsega formirano na uvroku steka obsega noviprazan obseg i sad kada dolaze lokalne promenjive M, ubacujemo upravo u taj obseg ovo IB, kada na kraju tela metoda dolazi do zatvarađa metoda, mi ćemo izlantčati taj lokalni obseg iz ove liste, ali ćemo IB zapamtiti kao atribut ovog objekta M, tako da ta informacija neće biti izgubljena. I konačno sa svim ovim dosadašnjim saznanjima možemo prikazati jedan kompletni interface tabele simbola, znači vidimo ova četvrjostnona metoda insert find open scope i close scope sa svojim parametrima, vidimo da postoje direktni pokazivače na neke predefinisane objekte i tipove, vidimo ovaj top scope listo aktivnih obsega i takođe, ostate kompara može pročitati nivo ugnježdenosti tekućeg obsega, znači dalje globalni obseg ili lokalne. U principu implementaciji koji vidite u vidu jar biblioteka i ovaj još par svar, znači sve ošto se ja priče malo abstrakovano, a tamo imate joši teratore i tako dalje, znači to su naravno pomoćne stvari da vožete to je efekta da upotrebite, a ne utiču toliku na ovu konceptualnu priču. U nastavku lekciju o konstrukciji tabele simbola za mikrojavu bavićemo se predstavljanjem tipova u programu i proverama tipova. Svaki programski konstruk, dilo da je deklaracija izrazili iskas, ima svoj tip. Vrste tipova u mikrojavi su osnovni tipovi način koji ne mogu da se dalje razloženo prostije komponente celobrojni i znakovni, u nekim variantama kada se zadeje domaći zadatak može biti i logički puo tip. Izvedeni tipoli u mikrojavi su nizovi i klasse. Tipovi imaju strukturu, odnosno imaju određene svoje osobine, imaju memorijsko za uzjeće, znači koliko promenjiva određeno tipa zahteva memorije za pamćenje vrednosti, u nekim vrednosti se izvedene tipove tu su i drugi osobine.
 što su kod nizova broj i tipovi elementata niza kod klase definicije članova klase polja i metoda i tako dalje. Tipove možemo predstavljati tako zvanim izrazima tipa. Oviso više o definišu počas i od osnomih tipova da oni predstavljaju izraz tipa, zatim ime tipa, to je kod koristničkih uvedenih imena na primjera klasa, predstavlja izraz tipa, a zatim se izvedeni tipovi dobijeli primjeno tako zvanih konstruktura izvedeno tipa na neki izraz tipa. Pogodan metu za predstavljenje izraza tipa su grafove. U slučaju mikrojave grafove tipova sadržaće strakt i obojr zapis. Saćemo videti dostad obojr zapis, pe smo već definisali, a strakt zapise, odnosno klasu strakt, mikrojavata, bele simbola, sad preledamo njenu strukturu. Prvo imamo niz simbolički konstanti koje se odnose na vrstu tipova, znači za celobrojnih znakovnih nizove i klase. I imamo naravno akon nije nikakav tip. Polje kind upravo pamti jednu od ovih konstanti, tako da onda znamo na koju vrstu tipa se odnosi odgovarajući strukturni zapis. Ostala polja u ovom strukturnom zapisu imaju interpretaciju zavisno od ove vrste tipa. Znači polje tip elementa lm type je preferenca na drugi strukturni zapis i kod nizola se koristi da opiše tip njegovih elementa, a ako od klasa se koristi kao pokazivač na nad klasu, ako ovaklasa izvedena iz neke druge klase. Zatim imamo celobrojno polje n koje klasa predstavlja broj članova klasa, i polja i metoda, i zatim imamo pokazivač na listu objeknih zapisa, koji predstavlja u članove klase u listi prvo ide niz objekničora koji opisuju polja, a zatim ide u objekničorove koji opisuju metode klasa. Ovo još nije kompletna definicija ove klasa strat, u smislu da klasa strat posledu je i neke metode za proveru ekivalentnosti tipova, o čemu će nakradno biti reči pa ćemo onda uvesti i te metode. A sad da vidimo kako se u mikrojava tabeli simbola reprezentuju različiti tipovi krenućem, od najjednostavnije godnost ovih ostanih tipova celobrojnog iznakovno, na primer da imamo ovaj niz globalnih recimo deklaracija, znači dve celobrojne promenjive a i b i znakovnoj promenjive u c. U tabeli simbola imali bi smo listu, svači objekni čvor opisuje jedno od ovih promenjivi, znači promenjiva a, ime promenjive, zatim ovo polje type koje dosad nismo prikazivali, koristili, u suštini se koristi da opiše tip promenjive i ono ukazuje na strukturni zapis. Znači po konvenciji objekne zapise uvek crtamo kao pravogonike, a strukturne zapise crtamo kao pravogonike zaobljenih uglova, tako da odmah razlikujemo koja vrsta čvora, znači strukturni čvor vrste int opisuje osnovni celobrojni tip, ova druga polja se ne koriste, plen type je 0, n i films se ne koriste. Vvaža je napomenuti da u celoj tabeli simbola postoji samo jedna instanca ovoga strukturna zapise i sve promenjive u ovom konkretnom primeru a i b koje su celobrojnog tipa, ukazuju na ova isti čvortoje, videte ćemo važno posle kod provere tipa, da li su dve promenjive istog, odnosno ekvalentom tipa. Promenjiva c isto ima svoj objekni zapis i njen tip ukazuje na strukturni zapis koji je vrste znak, isto sa ova druga polja ne koriste, isto iznakovni tip, znači sve promenjive u programu koje su znakovnog tipa, ukazivaće na ovu jednu i jedinstvenom instancu ovog strukturnog zapise. Naravno, ova neka druga polja u ovim objeknim zapisima za promenjive su njihove adrese u lobalnoj oblasti, memorie koje sekvencije alo se dodeljuju i vidimo da su u pitanju levolj jednako nula globalne promenjive. Kako se predstavljaju nizove u mikrojavata, Belisim, ola ovdje imamo deklaraciju jednog celobrojnog niza, a, naravno, da bih ga koristirio u programu, potrebno je isto kao i u javi, ali to je delo izgošno koda, znači nije deklaracija, reći, upotrebite operator nju, znači istog kao i kod jave, da bi se dodelila ovaj, znači, ovaj promenjivo i vrednost, ona zasađa samo referenza na nizu i imamo jednog celobrojnog promenjiva u B. Znači u mikrojavata Belisim, ola imamo listu zastanjenog 2 objekta čora za reprezentovanje promenjivih A i B i tip promenjive A ukazuje na strukturni zapis vrste niz, a LM type polje tog strukturnom zapisa ukazuje na zapis koji se odnosi na celobrojni osnovni tip. Klase imaju složeni zapis u tabeli simbola, pa ćemo kroz nekoliko primera, trenućemo od jednostavnih primera ka složeni im da vidimo sve osobi me ovoga zapisa. Znači, prvi primer je najjednostavni i mogući klasa C koja ima 3 polja xypselonicet, ona nema metode, niti se nasleđio neke druge klase i imamo promenjiv u V koja je tipa C naravno, za korišnje je promenjive V, treba operatorom Njujev je prvo dodeliti instancu klase C i tako dalje, ali to je deo izvršno koda, tako da nas ne zanimamo u ovom primeru. Kada par se naiduje na deklaraciju klase, on stvara odgovarajući objekni zapis u tabeli simbola, taj objekni zapis, panti će ovo ime. U tom čvoru polje tipa pokazuje na novih, da kažem, zapis strukturnog tipa či je polje fields, treba da pokazuje na polja klase či je ovo se deklaracije obrađi. Znači za ovaj primer, kako izgledaju grafoske struktura u tabeli simbola, objekni čvor koji panti ime klase i njegovog polje tipa ukazuje na strukturni čvor koju suštini opisuje struktur u ove klase. Vrste je klas, Ellen type je nul, pošto ova klasa ne proširuje ni jednu drugu klasu. Klasa ima tri polja i pokazivač na listu objekni čvor ovaj field, lista znači polja i sadrži pojedan objekni čvor za svaku polje klasem vrsta togo objeknu čvoru je field polje klase, znači nije var. U pitanju su celogrojne polja i njima su dodeđeni 0,1,2 u suštini pomera i u objeknom zapisu, u memori, znači kad se instanciro objekat ove klase na pomera i 0 će biti polje x, na pomera i 1 polje y, na pomera i 2 polje zet. Sledači primer vezan za klase ilustruje opisivanje klasa koje imaju i u običajne dinamičke metode. Svaka klasa osim glavnog programa kojih stomažemo tretirati kao jednu klasu što se tiče tabele simbola. Znači svaka klasa ima virtualnu tabelu metoda, tako zvanu v tabelu. V tabela se čuva u statičkoj oblasti memorije, adresa prve reči ve tabele u statičkoj oblasti memorije, se pampti u objektnom čvoru klase u tabeli simbolja u polju adr. Imamo primer, razmotućemo primer jedne konkretne klase C koja ima 3 polja i 2 dinamička metoda mag imet. Ovoj klasi odgovara ovaj graf u tabeli simbola, znači ime klase se pampti u objektnom čvoru, polje tip ukazuje na strukturni zapis koji opisuje struktur u klase, a polje adr ukazuje na početno adresu u statičkoj oblasti memorije, virtuela tabele ove klase. E sad treba napomenuti da virtuela tabela klase je jedna struktura podataka čiju strukturu compiler zna, ali koja svoje korišćenje u stvari i existenciju ima tek u vreme izvršavanja programa i ova statička memorijskoj oblasti u stvari jedna oblast memorije u mikrojava virtuela masini znači ona ne egzistira ova tabela sa svojim sadrežem ne egzistira tokom prevođenju u compileru nego tokom izvršavanja programa znači compiler mora da obezbedi da na početku izvršavanja programa se deo statičke memorije napuni ovin podacima i kasnije kad dođe do poziva znači dokoj dženja programa kad se poziva u dinamici metodi klase ova tabela se koristite da radreši poziv. Znači compiler o njoj samo zna šta koji sadreži treba da se unusmesti i znači na kojoj adresi u statičkoj memoriji. Kako izgleda struktura virtuela tabele u mikrojavi znači virtuela tabela je jedne klase ona ima niz ulaza za svaki metod klase konkretno ovom primjeru imamo 2 metoda prvi ulaz je ide od ovoga m do oga code adder 1, drugi ulaz ove tabele ide od ove čelije ispod do ovoga code adder 2 i kraj tabele signalizuje ova konstanta minus 2 znači kad više nema metoda na kraju liste je minus 2 je sad ulaz za određeni metod sadreži niz znakova koji predstavljio ime metoda znači mu ag i kraj niz za znakova označao se konstanto minus 1. svaki znak se pampti posebno u celoj memorijskih reči o 3 s 2 bit to je tako urađeno delo je rasipanje malo memori ali u suštini to olakšava u tokom interpretacije programa obezveđuje bržu interpretaciju a poštu u kupom broje metoda svih klasa nije tako velik znači nije toliko veliko trošenje memorije na ovaj detalj ime metoda završava konstanto minus 1 samo ime i poslednji element u ulazu koji je određeno metodu je početna adresa metoda u java bytecode i sve šta ga u
 program s koja oblast memoria virtuale mašine, a početnu znači adresu prevjedenog koda upisuje u ulad virtuale tabele. Uzatim ide za drugi metod metone klase znači prvo ni znakova koji predstavlje ime metoda, zatim Konstanta minus 1 značala kraj tomi izaznakove i početna adresa tog drugog koda za prevjedeni metod i kraj virtuale tabele. To je znači bila struktura virtuale tabele. Ono što je još ostalo, to je da se opiše struktura same klase, znači imamo struktu mi zapis klase. Klasa ima ukupno 5 svojih elemenata, znači 3 su polja i 2 su metodi, znači to su im dužina ove liste objektničvorova. Znači u listi objektničvorova na početku liste su prvo idu sva polja, to je koć svake klase, tako znači x, y, zet, a onda slede redom za svaki metod polja jedan objektničvor. Ono što na ovom diagramu nije prikazan jedan detaj, to je da drugi metod ima formalni parametra Q i onda bi tu postoje ododatni objektničvor tipa promenjive koji je vezan za ovaj metod. Znači da i detaj nije prikazan da bi se kompletirala ova slika. Šta još, Antrono, nismo rekli u opisu ove slike, objasnišmo struktur u virtuale tabele. Treba naravno još prisetiti se i posebno napomenuti da, takođe, ono što nije prikazano na slici, a što svaki dinamički metod ima, to je implicitan parametr dis. Argumentu dis odgovora isti strukturni zapis kao i klasi uunutra koje se metoda deklariše. Znači, ono što fali naravno i ovde, i ovde je pokazivačna dodatni objektničvor koji bi opisival, znači to ime dis i uunutra tog objektno čora imali bi polje type, bi ukazivalo na strukturni, upravo ovaj strukturničvor koji odgovora ovoj klasi. Znači to je prvi parametar i metoda mag implicitan, pošto on eksplicitno nema nije dana parametara, on ipak ima implicitan parametr dis, a ovaj drugi metod met ima, znači implicitan parametr dis, tipa klase c i eksplicitan celobreni parametr k. Znači te stvari parametri mi im su ovdje prikazani. Bi će prikazani u primeru u nastavku. Finalni primer za predstavljanje tipa klase je najsloženi i ilustruje naslijivanje klasa. Ovom primjero imamo dve klase, osnovnu klasu tkalk koja ima jedno polje tax. Ovdje je za potrebe primjero uvedeno kao da postoji i to je isto varijacija, na specificracijili kojave su je dešavaju kada se zadaju projektni zadači. I ovdje predpostavljamo da jedan od osnovnih tipova može biti i tip double, to je oni realni brojevi. Imojmo polje tax, osnovno tipa double i imamo metode kalk, price i check. Ovdje je isto ovo i primer je u sintaksi mikrojave, jer sintakse mikrojave zahteve i detaj to smo izostavljali zbog jednostavnosti ispretno i primerali, zahteva se detaj da kada prođu deklaracije svih polja i krenu deklaracije metoda mora otvoriti dodatan par ovih biti časti zagrada i onda ide nije iz deklaracija metoda. Metodi su kalk, price i imamo metod check u ovoj osnovi klasi tkalk. Klasu tkalk proširuje klasa atkalk, nače ona je nasleđena iz klaset tkalk i pored ovoga što nasleđuje, a to su ovo polje i ova dva metoda, doda je sopstveno polje a i takođe vidimo da rede finishe nasleđeni metod, znači pruža sopstveno implementaciju metoda kalk, price. E da vidimo znači kakva struktura podataka u mikrojavi tabeli simbola odgovora ovim deklaracijama. Kao što vidite primjer je dosta elaborira, ali ovdje su sad nijedan detaj nije izostavljen. Imamo za ime prve klase, prvi objekni čvor i onda je to uvezano na ime druge klase drugi objekni čvor. Struktur u prve klasa opisa najovim strukturnim čvorom. Ovo značava da na nekim drugim mestima, znači imamo u sušljeni pokazivače na ovaj čvor i da ovde je nazvan prosto, taj pokazivac nije crta na eksplicitna grana, orientisan odavde, dovde da se ne bi otrećivala slika, nego je prosto označeno, znači da je go odpiša tkalk, taj da u stvari ostoji pokazivačka u ovom strukturnom zapisu. Znači ovaj strukturni zapis odgovora klasi tkalka, ovaj strukturni zapis odgovora klasi atkalka. I sad rekli smo da osnovna klasa tkalka ona ima, znači svoje jedno polje tax, znači nekom tipa W. Znači tip W bi odgovaro jedan strukturni zapis, koji ovde je to i pa kima načinje kje detalje, koji nisu ekresivno natratan, znači nije natratan ovaj tip W, to bi bude jedan strukturni čvor, po što je to osnovi tip. I onda vidimo da u listi članova klasa, znači pozle polje idu metodi, metod kalk price i metod check. Znači ovde im je povratni tip za svaki metod, a ovde su sad eksplicitno prikazani parametri, znači koristi se ovna polje lokals da pampti, znači list o obitni čvor za parametre metode. I evo vidimo na implicitom parametra DISS, koji je za ovaj kalk price metod tipa ove, znači ukazuje na ovaj strukturni čvor za tkalka klasu. I posle toga ide ona eksplicitom parametra KOST, koji je onog osnovnog tipa W. Što se tiče drugom metoda check, isto imamo implicitom parametra DISS, da je to zelenka stom bojo na crtan, da se naglasi da je to implicitom parametra, ali da sve jedno moramo ga imati u tabeli simbola, isto naču ukazuje na tkalk tip i eksplicitaram parametr B, formalni parametr osnovnog tipa W. E sad kako tačno ide procesiranje deklaracije, kada imamo i situacije na sliđivanja, odnosno proširivanja neke osnovne klase. U sluče da klasa nasleđuje drugu klasu, prvo su tabeli simbola pronalazi čvor nadklase, pa se pravi je kopije čvorova koja je predstavljaju poja. Zastan se sve sam obrađaju poja, ne ime to, odi nadklase i te kopije se redom stavljaju tabelu simbola kao poja podklase. Kada se obrađuje ova deklaracija a tkalk, vidi se da je ona nasleđena iz tkalk, uzimaju se, pristupa se naravno, nalazi sa ova klasa tkalk, prvo njeno ime pa zatim ova struktura, pa se onda dolazi do ovoga poja. Poje se pravi se fizička kopije ovog objektnog čvora i popunjava se istim podacima. To sad postaje poje ove nasleđene klase. Ovde ovim plavi častom bojom, označena u pravo ta činjenica da je ovo nasleđeno poja. Šta se dalje rati? Positr toga se obrađaju poja, kod deklariše sama pod klasa i stvaraju novi objektni čvorovi, koji se dovezuju na čvorove nasleđenih poja. Po ranio opisanom principu proširivanja na desnom, i na nekome više memorijski adresama. U našem primjeru ova izvedena klasa ima poje A. Ovde u ovoj lista se nastavlja, tako da sledeći objektni čvor je poje odgovaratom pođu A. Sad tim kada su sva poja stavljanu tabelu svih vola dolazi na redu u bacivanja oboji o čvorove dinamicki metoda i čvorove se na dovezuju na čvorove poja. Opek će se prvo pogledati čvorove natklasa u tabeli svih vola i se da se da se vrdi je formalnih argumenata i lokalnih promenjivi i redom na dovezati na čvorove poja. Da vidimo samo dalje. Posle idu metodi koje deklariša sama pod klasa, podpis vake metode deklariša, nekod pod klase se prvuporedi sa podpisima metoda nasleđenih i nadklase da bi se ufrdilo dalje metoda redi finisana. Ako nije za tu metodu se pravi novij čor u tabeli svih vola, a ako jeste neće se praviti novij čor, reće biti modifikvam postojeći čor. Pod klasa koji odgovara to i metodi. Čor se modifikuje zato što je moguće da redefinisanja metoda nema istaj imena formalnih argumenata i broji tipove lokalnih promenjivi kao metoda koju redefinisana. Također redefinisanja metoda ima zaseban kodu proveskog memoria i pa treba promeniti po ljader čora metode. E sada jevo opet da se vratimo na primer i pogledamo šta sve kako procesiranje vezano za metode ove nasleđene klase imamo. Način nasleđena klasa prvo je rečeno da se prepišu način ovi i metodi to su cal price i check. Pristupa se struktura i ostore klase i krene se kroz ovu listu sada sa obrađuju metodi i vrši se fizičko kopiranje ova dva objeh na čora za cal price i check. Također je ovih povezanih čorova čitavog dela grafa koji opisoje nihove formalne metodi. Ode vidimo da im kopiranjem smo dobil cal price sa objehtim čorom za implicitim parametrem dis i inicijalno je bilo ovaj objehtnji čor koji se zval kost. Ode je finalno stanje pošto metodi je overaidovan onda je došlo da izražuje modifikacija podataka i modifikovanje vrednosti finalne su pisane ovdje. Inicijalno je ovde pisalo da smo izvašili kopiju dis je imao tkalk a lokalna promenjiva se zvala kost. Također kod metoda check smo bukvalo prekupirali parametre i vidimo da tu je samo jedna izmena bila u tipu parametra dis i nače drugih izmena nije bilo. Esad rečeno je da se proveri to su ti nasređeni metodi i posle toga se proverava dali sama izvedena klasa ima neke svoje metode da je postao neke poseban metod sa svim novom on bi se dalje na dovezival u ovoj listi za ovih metoda pošto u ovom primeru nevamo nekih nekog metoda nekog metoda nekog metoda nećemo dodavati ovu listu novog objekte čvorve nego ćemo naći ovoj postojeći objekni čvor koji je ovde za kalk prej svećunet i izvršiti modifikaciju potrebnih podataka zači srevenim su naznačene potrebne modifikacije prvo parametre dis nije tipa ove osnovne klase nego parametre dis mora biti tipa izvedena klasa
 u drugi metod koji nije on verajdovan, ali sve jednovek taj parametad disk treba posled gopiranja izmeniti njegov tip. E sad dodatno vidimo da u ovom donoj kalk price isto samo ne postoje lokalne promenjive, jedino će bi dodavali nove čvorove, nego postoji samo jedan formalni parametar, međutim u izbornoj varianti funcjon se nazivo cost, a u ovom promenjenoj varianti funcjon se naziva c. Zato moramo ime u ovom obiknom čvoru izmeniti u c. I time je obrađena kompletna deklaracija izvedene klasse i dobijen finalni graf u tabeli simbola. I sad još da vidimo ovaj slide prikazuje početno stanje tabele simbola sa predefinisanim imenima i njihovim tipom. A znači mi smo već imali sličan slide, ali on nije bio kompletan začo su ne dostali svi ovi strukturni zapisi koje tada još nismo objašnjavali. Sad vidimo kompletni usliku gde imamo sve te potrebne. Vidimo takođe da postoje direktno interface u tabele simbola i direktni pokazivači da kažemo referenci na ove neke predefinisane ugrađene tipove i tip constanten null je null type. Konstanten null ima svoj poseban tip null type. Van toga znači imamo naravno za ugrađene tipove, imamo za njihove imena i objekne čvonove in thar i ovo smo rani objašnjavali način konstanta end of line, konstanta null koja kao što sam reko null tipa i imamo metode za konverzio između znakova i celogrojnih vrednosti i obrnu to i metod koji određuje dužinu nekog niza, to je i brojela menata niza. Zagnitivu, a recimo, taj detač da taj metod len, naravno kao parametar prihvata neka ka niz i taj niz kao formalni parametar, znači opisanje kao niz ima uve istruktine čovrej, međutim zanimivaj da je tip njegovih elemenata tako zvani null type, nači poseban ugrađeni tip. Inači ova null object je ona i objekni zapis, to je ona posebna vrednost, da smo reklji da se javlja prilikom raznih rešaka, da vam se ima fin, ne nađenek promenju. Međutim, zašto je formalni parametar ovo glen metoda, ovo i niz koji ima kao tip elemenata null taj, pa videćemo da je to isto jedna posebna vrednost, uvedena zato što ova glen metoda može da se primen i na biloko i niz, znači kakav god niz da deklarišamo sa biloko no vrsto vele menata, ni na njega možemo da primenimo len. I videćemo da pri programa tipa kada pozivamo len, onda naravno formalni parametar zamenjujemo stvarnim i moramo proveriti, dali se stvarni parametar po tipu može dodeliti formalnom parametru. U toj proveri videćemo da posebna grana za ovaj null taj podgovara, znači bilokom tipu, bilokom organizam, znači dvok toga ovo nije mogu biti celog broj, ili neki konkretan tip, nego je morala biti posebna vrednost null type. Ostalo je da vidimo kako se vrše provere tipova u mikrojavi. Generavno gledano sistem tipova je upravila kako se dodelju tipovi različitim delovima programa radnih dekaracijama i drozima iskada. Za mikrojava jezik sistem tipova definisanja delovima specifikacije oddeljkom a3 semantika i oddeljkom a4 kontekstni usvone. Možemo pogledati taj del o specifikacije mikrojave. U a3 oddeljku koji definiša se mantika u mikrojave, vidimo da ti preferenci se odnosi na nizove i klasse u mikrojavi. Zatim definiša se tipovi konstanti celog brojne znakovne u ovoj varianti donoće dodatka bilet su i logičke konstante. Zatim definiša se kada se tipovi smatraje ekvalentima. Dva tipa podataka su ekvalentna, ako imaju isto ime, ili ako so oba nizove, a tipovi njihovih elemenata su ekvalent. Videte ćemo kastije da će ova i još nekolikovi sredeći rečenice imati svoju direktnu implementaciju u proveri tipova u metodama koji se koriste u tabeli simbola. Dva tipa podataka su kompatibelnako su ekvalentna ili ako jedan od njih tipa preference, a drugi je null tipa. Ova vide ćemo definicija su u suštini koristi kada, na primjeru, poredžujete dve promenjive xy, znači da bi kompajlet prevevo to. Poredženje prvo mora da se uveri da poredite kompatibilne promenjive. Takođe imamo kompatibilnost tipova podataka pridodeli. Izvorišni tip je kompatibilnom pridodeli sa odredišnim tipom dvz. Ako su izvorište i odredište ekvalentni, ili ako je odredište tipa reference, a izvorište tipa null, ili ako je odredište reference na osnovom klasu, a izvorište referenci na izvedenu klasu. Ovo je potrebno pli obradi eksplicitni dodela, na različenju x1 y, ili pri pozivu metoda kada se formalnom parametru dodelju je stvarni parametr. Znači u svim tim situacijama mora se proveriti, da li su izvorište i odredište kompatibilni pridodeli. Takođe vidimo da delo ove semantične specifikacije sa odnosim na definiciju, šta su sve predeklarisane imena u mikvoj avi, obseg važenja i tako dalje. Sredneća sekcija je konteksni uslovi koje se dele na neke opšte konteksne uslove i onda imamo za svaku konstrukciju jezika, to nam je uon trenutku zanimljivije, za svaku konstrukciju jezika imamo šta sve, znači treba proveriti, tipično su to, znači provere koje su deo semantičke analizaje kompajlera pri prevođenju programa. I to ima za različite, znači jezike konstrukcije, deklaracije, izraze, iskaze, ima puno znači tih konteksnih uslova, mi sad ne možemo da gledamo sve redom, ali recimo, da imamo možemo pogledati na primjera za if naredbu, kaže, u koliko je vrednostu uslonog izrad za true, izvašavaju se naredbu i u grani, suuprato mi dašavaju se naredbu Verozgrani ako je navedena tip uslonog izrad za condition, mora biti bu, znači to je, recimo, uslon koji kompajlera ne mora da proveri, ali ja imamo, recimo, da pogledamo u izrazima, ako je, nači, nekakva operator sabiranja i operandi su ove x-pressioni term, znači, x-pressioni term moraju biti tipa int, u svakom slučaju tipom, izraxpressioni term, moraju biti kompatibilni. Ako je ovoj operator sabiranja kombinovanja elektmetičke operatorna, če ove varianti domači gozvoljavalo sa uno plusi, jednako, kaže, x-pression mora odnačalati promenju element niza ili poljevunutra objekt. Proverom tipa implementira sa određeni sistem tipova. Provera može biti statička koja vrši kompajler, znači, u faziji semantičke analize, ili dinamička ako se izvedi u vrema izvršavanja programa. Naravno, dinamičke proveri mogu se vršiti pod uslovom da obiti u programu nosi informaciju tipu u vrema izvršavanja. Recimo, u c++ mora biti onog ućen runtime-time-identif informešel mehanizam, tako da onda su tekna raspolagali određeni ovi operatori koji vrše dinamičke provere. Jezik se naziva strogotipiziranim, ako definicija jezika podrežena statičkim i dinamičkim proverama tipova, garantuje da u izvršavanju programa neće doći do neprimećane greške upotrebe pogrešno k tipa u raznim jezickim konstrukcijama. I ovi jezici sa klasičnim premođenim kao što su javac, c++ i sharpi, tako dalje spada i u testrogotipizirane jezike. Njih ćete prepozititi po tome što zahtajevaju od svojke promenjive da bude deklarisana sa određenim tipom prekorišćenja. A su protost njime su slovotipizirani jezici, to su tipično razni skriti jezici, gde se ne zateva da promenjive budu deklarisane prekorišćene, nego prostom dodelam vrednosti. Znači ako u jednom delu provera napišete x1 koji je neki string, znači da ćete prosto uvodite promenju x i ova u tom ten od koji ima tip. Stringa ako uslećeli mi napišete x1 koji je jedan, znači dodelili ste nogu vrednost promenjuva i promenili njen tip, koji je sad celom vreni. A znači, tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. tj. Eklientnost po imenu znači da su tipovi reprezentovanji jednim istim čvorom u grafu tipova. Naprimera, kad uvedemo jednom deklaraciju, dači dve promenjive nekoh tipa t, one će u reprezentaciji u mikrojavata berisim vola, znači postoja će, naravno, dva ovjetna čvora za i b i njihovo polje type će ukazivati na potpuno isti strukturni čvor. I to znači ako ukazivano identično čvor da su eklient tipova imena. Eklientost tipova po strukturi. Rekli smo da u očne slučaju ne znači da su eklient tipova imena, odnosno, nikoji tipovi ne ukazivano isti čvor u grafu tipova. Evo, jedan konkretan primer. U ovom primeru imamo klasu x koja ima dva celobrojna polja i klasu y koja isto ima dva celobrojna polja. Ivena polja nisu ista u klasama x, y niti su naravno imena klasa ista. I zatim imamo promenjuvu v tipa x, ovo je referencija na klasu x i tu promenjuvu duplo v tipa y. I kad to reprezentujemo o njim strukturama koji smo bišavali da mi krejava tabela si boljala, znači mi ćemo imati promenju u v i njen tip će biti reprezentovan ovim strukturnim zapisom klase i ovin poljima, znači dva objekna zapisa polja a i b i ona su tipa int. Znači čita u ovaj deografa opisuje tip promenjuve v. V drugi strane tip promenjuve duplo veo pisove ovaj ovde deografa.
 dva objekna čvora koji istu ukazaju na tip int. I sad rekli smo da bi, a u ovom primjeru yesu, znači b i duplo b, yesu, ekvalenti postrukturi, to znači da moram ustanoviti jedan prema jedan korespondenciju između njihovih grafova koji opisuju njihove tipove, znači između svih čvora i između svih grana. Pri tome sadržaj čvora ne moraju se potpunok poklapati, vidimo da imena promenjiva nisu ista, ali kažem, sama struktura grafa je danči identiče ova istruktura i čvora od uora, ovo je objeka čvora, ovo je ovdje, ovo je objeka čvora, i koratno, ova je čvora koji ukazaju ovdje objeka čvora, ovo je isti čvora. E sad gde važi ova ekvalencija postrukturi, znači ova primjer je samo u sintaksi mikrojave, ali ne uklapa se u semantiku mikrojave, znači u mikrojave ove promenjive ve i duplove ne bi bila ekvalentnih tipova, veđutim primjer bi bio ispravan u ceu, uz malu izmenu sintaksnom da se u mnestove, tuče reći, klas u potrebe strukture, znači u ceu dve strukture, znači dve promenjive tipa zapisa, strukture, suve ekvalentna ako su ti zapisi da kažem imaju isti broj poje, istih tipova. Saćemo videti kako implementirana provera tipova u mikrojavi, to je nekoliko metoda koji su pridruženi ovom čoru STRACT i koji imaju svoju direktnu opisku u mikrojava specifikaciji u vodeku semantika i konteksnih usloj. Znači možda da krenemo od ovog slajda gde su ove pomoćne metode, rečeno je da je tip referenci u mikrojavi klasa ili nis. E sad pošto su ove metode pridružene ovom STRACT zapisu, to znači da se ispituje, kada pozave tovaj metod ispituje se DIS objeka instanca STRACT zapisa za koju nad kojem ste pozvali ovu provera. Ko dovi drugih metoda zahtevaju se dva STRACT objekta, znači jedan je taj DIS nad koji im poziva te metod, a drugi se prosleđuje kao parametar nači ovog equals, recimo metoda, znači ispituje se DIS i ADR da li se ekvalent. Znači ovo je ona osnovna ekvalencija koja se nekoristi posled direktno u kontekstnim usluvima, ali služi kao oslova za druga dva metoda, znači pozivaju ovaj osnovni metod i ta druga dva metoda ustvari implementiraju kompretne provera. Znači da vidimo ovo u osnovnu proveru, znači dva tipa su ekvalentna, ako, znači rekli smo, ako ukazuju na identičan čvor, to je ona ekvalencija po imenu, a postoji samo jedan iz uzetaka, to je da zanizove dvanizase ekvalenta ako su im ekvalentni tipovi njihovi helmet. Tako da vidimo ovdje, ova donja grana je znači u taj okšti slučaj, ako je ADR i jednako DIS, ako su u pitanju istim, stvari ako reče isto autorstruktura zapisu identičom objektu, a ovaj IF, znači obezveđio još ovaj posad s očin zanizove, ako je DIS čvor vrste niz, onda ispitujimo da li ADR čvor vrste niz i ako jeste, onda ispitujimo za njihole tipove helmeta, da li su ekvalenti i tu vidite, to se realizuje rekluzivim i pozivom ove ekvalenti metodom nad znači helmetaip je isto strukturni zapis, tako da pozivamo za njega i uzimamo i ADR helmetaip, tako da ovim je omogućeno da recelivate nizove, koji nisu samo sastavljeni od osnovi tipova, kao što je celogrovinima iznakovlima, nego može biti niz nizova i tako dalje, i sve jedno će ova provera raditi i u takvim situacijama. Znači ova osnovna ekvalenti definicija ekvalentnosti tipova se koristila u ovim operativnih metodama koji se posledirekno koristu u semantičkoj analizi, a prvi otih metode, ovoj kompetibil vid i on odgovara od im situacijama, kada dve promenjive treba da uporedite a nije dodela jedne vrednosti druge, nači to može biti u nekim marikmetičkim idradima, sabiranja ili u relacijom idradima, da li je kada u mikrojava programu imate ispitivanje, da li je x1, da koji x1, x2, x2, x2, znači poziva se ova kompetibil vid provera. Znači jedan čvori disc, drugi čvori ader. I, nači osnovna generička provera je preko ne equals metode, znači da li je dise ekvalenta ader i imamo i određene specijalne slučeve, znači ako ne prođe ta generička provera, onda proveravamo da li je disc ono posebno u građenog null na otypa i da je ader tipa referencija ili obrnuto da je ader na otypa a disc tipa referencija. Zašto nam je potrebno ova dva izuzetka, pa da omogućimo ove provere da li je neka promenjiva koja običu referencija neku klasu, da li je jedna kanal, da smo je dodeli neke konkritanobikatiri i još neunicijali za ovana null, da li je x1, jednako null. I ima još jedna metoda, a to je kompetibilnost pridodeli. Znači u situacijama kada izvorišnju promenjivu dodeljujemo odredišnje promenjive, pričemu disc, znači reprezentu izvorišnju promenjivu, akroz ovoj parametr des se dobi... Znači tip i dvorišnje promenjive, akroz parametr des se dobija tip odrediše promenjive. Znači kako ova funcija implementira na ona je kao što vidite najsluženi od svih ovih funkcija, ima nekoliko svojih elemenata, prvo, obšta provera je ona preko funciji equal, znači da li su po noji bazne definicijita dva tipa i kvalentna i sada ako je su ekolentne, znači bi će vraceno tru, je sada ako nisu ekolentne imamo specijalne slučeve da je disc ovoga ugrađenoj null tipa, a odredište tipa reference, to je znači da ovo mogući eksplicitnu dodelu x i jednako null. Znači promenjivamo tipa reference, to su u nijeg zove ih klasse, a imamo joši jedan specijalno sluče koji su odnosi na nizove, znači ako je disc odnosno izvorište tipa niza i odredište tipa niza i da je odredišnji tip elementa o najugrađeni tip null type. I ovde razljašnjamo nam ovaj komentar s vrhu ove specijalno slučeve, a to je da bi se o mogućila implementacija ugrađene metode lenu ako je vraće broj elementa da bilo kogniz, znači da bi su tu mogao proslediti bilo koji nisa, bilo koji tipom elementa, mi moramo bezbediti da bilo koji tip elementa bude ekvalentan sa onim null type, null type je formalna parametra ove len metode ugrađene funcije, znači null type u formalni parametre je niz, či su elementima null type i onda takavniji mora da bude ekvalentan sa bilo koji im realni niz. I to je sve ova prva grana, je sada ako ne uspe u sve te provere, imamo ovaj nastavak sa fore. Nastavak sa fore je potreban da bi obezbedili mogućnost da dodelimo objekat izvedene klasse, znači pod klasse promenjivo i tipa nad klasse i to može biti direktni odnos nad klasse i njena direktna pod klasa ili u grafu nasljeđivanja može da bude i više čvorova izmedju, znači bazne klasse koje je više u grafu nasljeđivanja i izvedene klasse. Tako da, znači ovaj fore petlja nam obezbedjuje te provere, znači ako nisu ne pripaduju direktno istoj klasi, da krenemo od dis lm type. To polje rekli smo ukazuje na nad klasu, znači klasu iz koje je ova dis klasa izvedena, ako, znači tako ako postoji o lm type će biti na liči tornal, i znači idemo na nad klasu i pošte to fore petlja, znači mi ćemo se prosjetati, ako ta nad klas ima svoju nad klasu i tako da je to formera čita vlana, znači ova fore petlja ide po zelom ton lanc element po element i ispitujemo znači, sada smo se prebacili na nad klasu i dalje odredišni čvor po tipu odgovorat o i nad klasi. Znači odredište može biti bilo koja od nad klasa dis i onda je to ispravno zadodelu. Naravno ako prođemo prosto ovu fore petlja, nema to poklapanje, onda ćemo na kraju vratiti false, da ta dva tipa nisu kompatibilna zadodela. I za kraje lekcije ostalo je da pomenemo još neke stvari veći tipovi proveratipova, koje mikrojava nema, ali neki drugi jezic imaju, u izrazima gde se koriste operandi različiti tipova, napr. sabiranje celog vrena vrednosti sa realnom, mora se jedan operant konvertovat u drugi tip, da bi se mogla operacija provestir, operacija su tipišlo definisane ako su binarne nad operandime istog tipa. Često se te konvercije rade tako da se jedan od operana da konvertu je u širi tipa, najkoji može predstavljati veći skup vrednosti ili veći precijnosti. Konverzija može biti eksplicitna ili implicitna, a eksplicitnu konverziju mora program je eksplicito da naglasi u ovim celog skvi familije zivit, ka to so bičo radi tako što ispred izraza, stavite u zagradi tip i time zakteva to od kompajelera da generiše kod koji će ovu vrednost X-a iz njenovo origilnog tipa, prevesti u format celog broja. Naravno, kompajeler pri tome mora da izvrši onu programu da li ove origilni tip kompatibilan za tu operaciju. Naravno, u neki jezic, u svojim semantičkim pravilima definišu implicitne konverzije, engleski termin je Cors, gde sam kompajeler zna da konvertuje jednu vrednost u druh, u nekim situaciju. I još da pomenemo da, pored termina, redefini sanja funkcija, kada jedna klasa nasleđuje drugu klasu, da sliđuje metod iz bazne klase i onda da redefiniše ove raiduje, tako što pruža s obstornom implementaciju, postoji i preklapanje funkcija kojima poseban termin overloading, a to je da u jednom istom obsegu važenje imena možete imati isto ime neke funkcije, koje se odnosi na različite funkcije.
 jedno funkciju koja ne znam prima celog brojini parametar i njenu telog je jedno i božete imati neko sasem drugu funkciju koja prima neki drugi parametar neko drugog tipa i radi neko sasem drugu obradu telog funkcije i to može biti dozvoljeno i sistemom tipova jezika je onda definisano kako se razrešava kad upotrebite ime FLA, u zavisnosti od konteksta upotrebe kompavir mora jedno značo da može da odredi da li stup potrebi ovo godnju funkciju ili ovo domnu funkciju on to naravno određuje tako što gleda tip stvarno parametra i gleda da ga mapira na nekiho tipa formalnih parametra i tako dalje to može da ga komplikure, travila, provere tipa i sistem tipova ali neki jezic i značo mogući i tu mogući
