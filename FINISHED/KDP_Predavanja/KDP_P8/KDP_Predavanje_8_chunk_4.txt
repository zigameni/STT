 Nemamo poima kog treba da probudimo. Znamo da možemo probuditi sve ili probuditi jednog, ali ako kažemo jednog ne znamu koga ćemo probuditi, ne znamu da ćemo probuditi onog pravog. Ovo rešenje, odnosno, ovoj problem može da se unapredi, da se reši malo bolje, a u slučaju da mi ne koristimo ovako nešto u tehniku covering condition, nego iskoristimo one prioritete. Šta radimo sa tim prioritetima? Pa kažemo wait, samo što ćemo pare toga da kažemo, gdje kažemo da želim da čekamo, stavimo još i to kao prioritet. I šta onda radi onaj što nas budi? Onaj što nas budi? Pita, il postoji nekog ko čeka? To je ovo ovde. If not empty od ček, i, šta je sledeće, mean rank. Ne znam da smo se do sada susrili sa ovim ovde mean rank. Mean rank je metoda koja postoji nad ustvonom promenivom, kod koja postoji prioritetni redov i čekanja, koje će nam vratiti prioritet, najveći prioritet onoga procesa, koji te remetno čeka. Najveći prioritet je najmanja vrijednost, što smo mi ovde koristili vreme, kad treba nekod da se probudi kao prioritet, dobit ćemo tu vrijednost. I kada znamo da treba nekog da probudimo, ako je to što smo pročitali, manje ili jednako od tod. Či sličeno ustvom kao što sam maloče sam napisao, samo što sam ja, šta sam napisao? Ja sam napisao if. I al to dobro da bude if, pa odradio sam signal all. Pošto sam tamo odradio signal all, save sam probudio. Možda postoji više, onih koji treba da se probude u istom trenutku. Kako možda postoji više, ako svako dođe u različitom, garantovanu različitom trenutku, ne mogu dva procesa istovrmeno da dođu. Kako onda mogu da se probude u istom trenutku? Mogu da ime u različitim tervala, koliko treba da budu zablokirani. Ne mogu da zaboravite to. Vreme kada nekod treba da se probudi, se dobije, tako što se sabere trenuta kada je došao i koliko treba da bude blokiran. Tako da. A može postoji ti situacije da u istom trenutku treba probuditi veći broj procesa. A kako smo onda ovde realizouli da se budi veći broj? Tako što smo rekli, ovaj što budi, dok legozda ima nekog kojog treba da probudi i nek probudi. Šta znači da ima nekog? A da lista nije prazna i da interval, kada taj neko treba da bude probuđen i je manji u odnosu na sadašnji trenut, odnosno prioritet koji smo izvukli, kaže da je taj neko treba sada se probudi ili možda trebalo da se probudi malo ranije. Ok, i mi smo napravili sada rješenji koji ima znatno manji broj budi. U materiali možda, vežba, mislim da postoji još jedna varijanta. A ovogo ovde rješenja, gde ćemo mi probuditi prvi proces, znači da ovaj ovde koji kaže tik, kaže, idem, ja da budim prvog. I onda ovde u mesto while napiš if. I probudimo samo jedan proces. E, al to nije dovoljno. Znači nije dovoljno da se probudi samo jedan. Ali je pitanje, a čekaj, je mora tog jednog da probudi taj što radi tik ili može da ga probudi bilo ko? Ma, može bilo ko da ga probudi? I u tom slučaju, i ovo parkče koda, a trebali da iskopiramo i na kraju metode delay. Šta bi to značilo? Da kada se neko probudi, zato što ga probudio tik, taj neko pogleda. I al treba još neko koje prvi narednji u listi da se probudi. Ako treba budim ga, ako ne treba ne budim. I na taj način smo realizuvali buđenje većih broje procesa u istom trenutku. Tako da kad rešavate ove probleme, synchronizacijone, vodite računa o tome da možda postoji većih broj procesa koji treba da se probude u nekom trenutku. Na primer, kojda problema filozofa koji rucavaju, kada jedan filozof završi sjelob, koliko taj filozof može da probudi drugih filozofa? Potencijalno dva. Nemaite zaboraviti da napisati samo rešenje, proveri za filozofa jednog. Ne, morate proveriti za dva različita filozofa, jer kada neko završi, možda će i levi, i desni sused počevo tog trenutka moći da jedo. Da, da što su oni iskazali želju, ostali nisu iskazali želju za jelom. Zbog toga, kod synchronizacijonih problema treba provjeravati, da li postoji više njih koji treba da budu probuđeni u nekom trenutku? I šta smo niko dolgo prirodi tjv. timeru radili? Imamo wild petlju, nekako napravljenu, koja nam je omogućila da budimo prvog sledećeg, da proverimo za prvog sledećeg, ako prvi sledeće treba se budimo, ako ne treba, ne budimo. I iskoristili smo min rank, koja nam kaže koliko iznosi prioritet tog jednog, ima najveći prioritet, ako taj neko treba se budi, budimo, ako ne treba da se budi, ne budimo. I ovde rešenje je znatno efikasnije, što se resursatije u odnosu na covering condition. Covering condition koristimo kao poslednju lini u odbrane, ako ne znamo drugaće da rešimo, ok, rešit ćemo nekako, bićem mogu sporo, ali ćemo rešiti. Malo, malo efikasnije varijanta tog rešenje za covering condition bi bila da ne budimo baš svaki put, nego samo onda kada ima nekog potrebe da budimo, znači proverimo da li ima nekog potrebe da budimo, i ako ima budi sve, neko oni se računavaju ko treba da se budi, pošto mi nemo drugi mehaniza. A videli smo da to može malo da se još proširi, tako što bi smo koristili lniz, nešto nalik na Andersenov algoritm, koji smo imali koji cikronizacije procesa. I to je to, što se ovog sikrizacijenog problema piči. Sa ćemo napraviti pauzu, posle pauze radimo slipping barber i round-the-bound problem. Pauzam. Bija. Bija. Dobar dan je ši jednom. Dobro došli na predavanje na predmetu konkurentno i distribujerano programiranje. Vidim da je bilo nekoliko pitanja ovdje u četu, pa idem da probam na ta pitanja o odgovorima. A monitori se pozivaju. Na istin acim kao što biste pozvali neku metodu neke klase. To je ime monitora, tačka, ime odgovarajuće metoda. Ako ima nekih argumentata, to biste prosledili. Šta je još ovde? Kod monitora imamo signal all. Kod monitora koji imaju disciplinu signal and continu, postoji signal all. Kod monitora koji imaju disciplinu signal and wait i njene podvarijante, nemo mu metodu signal all jer signal all bi značilo prebati sve da budu aktivni sada. Što ne možemo odraditi? Jer monitory sa disciplinom signal and wait puštaju jednog. Znači šta sam sad rekao? Metoda signal all postoji samo kod monitora koji imaju disciplinu signal and continu. I svi oni se iz liste blokiranih prebacuju u listu aktivnih procesa. Dok kod discipline signal and wait i signalizacija znači probudi jednog, pusti tog jednog. Ok, ajde da se vratimo na ovde naša predavanja, pa da vidimo šta ćemo sad preostala dva synchronizacijno problema odraditi. Ovo danje što je? Ovo danje što je? Ovo danje što je? Dobro došlo i na konkurentno distribujereno programiranje, ostalo su nam ještje dva synchronizacijno problema. A, hoćemo da vidimo kako razrešiti problem berberina koji spava i ulaska u raskarsnicu. Kako izgleda ove problem berberina koji spava? Vrlo, uveći broj procesa to su mušterija. Mušterija dolazi do berbernice, onda može da proveri da li ima slobodnog mesta u berbernici, ako ima slobodnog mesta, seda i čeka ret, čeka da bude obslužena data mušterija. Ako nema mesta potencijano ta mušterija odlazi, pa nekad možda kasnije ponola dođi ili odu u neku drugu berbernicu. Imoj u ovoj ove varianti problema i imamo jednog berberina i berberin ako ima posla 3, ono s lošišom ušteriju, ako nema posla ček. Znači to je sleeping barber problem, berberin čeka dok...