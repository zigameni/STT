 u mestu dohvotanja poruka koja su nam dolazila kroz komunikacijonni kanal na početku, mi sad abiramo, ako postoji neko u tom našem kanalu E, dohvoti tog nekog is kanala E, ako ne postoji ATIDI pa se blokiraj nem tri Q. Če ovo ovde na RISIV, da primu novi poruke, i ovo je jedino mesto gde smemo da se zablokiramo. Aha, dobro, kad smo mi dovukli taj kontekst, koji nam je neko dao, mi moramo da znamo gde ćemo doskočiti. Dakle da ako prajimo svič case, u tom slučaju bi morali da imamo dodatnu granu, odnosno dodatne grane, u tom sviču koje bi odgovaralo svim onima mestima, koja dolaze posle weight iskaza u nečemu što bi odgovaralo mekom monitoru. Znači, ovo može da se realizuje otomacke, može da se naprave otomacki prevodilac, koji će se ovo ovde prepakovati kakogod zna i jume, ali je moguće to napraviti. I ovdje imate jednu kompletnu tabelu, koji će sad sve ovde tri stvari koji smo do sada vidili da prebrojemiti. A kako se kod monitora razrealizuje razmena, ovo je promenjive lokalne, pa stalne promenjive monitora, tu se čuva nešto kod monitora, a lokalne servijski promenjive se nalaze, kod aktivnog monitora. Kako smo pravili procedure? Proceduru smo pravili kod običnog monitora, ču napišemo procedura monitorska, tako i tako izgleda. U javiji bi to bila neka synchronizda metoda. Šta smo imali kod aktivnog monitora? Morali smo da upišemo da je to poruka koji možemo da pošaljemo. A ako uzmete sada da gledate da se priset ćete i kako izgleda, ona je ramaj i u javi. Tamo ste morali u suštini da deklarišete neki interface i da kažete, ovo ovo je ono što ja delim s ostatkom sveta. E, u tom interface su suštini upisana imena svih metoda koji će neko moći da poziva. I ovde ćemo mi imati imena svih metoda kroz ovaj kanal i tipove operacije koji mogu da se obavljaju. A kod monitora smo imali poziva procedura. Ovde nema poziva procedura, to je negde na drugom računaru. Ali imamo potribu da to na kljenjenskoj strani realizujemo. Dakle što naprimo send request, kažemo ja od ovogo ovde, znači to moram da kažem kome upućujem, želim da se odradi ta operacija sa tim argumentima. I još i jedan red moramo da imamo to jer isivri quest. I to može relativno jednostavno, če to može trivilno vas implementira kao jedan omotač. Serverska strana se malo komplikovan i implementira, zato što ulazak u monitor je jednostavno, to je on je resivri quest, ok, to je na tom jednom mestu samo naprimo, ali je problem ona raznorazna blokiranja. Znači ulazak u monitor, kako smo veš ga garantovali da će samo jedan moću nekom trunutku da budu monitoru, pa postoji samo jednanit. Ako postoji samo jednanit, pa ne može više niti da švrđa isto vremeno po istom objektu. I vemo samo jedan nit garantovanu nam je tom našom definicijom aktivnog monitora. Dobro, kako smo realizowali wait-excus? Wait-excus smo realizowali tako što smo morali da sačuvamo to, sve što se odnosi na zaakte, u koji treba da sačeka. Sačuvali smo njegov kontekst, onakav kakav mu je potreban, a ne sve promenjive i sve što je taj tu imao sve lokalno, nekako da se sačuvamo, jok. A mi smo sačuvali u našem konkretnom primjeru samo identifikator. Ali nije doveno identifikatu, moramo da znamo i gde da doskočimo kad nas neko probudi, tako da bi tu trebalo sačuvati i odgovarajuću labelu. Kako smo realizowali signal? Signal smo realizowali tako što smo dohvatili taj jedan i ili ga prebacili u one red e, ili odradili posao koji treba da se odradi za to ko je probuđen. Šta je još ostalo? Tela procedure su grane u onom našem case iskazu. Samo što od tih delova u case iskazu može biti više. Ukoliko prajimo monitor kojima signal n-continuja, onda za svakonu mesto tog nastavljanja moramo da stajimo odgovarajuću dodatnu labelu. I oni smo mi završili rad sa aktivnim monitorima. Na vežbume ćete odraditi još jedan primjer. Šta ću da napravim jednu vrlo kratku pauzu. Pa samo da zbustim sniminje da bi bilo dva snimka. Pa ćemo onda nastaviti. Dobar dan još jedno. Dobro došli na konkurentno i distribuirano programiranje. Chod ćemo da vidimo novom času. Ja postoje još neki način i komunikacije. Ja moram da budu filtr. Ja moram da budu kljen server. Ja moram da budu kljen server. Ja moram da budu kljen server. Ja moram da budu kljen server. Ja moram da budu kljen server. Ja moram da budu kljen server. Ja moram da budu filtr. Ja moram da budu kljen server arhitekture. Ja postoji još neki način da mi povežemo neke procese. Postoji verotno bez konacu način na kako mi sve to možemo da povezujemo. Gde mogu čoraj da budu simetrični, asimetrični. Da rade sličnu stvar. Da rade potpuno različitu stvara. Gde možemo da napravimo protok informacija kroz naš sistem. Gde ćemo da napravimo da nekod radžuje neki posao za nas. Sad je pitanje samo kako su povezani čvorovi u tom našem grafu. Imao distribuirano programiranje. A kod distribuiranoj programiranja mi imamo veći broj čvorova. Veći broj procesa koji komuniciraju. Svima pitanje ko, s kim komunicira. Da li imamo centralizovanu rešenje, kao što je dato na ovom prvom crtežu. Da li imamo simetričnu rešenje gde bilo ko, sa bilo kim može da komunicira. A ili imamo prsten gde možemo da komuniciramo samo sa susedima. Ili imamo neki graf gde neka dva čora mogu da komuniciraju. A neka druga dva čora ne mogu da komuniciraju. To će se zavisitio kako izgledaju ti obrazci. Komunikacije koje mi želim da poštujemo u ovom ovdešto sistemu koji projektujemo. Različito izgleda implementacija nekih rešenja. Uzavisnosti od toga da li imamo centralizovanu simetrično ili kao prsten. Datu topologiju našem rešenju. Če nam dati topologiju mreže i reći kako se komunicira. Da li imamo centralizovanu? Ovo centralizovanu sad rešenja možete da zamislite. U pao ovde dosta liči na aktivni monitor. Ovo može ličiti i može biti aktivni monitor, ali ne mora. A ovo nisu interagujiciji procesi, filterski procesi koji su mi da imali to su različite stvari. Interagujiciji procesi i filterski procesi mogu da budu slični, ali ne moraju. Mi smo rekli da su ovi naši procesi koji se učinili. Ulaza i izlaza je određen broj. Trebalo bi da se oni rade neku sličnu obradu. Ako smo ih povezivali. Ali ako uznete gledate, pa svaki proces ima neke ulaze i neke izlaze ako želite da komunicirate s njim. To je tačno. I sama pitanje, kako ćete vi to sve povezivati? Odnosno, koliko ima čvorova koji rade neku sličnu obradu? Ovo je sve sači samo kako se oni povezuju. Ovo da imamo? Tri neka tipa. Sistema. I sad želimo da rešimo jedan, vrlo, vrlo, jednostavno zadatak u vam ovte. Želimo da vidimo kako, da nađemo na primer najmajno, da se ovo je uvijek, da se ovo je uvijek. Znači, želimo da vidimo kako da nađemo na primer najmanju i najveću vrednost. Znači svaki od ovih čvorova, svaki od ovih p1-pn, ima sačuvanu neku vrednost. Sad sam sada rekao, svaki, uključujići i ovaj ovdeg čvor p0 koji do ovog našeg centralizovanog rešenja, a koji do ovih simetričnih, tako da siti u čvorovi imaju neku vrednost. Ta vrednost je označeno sa v. I mi želimo sada da napišemo program koji će da odredi najmanju i najveću vrednost u ovom ovde sistemu. I to je to. Ta me pitanje, kako izgledaju ove čvorovi, odnosno kako izgleda topologija mreša. Zašto bi neko pravio različite konfiguracije, zašto se ne bi svako sa svakim komuniciralo, naprivo želite da pravite raznorazne zaštite u vašim sistemu i nedozvoljavate da bilo koje dva računara mogu da komuniciraju, nego želite da to bude nekako realizano. Ako želite da svakim svakim imate, a ono potpun o simetričnu rešenju koji smo maloče svideli,