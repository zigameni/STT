 Dobar dan, dobro došli na predavanje na prednetu konkurentno i distribuiranu programiranje. Tema ovog današnjim časa su i dalje synchronizacijone algoritmi. Hodjemo da vidimo, da li možemo da napravimo nešto što odgovara o nam ticket-algoritmu, gde ćemo budeti sledeći proces, ali tako da ne znamo koliko procesa ima. Kod ticket-algoritma, manje je bilo ta što su svi procesi čekali na istoj promenjivi. Svi su čekali to istu promenjivu dokli gota ta promenjiva nedobije vrednost koja njima odgovara. To bio mali problem jer je to zahtjevalo obaveštavanje i popunjavanje svih keš memorija, a samo jedan može da nastavi dalje. Svi ostali su se bezpotrebno budili i proveravali svoju ustavu. Ljudi su malo unapredili taj algoritm. To malo unapređenje je nazvan Andersonovalgoritm, prema autoru koja to napravio. Taj autor je reka, ok, nećemo mi čekati svina istoj promenjivi, nego će svako čekati na različi toj promenjivi. Imamo jedan niz, gde svako čeka na tijim elementima niz. To su malo razmadrali, predkodni put. E, šta je mana tog pristupa? Zahtjeva, pođedan, poznavanje ukuplnog broja procesa pod sdva, ba baš i nije da on bude samo jednog. E, da probam da nacrtam, da se vratimo na sliku koji smo imali predkodni put. Nijamo niz. Kada imamo niz, koliko elementa smo mi u suštini kada promenimo jedan, promenili. Nakoliko to procesa potencijalno utiče? Ako se setite malo aore 1, to će uticati na sve one koji spadaju u istu kešliniju. Podaci se unutar procesora čuvaju u kešmemori. Kešmemoria je podeljena na neke linije, blokove koliko se može dovući jedan podatak. U tom podatku, u toj liniji će se naći više od jednog elementa niza. Kada neko promeni jedan element niza, u svari, nije promenio jedan element. A procesor ne zna koliko elementa je tu promenilo. Dali jedan, dali dva, dali više. Procesor to ne zna. A razmog procesor zna da je došlo do promene na nivou kešlinije. I svi oni koji osluškuju datu kešliniju će biti probuđeni. To je znatno bolje nego da se svi probude. Možda ne očekuju svi. A tu kešliniju tada njima treba to da se ažurira i da se ne oni nekako obaveštavaju harderski. Ali opet nije samo jedan kao što smo mi želili. Kad budete to implementirali koristići semafore. A mi u svari nećemo imati semafor na tom mestu nego ćemo imati pokazivaču u svari na semafor. Tako da mi nećemo nikad ažurirati sam niz nego ćemo pristupiti elementu na koju ukazuje to što se u nizu navazi. Či tako to realizovano u nekim sistemima. Tako da andresenoval aguritom može da se koristi za synchronizaciju ako treba dobezbijete FIFO redostat. A nije vam garantovano da su semafori realizovani kao FIFO. Jednostavno imate nije semafora gde će svako čekati na različitom semaforu prema svom redostat u dolasku. I na taj način možete obezbediti FIFO redostat čak i koj semafora koji negarantuju FIFO redostat. Tako što svako čeka na različitom semaforu. Aguritom koji mi sada hoćemo da primenimo, bi trebalo da bude takav da nema pojma od užini niza. Dobro čekaj, nema pojma od užini niza. Sad treba da se setim. I radili neku strukturu podata ka do sada. Znači, dali smo do sada na fakultetu videli neku strukturu koja nam omogućava. Ovakam isti pristup kao do sada što smo imali da možemo da čitamo prvi naredni i da možemo prvi naredni odnovo da su na nešto drugo da posećemo. I jedna takva struktura, mislim, postoji veratno iš dosta takvi strukture, najobičiji je lista. Šta je dobra osobe na liste? Nemoramo u napred da znamo njenu dužinu. I to je baš ono što mi želimo da razrešimo kao problem koji mi imamo ovde. Želimo da ne moramo da znamo dužinu, da ne moramo da znamo koliko ima elemenata. Da možemo da radi za dva procesa, ali da na isti način možemo da funkcioniše za sto procesa. Da to nama bude potpuno sve jedno koliko procesa ima. Jer kako funkcioniše lista? Sada mi treba nekako da naparemo tu listu, način mi ćemo imati taj element na kume mi čekamo. Mi ćemo čekati na ovom ovde. Kako ćemo do togo doći i imati imaćemo pokazivač na prvi sledeći. Prvi sledeći kad dođe da čeka, on će čekati na tom tu, a preko svog pokazivača će obaveštavati onog narednog u listi da treba nešto da se desi. Znači mi ćemo imati naš element, to je ovaj ovde koji mi tremotno posmatramo i tekući tačka naredni će biti onaj gde treba da postajemo odgovarajuću vrednost. Imaćemo da vidite dva pokazivača, jedan je ovaj pokazivač koji kazuje na našu vrednost i imamo pokazivač ovde koji će ukazivati na to šta je naredno. Dobro, ovaj ovde lepo radi kad počinu da radi, niko samo kako ovo radi. Šta je nama još potrebno da bi ovde sve moglo da funkcioniše? Nemam pojema, ajde da vidimo. Treba nam neki pokazivač koji kaže šta je poslednji element, da bi mi znali da na njemu treba da sačekamo a ovde ovde poslednji element, moramo da imamo ovako jedan pokazivač koji kaže to je poslednji. Šta onda mi treba da napravimo? Treba da napravimo slednji element u nizu gdje će prvi naredni da ček. Dobro, šta onda mi odradimo? Imamo pokazivač koji pokazuje tu na taj, pošto to mi pravimo, to je za sada naša lokalna promeniva, to smo napravili. Ovo ovde je pokazivač koji kaže šta je taj poslednji, ovo ovde mogu da nazovimo last. Ovo ovde je next. Mogu tako da nazovim da se tako zavom materialima neznam. Ovo ovde je poslednji, ovo ovde ška koji da procedura? Mi dođemo, mi napravimo ovaj ovde slednji element i onda ćemo da odradimo jednu, da kažem tako, zamenu, trojnu zamenu. Mi ćemo da postajemo da je ovaj ovde, kako bi mogli da ga nazovimo current. Da postane jednako last, a last da postane jednako next. Znači šta mi želimo da napravimo, da bi smo mogli da ubacimo element u listu? Ovo želimo da prevežemo. A nekako, znači to da upišemo. A sad ja to nekako da probam da napišem, znači šta kako bi to glasilo? Last, tačka next je jednako do tom našem next koji smo napravili. Vaj da neću nisu da izmešamo ovde, a current je jednako last i last je jednako next. Ovo želimo da napravimo, znači želimo da kažemo slednji element u listi je tie to. Pa dobro, sad ima tu nekako previše ovih pokazivača, ali božemo je, izborićemo se s pokazivačima, to smo barem naučili da radimo na razno raznima algoritima i strukturama podataka. E sad i pitanje, a gde ćemo mi da sačuvamo jednu, ovakvu listu? Ja nama baš treba to, toliko mnogo o tih last, next, current i šta govorite, pa piće nam potrebno, ali, sad ovdima jedno ali, možda nećemo morati baš da pravimo listu na ovaj ovde način, jer ajde imaš, šta ja ovde treba da radi, baćeš jednom da se podseti. Kad ja dođem, treba da napravim prvi naredni element, dobro, ok, to znam da napravim, šta onda treba dodradim? Treba current da postane jednako last i last da ukazuje na next. Mislim šta će mi ovaj ovde pokazivač? To mi baš da usušti.