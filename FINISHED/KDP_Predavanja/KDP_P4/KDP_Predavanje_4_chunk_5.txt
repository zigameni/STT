 koji će dalje obavljati synchronizaciju. I vidite, ovo ovde rješenje će u mi često koristiti ovaj ping-pong. Imamo neko nam nešto da javi, mi to nešto primimo pa resetujemo to. Pa onda nekom drugom mi nešto javimo, mi setujemo to, a neko drugi će to da sačeka i da resetuje. To je princip koje smo mi ovdje imali. Neko je nešto setovalo, druga strana je to resetovala. Nismo morali da čekamo. A ovdje koordinator nije morao da čeka da continu postane jednako nula. Jednostavno toga ne zanima. Zato što nećemoći na naradnu iteraciju da se prođe, dok lego vorker to ne resetuje. I dalje ovde ostalo još nešto? Jeste. Problem zaposlednog čekanja. Je nešto što bi ste trebali da izbegavate. Znači zaposledno čekanje možete primjenivati u slučajevojima. Da je posao koji treba da se obavi kratkotrajana. Tako da nema potrebe da vi obaveštova to operativni sistem sa nekom težom synchronizacijom. I jednostavno provediti su 5-10 puta dok neko ne napusti to je posao koji treba da se rati. Tako da za kratkotrajna operacije zaposledno čekanje ovako kako smo radili da kažem idealno. Zaslučaj da postoji mogućnost da se ono skip realizuje na neki malo pametne i način. U knisi konkurentno i distribuirano programiranje imate jedan od algoritama koji se dosta često koristi ako nemate ništa pametno. To je da povećevate interval. Da u tom skip vi u svariji radite slip. Kažete ok ja neam sad pametno šta da radim ajde idem da spavam 10 milisekundi. A pa ću onda proveriti oslo. Ako nakon 10 milisekundi se ništa nije promenilo ja ću da uvećam ta interval i sada to uvećavanje može biti linerno sa vremenom a to uvećavanje može biti i eksponencijalno sa vremenom. Češći se koristi ovej eksponencijalno. Šta sam rekao? 10 milisekundi ako se ništa ne po 10 ja ću da slet ću počekam 20 milisekundi pa ću čekati 40 milisekundi. Pa 80 milisekundi dok nedojim do nekog maksimulnog intervala koliko smem da čekam. Znači takva rešenja ljudi koriste gde ako nemaju nikako realizovanu skip na pametan način to iskoriste. Kažem koriste to čekanje koje se produžava. Ili drugi način je ako postoje mogućnost da se hardware-ski zablokiraju do klegu ocene da se neki dogodje kaže ja neam šta da radim čekam neku nešto tamo da se desi na magistrali pa onda tako nešto čekam ili ako ujavi imate taj unsafe weight na nečemu na tome isto možete čekati to bi trebalo da odgovarat tom harderskom čekanju da se nešto desi deka promena negde u kjaš memori da vi možete da nastavite da odblokirate nit. Ali u većini drugih slučeva kad imate dugo trena operacija koje ne znatite koliko traju poželije da imate neku malo bolju sinchronizaciju a ne ovu kojoj smo mi do sada imali Ova sinchronizacija sada radi ekstra i mnogo se koristi a to je lock free synchronization ali možda ne može svaki puda se primene Ono što ćemo mi raditi počao od naravnog časa je sinchronizacija koristići neke malo drugačije tehnike i na naravnom času danas i na naravne nedljećemo razmatrati semafore šta oni nama pružaju kako se koriste nećemo razmatrati kako se oni prave Praviliste na operatinjom sistemima semafor i možete viditi implementaciju semafora u programom skom jeziku java Dali možda imate pitanje neki koji se odnose nove sinchronizacijone algoritme do sada Ako ne mati pitanja ode ćemo napravit pauzu posle pause ćemo videti kako izgleda rad sa semaforima pausa dobar dan dobro došli na predavanje na predmetu konkurentno i distribuirano programiranje tema ovog danasnog časa je rad sa semaforima hoćemo da vidimo šta su semafori i kako možemo da ih iskoristimo da odradimo dve osnovne stvari koji smo rekli da postoje u konkurentnom i distribuirano programiranju prva je međusobno isključivanje druga je uslovna sinchronizacija hoćemo da vidimo kako semafore da iskoristimo i za jedno i za drugo pa idemo del po del dal nas zanima na ovom predmetu kako je napravljana semafora za sada ne praviliste semafor na predmetu operativnih sistemi i napraviliste ga kako god znate i umete a bojte ćemo na predmetu ovom gledati kako napraviti semafor koristići monitor ili koristići struktur u koje postoji u nekom višom programskom jeziku ali se nećemo baktati s tim šta radi operativni sistem pošto nas to ovde ne zanima jer možda ovo nije pod kontrolom operativnog sistema nego pod kontrolom virtualne mašine ne znamo šta ješto ono što se navazi ispod ali kada radimo sa semaforima nije ne zanima nas neko nam je dao semafor idemo šta je taj neko nama dao uzat ćemo u suštini minimalan skup stvari koje neko nama dao da bi ovo moglo da funkcioniš iman ćemo prvi deo to je deklaracija kako ćemo mi da deklarišemo semafor semafor sem je jednako sem s ili sem lock i onda bošemo da dodelimo početnu vrednost to bi odgovaralo konstrukturu na svojom svojom da bi odgovaralo konstrukturu našeg semafora na vežbima ćete videti da možda postoji poseba način nećemo ovako da dodeljimo vrednost zato što ovo ovde neki preklopljeni operator malo čudno izgleda ovako da se dodeljuje nego će se vrednost dodeljivati ili koristeći konstruktor ili koristići metodu init kojom se inicializuje dati semafor na neku vrednost semafor možemo jednom inicializovati kao što konstrukturu možemo nad nekom istancom pozvatiti jednom postavljamo početnu vrednost šta dalje imamo za rad sa semaforima imamo dve metode signal i wait šta radi signal uvećava internu semaforsku promenljivo za jedan nedeljivo šta radi wait wait a wait dokle god je interna semaforska promenljiva manja ili jednaka nuli a ti čekaj čim postane već je od nule a ti u manji internu semaforsku promenljivo za jedan a ovo ovde kao što možete primjetiti coarse grain rešenje coarse grain rešenje kaže šta će se desiti ne i kako će se desiti kada će se one gore sa wait probuditi po kome rednost edu će se neko buditi to nam ništa ne kaže ovog gore da će se desiti signal pa mi izlađemo isto signala pa nekad u budućnosti se tu opameti po odradi wait to nam uopšte niko ovde ne kaže šta će se desiti može se desiti signal pa se opet desi signal pa se te malo kasnije neko opameti pa pogleda wait koji u vrednostima to u ovom našem coarse grain rešenju u ovšte nije specificirano šta će se prvo šta će se drugo desiti ne znamo, ove smo dobili šta će se desiti kada se nešto desi ne znamo po kome rednost edu i da će se ove signal više puta izvršiti a nekada se odradi odradi neki wait to ovde uopšte nije specificirano tako da mi uzimemo najopšti slučaj rada naših semafora ako u nekom konkretnom programskom jaziku dobijete nešto više informacije o tome, super ali ako ne dobijete onda možete ići od ove predpostavki ovo je naši coarse grain a kako radi kod koga bude baš to ne znamo niti nas zanima to zanima one koji se budu bavili projektovanjem samih semafora mi ćemo od ovog trnutka pa nadalje naravne 3 časa 4 časa vežbi 7-8 časov se baviti semaforima koji rade ovo kako su napravljeni nezanima nas na opretim sistemima steh pravili vidite ćemo možda kad budemo došli na laboratorijski vežbe kako izgleda kod kako je semafor napravljen u pozadini u javi koristići fečened ili tako nešto kako je napravljen koristići cel h algoritem koje smo maloče s razmatrali ali ga nećemo praviti na taj način semafor ćemo praviti koristići monitori jer ne znamo šta je starija u nekom programmskom jeziku semafor ili monitor neko će reći semafor je najstariji možda, al u javi nije bio u javi je bio stariji monitor kada su napravili programmski jezik java