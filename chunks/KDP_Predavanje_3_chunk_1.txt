 Dobar dan, dobro došli na predavanje na predmetu konkurentno i distribuirano programiranje. Ja sam Zachar i Radivojevic, tema ovog danošnog časa su synchronizacijoni algoritmi. Hoćemo da vidimo kako synchronizovati dve niti ako nema na raspolaganju usluge operativnog sistema. Ako na raspolaganju imamo samo usluge koje se na neki način odnose na specijalne instrukcije ili možda čak nije na specijalne instrukcije koje postoja na našem procesoru. Ako uzmeti da posmatrate vaše procesore, skoro svi oni imaju mogućnost za puštonje većih broja niti istovrmeno da nešto rade. Idemo više izgara i na svakom jezgru možete pusiti nezavisnu nit. Kako synchronizovati teniti? Dali moramo da koristimo operativni sistem da vi smo to odradili ili ne? U ovim ovde prvim slučajima koje razmatramo, posmatramo sistem gde ne koristimo usluge operativnog sistema. Za sada ćemo koristiti zaposlenu čekanje ali to možda nije baš pravo zaposlenu čekanje. Postoji jedna petlje u koji se mi vratimo, ali na kraju te petlje stoji informacija da možda treba da sačekamo nekako. Možda prepušnamo nekom i drugom mogućnost da implementira to naše čekanje. Vidir ćemo, ako budemo deten opozmatrli programski jezik java da neki od ovih algoritama koji će u mi sada razmatrati se stvarno sada koristi u programskom jeziku java i se ove ovde specijalne istrukcije su stvari implementiran u programskom jeziku java da bi ljudi mogli da napravaju mnogo bržu synchronizaciju. Sinchronizacija koristići semafore monitori, regione, radi ali je spora. Dosta je spora u poradženju s onim što možemo odraditi koristići ovako vrlo jednostavne synchronizacijane algoritme. Nekada zaposlenu čekanje možda i nije toliko loša stvar, uko li ko znamo šta je posao koji treba dobavio na druge strana. Kako sa to znači se? Ako imamo na primer filozofa koji rucava, gde je filozof jede i ne znamo kako izgleda to jelo, tog filozofa U tom slučaju nije poželjno da koristimo zaposlenu čekanje koji je synchronizacija. Ali ako u tim delojima za synchronizaciju jedini posao koji treba da sodrde, napr. umetni nešto u listu, izbaci nešto izlisti, da će relativno kratak posao, desetak nekih možda 15 instrukcija. U tim slučajima se možda više isplati da se pozove zaposlenu čekanje sa synchronizacijom, bez zaključavanja, jer brže doćemo do rezultata, posao se brže odradi. Kada imamo zaključavanje, moramo da pozovemo operativne sistem. Operativne sistem treba do parkera našu nit, onda kad neko signalizira treba da se isparkira naša nit. Dosta vremena potrošimo na taj okoliš. E sad i pitanje, da li tačno znamo šta je posao koji se radi ili ne? Ako ne znamo tačno šta je posao koji treba da se obavlja, kao što bično ne znamo koji je filozofa ili koji je proizvojđačaj potrošac, ako to može da traje proizvojno drugo, a onda čisto zaposlenu čekanje nije opcija koju bi trebalo razmatrati, jer u tom slučaju previše vremena trošite na procesoru, a nikodrugi ne koristi taj procesor, a nema napretka u izvršavanju naše niti. Ali ako je vreme, koje potrebno da se sačekaj na tom procesoru, vemo malo, znači uspašće u taj kvant vremena koliko je već naš proces dobio i dobit će sigurno naredi, zato što je posao koji se čeka kratkotrajan, onda se isplati ovako nešto raditi. I možete nadići sada puno synchronizacijonih algoritama, koji omogućavaju synchronizaciju bez zaključavanja. Ona je u ovom trnutku dosda poporna, a ako treba da se odradi velika količina kratkotrajnih poslova, jer ne moramo da parkiramo i isparkiravamo niti da trošimo na synchronizaciju izmiju svih tih niti. Ako treba se sačeka 10. instrukcija, 20. Možda ovo ovde je više nego prihvatljiv. Vero, vatno, bolje rešenje ne bi smo mogli da naprijemo, nego koristiti ovakve specijalne instrukcije i neki vid zaposlenog čekanja. Na prošlom času smo videli nekoliko algoritama zaposlenog čekanja, koji koriste. Ovo. Prvi je bio Test and Set. On je zahtjevo o postojanje 1. posebna instrukcija. Test and Set, ta instrukcija nam je dovlačila staru vrednost neki promenjive, a tu promenjivoju upisivala vrednostru. Set je odradila. Videli smo da ta algoritam radi, ali da ima problema što se performansi tiče, jer zahteva neprikjedan upis u cache memori i synchronizaciju svih cache memoria u našem sistemu. A zbog toga su ljudi izmislili jednu malo drugačju varijantu toga algoritma, koja se naziva Test and Test and Set. Gde minimalan broj puta pokušavamo da upišamo nešto, da probamo da uhvatimo one trenutak samo kada je došlo do promene odgovarajuće promenjive. Trećim algoritem koji smo razmatrali pretkodni put je bio Petersonov algoritm. Taj brekjer algoritm za dva procesa. To je bio prvi algoritm koji smo mi ovde videli koji ne zahteva ni jednu specijalnu instrukciju. Taj algoritm radi sasvim lepo za dva procesa. Šta smo biše rekli, kak on funkcioniše? Taj algoritm kaže, a mogu proći, ako želim da prođem a nisam poslednji, ili ako sam poslednji jedini sam. Šta smo sad rekao kada neki proces može proći i ući u kritičnu sekciju? Ako je jedini ili ako nije poslednji može proći na sledeći gorak. I mi sada ovo kao pravilo želimo da koristimo prilikom rešavanja našeg synchronizacijonog problema gde imamo armičanom prvi algoritm. Imoj, da se prvi algoritm znači i u korivizacijonog problema gde imamo razmatranje za n procesa. Znači sada razmatramo taj brekjer, odnosno petersenova algoritm za n procesa koji se po nekad naziva i filterski algoritm. Gde su ljudi rekli, ok. Šta radi naš originalni petersenova algoritma? I da ponujem još jednom. Za ustavlja poslednjeg ako nije jedini. Znači, za ustavlja poslednjeg ako nije jedini. I onda su napravili algoritm koji liči na igru sa stolicama ne znam da ste to nekad igrali gde se pušta muzika ima en osoba koja igraju oko stolica a ima n-1 i u svaku iteraciji ispadne po 1 onej koji poslednji dođe i pokuša da se da na stolicu taj ispadne iz igre. A cilj ovog našeg algoritma želimo da zaustavimo onaj poslednji proces koji je došao ne može da napreduje ne može ići dalje poslednji proces se zaustavlja tako da je logika ista kao ona koje smo imali maločas a to je a mogu proći ako sam jedini ili ako nisam poslednji ako sam poslednji mogu proći samo ako sam jedini koji je došao i šta su onda ljudi napravili pa rekli smo da treba da se napravi n-krugova onaj igre sećete se, bira se pobenik tako što se u svakoj iteraciji izbacuje po 1 onej koji je poslednji došao i to je ovde isti slučaj imamo 2 niza 1 niz in gde se ja trenutno nalazim dokle sam ja trenutno stigal da li sam u prvoj iteraciji te igre drugo i treće i imamo drugi niz koji kaže koji proces je poslednji došao u datu iteraciju da či to su dve neke naše promenjive in nam kaže gde sam ja a last kaže koji je poslednji došao u dato stanje da či to je zabeleženo last od jot tu se upisuje identificator da znamo je bitno da znamo da li sam ja došao poslednji ako sam ja došao poslednji kad smem da napredovajem samo ako sam jedini i mi kaže koje to stanje dokle sam u suštini ja uznapredoval i šta smo rekli kako izgleda algoritm imamo jednu spojdu petlju koja će se ponoviti po 1 mi onda idemo i poredimo se sa svim procesima koje tu imamo kogod da ih ima odemo i proverimo dokle došao moj suset broj 1