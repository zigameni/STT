 Kako buffer ili ne, odgori ne, korisnik će dobiti odgvor, tek kada mi dođemo na ovaj ovde del. Tek kada završimo našu alternativu, a ovu ovde našu komandu, tek tada će korisnik dobiti. I ovde mi gde, nemamo eksplicitnu pošalji poruku korisniku, kao što smo imali koji je aktivnik monitora. Ili kao što smo imali u programu s komodelu CSP. Pošalji poruku da se ono je dobro, ovde toga nema. Ovo ovde, ovisvi različiti jezici, odnosno, su modeli. Liče jedan na drugi, ali su svaki od njih različiti. Znači svako ima neke različite svarije. Dalje to, asynchrona komunikacija, asynchrona komunikacija, direktnoj minuvanje i direktnoj minuvanje. Alternativna komanda, nije alternativna poruka, komanda smo da bavelišimo poruke, ne svemo da bavelišimo poruke, videse poruke, ne videse poruke, videse komunikacijuni kanali, ne videse komunikacijuni kanali. Znači to su različite variante koja postoje. To ćete vi imati u nekom konkretnom jeziku, pojma nema, zavisi od tog konkretnog jezika. Videli ste malo čas kako izgleda programski jezikog? Koristi alternativnu komandu i koristi komunikacijune kanale. Jel moraju tako dizgledu jezici, ne moraju, videte ćemo u struadu koja izgleda Dugačija. Videli ste javu koja ima rma i koji je sakrive. Znači to se konkretnog od konkretnog jezika zavisi. Ili možda čak i od konkretne biblioteke jezika koji koristite. Ode sad imamo jedan malo drugačiji primjer. Chod ćemo da naparimo istu stvar koji smo radili negde na početku ovog naše kursa. Kad smo razmatrali monitore i rekni smo, hoći da radim slip 10 sekundina. Sad je pitanje, kako napraviti slip na 10 sekundini? Ja hoći da pozovem slip i kažem želim da spavam 10 sekund. A sad da se sjeti kako smo da se to radili. Tomo je bilo metoda tako da se zvala. Mi smo proslodživali brojkicu i onda smo rekli, wake up time je jednog o current time plus interval. I onda smo radili slip while wake up time in mind you now. Sve mind you in current time. Dok le god mi radimo slip. To je super, samo što ovde baš i ne može mu da radimo. Naš koristnik na klinickoj strani. A ne može da pristupi našoj promeljnji koja kaže koju ima sani. Pa ne može. Istribuirano programiranje, nema deljalnih promeljniku i ima samo poropit. Jeste. A kako onda da rešimo? Ovo je napravio je nomal odrugačije rešenje u odnosu na ono rešenji koje smo uvijeli pre. I dalje ćemo imati metodu tik. Ka se desi tik šta mi je odravimo, kažemo, vekuć je vreme plus plus, ma je što je vrlo jednostavno. Ali sada u mes tonog metoda je slip. Odnosno delay, kako smo je nekad zvali koji smo proslodživali. A za koliko jedinica vremena treba nekoda se probodi, zato je izvalo malo drugačije. I nije za koliko jedinica, nego probudime u toliko i toliko sati. Čvijete, malo drugačije. Znači naš potis, sada nema dve metode, kao smo smo preimali, nego ima... Tri. Zašto ima tri metode? Pa ako dođe nekoj, kaže, probudime za sat vremena. A ja konstatujem, uff, pa ja ne mogu da baferišem tu porogu. Sad mi ja moram da stavim, ok, možda bih ja mogao to nekako da realizujem. A tako što bi u in imao uutar onog bloka, onog s bloka, imao slječin, pa slječin, a koliko puta to mogu da stavljemo, dobil 5, 10, 20, 50 puta. To mi sad već predstavljam malim problem. Jer ne mogu kao kod aktivnih monitora da baferišem porogu. Sto ne mogu da baferišem porogu. A korisnik, kada mi je pozvao nešto, čim ja dođem do njih, on se odblokira. I onda su vi udi reki dobro, to ne može na taj način da se realizuje. Barem ne, jednostavno i barem ne, ako ne znamu, dobinu. Ako znamo, ima 10 niti i to možemo da razlišimo na isti način, kao je pre, nije problem. Nisi mi biće ružan kod, al božemo je, je bitno to, toliko lepota koda ako hoćemo da napremu da raditi. Ali ako ne znamu, koliko ima nini. To ne znamu, do koji dobine, to može da ide iz utr. Onda to realizemo malo drugačije, tako što ćemo staviti. Sa imamo u jednu metodu koja kaže, koliko ima sati, sad, a ona je što mi kaže delay, reže probudime na primjer u 12.00. Svim u 12.00, ako onda izgleda tam metoda delay. E, vidite, ovdje je moguće da pročitamo taj, fake time. I onda kažemo, ako je, fake time, delay od fake time, i ako je to fake time je manje od tod, onda prihvatite takvu poruku i krenite da je obraziraj. Aha, a što radimo, ako nam je neko reko, sada treba da ga probodimo, ne radimo ništa, došli smo na skip, dobra, a što radim, koo skip? Dođe na ni. A što radim ni, o onoj drugoj strani kaže, primjena poruka. Možeš da nastavis dali. Apo dalje, napravili smo synchronizaciju sa onom drugom stranom i ta druga strana je nastavila dalje sa svojim datom. A ovo ovde je sad nešto što nismo imali u CSP-u. CSP-u nismo mogli da kažemo end za poruku koja će nam doći. Zašto nismo mogli, pa zato što je kojda CSP-a bilo buljen pa prijem poruki. Ači bolo vizraz pa prijem poruki. A slovi, kad nas upravili, a ovakav, jedan koncept, rendezvousa malo drugačije, oni su reke, ne, možemo stajemo prijem poruki, pa onda da stajemo bulj o vizraz koji može to da nam razreši. Če malo su kažem drugačije. Sači samo to pomeranje argumenta nam je dozvolilo da možemo da gvirnamo i da vidimo šta se nalazi. I to je u srstini sve što se ovo ga tiče. Sada imamo samo koje su razlike da ponemo još jednom izmiđu rpaca i rendezvousa. U rpaca svaki put, kad se desi poziv te naše operacije procedure, kreira se noviji proces. To je konceptuoma razvika, kod rendezvousa. U okviru postojećeg procesa se sve odražuje. U tom jednog procesa i na tom jednom ćemo sada morati da imamo razvečit onaj accept, koji ćemo da primimo poruku i da odredimo dalje. A kod rpaca, znači, imamo niti, synchronizačiju. Kod rendezvousa imamo sve u jednom toku kontrole, nemojmo mitu da primimo neku synchronizačiju te server-skeniti. Moramo da synchronizimo sa klijenckom stranom, da. Ali ta server-skenica nesynchronizuje sama sa sobom. Znači, to je zajednico. Izarapac iz rendezvous je da je klijen server architektura i da je to blokirajuća klijen server architektura. Da je to do nekle liči i na csp i na aktivne monitore. Ali svaki od ovih ovde koncepata je potpuno izdači. Liče ali su isti. Dobro, je neko ovu implementira? Ilićemo sada ukratko jednom programski jezik, to je programski jezik Adam, u implementira koncepte koje sada videli. Programski jezik Adam je programski jezik koji si dalje korista. Ne koristi se on toliko Evropi, koliko se koristi sa one druge strane, azlansko opijana. Daj ljudi i dalje programiraju u njemu i taj programski jezik živi. Znači, nije mrtav programski jezik, ono napravio ga neko 60 neke i više nikod to ne održava. Ne, održava se postoje, svaki godine dolazi novod, svaki nekoliko godine dolazi novod definicija programski jezika. Taj programski jezik se razvija i ima puno konceptata koji se odnose i na konkurentno i nedistribujerano programi. Mi bismo potencijelo mogli dozvo i ovaj ovde programski jezik i da bozimo skoro čitam kurs koristići dati programski jezik, zato s ovom podržava i niti i monitori i semofore u određenom obliku i randevuje dosta stvari ne podržava sve. ELEKTIMIMOV IMA MOV MESTISTOJ RAZVIČU TO Imenovanje na strani prozivac. Zivac mora tačno da kačem želim da pozijom taj-taj prociš.