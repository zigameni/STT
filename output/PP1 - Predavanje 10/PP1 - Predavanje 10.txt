 U ovaj lekcij pričat ćemo o izvršom okruženju programa. Taj pojam odnosi se na podršci pri izvršavanju programa na višam programskom jaziku. I o buhvata sledeća razmatranja izvršno organizaciju memorije, to jest kako se predstavlju razljede tipovi podataka i kako se dodeljuje memoria, promenjivama različitih memorijskih klasa u programu, kako se pristupa u remezvršanja programovim programu, zatim praviva lavidljivosti, kako u potreb određene promenjive da se upare sa odgovarojećem dekoracijom i kako se iz određene procedure u runtime u pristupa promenjivoj, koja nije definisano u toj proceduri, tako dzvano i nelokalno i promenjivoj. Zatim poziv procedura, kako se generiše kod za pozivi povratak ispod programa, kako se pozivu procedura prenose stvarni parametri, kako se realizuju rekozivne procedure. I drugi stvari, znači izvršno okruženja je obuhvata podršku obrad iz uzeta, ka podršku simboličkom debagovanju, dynamickom povezivanju. Ova lekcija i obim kursa je ograničen, tako da mi ne možemo u svim ovim aspektima govoriti, ali ćemo pomenuti najvažnije od njih. Kako se deli operativna memoria u vreme iz uzošavanja programa, ovo je jedna tipična slika. Na ovoj slici memorijski adres se rasto od dole na gore, znači dole najniža gore, najviša adresa. Operativna memoria deli se na neke logičke zone koje imaju različito namenu. U ovom slici prikazano je da memoria počinje oblašću programskog koda, nači gde se nalazi prevedeni binarni mašnjenski kod, koji mora da se napuni neposredno pre početka iz uzošavanja programa. Zatim na to je na dovezana oblast statičkih podataka, znači globalnih promenjivih i tako dalje podataka koji su prisutni od početka iz uzošavanja programa i celo vreme iz uzošavanja programa, znači granice ove ove oblasti su fixne i poznate compiler u vreme prevođenja programa. Ostatak memorie predstavlje je oblasti koje se po potrebia avociraju i to je s jedne strane oblast dinamickih podataka odnosno hip, koja se koristi za promenjive koji ma se u programu eksplicitno dodeljuje a takođe može dinamicky da se eksplicitno ini impilicitno od uzima memoria, znači to su radne konstrukcije u javi C++ operator nju i razlika između javi C++, što C++ ima eksplicitnu deavokaciju sa delete a java ima impicitan garbič kolektor, znači sve to utiče na sadržaj i veličinove oblasti dinamickih podataka ona u principu kako se stvari dodeljuju memoria, promenjivima raste na gore od oblasti statiški podataka a takođe od vrha adresnog prostora programa pa na niže, ta i deo memoria se koristi za oblast steka znači oblast izlošnog steka protesora koja se koristi tipično za podršku, pozivanju pod programa i lokalne promenjive znači deo memoria naravno ne iskorišćen i ove dve oblasti idu ususred jedna drugo i obično postoji neka hardwareska proverati granica i da se memoria ne prepuni najčešće u savrenjom uslovima koristi se u operativnom sistemu virtualna memoria tako da proces dobija svoj virtualni adresni prostor i znači sopstvene adrese koje po nachodjenju može da koristi naravno realna slika obično znenijan su, složenija tu postoji prostor za raznavne dinamike bibliotekije tako da li je onda deo memoria se koristi naravno za potrebe operativnog sistema ali ovo je jedna konceptu ona slika koja nas zadovoljava za ova naša razmatranja kada kažemo statički to se odnosi na vreme kada radi compiler znači veličine su poznat u veme prevođenja tok termindinamici se odnosi na veličine koje nisu poznat u veme prevođenja nego se menjuju tokom izvršavanja programa vevrednost neke promenjive u toku izvršavanja programa može se čuvati na različitim estima neke promenjive mogu biti u procesorskom registru one se nazivaju registarske promenjive zatim neke promenjive njihove vrenosti mogu da se čuvaju oblasti statički podata kada to su tako zvone statičke promenjive u oblasti STEC-a su tako zvone automatike promenjive to je terminologia i SCAC++ i u oblasti dinamickih podata kada tako zvone dinamike promenjive znači promenjive posleduju različite memorijske klas kak u program svim jezicima programer specificira memorijsku klasu promenjive to je ili implicitno određeno nekim jezickim konstrukcijama naprim. u paskalu promenjive da je kaleresan u glavnom programu smeštaju se statički lokalne promenjive procedura uključujći parametre smeštaju se na STEC-u a dinamike promenjive se znači pozivom funkcijenju alociraju u Ceuse globalne promenjive deklare se neizvan procedura i funkcija smeštaju statički lokalne promenjive procedure njihovi parametre smeštaju se na STEC-u postoji funkcija za memorijsko alokaciju kojima se može znači u dinamicoj o oblasti dodeliti memorija takođe i kom deklare sanja promenjive recivo ce ima različite može se navesti ključno specifikator memorijske klasse kao što je registr statički ili aut za lokalne promenjive koje se smeštaju na STEC-u među im recimo vi možete u podprogramu uvesti lokalnu promenju a onda u deklare aciji staviti statič i ce kom pare će znači da tu promenju jako lokalna za funkciju čuva u statičkoj oblasti na te način da njena vrednost preživljava pozive između razlišti poziva u stetetu memorijsku klasse register kompajder će nastojati da vrednost te promenjiva čuva u nekom procesorskom registru to nije garantovanu to je samo preporuka pro programmera kompajder a kompajder samo u postupu generisanja kode i optimizacije da će da stavi promenju i sad u zavisnosti memorijske klasse u kodu će se promenjivoj pristupati različitim načinima adresiranja recimo registrskim promenjivema u statičkim promenjivima pristupa se memorijskim direktnim adresiranjem jer je i veričina i počina adresa promenjive su poznati u vreme prevođenja programa automatkim odnosno promenjivom koje se dodelju na steku koriste se za njiho pristupanje njima varijanta indexnog adresiranja koje se najčešte zove bazno adresiranje to je u svoje suštini vrednost u nekom registru koja je poznatu runtimeu plus neka konstanta koja je poznata kompajderu znači, sabelu se te dve urednosti dobije se finalna adresa, to ćemo još videti i konačno dinamičkim promenjivama se pristupa nekom vrstom indirektnog adresiranja znači, adrese tih promenje takođe košta su dinamički dodeljuju ne mogu biti poznati kompajderu nego tipično imamo neke pokazivace ili referencija u programu i oni čuvaju adrese takvih promenjevih i onda pristupam preko pokazivaca pristupam u vrednostima tih promenjevih za konkretne primjere i ilustrovatite razne koncepte izvošnog okruženja koristit ćemo kod za intelu x86 na istarju 16-bitnu varijantu s sadašnji procesori koristit 64-bitnu varijantu i kod je malo drugači ali u slušniji nije bitno drugači ovo svatite kao isto konceptuone primjere tp. kod 64-bitni procesora ax bi se zvao rax i nekad je bio dužine 16 bita sadajnje 64 i se imao 4 nekoliko registara na mene i tako zivane indexne registre s i i d i zatim na 40 su bile na nivo u baita i na steku su se čuvale 16-bitne veričine za rad sa stekom koristite se 16-bitni registri stack pointer i base pointer i stack raste premanižim memorijskim lokacijama i stack pointer ukazuje na poslednju popunjenu lokaciju i jedan mali izbor seta instrukcija koliko će nam treba za primjere koje pokazujemo znači imamo instrukcije za rad sa stekom push i pop koji ima operand može biti zadat registar, s kim adresirajem če ja se vreno stavlja na stek ili se uzima sa steku i upisaju registar i takođe memorijskim adresiranjem to je ovo m neka memorijska lokacija može da ide na stek ili da se uzima sa steka zatim poziv pod programa teku će vreno zbranjačanarek bi ide na stek i stek u steku i opcijnoj parametar c koji je na celobrojna vrednost ako je c zada to onda se stack pointer pre skidanja povratna vrednosti sa stacku uvećava za vrednost spetificiranom operandom koji opet može biti dat ili ka u vrenost registra ili ka o nekad direktna memorijska adresa nared pa za povratak iz pod programa znači skida prakčno vrednost sa vrha steka i to ide u brojač nared bi znači vrši se povratak iz pod programa i stek uvećava za vrednost spetificiranom operandom c vide ćemo da ta varijanta naredbe služi da se sa steka dealocijaju parametri poziva pod programa znači ima svoju urogu pri pozivanju u toj sekvenci povratka iz pod programa i konačno neke aritmetičke naredbe x86-ce bilo u svoj osnovi dvo adresna mašina tako da su bila dva operanda srca s abira vrednost operanda srca s operandom ds i rezultat opet smešta u lokaciju ds slično tako naredba od uzimanja i naredba direktno kopiranja iz izvorišta u odredište to je neki mali skup naredbi koji nama treba za naše primere ašto se način adresiranja u tim naredbama tiče koje ćemo koristiti može da se piše konstanta to je nepasredno adresiranje tako konstanta se ugrađuje u kod naredbe o suži kao konstantna vrednost zatim je morisko direktno adresiranje može da se specificira ili konstantnom adresom onda se ona stavio uglaste zagrade čitamo sa fixna adresa 100 ili se simbolički najčešći osembler navodi neko ime koje za menju je neku konkretnu vrednost zatim registrsku direktnu ime na raznih registara registrsku indirektno znači da registr sadrži adresu
 I da će se koristeći tu adresu, pristupa se memori i na to i lokaciji su stvari čuva vrednost. Znači, to je ime registra okruženovi uglastim zagreda. I konačno, bazno ili indexno adresiranje. Kod toga načinu adresiranja, adres opranda se dobija kao zbir sadrža registara i pusili minus neke konstanta. Evo kakva je notacija. Da vidimo jedan primer u nekoj c-proceduri, promenjive RSA i D-deklarisane su na sljedeći način. Promenjiva RSA celo brojna i na vede na vas torič klaseregistru. Našem primeru prepostavit ćemo da se ona čuva nje na vrednost u nekom procesorskom registru. Zatim statik int s, statička celo brojna promenjiva s, zatim auto int a, tako zvan automatska celo brojna promenja u zištini. To je promenjiva či jo se vrednoš čuva na procesorskom steku. I konačno statik int pokazivač D. Znači, to je statička promenjiva tipa pokazivača na neki celo broj. E sad kaže poprespoko da je dužina celo brojna podatka še se zbite i da se pokazivač D inicijali, zove pozivom procedure za lokacijom memore način u suštini to deli neka adresu dinamičkog oblasti i da se onda njena adresa te dinamičke promenjive do deli D, koji je assemblerski, ko od odgovara, način, na redba na to dela je R jednako S i A jednako zvezdica D. Zvezdica D znači da preko pokazivača D, način, pristupamo do toj lokaciji i onda njen sadrežaj, upisojemo Ua. Nas naravno zanima kako izgleda mašinski kot, koji će procesori zgenerisati za ove dve naredbe, ako pretkodno ima ovakve deklaracije. Za do delu R jednako S, to je naravno neka naredba mu koja kopira vrednosti, pošto je S statička promenjiva, kompajder zna njenu adresu, recimo da je to memorijska adresa 200, znači čita će se iz memorie sa adresa 200, mora da se stavi uglaste zagradu, i način, bi to označavalo konstantu 200, da zrzelimo S i da dovedemo broj 200, ali mi ne želimo to nego želimo da pročitamo memorijsku lokaciji u 200 i upisemo znači Ua, a predpostavka je znači da se promenjiva R čuva Ua, u odredišnom registru, S. To je jedan mogući prevod ove ove, znači jednom jedinom mašinskim instrukcijem. Ova druga naredba do delu A jednako zvezdica D, potrebno je naravno prvo pristupiti preko pokazivača D, a znači, da se promenjivo i koja se čul dinamico i memori, ako je D, pošto je D statičke alocirano, recimo da je ona nekoj adresi 200, da bi smo pročitali vrednost pokazivača, koristimo memorijsko direktno adresiranje i vrednost pokazivača upisujemo u BX registar, a zatim čitamo indirektima adresiranja i koristići registar BX, pročitamo našta ukazuje vkazivač T i vrednost sa T memorijske lokacije, znači, to nije adresa 200, da 222 je bio sam D, a znači, u delu je nešto što mi ne znamo što u ranta imo će biti upisano u BX, ali će to biti adresa znači sa koje će se opet pristupiti memori i čitati i upisaćemo u AX, to je u stvari vrednost izvorišnog operanda, i onda znači ta vrednost u AX će biti upisan u odredište, sad pošto u odredište lokalna promenjiva, uskoro ćemo to detaljnije videti, ali lokalnim promenjivamo svek pristupa tako zvanim baznima adresiranjem, u ovom je vredanta index na adresiranja, gde je registar uvek ovaj base pointer i postoji nekakva konstanta koja compiler zna, znači svaka promenjiva ima svoju konstantni pomera i odnosu na lokaciju BP. Zbog ogranjčenja architekture i ovog intelovog procesora ne može se realizovati jednom instrukcijem čitanje indirektno BX, pa smeštanje na ovu adresu na koju kazaju BP minus 2, i u to bi gleda instrukcija transfera iz memori u memori u A, u jednoj mašinskim instrukciju x86-ce, može biti samo jedno memoriske adresire, način memorie može biti samo izvorište ili samo odredište, a ne može biti i izvorište i odredište. Zada detaljnije vidimo kako se u mašinskom kodu realizove pozivanje i povratka takih spodprograma i koje memoriske strukture odgovaraju čuvanju lokalnih promenjivi. Pri svakom pozivu procedure u tokoj došavanja programa na vrh steka se stavlja blok podataka koji koristi pozvana procedura u svom radu. Ovaj blok se zove activationi zapis ili okvir, način activation record ili frame na engleskom. Aktivacin zapis na steku osta je sve do pozvana procedura, ne vrati kontrolu pozivavcu, kad se akivacin zapis pozvane procedure skida sa steka. Evo imamo primer koji to ilustruja, čim se izgovanog programa pozove procedura x, na steku se formira akivacin zapis procedure x, uskora ćemo vidjeti struktur u akivacin zapisom, on čuva sve bitne podatke za izvršavanje procedure x. Ako sad u toku izvršanja procedure x pozovemo procedure y, na vrh steka, na či iznad akivacin zapisom procedure x, formira se novih blok podatak akivacin zapis procedure y, na čom se formirate nutku, kada pozivamo proceduru y i osta će na steku sve do godi aktivan taj poziv y, ako se izy zove sada neka treća procedura c, na vrh steka, na či iznad y dolazi akivacin zapis procedura c. E sad, kako se završavaju da kažem ovi pozivi, kad procedura c završi i vrati su y, sa vrha steka prvo će biti uklanjen ovoj akivacin zapis procedura c. Kada se je izvaši povratak iz yx, sa steka će biti uklanjeni ovoj akivacin zapis y, i konačno, kad procedura x završi i vrati su uglavne progamse, s steka će biti uklanjeni i akivacin zapis procedura x. E sad malo da konkretizujemo priču i prva ćemo razmotriti variantu koja odgovara c i jeziku, a to je varianta kada imamo model izvašavanja, gde imamo procedure i promenjive ili mogu biti lokalne za tekuću proceduru, ili one globale, promenjive koje rekli smo sačuvaju u statičkoj memorite, u stvari relativno jednostavna situacija. Jeziku c odgovara, evo ovakva struktur akivacin zapis, na ovoj slici punom linijume prikazan akivacin zapis tekuće pozvane procedure, a crtka na linijume prikazan drugi akivacin zapis procedure koje pozvala tekuću proceduru. Na nuslike su niže memorijske adrese, a memoria rastr, znači, na gore. I nos teka je ovde gde ukazuje steku po internaču, u trenutku kada poziva oc, či akivacin zapis je prikazan ovim catkanim linijama, pozove tekuću proceduru, prilikom tog poziva formira se na vrhu steka ovaj blog podataka koji čini akivacin zapis pozvane procedure. U tom akivacinom zapisu, najvišim adresama, znači, prvo se na stek potiskuju stvarni parametri koje poziva oc, prenosi pozvanoj proceduri, zatim, u trenutku kada se izvrši mašinska naredba call, na vrh steka ide povrat na adresa, da je će kontrola da se vrati pri prilikom povratka, zatim, na vrh steka ide polje kontrolne vese. Polje kontrolne vese u suštini stari sadržaj BP. Do tog trenutka BP ukazivalo na akivacinom zapis pozivalac, i to konkretno u pravo na polje kontrolne vese u pozivalacu, a onda u jednom trenutku mi ažuriramo BP da ukazuje na akivacinom zapis pozvane procedure, a staru vrednost BP čuvamo znači na steku. I u suštini, to polje kontrolne vese i kao pokazivač, znači na odgovarajuće polje kontrolne vese u akivacinom zapisu pozivacu, sad i te pozivaca koja njega neko pozvo isto ima, znači jedan tako pokazivač i inače, ovaj lanac tih pozivacu zovemo lanac kontrolnih vez, on može recimo da bude odkoristi, naravno osim normalno izvašavanja programa, kadam posle povratka iz procedure zatreba stara vrednost BP da je stabiliramo, može biti odkoristi recimo i pri debagovanju programa, kad prekinete programu u debuggeru i želite da pogledate stek, debugger može da koristu ovo polje kontrolne vese, da bi vam prikazo koji sve akivacine zapise se u tom trenutku nalaze na steku i tako dalje poved polje kontrolne vese, na kraju delo prostra odvojen za smešta i lokalnih, promenjivih procedure i nači tu je sad vrh steka odnosno stek pointe, načo ovaj akivacin zapis se formira na početku poziva i existira na steku dogod se izvršava kod pozvane procedure, pri dogod se izvršava kod pozvane procedure ovaj zapis se dialocira sa steka i na vrhu steka ostaje akivacin zapis pozivaca, to znači da lokalne promenjive imaju svoji život od trenutka poziva do trenutka povratka iz stekućeg poziva sekvenca pozivanja je niz aktivnosti koje pri pozivu neke procedure izvršava i u pozivalaci pozvana procedura da bi uspostavili akivacin zapis pozvane procedure, to je naravno sekvenca u mašinskom kodu koja se znači da je izvršava u vremu izvršavanja u trenutku kada se pozove neki podproba sekvencu pozivanja zajednički izvršava u jedan del sekuvence procedura pozivalac a drugi del sekuvence pozvana akivacinog zapisa ako je znati koji del formiranja zapisa radi pozivalaca ako pogledate gde je povratna dresa jer povratna dresa je trenutak kada se kontrola stek kontrola se prenosi sa pozivalaca na pozvanog ovaj del zapisa koji je više na steku za ključno sa povratnom adresom njega formira pozivalac ovo sve što je niža od toga mora da formira pozvana procedura ako to taksativno naprojimo akivnosi započinje procedura pozivalac koja prvo na stek redom stavlja stvarni parametre za pozvanu proceduru videte ćemo da hod jezika kao što je C stvarni parametri idu poslednjeg k prvo obrnutim redo sam prvo ide poslednjena stek to je za toh što C dozvoljava promenji v broj parametara pri pozivu ima mehanizam da obezbedi da napišete pod program koji možete pozvatiti s promenjem v brojim parametro i neke bibliotečke funcije decimo funcija printefije dobra primer mogu da primaju promenji v broj parametara i onda taj redo sred od poslednje ka problemu zna te nakon pomeraju je prvi parametra pa poslednoga uvećavanje možete doći do ostali parametra no dobro to je jedan dete prvo se stavlja stvarni parametre i onda se izvršava kol naredba koja na stek stavlja povratno odresu i prenosi kontrolu pozvanu i proceduru
 Pozvana procedura, znači mora da sačuva stari sadreže registra BP i na te način formira polje kontronove vese, zatim sadreže registra STEC Pointer koji u tom trenutku ukazio na kontronu vese, jer spoluprvo njom potisno rino STECa STEC Pointer uvek ukazio na posljednju punu, znači se kopira u BP, tako se znači formira novi sadreže BP i od sadreže registra SP oduzima se broj N koji je poznatu vreme prevođenja, radi se obroju memorijski lokacija, znači kod x86 i cepro i byte-ova, potreban za smešta i svih lokali promenja, znači to je zbir veli čina svih lokali promenji, mihno ovaj način se na STECo locira potreban prostor za lokali promenje, nakon završetka sekvence pozivanji izvršala se kod pozvane procedure za inicijalizaciju lokali promenjevi, i tako dađe, znači ovo najnevidljiv del koda koji su u programu koji programmer piše na višom programskom jeziku i ne vidi nego tek znači kada se taj kod završi, ide taj kod koji je programer, da kažem koji je prevedeni kod sa više programskog jezika. Je znači na kraju izvršavanja pod programa, znači pri vrihom povratka iz pozvane u pozivajući procedur, izvršala se sekvenca povratka, znači nju počin je pozvana procedura, u slušljini radi su o potpuno komplementarno i aktivnosti o ne sekvence pozivanje, jer sve što smo na STECu avocirali, sad treba ukloniti ta manu obrnutim redom. Znači poslednja smo stavili prostor za lokalne promenjeve, to je prvo što se uklanja, i to na taj način što se sadrže registra PPEK kopira u registra SP, čime se sa STECa oslobađa prostor za lokalne promenjeve i ona je efektivno prestevi da postoje. Zatim se sa vrha STECa, koji u tom tenutku kazu na pođe kontrolne veze podzvane procedure, skida vrednost kontrolne veze i smeštu registra PPEK, i time smo restaurirali zapamđeni sadrže PPEK, odnosno on je sad odgovara proceduri pozivavacu. I zatim naredba ritran skita sa STECa povratno odresu i smešta u brojač naredbi IP, time se kontrola preda je pozivavacu, znači na onom mesto i za onog poziva mašinske naredbe call. E sad pozivala cioš mora da dodavanje odgovarit će vrednosti na SP, sa STECa ukloni stvarne parametre i potom je za vašem poziv i nastavlja se naravno izlašavanje koda koji je bio posle poziva. Eho da vidimo na konkretnom primeru jednog romalog podprograma, napisati znači x86 semrljski podprogram, kvalentan datom programu na ceu, procedura primer koja prima 2 ce lvna parametra A, B, ima jednu lokalnu promenju u C, ima samo jednu dodelu u telu C jednako A, i kaže koja se kvensa semrljski kod odgovara pozivu primer, znači sa stvarnim parametrem, konstantama 10 i 20 u glavnom programu. Znači što se tiče samog poziva koji je deo glavnom programa, potrebno je znači prvo na STEC staviti stvarne parametre, a to se radi znači sa dve puš naredbe i rekli smo parametri se stavljaju redom zdesa na levo, prvo 20 pa 10, zanim ide znači poziv i kada se vratimo, znači u glavni program moramo skinuti, znači to ili može da bude ed sp zareš 4 ili 2 puta neka pop pričemo ovo CX, je neka vrednost koja nama ne treba, pošto ova 2 pop su prža nego direktno ovo ed ADD, onda često je kompajler u gradi ovako ovaka kod. Sama procedura primer njen kod je sledeći. Početak je u svake procedure uveki stir, to je standardne ideo kao i sam kraj. Iako se ne koriste posebne naredbe za podašku pod probleme kojima ćemo uskoro pričati, onda kod izgleda ovak puš BP, smešta znači čuva BP na STEC-u, evo ovde možemo videti konkreta izgled aktivacijenog zapisa za konkretno ovu proceduru primer, znači ovo su ona 2 stvarne parametre 30 i 20 potisnuti na STEC, zatim ovo pripozivo, znači povratna adresa, zatim smeštamo, to je upravo ovo polje kontrolne veze, znači se s ovim puš BP smešta na STEC i potom muv BP-SP, znači BP u toku izvršavanja sad procedure primer od ove naredbe pa nadalje ukazuje na ovo polje, tako da sve druge vrednosti to je upravo i referentna tačka ovog aktivacijenog zapisa, do svih drugih delov aktivacijenog zapisa stvarno je uvek stvarno, a opet prva vokalna promenjiva je na BP-2 od ovog 16-bitnog procesora, mislim te konstante se proprocenu uveća vojako je 13-64-bitni kod došli smo u obješnja vanjem do ovom BP-SP, zatim se SP smanje za 2, da bi se alociralo prostor za ovu lokalnu promenju u C i sad ide konačno ona dodala C jednako A a to se realizuje tako što se čita stvarni parametra A kako BP plus 4 i svojom sprem, da se je uvek stvarno, da se je uvek stvarno a to se realizuje tako što se čita stvarni parametra A kako BP plus 4 i smešta ta vrednost u AX mora da se iskoristiti za privremenu smeštanja neki registar i pošto to sad dodeljujemo od promenjiva C, promenjiva C na BP-02 znači su sadrži za X, smešta na BP-02 i tim je sa ove dve mažnjske naredbe realizovanja da dodala C jednako A potom ide povrata quiz pod programa znači sam u sPBP uklanjamo prostor za lokale parametre i dolazimo do ove navrhu steka kontrone vede sa popBP sta rurrenu s BP opet smeštamo u BP i sa return kupimo povratno adresu i vraćamo sa uglavni programa znamo da uglavnom programu se još sa 2 ona pop skinu još ove dve lokaci i što se te steka ti če on je ispražnja kako se realizu rekurzivni pod program i isto je ova steka je ja považan znači za realizaciju rekurzije u program svih jezicima evo kogretan primjer datare C funcijan fact pratiti toki zvašavanja, poziva FAKTO 3 i odrediti izglede procesu steka u tenutku neposledno preprvo povratka iz funcija znači ova funcija FAKTO je u stvari kao računanja faktorijela na rekurzivanja način prima znači parametra n i sada ako n strogoveće od nula dešava se rekodivan poziva koja n jednako nula to je onaj izlans iz rekurziva onda se vraća 1 kao vrednost faktorijela ako je n već od nula onda je vrednost faktorijela n puta pa faktorijel od n-1 znači svoji se slučena n-1 i sad za FAKTO 3 iz glavnog programa poziva se FAKTO 3 pojenta je da svaka aktivacija, procedurili funcije formira sobstveni aktivacijun i zapis, znači ako u ovim slučima kao što rekurzija njima imamo više aktivacija, više poziva znači srednji poziv će se obaviti pre nego što se prvi poziv završi i to znači da ćemo imati više aktivacijun i zapisa za FAKT na steku i jednom trenutku znači prvo će na stek ići o aktivacija FAKTO 3 znači čuva se naravno vrednost varno parametra povratna adresa lokalni promenjuva je nema znači ovo je kontrolna veza znači samo ta 3 polja efektivna postoje u aktivacijunom zapisu i sad kada dođe do rekordzivno poziv znači abi se izraču na ovaj izraz 3 puta FAKTO 2 dolazi do rekordzivno poziv o FAKTO 2 znači iznad ovog aktivacijun i zapisa formira se aktivacijun i zapis FAKTO 2 znači on ima sopstveno vrednost varno parametra dobro povratna adresu i polje kontrolna veza u okru računanja FAKTO 2 dobijemo izraz 2 puta FAKTO 1 znači dolešava se rekordzivom poziv FAKTO 1 novi aktivacijun i zapis i u okru računanja toga imamo 1 puta FAKTO 0 dolazi do rekordzivom pozivom FAKTO 0 i to je poslijenja aktivacija zapise sad kada računamo FAKTO 0 nema više rekordzivima poziva nego se direktno vraće jedinica znači nastaj ne ispo vrataka kad se FAKTO 0 vrati tu jedinicu onda se završi računanje izraz za 1 puta FAKTO 0 to je 1 puta 1 jako 1 i to se vraća na ovaj vredkodni nivo znači to je bio FAKTO 1 sad on vraća kontrolu na FAKTO 2 gde se računa 2 puta 1 jako 2 i to se vraća u FAKTO 3 i tu se se vraća na 3 puta FAKTO 2 1 jako 6 i to se vraća u kvala rezultat kompletan kako se vraća ta vrednost iz procedure do sad nismo rekli i da se vidimo da na steku postojete povratne vrednosti pa po konvenciji u ovičnosti, ovoj slučajima kad može dostane u jedan procesarski registrer a jedan se upravo može dostane u procesarski registrer po konvenciji to se vraća u procesarskom registru AX ovo je odgovaralo slučaju CA sad će bo razmatiti statičko okruženje za nej lokalne provenje realizovanog pristupnim vezanom postoje progranski jezic, jedan od primera je paskal to je već zastravo na neki način primera ali neki novi progranski jezic i koji to isto koriste i takođe, gnu C++ i sto ima tu nestan dan na ekstenziju da se dozvoljava statičko okruženje za ne lokalne promenjive praktično, očemu je reč dozvoljene ugnježdavanje deklaracija procedura da pišete neku funciju i u njenom telu možete da definišete drugu funciju kod onda lokalna za tu funciju i sad to samo po sebi ne bi bila prograna da se dozvoljava statičko okruženje za ne lokalne promenjive praktično, očemu je reč to samo po sebi ne bi bio problem nego učinjenice da sa ta ugnježda na funcija može da koristi i promenjive koje su lokalne zna ono spojno funciju može da pristupi promenjivama koje nisu njene a z druge strane nisu ni globalne i takav pristup zovemo ne lokalni pristup promenjive na neke način moramo da obezbedimo u runtime u pristup tim ne lokalnim a to se realizuje preko ovih pristupnih vece evo, sad ćemo videti šta, tačno, te pristup ne veze znači struktura aktivacenog zapisa kad postoji pristup ne lokalnim promenjivama mi ćemo primjer Paškava uzimati ali to važi kažem za te druge jazike koji dodvoljavaju ugnježdavanje procedura kao iranije znači, ovo je aktivacin zapis pozivavac, zato je samo na značen od crticama a ovo je znači tekući aktivacin i zapis pozvane procedure i sad tu vidimo naravno polja koja smo iranije videla stvarni parametri povratno adresa, kontrol na veza lokalne promenjive ovo je pristupne veze se definiše na taj način kako pokazivačna jedan aktivacion i zapis koji se već nalazi niža na steku ali znamo da je kontrol na veza usuštini pokazivačna aktivacion i zapis
 kontrolna viza ukazuje na aktivacijoni zapis, onoga koja u runtimeu neposredno pozvao tekuću proceduru. Polje, pristupne vize ukazuje na aktivacijoni zapis, aktivacije one procedure koje je okružujuće za posmatranu proceduru u listingu programa. Znali na koju proceduru će da ukazuje pristupna viza, mi možemo da pogledamo listing. A kažem za kontrolnu vizu je bitan poziv u runtime. Postavlja se pitanje kako ćemo formirati pristupnu vizu i videli smo da u sekvenci pozivanje pod programa treba svako ovu polje definisati, u njegu upisati neku konkretnu vrednost. I znači takođe i što se polje pristupne vize etiče, znači compiler mora generisati kod koji će postaviti prilikom poziva vrednost u to polje pristupne viza. Ako pogledamo ovostrukturu zapisa vidimo da se pristupna viza nalazi pre povratne adrese što nam govori da to polje mora da definiše još pozivalac. Znači u okviru koda poziva oca mora da se tu definiše vrednost. I sad postoji u suštini tri slučaja. Znači uz avisnosti od toga kako u listingu izgleda odnos procedure A i B, ako procedura A poziva proceduru B. Ovom prvom slučaju deklaracija B ugneždena u deklaraciji A, odnosno B na jedan više mleksičkom nivou ugneždavanje od A. I znači rekli smo da ova procedura koja je spoljna poziva proceduru B, znači ona je ustvarila definisana neku svoju lokalnu proceduru i onda u telu procedura A. Naravno možemo koristimo tu lokalnu proceduru. Znači to je taj prvi slučaj. E sad kako formiramo pri pozivu, kako taj kod za A da formira pristupnu vezu za B. Pristupnu vezu za B mora da ukaze na sam aktivacijani zapis procedure A. U suštini na polje kontrolne veze. Procedura A će upisati prosto vrednost svog BP stavit će nastekit i me će formirati pristupnu vezu. Na sobstveni aktivacijan zapis A. E sad u drugom slučaju deklaracija B ugnježdeno u nekoj proceduri X, kao i deklaracija A. A i B su na istom leksičkom nivou i procedura A poziva proceduru B. O ovom slučaju pristupna veza A kopira, su u polje pristupne veze B, oni dele znači isti pokazivač na aktivacijani zapisove okružuviće procedure X. I konacno postoji treći slučaj koja je na neki način aj komprikovanija, to je da je leksične nivou ugnježdavanja procedure A veći od leksičkog nivu AB i ta razlika može da bude i već od jedan, evo ovdje je prikazan jedan primer. Imao nekakve procedure skroz okružuviće X u X u E B, onda imamo unutr B nekoj Y, pa tek onda imamo A. I sad to naju grijednije A poziva ovo B koja je negde spolja, znači okružuviće, ali ne neposredno okružuviće. U ovom slučaju potrebno je slediti lanač pristupni veza, počeši od pristupne veze A, pošto to trenutno imamo, pošto procedura se A se izvršava i njenu pristupnu vezu smo već formirali. Koristet ći tu pristupnu vezu A kao početa klanca, sledimo, znači, po tim pristupni vezama koje formiraju lanač, sledimo n, n član ova to klanca i onda kažu, po lje pristupne veze za B, iskopiramo sadreže n to po lje u lancu. Znači, znači jedan na koje jedan to je, po lje na koje ukazuje, po lje pristupne veze za A i tako dalje. Kako izgleda sekvenca pozivanja način ovo slučaju ovih pristupni veza, malo je različite, znači odnosno C. Pri pozivu procedura pozivalac, način radi sledeće, na stek redom stavlja stvane parametre, recimo za Pascal je bilo suprotno nego koca parametri su išli onim redom, koji su navedeni prvi parametre i de prvi na steki tako dalje, pošto Pascal nije imao mogućnost promenivog broja parametra u podprogramu. Zatim na stek se stavlja vrednost koja definiše sadreže pođa pristupne veze pozvane procedure, premat način o nim pravilima, o najprvi drugi, sad treći sluča algoritma. Zatim se izvršava na RedBad, način koliko je na stek stavlja povratno adresu i prenosi kontrolu pozvanoj proceduri. Pozvana procedura na stek stavlja sadreže registra BP, to je spolje kontrolne veze, zatim sadreže registra SP koji u tom trenutku ukazuje na kontrolnu vezu kopira u BP, tako formiramo novim BP da ukazuje na pozvanu proceduru i kažemo, sadreže registra SP oduzima brojen koje je poznat u vreme prevođa, radi su o brojima morisko lokacije potredno za smešte i svih lokale promenjivih i nakon za ušletranje sekvence pozivanji, izvršava se kod pozvane procedura. Kako izgleda sekvenca povratka? Prilikom povratka izpozvane u pozivojiću procedur izvršava se sekvenca povratka koju u potpunosti realizuje pozvana procedura, znači pozivala cnema šta da radi. Sadreže registra BP kopira se u registra SP, čime se sa stek oslobađa prostor za lokalne promenjive, one efektivno predstavio da postoje onda, znači u tom trenutku stack pointer ukazuje na pođe kontrolne veze, skida se znači ta vrednost kontrolne veze i smešta u registra BP, znači to je ono pop BP, dim je ovaj registra postao sprana za upotrebu u pozivavcu i kaže naredba redn, znači koristiti se ovaj parametren, skida sa vrha steka povratno odresu i smešta u brojač naredbi, IP, instruction pointer. Ova naredba zatim uvećava registra SP za vrednost n, čime se sa steka skida ju stvarni parametri i pristupna veza. Nakon toga se kontrola predaje pozivavcu. Ove se koristio ona vrednost, da se vratimo na aktivacijun i zapis, koristis se vrednost n koja, znači mi smo u tom trenutku smo stack pointer ukazivo na povratno odresu i kac izvaši redn, znači prva se skine ta povratna odresa, a zatim se još stack pointer uveća za ovo n i time se eliminišu pristupna veza i stvarni parametri. Komparer znak ovdje ko treba da to n u zavisnosti od veličine uprojavu i stvarni parametra. Tako da kac evratimo kod pozivavca i za kol nemora nikakve više naredve da se generišu tuje razlika između c a i paskala. Znači to je bilo ta sekvenca povratka. I da vidimo konkretan primjer odrediti x86 sembljške kolendato paskal programa kako izgleda procesorski stack u trenutku neposejno pre prvog povratka iz procedure. Evo da vidimo kako izgleda program, to je sada ova paskalska sintaksa, znači problem se zove glavni i unutar njega imamo definisan u proceduru, jedan koja ima promenji u lokal jedan, znači celobrojnu, a unutar procedure jedan, ovo je tako da je na formar deklaracija, znači da će tek biti deklarisan na procedura 3, međutim onda ide deklaracija procedure 2. Znači unutar jedan imamo proceduru 2 koja poziva 3 i zatim, znači istu unutar jedan imamo i proceduru 3. Znači procedure 2 i 3 su obe unutar procedure 1. Procedura 2 poziva 3, a procedura 3 ima pristup ne lokalno i promenjivo je lokal jedan, jednako 10 i onda sledi povratak iz procedure 3. I onda i procedura 1 poziva proceduru 2, a glavni program poziva proceduru 1. Znači kako u toku izvršavanje ide redosled, glavni program poziva proceduru 1. Procedura 1 poziva svoj ugneždenu proceduru 2. Procedura 2 poziva proceduru 3 koja je na istom nivo i pristupa ne lokalno i promenjivo je iz procedure 1 i onda redom ide redosled povratak iz 3 u 2, iz 2 u 1, iz 1 u glavni program. Vrena, koji je u detađe s kodom, može pogledati izgled steka. Što se tiče glavnog programu, u principu, kot pa skala glavnom programu ne treba neki poseb an aktivacijon i zapis, bo stoji samo jedna lokacija koja izigrava, da kažem neki degenerisani aktivacijon i zapis, zato što promenjive glavnom programa idu u statički deo memorida, čuvaju se na steku. Međutim, kad si glavnom program pozove procedura 1, njen aktivacijon i zapis se formiraju. I ovom konkretnom primjeru, konkretna polja koja ona ima su povratna adresa, pristupna veza je ne treba, jer glavni program nema svoj aktivacijon i zapis, tako da ta procedura koja ne posebno u glavnom programu nema pristupnu vezu, nego samo znači ima povratnu adresu, kontrolnu vezu i promenjivu lokalijadan. To je aktivacijon i zapis procedura 1. E, sad kad se iz procedura 1, pozove procedura 2, ona ima pristupnu vezu i ona ukazuje na 1, pošto je 2 u listingu ugnježdena na 1. Znači od procedure 1 se u stvari poklapaju pristupnu i kontrolnu vezu, što je samo koincidencija slučajna. Znači s ove strane su prikazane kontrolne veza, a s ove strane su prikazane pristupne da ne bi se zbunjivali, znači s ove strane su prikazane s desne strane su kontrolne, ona nema svoje lokalne promenjive. I sad kad si z procedure 2, pozove procedura 3, na vrhu steka se formira aktivacijon i zapis procedure 3, i skopira se pristupnu vezu procedure 2 u pristupnu vezu procedure 3, jer one su na istom leksičnom nevoju, be ukazuje u stvari na aktivacijon i zapis procedure 1. Znači to su te pristupne veze, a kontrolna veza naravno procedure 3 je prema onom redu sredu pozivanja. Znači 3 ukazuje na 2, a 2 ukazuje na 1. A 1 ukazuje na i rudimentarni umesto aktivacijonog zapisa celog programu. Ovo je izgled aktivacijon zapisa pre nego što se realizuje prvi povratak iz bilo koje procedure. E sad još da imamo mašinski kot koji se generiše. On se prema onome kako se ilazi u listingu programa na tela pojedini, na izvaša tela pojedini procedura. Ode je prvo se u listingu na ilazi na izvaša tela procedure 2, koja poziva proceduru 3. Ide deo sekvence poziva, to je ideo posle. Poziva treba da se formira pođe kontrolne vede sa puš-BP i mu-BP-S5 da se ažurira BP. Zatim i tim smo završili. Znači sekvencu poziva 2 od strane poziva i sad ide prevo tela. A u telu je bio samo poziv procedure 3. E sad kako se taj poziv procedure 3 realizuje prvo pošto nema parametara, znači ništa ne ide na stekot parametra. Sledaj će da se formira pođe pristupne vese procedure 3 i pošto je procedura 2 na istom nivou kao 3 za
 Znači rekli smo njenu pristupnu vezo, a to je kad pogledamo aktivacijon i zapis, da bi znali tačno kako doći do pristupne veze procedure 2. U trenutku kad smo ovo radili, imali smo je ovdje BP o ovde, ukazivo je na kontrolu vezu procedure 2. I sad BP plus 2 je povratna adresa, a BP plus 4 je pristupna veza. Znači da bi pročetali ovu vrenost koriste se adresiranje BP plus 4 i to se prosto potisne u tom trenutku na stek, čim je formiramo ovu pristupnu vezu procedure 3. Znači puš BP plus 0, 4 formiranje pristupnu veze procedure 3 i pose toga ide poziv procedure 3. E sad naravno kad se vratim iz procedure 3 treba je samo realizavati povratak iz 2, kod pozivao, cato znači ako treba nešto da je alocirati, i ako ništa nismo imali alociran, ali compiler je najčeštji izgeneriš ovom u SPBP, zatim pop BP, znači da se je restovljila stari sad, dažli BP i imamo samo ret sa prepoziva, su 2 baita na steku alocirana za pristupnu vezu, je sad procedura 2 je zadužena da skloni svoju pristupnu vezu i to je sa ovim ret 0, 2 realizavati, znači pro se pokupi sa steka povratna adresa, a onda se znači još skinu 2 baita, da bi se skinula i pristupna veza procedure 2. I tim je prevedeno kompletno teloprocedure 2. Posle procedure 2 ide teloprocedure 3 koja je dosta slično, ovo je početak pužbe PEMU B, PSP da su stanovita kontrla veza i BP za proceduru 3, i sad u proceduri 3 njen o telo ima pristuponoj lokal 1 njen ako 10 dodelu, nači kako pristupiti promenivo i lokal 1, moramo pročitati pristupnu vezu, a ona je uvek na BP plus 4, u suštini d i nam je referentna tačka sad ukazuje na aktivacijon i zapis, neposredno okružujuće procedura, a to je upravo procedura u koje je esteta promeniva, to je procedura 1, tako da sad nam d i menja u stvari BP, pošto on ukazuje upravo na pravo mesto u proceduri 1, i sad d i minus 0 a 2, pristupamo, označi prvo je lokalna promeniva, to je istost standar na lokacije, gdje suvek može naći prva lokalna promeniva, u ovom sučaju to je jedina lokalna promeniva, i na to mesto upisujemo konstantu 10. Ovdje postoji samo jedna napomjena da sama syntaxa ovaj move, narjedbu assembleru ovdje bi pisala, ne znam word, pointer 10, ili tako nešto, mavo je komplikovan i ovdje malo uprošće nije, svodi se na suštinu, znači da imamo ovo index na odresiranje, znači register manja ova konstant. I time smo u suštini obavili telo procedure 3, sledi samo ova sequenci povratka koja znači dialogira, ako postoje lokalna promeniva, u stvari BP i povrata ku zklajanje pristupne veze procedure 3. I konačno i detelo procedure 1, koja kao što znamo samo poziva proceduru 2, znači opet stantemda i početak uve koji dojde narjedbu pušće BP mu BSP, je sad pošto ona ima promenivu, znači moramo smanjite SP za 2, čim smo dodelili prostoru promenivo i lokal 1, i zatim pošto pristupne veze za proceduru 2 treba baš da ukazuje na ovaj tekući aktiv, znači prosto vredno z BP na to mesto potiskujemo na stek, pozivamo proceduru 2, naravno kad se vratimo iz 2 već je sve obavljeno vezan ozato i poziv, znači posljetoga ide samo sekuvenca povratka, a u glavnom programu imamo samo poziv procedure 1. Statičko okruženje realizavano display. Ma na ovih pristupnih veza, što si i nače manifestovalo nekada su ljudi pisali veće paskalstke programe, u opšten sluči ako se promenivite klarisan na ne ljubom, na leksičkom n n n n klo n n ne lokalnoj, pričemu je značo ovo n ugnežde nije od m, potrebno je slediti lanač od n manje m pristupnih veza, da bi se došlo do aktivacijom zapisu, u kome se nalazi i promeniva, nače ako je ta razvika tih leksički nivola veća, onda u suštini relativno je neefika sa pristupire potrebno tih n manje m plus 1 pristupa memorija, da bi se pročitala, promeniva. U mesto pristupnih veza mogu će koristiti koncept displaya. Ideja, znači displaya je da u stvari, imamo čitav jedan nis pokazivača i taj nis je naziva display, i znači onda u tom nizu svaki element nize pokazivač na aktivacijon i zapisa taj nivo, znači ako display ima n n n n i loa, prvi element je pokazivač na aktivacijon, na leksičkom nj ovo 1, koja je trenutno aktivna, zatim drugi element je pokazivač na aktivacijon i zapisa taj nivo, znači ako display ima n n n n n n n loa, prvi element je pokazivač na aktivacijon, koja je trenutno aktivna, zatim drugi element je pokazivač na aktivacijon i zapis procedura na leksičkom nj ovo 2, koja je trenutno aktivna i tako daje. Ako tako u strukturu podatva usvojimo za pristup ne lokalno i promenjivo i putem display, uveks je dovoljene 2 naredbe bez obzira na kojem se leksičkom nivo unalazi ne lokalna promenjiva. Prva naredbu u registra dovodi sadrža i duvarići pokazivača koji predstavlja dresu aktivacijon i zapisa u komese nalazi ne lokalna promenjiva, koristeći bazno indeksilanja sa poznatim pomera. Da se čuvac je o taj niz display, a moguš, to je gdje vi su i odrealizacijemo, ako ima dovoljno registra procesora, najefikastnih ih je čuvati u registrima procesora. Ako ne onda u statičkoj zoni memorie ili čak u aktivacijonom zapisu procedure videte ćemo da ovaj treći način u stvari je način koji realizu x86 procesor ako koristimo posebne naredbe koje način on ima hardware skupo za ove display kao što ćemo uporzo vidati. Ponovit ćemo primjer o sličan predhodnom na paskalu. Opet imamo glavni program i procedure 1,2 i 3, i procedura 1 kao u ranijem primjeru ima ne lokalno promenju u lokal 1. Zglavnom programa se poziva procedura 1 iz procedura 1 se poziva procedura 2 iz procedura 2 se poziva procedura 3. Znači sve to je isto i u proceduri 3, i onda pristupa to je promenju u lokal 1 kao ne lokalne. I sve to je isto. Jedina radike zmiju pretkodnog i tekućeg primjera. I sada vidimo druga radika, na rovom što ćemo sve pristupi hve zakoristiti koncept display. Da vidimo znači sliku da kažemo u memori koja se formiru u toku izvršavanje ovih programa prvog znači povratka iz procedure, praktyčno bi smo imali display od 3 elementa, ne raču namo glavni program, znači procedura 1 je na lekčunu u 1,2,3, i 3 elementa ne raču i procedura 1 je na lekčunu u 1, procedura 2 je na lekčunu u 2, a procedura 3 je na lekčunu u 3. I u trenutku izvršavanja, nači procedure 3 imamo ovakav izgled, znači na steku su ta 3 aktivacijona zapisa za 1,2,3, a u nizu display koristimo 3 elementa, i znači prvi element pokazuje na aktivacijne zapis procedure 1, drugi element pokazuje na aktivacijne zapis procedure 2, jer ona je okružujuće za 3 i konacno 3 element pokazuje na tekuće aktivacijne zapisame procedure 3 kao što i Bp ukazuje, znači mi možemo lokalnim promenjivima za 3 dok izvršavamo 3, pristupiti preko Bp i preko displaya 3. Kako izgleda prevedeni kod? Nemoramo sve gledati, samo da vidimo kako izgleda ona u proceduri 3 prevedena na redba dodele lokal 1 je 1, kod s, znači to je ne lokalna promenjiva za proceduru 3, a ona je lokalna za proceduru 1. E, znači kako koristimo display, znači mi vi sam vi skoristili 1 element displaya, doveli ga u neki register i onda preko poznat o pomeraja došli do lokal 1 promenjivima, njoj upisali 10, ako bi smo koristili pristupne vese kao ranije ovde je jedinog sad situacija drukčija, u toliko što je 3 ugneždeno u 2, a 2 ugneždeno u 1 znači moramo sledeti lanac pristupnih veza ova prva asembrska naredba u stvari kuzima znači u dei i sadržaj pristupne vese procedure 3, onda moramo koristeti tu pristupnu vezu da pristupimo vezu procedure 2, i opet preko poznat o pomeraja dodođemo do pristupne veze procedure 2 a ona tek ukazuje na 1 i onda tek koristeteći znači ta idei upisati lokalnu promenjivu vrednost 10, znači vidimo da je efikastnije kada koristimo display postavlja se pitanje dobro pristup promenjivamo efikastnije, ali šta je sa žuriranjem samog tog niza displaya i koliko mašinskih naredbi moramo za to utrošiti jer u onom predkudom slučaj sprisnujom vezama, abim ali smo samo jednu lokaciju pri pozivu, ali tako pod programa jednu pristupnu vezu ovde, sad imamo čitav vektor tih pokazivača. Tu postoji jedna srećna okolnost u suštini dovoljno u tom nizu pri svakom pozivu samo jedan element menja, tevo kako to tačno ide način, naravno mi moramo pri svakom pozivu da ažuriramo taj niz displaya da bi odgovarao trenutno aktyvnoj proceduri, odnosno čijove je aktyvativna zapis na vrhu steka i sad, uzavisnosti od nivoga u gneždenja u listingu, znači aktyvne procedure, ona će koristiti n registara displaya, znači, ono što su u gneždene, znači na manjem nivou će koristiti manje registara a one što su u gneždenje i je koristeće više registara. E, ali ono što je srećno okolnost, to je ova treća tačka u svakoj situaciji dovoljno ažurirati jedan registar displaya to je ona i koji odgovara nivog u gneždavanja n, na kome se navazi pozvana procedura P, kako ažuriramo taj jedan registar, pri pozivu stari sadrežej registra n, čuva su aktyvativna zapis u procedure P, znači, čuvao stari sadrežej, onda u taj, znači, dispe registra n, stavlja se pokazivačno upravo formirane aktyvativna zapis a, prilikom povratka iz P, ona stara sačuva na vrednost se ponovostavlja u display. Da vidimo, kakoa može biti hardwareska procesorska podreška, višim programskim mjezicima, na primjelu x86. Sam x86 nema ove mašinske naredbe, ali počevši od znači 100, 1, 8, 6, 8, 6 i tako dalje svih ovi pentium i tako dalje imaju znači dve mašinske naredbe za direktnu podrešku izrušanju organizaciju memorie koji viši programskih jezika, te dve naredbe su enter, size, arreza level i live. Grubogledano enter odgovara podrešci za del sekvence pozivanja koji radi pozvana procedura, a live odgovara podrešci za del sekvence povratka koji vrši pozvana procedura i o...
 Ovo u suštini znatno uprošćava kod procedure u tim standardnim delovima koje imaju sve procedure na početku koda i na kraju uvek ćete na početku videti enter, a na kraju neposjedno pre-retran ćete videti live. Evo da vidimo kroz prvo, znači da objasnimo kako ove naredve funkcionišno, da to vidimo na konkretnom primjeru. Znači što se tiče variante kada se koriste enter i live. Stari kompariris u znači mogu da se bira, da li da se uključi ta podeška ili da se prosto generiše kod za u osnovu osnobu 86-cu koji onda nema tu podešku. Znači, one dosadnošnji svih primjeri su bili kada se ne koriste te posebne naredve, a sad ćemo videti znači šta se dešava kada se koriste. Znači onda struktura aktivacijonog zapisa izgleda sredeća. Znači imamo stvarne parametre povratno adresu kontrolnu vezu. Zatim zanimljivo je, da kod x86-ci skoristjen deo aktivacijonog zapisa, znači poslije kontrolnu veze, zasmhešta i onog niza tih display pokazivača i zatim idu lokalne promenjive. Naravno kod jezika kao što je c kome ne treba display, znači ovo se ne alocira i ne koriste, ali kod jezika kao što je paskal, znači ovo se koriste. Znači naredba enter podržava obete svoje variante, zavisno kako je parametre, zadamo to ćemo evo sad videti. Znači ovešnjenje naredbe enter. Naredba enter ima s dva parametra, parametra size koji je 16 bitna veričina, definiše koliko memoria treba alocirati u aktivacijonog zapisa za lokalne promenjive, znači to je veričina lokalne promenjive, a parametra level je 8 bitna veričina, znači može da ima ukuplo 256 r. Vrednosti predstavlja leksički nivo pozvane procedure. Kako se izvršava ova naredba? Znači ona se izvršava kao prva naredba pozvane procedure, na sljegi način. Sadrže registra BP idena stek, čime se definiše polje kontrolna vese, u registra BP upisuje se sadrželje registra SP, čima je BP postavljen, to ukazuje na polje kontrolna vese. Znači prakčinu na početku izvršavanje ona menja dve naredbe puš BP mu BP SP. Treće, šta još ona radi? Ako je level 1 konnula, onda se preskače na meštanje display, kada se prevodi C kod, onda je uvek drugi parametra level 1 konnula i onda se ne radi o aktivnost 4, pošto nema ne lokani projne. Međutim, kod paskala, ovoj level će uvek biti veći od nule i kaže označimo o vrednost level manje 1 sa n, a sadrže polje kontrolna vese sa a. Na stek se smešta n reči, koje se kopiraju redom počeši od lokacija minus 2k nizimemoriskim lokacijama. Potom se na stek smešta, adresa polja kontrolna vese ovim je uspostavljen display pozvane procedure. Evo samo da pročitam do kraja, pa će ubjasniti malo ovaj korak 4, malo bolje. Način posljednje što se radi, kaže registra SP se umanjuje za vrednost operadana da size, čime se alocira prosto za lokalne promenjove pozvane procedure. Način kompletan, kažem, ono što radi pozvani na meštanje je aktivaceno zapisa, znači, obavlja ovaj ent. E, sa samo da se vratimo na malo bolje obješljenje koraka 4, to će ono bolje svatati gledoviće o usliku. Način, u suštini što radi taj korak 4? On formira niz pokazivača, tako što kopira u suštini niz koji se stoji odpozivaoca. Znači, ono pozivaoca preuzme ono likopodokazivača kolikomu treba, uzavisnosti od tih odonok parametra leksički nivu ugnježdajenja tomu tiktira. Šta treba? I onda poslednji onaj koji ukazuje da kažem na najugnežnjeni nivo, to je u stvari ovaj tekući koji su upravo formira i onda kao u poslednju vrednost u tom nizu postavi u suštini vrednost ovu novu vrednost BP. To to je to što se radi u 4 koraku. Šta radi naredba liv njen? Efekat izvašavanje je mnogo na svu sreću jednostavni, nego naredba enter. Naredba liv realizuje delo sekvence povratka koji izvašava pozvana procedura. Ova naredba neposedno predhodnji naredbi red, nema parametra, izvašava se sreći način sadeži registra BP, kopira se o registra SP, ovima se delocira sa steka, delo aktivazan zapisa pozivavce ispod kontrone veze i potom se sa steka skida sadreže polja kontrone veze uz meštu registra BP, time BP namešten zapozivavca, a polje kontrone veze pozvane procedure uklonjeno sa steka. A čo ono ova nareda livu stvari menja one dve naredbe mu vespe BP, pop BP. I potom ide naredba return. Na konkretnom primeru da vidimo kakav se kod generiše kada se koriste na naredbe enter livu, primere je potpuno isti kao malo časa displayima, znači imamo glavni program pocedure 1,2,3, glavni poziva 1,1,2,2,3, 3, pristupa ovoj promenivoj koja je lokalna u proceduri 1. E sada smo videli konceptu primersad displayima, a ovdje sad gledamo konkretan kod kada se koriste, znači x86 naredbe enter livu. Evo koliko one uprošljavaju kod, prvo ide kod procedure 2, pripremna naredba je enter 0,2, procedura 2 nema lokalni promenjevi, znači 0, bitova se koristi u aktivacijen zapis za njih, a ona je na leksičkom nivou 2. Zatim i da poziv procedure 3, posledog ide naredba livi i naredba return. Procedura 3, znači isto nema lokalni promenjevi, nalazi se na leksičkom nivou 3, zatim ide prevod naredbe lokal 1,1,10, desma rekli u varianti sa displayima potrebu na je samo jedna pripremna naredba da dovedemo odgovarajući display, sad se display nalaze na steku, tako da bpm manja 0,2 odgovara u suštini tom displayu na leksičkom nivou 1. Zatim, znači sada pošto imamo de i nam ukazuje na aktivacijen zapis 1, onda de ima nje 4 u ovom slučaju, upisu je, znači u lokal 1, constantu 10, imamo livi i red. I konac na procedura 1, znači ima svoju lokalnu promenju, tako da 2 bitova steku treba opredeliti za to i nalazi se na leksičkom nivou 1, ona poziva procedura 2 i imamo samo posle sekvencu povratka livi i red. Glami programima samo poziv procedura 1, znači kod je krajnje uprošljen kada imamo korišćenje enter i live. Architektura mikrojave virtual machine. Kao je jedan konkretan primer izlašnog okorženja koji mi koristim u projektu mikrojave, ova lekcija nam daja osnovne podatke o mikrojave virtual machine. Takođe možete pogledati u specifikaciji mikrojave, postoji odelja koji mikrojave virtual machine, gde su dati dodatni detalji. Šta je genano virtual machine? Možemo je svatiti kao jedan procesor koji nije implementiran u hardwareu nego u software-u. Što znači da pisam program pisam za mikrojave virtual machineu, moga izvašavati, mora postojati sloji softwarea tako zvanim runtime koji interpretira mikrojava instrukcije na realnom intelom procesoru. Taj koncept se puno koristi u savrevenom software-u, znači primeri realnih virtuali machine su java virtual machine Microsoft of Common Language runtime u dotnet okruženju jednot prvi virtualnih masina historijski bio je paskalski P-Code. Mikrojava virtual machine osmišljena je pogledu na pravu java virtual machineu, ali je znatno uprošćena o slobodje na raznih detalja koje su potrebne javi kao jeziku i koji bi komplikovali koncept. Mikrojava virtual machine je stack-masina ili nula-adresna masina, a to znači da ona nema procesorskih registara, nego u ulogu registara preuzima tako zvani stack-izraza ili stack-expression-stack, to je struktura podata KALAST-in-first-out koja je realizovan preko jednog niza, znači konačne riječine, pošto osnovna memoriskaj jedinica u mikrojava virtual machine je jedna memoriskareč riječine 4-byte, znači kod mikrojava virtual machine sve adrese i tako dalje si izražavaju na nivou memoriskareč. Na primer stack-e-stack može biti na primer 32 registra i interno postoji s-up na čivrh tog express-on-stacka koji služi za kontrolu stack. Kako radi stack-masina, na jednom konkretnom primeru kako izgleda prevod jednoj naredbe dodale i jednako i plus jod puta pet u mikrojava byte kodu, ako su i od lokalne promenjive, to znači da će one biti smeštene u okviru tekuće procedura. Postoji još jedan stack u mikrojava virtual machine i tako zvanim procesorski, ili programski stack P-stack i na njemu znači jedan del prostora se odvaja. Na čivrh programskog stacka na njegu ukazuje stack pointer a za pristup lokalnim promenjivima se koristi još jedan interni registra mikrojava virtual machine frame pointer i onda se lokalne promenjive čuvaju na pomeraima koji su relativni odnosu na frame pointer recimo i može biti prva lokalna promenjiva na pomeraju nula ovdje je prikazana sa konkretnom recimo vrednošću i jednako 3 a i od sredneća lokalna promenjiva pošto svaka zavozima fiksla po jednu mevorisku celiu to je pomera 1 i na prinjada ima vrednošć 4 ako glasi prevod ovog iskaza na jazik mikrojava virtual machine to jestu na mikrojava byte kod prva instrukcija je load nula to je instrukcija koja čita lokalnu promenjivu nula i stavlja na stack izraz zato je kog gledamo sadraža i stack na nje je prvo išla vrednošć 3 zato je stavljamo vrednošć 4 zato je konst instrukcija stavlja određeno konstantu koja je zadata na expression stack konstantu 5 koja je nam ovdje treba posljed toga aritmetičke instrukcija množenja nisu je potrebno operandi jer ona svoje operande uzima sa vrha expression stack pomnoži hire resultat ope stack i stavlja stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku i stak u staku
 Iko što je bilo i na početku, XpressureStack je praz. U micro-avertile mašina ima nekoliko oblasti podataka. Dostavno pomenuli XpressureStack, pomenuli smo malo i taj programski stack. Zatim globalne promenljive, to su promenljive glavnog programa, čuvaju su oblasti globalnih podataka. To je implementirano kao jedan vektornih zreči u micro-avertile mašini. Osnovno implementacija micro-avertile mašina je interpreter ovoga bytecoda i napisan u javi. Kro javi virtuale mašini je potreban java runtime. Vektor data je oblast fiksne veličine, globalne promenljive postoje dokom čitavog programa. Svaka promenljiva zazima po jednu memorijsku reč i adresa. Tih globalnih promenljive je u stvari index u ovom data nisu. Tako da videte ćemo posebne naredbe kao što imamo load za lokalne promenljive. Tako za globalne promenljive imamo get static, recimo 2. Učitati globalni podatak na adresi 2. Na x-projšan stack. Ovo je potkuno analogno load samo što ne učitava lokalnu promenljivu, nego učitava globalnu promenljivu na x-projšan stack. Zatim oblast lokalnih promenljivih je na ovom p-steku. Svaki poziv metoda dobija sobstveni okvir na stacku. Oni se pri pozivu metoda stavljaju na stack, a skidaju na stack prilikom povratka iz odgovarajućeg metoda. Ovo je prikazano ako metod P, kada njega glavni program pozove na vrhu stacka, se nalazi. Njegove lokalne promenljive ako on pozove metod Q, iznad okvira za P se formira okvir za Q, kome se nalaze lokalne promenljive za Q. Ako su u toku poziva Q pozove neki R, dalje se znači formira okvir za R. Na vrhu stacka je onda svatri ta okvira, dogod pozivi nisu završene existiraju. Kada se vraćamo, kada se završi izvašavanje metoda R, sklaňa se njegovo okvir sa stacka, kada se vratimo u kusituacije opetove, a sad kada se skuvratimo u P situacije opetove. U drugim rečima ovdje je to prikazano samo malo više zetajja. Ako ovopo stack je jedna, da kažem opet jedan, implementerno kao jedan niz u javi, ovih memorijskih reči vektor, dači sa indeksima 0 do M, postoji interni registar mikrojav, virtuo mašina koji naravno nije vidljiv iz mikrojava, pa idete kode direktno, nego su koriti prosto implementaciji virtuo mašine, znači stack pointer ukazuje dokle smo popunili ovaj niz, a frame pointer je druga granica tek ućeg okvir. Lokalne promenje se adresiraju relativno odnosu na frame pointer, znači svaka promenjiva, to smo već rani rekli za uzima fixno po jednu režu, da bi nastavili radsa i generisanja koda, vide će bo kasnije, znači skup instrukcija, šta sve možemo da radimo sa lokalnim promenju. Svedet će oblas podata ka mikrojav, virtuo mašina je oblas dinamičkih podata ka hip, to je isto implementerno kao jedan posebar niz, i takođe postoji interneti po interfri da znamo dokle smo popunili hip, naravno hip se koristi pri instanciranju novih objekata, neke klasa znači kad za su u programu potrebi operator nju, i naravno za instanciranje niz ova slično kao i u javi. U ovoj osnovnoj verzi mikrojav, virtuo mašina koji vi dobijate, jednom malo ocirani objekti se ne dialociraju, znači ni ti ima eksplicitant dialokator, ni ti ima zakupljač smeća kao što postoji u pravo javi, i dalje jedinica alokacija, jedna memoriskareča, i adrese su na nivou memoriskireče. Ovde se ilustroje raca hipom, napr. ako imamo neku klasu, i promeljiva objekat je tipa x, i alociramo novih objekata, znači instancu x, naravno promeljava objekat će nekde druge da se nalazi, a ne na hipu, znači to je ili lokalna ili globalna promeljava, ovde nije prikazan taj detalj. Međutim na hipu će se znači ovim operatorom nju alocirati dovoljom prostor, znači za svako polje po jedna memoriskareča i dodatna memoriskarečka o pokazivač na statičku data oblast, gde se formira virtualna tabela klase x, sad pošto neva nijedan metod, virtualna tabela je prazna i ima samo naj kraj virtualne tabele minus 2. Ako je u pitanju niz, imamo dva tipa nizom niz, celih brojeva, iznakovni niz, ima male razvike u alokaciji, znači kada se sa nju alociraricimo celobrenje niz, znači da će se na hipu četili memoriske lokacije alocirati, jer na adresi a, prva memorisk čelija, iskoristit će se da se zapamti broj elemenata niza, to je kod svakog niza, i onda te kod indexa plus 1, pamti će a od nule, indeks i du kao u javi, ali kažem ova prva čelija je rezervisa na zadužinu niza, tako da ima još 3 čelije za element niza i kod celobrenih nizova, svaki elemenza uzima tačno po jednu memorisku rečto, se tiče znakov nizova, iskoristit će se zapamti broj elemenata niza, prva memoriska čelija na ovoj adresi, koji u vrati operator njuta, čelija na adresice se zapamti broj elemenata niza, pet, međutim kod znakov nizova, koristi se pakovanja, tako da u jednoj memoriskoj reči mogu da stanu 4 znaka, tako da recimo nizu z dužine petnje, u treba samo 2 memoriske reči, plus 1 za dužinu niza, u drugoj memoriske reči su 4 znaka, i memoriskoj reči se pamti još na 1 peti znaka. Oblast programmsko kode je isto neka vektor kod i kod se jedini u baitovima pise i pamti i metodi su redom, kako ih i kompaljert preveo 1 za drugim, a promenjiva main PC ukazuje na početak program, odnosno gde je preveden main metod iz glavnog programa. Postoji naravno kao internet i registar i program counter, kada mikrojava virtual masina izvarsava interpretira program da zna koja je tekuća instrukcija bytekoda. I sad ćemo dati jedan, kratak pregledi obješnjenje skupa instrukcija mikrojava virtual masine, inspiracija za bytekod mikrojava virtual masine bila prava java virtual masina i instrukcija mikrojava virtual masine ili bytekoda, blisko pratte instrukcija pravog java bytekoda uzodređena u prošćenje, kod pravog java bytekoda, unutar instrukcije pamti se tipo peranda u kojima instrukcija radi, jer java ima verificator bytekoda, koji može da proveri integritet programa preizvarsavanja. Dok mikrojava u tom smislu jednostavnija ne kodila se tipo peranda kao deo instrukcija, ali van toga funkcionalna instrukcija imaju istu funkcionalnost. Mikrojava program je nisih instrukcija, a svaka instrukcija počinje operacijelim kodom, jednobajtnim, a i za toga može biti promeniv broj operanada 0,1,2 pri čemu operandi mogu različit broj bytekoda 1,2 ili 4 bytekoda postoje možda izuzecio za poziv dinamićih metoda klasa, znači realizaciju polimorfnih poziva, taj metod može da zauzima i više bytekoda. Primeri nekih instrukcija, znači instrukcija sa 0 operanada videli smo da veći i na ritmetičkih instrukcija nije samo ima kod, zato što sve operandi rezultat na xp.stack postoje, naravno, instrukcija s jednim operandom, recimo, instrukcija load koja dohvatila lokalnu promenivu i stavlja na xp.stack a postoje instrukcija sa više od jednog operanda da, recimo, postoje instrukcija enter koja ima sliču se mantiku kao, ali ne isto kao intel-ova enter instrukcija, znači za podešku pozivanju pod programa. Što se tiče načina adresiranja, znači postoje radični način adresiranja koja ima se može pristupiti operana, znači nepostredno sve za constante i vrednost konstant ugrađena je u sam bytecode znači postoje postoje instrukcija recimo const7 koja služi tome da konstant u 7 stavi na vrha xp.stack znači lokalnim promenivama se znači pristupa posebnim instrukcijama znači da se dohvatila vrednost sa onog psteka i steku će gokvira znači statičko adresiranje da se dohvate globalne promenive znači statičke alocirane, opet posebno od ovih služe tome stek adresiranje znači to je na neki način podrazumevanog ako nema operana da onda se brata sa xp.stackom, relativno adresiranje je za polja objekata znači tipično se na xp.stacku mora dovesti početna adresa zapisa a onda se u okviru instrukcije doda je relativni pomeraj da bi se onda cela adresa izračunila kao zbir, znači onoga što je na vrhu steka plus relativno pomeraja, znači to je za pristup poljima objekta, instanceklase index na adresiranje za nizove kote vrste adresiranja sa obično na xp.stacku stavljaju i početna adresa niza i index i pošto smo rekli da na sam početku nizovek proj elemenata onda zbir ta dva podatka sa vrha steka plus 1 da je adresu gde se navazi i tjelement nizom. I sad ide pregled celog instrukcijskog seta, ovo takođe može još i kompletnije da se nađe u mikrojava specifikaciji i samo ću objasniti ovo tabelu i šta znače pojedini telovi ove tabele, znači ova prva kolona služi da se definiše nemonik instrukcije i koj instrukcija ima operant onda će ovo ovo je odvojeno pisati operant i će upotrebljeno b, s ili duplo ve slova da označi u koliko byte ova se pamti, znači okolik instrukcijskog koda operant znači b je 1 byte, s je shor 2 byte i duplo ve reč 4 byte znači 4 instrukcija load ne zahteva operant do rečina 1 byte što znači da može biti do 256 lokalnih promenjivih sledeća kolona označava stanje steka znači ona ima 2 vrste prva vrsta je stanje steka preizvršanja instrukcije a druga vrsta je stanje steka poslizvršavanja instrukcija znači instrukcija load ne zahteva ništa na ekspresno preizvršavanja instrukcija poslizvršanja instrukcije na vrh što je simbolizovan ovim vrhi uvekovano skroz desno biće stavljena vrednost i poslednja kolona da je obješnjenje efekat izvršavanja instrukcija da se u lokalnom na atresi b, to je u stvari oznaka u frem pointera, da se to pročita i da se onda puš na ekspresno steka izvršio zanimljivo je da znači load instrukcija ima više od jednog opresnjiva
 i dolazim u ova dva varjeteta, ovaj koji smo upravo vjasnili sa jednim operandom, ali postoji varjetete sa nula operana, znači za nju je izdvojeno četiri različita opkoda za n jednako 0, 1, 2, 3. Znači za razlik od ove gde je blanko između, ove ostale četri se pišu sa spojenim ovim n, znači piše se low nula kao jedna rečla u 1 i tako dalje, i to su posebne opraceni kodovi, te instrukci imaju potpuno isto značenje kao ova lowca odvojenim operandom, ali zbog efikasnosti izvršavanja, znači ideja je da ćemo najčešće baratati sa prva četri lokalne promenjive i onda imaju tu privilegiu da imaju svoje posebne opkoda, odnosno ova instrukcija ovakva se znači izvršava malo brže od lowd pa blanko pa nula, i da efikat je isti, zato što prosto interpretar treba manje mu vremena traba pročita, taj samo jedan biti da ga dekoduje, nego ovde gde mora da pročita posebno prana. Isto tako važi za stor stojima komplementa ne efekata, znači sa vrka steka skida vrednosti, i onda upisuje, kao što ide posledoga nema više na steku, i upisuje u lokalni okvir na ovu relativnu adresu b, isto ima ove variante sa spojenim operandima od nula do 3. Što se tiče ovih globalnih promenjiva, imamo analogne cat statiki put statika, one nemaju svoje skraćene variante, nego tu je operand short, znači njih možemo imati 12,16 oko 65,000 globalnih podataka. Za pristup poljima, znači objekata, instanci klasa koristi se cat field, znači da dovuče iz polja objekta na expression stack, ta instrukcija zahteva prejnjenog izvršavanja da adresa, početna adresa objekta u hipu se stavi na expression stack, a onda se znači za delove instrukcije, ona ima jedan short operant koji predstavlja pomeraj, znači da bi se došlo do polja u okviru zapisa objekta, tako da izvršavanja te instrukcije da se pogupi adrese i se expression stack, da se sapere adresa plus pomeraj i da se onda pristupi hipu pročita se ta lokacija i sadrže i postavi na expression stack. Znači na taj način smo dovuklji polje objekta i stavili ga na expression stack, put field ima oprnoto dejstvo, znači ona zahteva da prejnjenog instrukcije i početna adresa objekta i vrednost koji želimo da upišamo polje budu na expression stacku i kao rezultat njenog izvršavanja te dve vrednosti će biti skilute sa expression stacka i u hip će biti na adre plus s lokacija upisa na ta vrednostva. Rekli smo za razsa konstantama, postoje obšta instrukcija constant duplo ve, konstanta je na dužini, širini cela je memorisk reče, može bi loko a trizvo bita konstanta i efekati zvršanja instrukcija se ta konstanta postavi na vrhnih expression stacka i postoje dve posebne variante, konstante 0 do 5 su povlašćene i to se pise kao jedna reč konst 0, da dovučamo konstantu 0 na vrhnih expression stacka, takođe konstanta minus 1 je isto, jedna od povlašćenih konstanti. Ovde ima nekoliko primera, znači kako se prevode na redbe dodela ako su u pitanju dve lokalne promenjive xy, onda se naravno, pristupa tekućem okviru na psteku, ovde ponegde su pomere na ovo 1 i 1 treba da bude ovoj koloni bytes, takođe ovo 1 i 1 treba bude u koloni bytes, jer ove instrukcije, recimo load jedanje bez operanada, to je ona povlašćena varianta, da se dovuče prva lokalna promenjive i stavi na mesto 0 lokalne promenjive, preko naravno expression stack gx je nakon gy, to je isto samo sa globalnim promenjivanem, dolači se prva globalna promenjive na expression stacka, onda stavlja na mesto 0 lokalne promenjive, ovde piše koliko byte-ova se kodira po jednačni instrukcije, našto stvrti kodiranja, d je definisano ove tačno koji byte-ovi služe za kodiranje instrukcija, definisano je u okviru bibliotečke funkcije, koji ćete vi dobiti to je klasa kod, deo tih bibliotečki funkcija koje dobijate i tamo je znači kroz konstante, mnemoničke direktno povezani svake obkod sa konkretnim vrednoškim. Kada želite na kod nekoga objekta p, koji je ove zapamća na njegova adresu lokalnoj promenjivo i 2, i sad želite da polje y objekta p, njegu u vrednostu pisete u polje x, to zahteva 4 instrukcije java byte koda da se dovuče adresa objekta p na expression stack, treba će nam još jednom ta adresa objekta p jer jedna treba za čitanje polja, druga za upise o drugopolje i onda znači getfield2 koristi jednu od ovito u učenih p zada je izgled expression stacka kako se koja instrukcija izvršava, znači skinuće ovo drugo p sa vrha stacka, sa braćega sa 2 i pročitaće hip na adresi p plus 2 i ono što pročita na hip, a to je vrednost ovog p y, polja staviće na vrha expression stacka, znači poslednog e expression stack ima ovaj izgled adresa p i vrednost p y, je zatim putfield1, je instrukcija koja upisuje u polje 1 dogo objekta p, odnosno skinuće ove vrednosti sa ovoj expression stacka i sa braće ovo p sa ovim 1 i u nadresu hip od p plus 1 upisaće ovo p od y, expression stack će ostati praca. Nastavljamo sa microjava byte kod instrukcijama, različite aritmetičke instrukcije, imaju nula operanda, jer sve svoje operanda i rezultat koristene expression stacku u sabiranje znači zahteva dve vrednosti na vrhu expression stacka i tokom izvršanje instrukcije te dve vrednosti se skinu sa stacka, saberu i rezultac se stavili, znači ovaj sad jedna vrednost koja predstavlja zbir, one dve vrednosti od uzimanje množenje deljenje, deljenje po modu, znači dobije s ostatak il pri deljenju, unar na negacija, aritmetička onda pomeranje, znači vrednosti mora biti dve vrednosti na expression stacku jedno je vrednost, a drugo je koliko pitskih mesta se vrši pomeranje, pošto vrednost 30 obitna, znači ima smisla da ovo drugo pojede ide od 1 do 32. I ume sto ove dve vrednosti rezultace smešta na stack, znači to su isto binarne operacije. Evo primvred način načinanje izraze x plus y puta 3, zahteva dovođenje na stacka koja je to lokal napromeniva, znači s jednim load x, s drugim load y, zatim se dovodi konstanta 3, zatim multiplaj skida y3 i njihov proizvod stavljanje na expression stack, a et instrukcija ovoj jedinice je pomerana iz ove kolone, znači da zahteva sam o jedan bit, znači et nema ovih argumentata, znači skida x i ovoj medju rezultat i c je ozbil onda stavlja na expression stack. Nastavak skupa instrukcija, znači stvaranja novih objekata koristi se bytecode instrukcija nju sa jednim operandom koji je short tipa, znači dva byte, ne zahteva na expression stacku nikakav sadržaj preizvašavanje instrukcije. Efekat izvašavanja je da se alocira s memorijskih reći u na hipu, da se popuni ta oblast novode oddeljena nulama i da na expression stack ide početna adresate oblasti. Za alociranje nizova u mikrojavi koristi se ovanju rej bytecode instrukcija koja ima jedan operand veričine jednog byte i zahteva n na expression stacku preizvašavanja. Znači ovo b se odnosi na tip elementata, u stvari možete njegove ispravne vrednosti su 0 ili 1. Ak je b 1 ko 0, onda želim od znakovne nizove, a za b 1 ko je 1 celoprojne nizove, a n je broj elementata nizako koji hoćemo da alocirno našli izima je n elementata. I kao efekat izvašavanje instrukcije biće alocirano nuliko reći na hipu koje neophodno za znakovne nizove biće pakove no po 4. I plus jedna reć za broj elementat se cela oblast koja koja se dodeli će biti alocirana nulama, ali onda će na početak u prvanu ovu adresu na hipu koja se vraće biti smeštena broj n. I početna adresa celeta je oblasti odnosno tačno adresa kde je smeštena ova konstanta n se stavlja na expression stack to je povrat na vrednosti zove instrukcije. Prima reći sa krajiranjem objekta neke klasse, kada se zada instrukcija nju želimo 4 lokacije na psteku ćemo dobiti značineku adresu i onda ćemo upisati u ovu lokalnoj promenjivoj p, znači se stornula. A ako alociramo novi niz onda znači moramo zadati broj elementata na expression stacku i pozvati nju rej sa jedinicom ako je celobrojni niz, znači nama će instrukcija alocirati na hipu odgovarajući broj, to je 5 plus 1 reći, smestit će početno adresu na expression stack, skinuće naravno u peticu i onda moramo sa stor 1 tu, kde lokalnoj promenjivoj a upisati adresu u promenju a za kasnije referenciranje elementataniza. Nastavak pregleda skupa instrukcija, za pristup elementima niza, znači za čitanje itoge elementa niza imamo ovu aloud instrukcija, odnosi se na celobroj nizove, odnosno njenu b aloud variantu za čitanje znakovnih nizova, znači jedna i druga zahtevaju preizvašanje instrukcija, znači nemaju operande, ali preizvašanje instrukcija zahtevaju dve vrednosti na expression stacku, to je početna adresa niza i index itoge elementa, izvašanje instrukcija znači skinu se dve vrednosti, pristupi se hipu na adresa plus i plus 1, zbogone veličine, što se pampti u nutom elementu i znači pročete na vrednost mešta se na expression stack, ova vrejanta b a stor razlikuje su toliko što se i deli sa četiri, jer znamo da su tamo po četri znaka smešte na ujednu reč, tako ali isto je pojenta da iti, znači znak reči pročitamo i to je ovako aloudu stvari, adresa plus 1 plus igros 4 i još onda određeni byte smeštamo na vrh expression stacka, naravno taj byte se proširi u četiri byte.
 kao celo reč. A stor instrukcija služi za upisu i taj element nekog niza. Moraju tri podatka da se zadoju preizvašavanja početna adresa, indexi i vrednost koji upisujemo. Znači sve se to pokupi sa expression stacka upiše se u hip na adresu plus i plus jedan upravo ta vrednost val. Varianta za znakovne nizove b, a stor ona samo manipuliše sa ovim i. I naravno upisuje samo ona i jedan byte. Za svaki niz možemo dobiti, znači ovo je direktna podreška za ona i ugrađeni metod len koji možemo zabilo koji niz dobiti dužinu niza. Znači i za njega postoji posebna byte kod instrukcija ray length koja je zahtava početnu adresu niza na expression stacku. I ona ustvari samo pristupi hipu na toj adresi pročita reč i tu vrednostu stavi u mestu ove adrese koji pokupi, stavi tu pročitanu reč koja treba da je dužina niza. Naravno ako je to stvarno niz na toj adresi inoče će prosto dati bilo šta što je na toj adresi i da će na vrha expression stacka. A od i jednako b od i plus jedan, znači vidimo to je niz ovi byte kod instrukcija. Znači prvo stavimo a na expression stack, zatim stavimo i iltako na expression stack, zatim sa load 1 stavimo b na expression stack, Zatim ponovostavimo i na expression stack, stavimo a i b i na expression stacku, stavimo konstantu 1 na expression stack sa et dobijemo ovo i plus jedan sa a load. Znači ona iskoristi ovo b i ovo i plus jedan da nam pročita i plus prvi element niza b i stavi na expression stack. I konačno upravo ta tri podatka a i b i plus jedan iskoristi ova a stor instrukcija. Inačo ova jedinica nije njen oprant nego je kažemo bit pomerana iz ove kolone pajc, dači dužina koda instrukcije i ona onda upiše u a od i isprazi expression stack. Imamo i instrukciju pop koja prosto skida sa vrha expression stacka vrednosti i zaboravlja, znači ako nam ne treba kutra sam vas skinamo jedan element z expression stacka i zatim za realizaciju skokova imamo instrukciju bez uslovnog skoka koja znači kao svoj short oprant daje adresu skoka. U ovom predavanju opisi su kao da se zadaju absolutna adrese kod memoriji, međutim to treba proveriti kasnije u primerima zaista s ovnom klasom kod da nisu slučeno relativne ipak adrese u odnosu napisi. I zasaćemo se držati ovog ovde opisa, nači koji je absolutne adrese. Postoje uslovnih skokovih da se opraceno kodu kodiraju jedan od nekoliko uslova, jednako s nejednako strogo manje, manje jednako strogo veće do jednako. Znači ta instrukcija zahteva dva operanda koji će se porediti ovim relacijanom operatorom. Znači ima nekoliko kodomer se sam relacijan operator, znači kodira u opkodu. I instrukcija se zvršala tako što ove dve vrednosti skine sa expression stacka u poredi ih operatorom. I ako je uslovo zadovoljen, onda se naravno skače na odredišno adres, ako uslovo nije zadovoljen, izvršavanje se nastavlja sekvencijalno od sredneće instrukcije. Što se tiče pozivanja metoda u microavirtonašini, ovo na ovom slajdu je objašnjenje za statičke metode, kada nije polimorfni mechanizam u igri. Onda imamo nešto slično što imaju i oviralni procesori. Znači, evamo instrukciju, poziva pod programa gdje se adresa zada je operandom. I znači, ta instrukcija se izvršava tako što povratno adreso, znači adresu na redba odmah izakolop stavlja na programski stack, to je veliki push, a onda znači program counter izvršavanje se nastavlja od zadata adrese s. Zatim imamo enter instrukciju koja zahtava dva operanda i evo ima poseban slide koji objašnja vama malo polje tačne efekte tih instrukcija. Znači, pozivalac naravno kodira u call.m. instrukciju i onda kad prenosimo kontrolu pozvanom pod programu, na početku svakog pozvanog podprograma, to je slično kao kot Intel OVX86-ce imamo u enter instrukciju koja ima dva operanda. Prvi operand odnosi se na ukupam broj stvarni parametara, a drugi operand odnosi se na veličinu potrebnu za pamćenje lokalnih promenjivih metod. I pozivalac mora da preove call instrukcije na vrh ekspresno stack redom stavi parametre, znači stvarne parametre poziva i onda izvršava call instrukciju. Kada se kontrola prenese kod pozvanog programa, izvršava se instrukcija enter. Ove je izgled programskog ekspresno stacka u trenutku kad je pozvan enter, tada je fp isp još ukazuje na okvir pozivaoca, znači samo je na vrh stacka ovom na redbon call stavlja na povratna addresser, return addresser a podatak. Znači to je izgled stacka neprosredno preenter, a ovo je izgled psteka i steka pošto se enter izvrši. Šta tačno? Enter, kakav efekat ima kao što vidite, ona ima nekih složeno, da kažem efekat ažuriranja i jednog i drugog stacka. Prvo se na stack stavlja stara vrednost ovog frame pointer, a to u sluštini odgovaravanoj dinamicovi vezi. Zatim se rekući stack pointer se upišu frame pointer, tako da se postavlja frame pointer za ovaj sad naš sadašnji okvir pozvanog podprograma. Zatim se stack pointer uveća za ovu drugi parametar envars, čime se locira prostor za lokalne promenjive. Zatim se inicializuje sadržaj, znači tog alociranoh dela na nuli, i onda se prebace svi parametri sa esteka redom u lokalne promenju. I to je kompletan efekat enter instrukcije. Efekat exit instrukcije, koja se odljude sada i do loštom, programer izprogramira za neki metod, sekvenca povratka, se realizuje sa exit i return, opet, kajžem, vrlo sličanim live instrukciji kot x86, znači exit instrukcija ima u spušlji za datak da obrne efekat procesiranja ove enter instrukcije i ona je, naravno, jednostavnija, nema nikakove parametre, znači ona zatiča ovakav stack, u spušlji ovej stack koji je ostavio enter plus, što ako je u pitanju funkcija, znači povrat na vrednost funkciji uvek se stavlja na estek, a ovo drugo je sve da kažemo, ovu kako ostavio enter. I exit samo treba da uvradi sp jednako fp, čim je dialocira sve lokalne promenjive i opet vrati stack pointer da ukazuje na ovu pođedinamičke veze, odnosno, stariji fp, i onda se, nači pročita stariji fp istog pođedinamičke veze i postavi kao što odgovaravom poziva ocu, i to je efekate exit, ove dve instrukcije. Posle toga je još samo potrebno, nači pošto kad se schina pođedinamičke veze na vrhu stack, je povratna adresa, nači instrukcija ritranica je naravno opročitat i tu povratno adresu sa posteka, i preneti kontrolu izvršavanja i zakol, i su odpozivala, samo može saj isteka da pokupi ovu povratnu vrednost funkcije, rezultat funkcija, ako funkcija ima rezultat. Kako izgleda, znači u byte kodu neki pozim nekog podprograma koji vraće rezultat, pa znači treba pripremiti stvane paramete, tako što se potisno na x-bration stack, recimo iz nekih lokalnih promenji vihai b, pozave se, znači metode m, i nači ako taj metode ima vraćen neki rezultat, on se sa storu upiše u odgovarajući lokalnu promenju. Da objasnimo kako se realizoje u microjava virtual machine poziv dinamičkih metoda klase. Rekli smo da svaka klasa, osim, glavne koja predstavlja program, ima virtualnu tabelu metoda v tabelu, a ona se čuva u statičkoj oblasti podataka, a adresa prve rečite v tabele se pampti u samom kompajleru u okviru onog oboj čora klasa u pođu adr, ako imamo nekakvu klasu koja ima neka pođe xypsoni ceti, neka dva metoda dinamička mag i met, njena, nači u kompajleru će naravno piti formirana njena virtualna tabela, biće i alocirana deostatičke memori, nači kompajler zna gde se nalazi za klasu c virtualna tabela, a sadrže virtualna tabele, biće od dva zapisa za metod mag, nači redom ime metoda, rekli smo svakost lovo se pampti učitavo i memoriske reči, nači tri memoriske reči za ime metoda, zatim jedna reč za konstantu minus 1 kraj imena metoda i jedna memoriske reč za početnu adresu metoda mag kad ga kompajler prevede, a onda ide drugo ime metoda met, minus 1 kraj imena i adresa drugog metoda i minus 2 oznacava kraj ove virtualna tabela, nači to je struktura koju kompajler formira, a koja isto u runtime, znači mora da se napuni u statičku oblast memorie i koristi se plipozivu ovih dinamičkih metode, evo da vidimo sad kroz primer, nači kako to ide, rekli smo da se operator nju koji alocira memoriju na hipu, koristi za pravljenje i alokaciju objekata neke klase i evo sad ćemo videti sa svim konkretno za ovaj fragment mikrojava programa, znači instanciranje novog objekta klase C koji smo definisali i poziv metoda met sa stvarim parametrom A klase C kakal bytecode mora da se generiša, kao što vidite bytecode je podugačak, znači to je postoji kompleksna obrada i zna toga, prvi ideo bytecode odnosi se na pravljenje novog objekta klase C ukupro nam treba 16 byte, imamo 3 polja u klasi X, Y, C, svako je po 4 byte, to je 12 byte, plus 4 byte za pokazivačna virtualna tabela, ukupro 16 byte i pozivom bytecode instrukcija na X-mreshan stek će doći.
 adre sa odgovarajućeg zapisa na hipu. E sada treba zapamtiti tu početno adre su pod pretpostav okon del ovo c statička promenjiva na indexu 0, zapamtit ćemo tu početno adre su u c i ono što još nije goto prevojt cejle ove instrukcije, potrebno je još upisati u nulltu reč tog objekta pokazivač na virtualnu tabelu. Znači moramo ponovno dovesti početnu adre su objekta na expression stack, staviti constantu 32, 32 pretpostav kada je compiler smestio virtualnu tabelu na adre su 32 statičke oblasti i sa putfield 0, putfield koristi adre su početno adre su na hipu sa expression stacka, pomjera je 0 znači da pa šupiše u nulltu reč tog objekta ovu constantu 32, na taj način smo u stvari napravili noviji objekat i on sad ima taj dinamicki tip ove u zvištini, ta constant reprezentuje dinamicki tip tog objekta, a sve ova druga njegovja polja, pošto je to podrezovavani konstrukture, znači vrednosti su i nula. Ovih pet instrukcija byte koda realizuje ovu ovde liniu koda. Posled toga još imamo u drugu liniu koda gde pozivamo, znači metod met, kako teče poziv metoda met, iz globalne promenjive c čitamo adre su objekta, na expression stack stavljamo stvarni parametar, znači pod pretru su kada opet neka statička promenjiva, na pozici jedan način je vrednost a stavljamo na expression stack, znači sad jedan expression stack u adre sa objekta na hipu i vrednost ovog stvarnog parametra. Zatim nam je potrebna adresa, znači v tabele objekta, a nju ćemo dobiti tako što opet stavimo naravno adresu celog objekta na expression stack i sa getfield nula, znači dohvatimo to nulto polja objekta, koja je u jedno adresa početka virtual na tabele i onda sledi ovaj glavni poziv invoke virtual posebna instrukcija java byte koda za realizaciju i svih dinamićih poziva. Ta instrukcija kao svoje argumente ima niz byte-ova koji predstavljaju ime metode i krajnje argument je minus jedan, znači kraj imena. Ta instrukcija prvo uzme sa stacka, znači, na vrhu stacka adresa veta-bele, pristupi to i veta-bele i pretragom, znači u ulazima veta-bele, traži poklapanje ovog imena koja je zadatoka argument sa, znači, nekom imenom u veta-bele, ako je ime nađeno, iz veta-bele se čita početna adresa koda metoda, prvo z povratna vrednost pisija upisuje na stacka u povratna adresa, a onda se skače na adresu koja je pročetana iz veta-bele. Ono što tu još ja nisam pro komentari su u kodu ima, evo sad vidim da sam preskočio. Takođe i tis pokazivač odnosno adresa u samog zapisa, tako na hip-utu, ovog veta-get static nula, znači vrednost c je bila pre samog poziva, znači, poret parametra a, na stack se stavlja kao stvarni argument, znači, dis i a, pa se onda tek zove invoke, virtu, znači, dis je implicitni parametra. I je to, cela ova obrada je potrebna za poziv dinamickih metod. Nastavljamo objašnjavanje skupa instrukcija. Ulaz izvezi je vrlo elementaram, zato što mikrojava je prosto njena ostona name, znači, naja da se napiše compiler, a ne da se pišu sada neke elaborirani programi. Tako da u suštini ima samo najosnovni ulaz u obliku čitanja jednog celobrenog podatka ili čitanja jednog znakonog podatka. Znači, instrukcija read prosto ne zahteva ništa na stacku, a na stacku ostavlja prekide izvašanje programa, znači, na ona i kada otvorite terminal, znači, tu ćete moći da ukucate broj, koji će, naravno, onaj runtime da konvertuje u ceo broj, i onda će ta vrednost da se nađe poslidušanje instrukcija na vrhu expresson stacka, izlazi realizovan sa printom zahteva vrednost koja se štampa i na kojoj širini kao format, znači, koliko znako ona izlazu, da se ta vrednost kao stringa predstavi, znači, te dve vrednosti se pokupe sa stacka i da i izdaju na console i al, kao ispisu terminalu, znači, za znakovne promeljive imamo read i blueprint, slično kao ove dve, samo sa odnosno se najada znak, poslidoj instrukcija software-sko prekida trap, koja ima jedan operant, koji je opet povedan sa radištim porukamogrešći koji runtime izdaje, znači, efekati došanje instrukcija se prekine izdošavanje programa i da se izda poruka od grešći koja zavisi od ovoga p, uglavnom, iskorišćena je za jednu konkretnu namenu, da se na kraju tela svakog metoda posle return, znači, kako compiler prevodi tela metoda, na samom kraju tela ovek stavlja jednu trap instrukciju, to je ako slučajno programmer uspe da nekako zaobiđe na redu return, da se na leti na ovej trap, koji bi onda izdao grešku izvršavanju, znači, da se ne dozvoli da program odluta na neku slučajnu lokaciju. Ovde imamo jedan kompleksni primer prevođenja znači čitavog jednog metoda od nija za instrukcija koja koriste i if i while. Konstrukcija narav sve mora da se prevede na nivo uslovnih i bezuslovnih skokova u byte kodu, pogledajte sami detaljnije, provučite primer. Mi ćemo još pričati o generisanju koda u posebnom materialu, tako da sad ne moramo prolaziti detaljno kroz ceo primer. I na kraju da kažemo da je definisano kao što prava java ima klas file-ove, tako i ova mikrojava ima svoj objekni file, koji su najčešće, nije definisana standana ksenzi, ali najčešće se koristi tačka oboje. I to je u stvari file koji na ulazu zakteva mikrojava runtime. Znači vaš compiler kad prevede programo, on ću u stvari generisati jedan ovaj objekni file. Struktura objekta file je takva da prva dva byte u tom fileu treba da budu mjelo slova, kao neka magična konstanta se znači sadreže. Taj objekni file, zatim svedaj će četri byte su veričina prostora program skoda, zatim će četri byte su veričina statički podatak, znači koliko da runtime alocira za, pošto su to fixne veričine, znači za sve metode i za sve glopane promenjive. I sledeća četri byte je adresa, gde se u ovoj code size oblasti nalazi main program, od atletrapa očet izvršavanje. I još jedino što, znači u fileu kreće od 14 byte, to je prevedeni byte code, u veričina ovog dela je promenjiva uzavisno, zvijedno od kogako ste imali naču prevedenom programu metode. Tako da to je sve što se pamiti u objeknom fileu. Tu možda je taj format malo mogavi da se proširi, ali recimo treba primetiti da nema nikakav početni sadreže statičke oblasti, znači alocila se samo da statičke oblasti na puni nulama, a naprimer morat u izvršno kodu onda puniti one virtualne tabele, a da nikakav sadreže fiksam.
