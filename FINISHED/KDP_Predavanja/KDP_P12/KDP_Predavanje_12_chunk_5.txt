 pokreće u zasebnom toku kontrole na serveriskoj strani. A je to novo, pokreće se u zasebnom toku kontrole na serveriskoj strani. Znači serveriska strana, kako da nema ja? A mi nignetamo, nismo krjerali neke tradove nešto, a morali smo da stavljamo synchronizaciju. A razlog zašto mi nismo morali da krjerali je zato što neko drugi krjeralo. A ona i naš server ko to treba da radi, čim priknoti zakte, on krjera novu nit. Ova nit onda pristupa ovom ovde objektu. Dobro, mi šta sam sadio ovde reko? Poziva se što se kvinice strane tiče kao najobični poziv procedura. A ovo ovde može da bude na različitim mašinama napakova. Ovo i što poziva se blokira. Dok legod pozivana procedura ne završi. Tako da se ovde ove ponaša i kao monitor, čekamo da se to izvrši, ali u pozivni je napravljena sihlona razmena poroka. Odradi ovo i čekamo odgovor da mogu da nastajim dalje. A kako se to realizuje na serveriske strane? Vlaki poziv operacije krjera nov proces od ovdjehlu novu nit. I ovo baš tako i se napravio neki bazen nit i pa se onda to reciklira, to je svar implementacije kako je to neko napravio u pozivni. A mi možemo da pošaljemo nešto i možemo da dobijemo rezultat nazat. Aj, polovo. Znači, ja kada pozivamo ovde čudo, na serverisku strani se krjera nova nit. Ako ođer da synchronizuje te nit? A korizni programmer koji piše serverisku stranu aplikacije mora da synchronizuje iti. Aha, dobro, ako biste kodim slučem dobili zadatak, a koji s odnosi na rpaca, na serverisku strani, vi u svariji imate nit. Tako da tu može doći opet ono. A monitori se možemo pošaljati, monitori semafori regioni. Znači, nije da se monitori semafori regioni javljuju samo kod konkurentog programiranja, javljuju se kod konkurentog programiranja, ali se mogu javiti i u nekom delu ovog našeg distribuiranog programiranja. A kom delu distribuiranog programiranja? Pa za nije to sve razvečiti ratunare. A ma jesu to sve razvečiti ratunare. Ali kad se pozove nit na serveru, a nit, te niti treba na serverisku strani synchronizovati. A dobro, da vidimo kako se onda ovod deklariše. Imo modul name, ono navedemo, šta taj modul pruža ostatku setnoć. Isto stvar kao što smo imali kod rpaca, kod rama i ja. Moramo da navedemo, nači ona je naš interface, kažemo, mi zadovoljamo sledaći interface. I onda navedete kako nekoma može da koristite. Onda dođe modu, mogu da se deklariše promenjive, mogu da se naprave raznorazne metode, koji se nam potrebne, ali možemo da napravimo i gomilu ovih delini, je zanimimo da stoje ovdje istrk u človečom ovom procesu. To proces u svištini označova, da će se to izvršiti u zasebnoj miti. I sad u nutram metoda, koja metoda, pišete lokalne promenjive, ispisnite izraze šta to treba da se radi u nitartoktu, što se napravimo. Imo možemo uvujstnut da napravimo rma i objeka. Rma i je u svištini samo preslikano ovo što imamo kod rpaca. Imamo deklaraciju interfacea, uštini i servici moderni, svi tako rade. Moramo da objavimo negde da imamo service, kako izgleda servis. To je neki interface, kako se to poziva, jer niko ne vidi naš kod, pa da vidi u pazilinkovanja, jer će to da prođeli neče. Nema pazilinkovanja, to je servis negde koji treba da se izvršava. I pitično stvar, ovdje svaki zakdel koji stigao, se izvršava u novom nit. Nova nit, pusti posao odrednipo. Dobro, o čemu onda ove treba još voditi racontam? Kako se poziva? Ove stoji da se poziva kao call i onda se zove taj naš paket, ili kako god, tačka operacija u koji se navazne. Ovoj u fustini možda je lične objekto orienti se nupot. Jeranja nije baš, to je samo kako da nađemo tu naši metod. I to ćemo vrlo cesto mi izostavljati, jer ovdje našo metode biti veljene, nećemo imeti objekat koji može da radi nešto, povdajemo 10 objekata. Ono što se nalazi u turistom modula? Voda da bude u istom adresnim protama. Čo njih naštamo server, mora da bude do... Jer tu imamo nit, nit i dele promenljive, tako da nema razvijene poruka i je go deloba promenljiva, istoj promenljivi. Po pristupa to je promenljiva, pa kada se pozdove metoda, kreja se no proces, objezno, novanic, a i ta je posao treba da se odrediti. Ok, serverski proces može zove neki drugi. Serverski proces da bi se odradio neki posao. Serior može da postane klient da se odredima nekom drugom serverom. Želimo da naprijemo neko sa krivanje. Ok, ne želimo da klient gađa neki tamo gore server, nego dođe na privir ko nas, provarimo o to, da li potoji tu u kešu, ako potoji, vratimo kao vrednost, ako ne, zove dalje. Ali server naš prvog nivoja će to pozvoti tamo na drugom. Objevamo jedan primjer učimo sad odraditi, poslice u naprevi pauzu naš buffer konacil kapacit. Znači buffer konacil kapacit. Buffer konacil kapacit petar je našo trg. Pijuno, da možete obe želimo da naprijemo buffer kroz koji će u mnici peti, dve strane koje neboda raditi. Tako kači i potoršac. Kako oni kodniciraju, kozo ovaj objekat koristići dve metode. Jedno metode je put, drugo metode je get i kako se ovde u kratom primjenu zovu, dipozit u baci element stoje put i patch od get koja treba da nam vrati taj element. Što bio deklaracija interfejsa. Ovo o ovde je šta tak sveta vidi i kako smo je da poziva naš modu. Da nakon toga ide body to je body, body je mesto da deklarišemo u kustini sve naše promenjive. I šta mi ovdje imamo? Miz od 1 elementa i ovu 2 podivača front rier ja mislim da je to možda dobrojno. Zato smo ćemo problemi razarješiti koristići o nerastrazne semopore. Semopori ćemo full i anti. Zato imamo semoporu dašto imamo semoporu u distribuiranu programiranju. Zato će se miti na server s koj strani izvršavati kao konkurentne aplikacije. I onda ovo ovde nije ništo drugo nego iskopiran primer. Uzili smo iskopirali smo primer a iskonkurentno dela i stavili smo ovde da vidimo samo kako će to realizuje. Nema ništo drugo. Ovo je proces ovo značo metoda izvršavati kao rpac metoda. Kako se izvršava. Sačekaj da imam varje mneček u bufferu a kažemo wait mutex dašto se ovde zove d zato metoda i pozit. Nije put i get pa da budem mutex p i mutex c ili producer, consumer ili put i get pa da se ovo ne ovde na poslu su metode zove poziti patch onda su mutex pojda. Šta radi ovoj mutex d kaže za brani drugima da pristupaju dok lego od ja ne ubacim elementu buffer mrnem za jednu pozicurije. Kao se to desi kažemo rati mutex a vrati put. Prva metoda to radi. Šta radi druga metoda a druga metoda koja treba da dokva te element kaže wait pull čim dobijem dozol do način ima nečegu bufferu posliču sada čačkom taj buffer da menjam on inam pokaziručku se zove prompt onda kažem wait mutexf dokva te element mrni se malo po bufferu i vrati nazad mutexf i kaži u drugu strani sve je slobodno a druga strana je proces. Nisam morali da rekvarišu da se radi o procesu pohvatanje. I to je to. Ovo ovde je osnovni koncept koji postoji kod rpac a to je sakri sve od programera. Ono koće to da koristite i da poziva taj objek. Mi damo programeru naš podpis a mi pravimo proces, odnosno programstvji jezim će za nas da napravi taj proces i objekat koji će komunicirati sa serverom i dokvata ti nazad. Sa kriveno podpuno sokiti ili komunikacijoni kanali.