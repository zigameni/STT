 ili kojih ima. A onda bi smo nekako morali da doklatimo i to jednosti n i to smo rekli ili je statički definisan u ovom primjeru koji smo sad da radili. Bilo statički definisan i menadžer konfiguracija, ono je program koji radi povezivanje, je morao da ozna druga varijanta imamo neki grad, a moramo da prosta dimo tu vrednost, to će možda morati osvaljiti kroz neki prsten, znači primjer će biti sa neki prstenom da graf će izgledati malo drugačije. Ili ćemo nekako drugačiji topologiji imati ili ćemo morati da šaljemo ovako sentencijalne vrednost. Znači kažem ili se nekako statički zadaje to ili šaljemo najčešći kao prvu vrednost, a možda ćemo morati da koristimo ove specijalne vrednosti da bi smo znali završeno je nešto, posled tog nečeg završeno da nam dolazi specijalna vrednost. I moži to. Tav je bilo da smo da se u ovom ovde ršenju zatevalo da izbacimo duplikate. Znači sad zamislite da ove naše ršenje treba i o tome odi racunom. Da li bi trebali da prosledimo svaku vrednost ili ne? Ako smo već, ono moramo da znamo koji smo poslednju vrednost prosledili po nekoj od ovih kanala. I ako smo na primer već prosledili broj 3, dođe nam ponov o broj 3, ne prosleduju i dalje broj 3. A znači šta moram, nijam zapavnit ćemo, a moram nijam zapavnit ćemo još poslednju vrednost koji smo prosledili nekom. Neće biti za dovoljno da imamo promenjive v1 i v2, nego ću morati još nemoj promenjivu last. Jer je samo ona dovoljna da nam kaže da li smo već prosledili, jer reko smo imamo sortiranene izove. Ima treba nam još jedna promenjiva last, ta promenjiva last bi nam rekla šta je poslanja vrednost koji smo poslali. I ako je sadašnja vrednost predkudno je vrednosti, ne šalji tu vrednost ponov, već smo je poslali tamo preuzmi novu vrednost za ulaznog kanala. I o tome možete voditi raduna, ako treba dobezbiljite da se vrednosti ne ponavljaju, možete morati da radimo izbacivanje elementa iz naše gniza. Što je bilo stoj elementa, na kraju možda se zavšimo da zavšimo sa jednim elementom, jer su sisti. Tako da moram, moram, moram, bila smo ovdje da čuvamo i tu promenjimo last. I onda samo proverite da li je last jedna ko o tom što bi smo uslali, ako jeste, ne šaljemo, ako nije, šaljemo. Ok, i to je to. Znači videli ste primer, kako izgleda jedna mreša za stapanje. Kako smo mi povezali ovo mreša? A, rekli smo da možemo da nekako dobijemo i1, i2 i out. Najčešći kurs kontruptor. Odnosno kurs potpis ove ovde metode. Ovo je ovde proces, bih verovatno u svom kontruptoru trebao da dobije sva ovde tri komunikacijana kanala kaos argument. A neko poradi povezivanje. Morati da koristi ili statičko ili dinamitko imenovanje. Kad bude određival, ako, kome treba da prosledži i ko od koga treba da čita vrevnost. Statičko giminovanje. Viću morati da naparemo negde niz, niz, dužine, a, n, odnosno, n-1 ili 2n-1 kanala u zavisnosti do toga koliko imamo tih naših kelamenata. I onda da to se lepo povezemo i da tačno na osnovu indexa. Znači čvor zna, ja sam čvor broj 10. To znači čitam sa 10 i 11 ili sa 20 i 21, a šaljem na izlas 22. Bilo statičko imenovanje. Taki proces dobije svoj ID, a onda na osnovu svoj ID preračuna iz kog tog mnoštva kanala treba nešto da pročita i u koji od tih kanala treba nešto da upiši opet. O zavisi toga, kako nam je neko nešto dotur. Ako nam je neko dotur i okroz konstruktur, uopšte ne razmatramo kako je taj neko nam te komunikacijone kanale dodelio. Umez to ovog statičkog, da je na osnovu indexa nešto raspoređu, možemo da imamo i dinamicku imenovanje. U dinamickog imenovanja opetci kanali su globalni. Ali neko može da ode da kaže, e napravo im dodatni kanal, e na osnovu nekog imena, ja mogu da kaže u kojoj kanal nešto želim da ubatvim, to je u sestini kada bi ubatvite nekog u telefonski imenik. Predkonno niste imali tog nekogu telefonskom imenik. I onda kada su poznate s nekim, taj nekom da, svoj broj telekona, a vi nekako to upišete u svoj telefonski imenik, i na osnovu toga možete da ostvarite nakon toga komunikaciju. Komunikaciju onda poslo obavljate statičkim imenovanjem, odnosno koristit će to, s kim želite da komunikacijate, možete napraviti, pošeljete na nekom. To je grupi su za sada statički i svimi korici, a može biti statička grupa, ali možete da se napravite i dinamicka kao što imatete. Sprengde možete se prijavljujete i odjavljujete sa raznoraznih grupa. To bilo dinamicku imenovanje gde možemo na osnovu nekoga tributa, daj mi poštansko sanduče koji odgovara za q, meni koji ćete pošeljete poruku, i onda u to poruku na osnovu nekog identifikatora pošeljete nešto. Imate statički definisano sve koj sebe, nego treba dinamicki da dovučete kanal preko toga. U javi, taj kanal ćemo dinamicki praviti, tako što ćemo reći IP adresu preko koji želimo da radimo komunikaciju, 147.9.1911, na primer ili koji godnoć brou bude kod nas u laboratori i dole. I preko to kanala ćemo mih formirati novu kanal, način ćemo kako ide to pyriranje sa svakitima, koji će kome šta da dobaci, da bi to moglo sve da radim. Plexibilije mnogo raditi sa dinamickim kanalima ako nam to je zik dozvoljava. Peki jezici ne dozvoljavaju rad sa dinamickim takvim trupurama, zato su kaj su to oče, onda mnogo da uspori rad našeg sistema, na primeru kanu, a vi baš i nemate mogućno da pravite tako dinamicke neke strukture. Možete statički usluštini sve to da radite i mnogo brazo. Možete mnogo brazo, onda tako nešto da radite, a u sluštini možete sve isto da odradite kao i pre, samo možda malo treba da se fokusirate kada nešto budete programirali. A mi ćemo ove komunikacije imati u glavnom statički definisane, ali ćemo moći da napremu možne dinamicki, kažemo program, a ovo ćemo dinamicki. Kaj kanal je, kad godnom bude nešto zateljeno? Ok, nismo šta sam beš radili? Radili smo svojdiranje koristici binarno stavlo. To bio jedini način da ovako napremu našom rezu i da napremu svoj sortiranje. Odgovorio nije, sortiranje možda se obavi i koristiti list. A imati u materialima, u istitim zadacima da napravite sortiranje, a ako imate veći broj procesa, koji su povezani u pipeline. Značim, imate jedan ulazni kanal i jedan izlazni kanal. Jedan ulazni kanal ovde i jedan izlazni kanal. I ovako može takođe da se napravi algoritm za sortiranje. Ta radi ovaj algoritm za sortiranje. Dobije vrednost i ako je vrednost koja mi stigne, manja u odnosu na vrednost koju imam, ja pošaljem tu manju vrednost. Ako je vrednost veća u odnosu na vrednost koju ja imam, ja pošaljem svoju vrednost, a primim koje sebe tu veću i stajem je dalje da to stoje. Či vidite, a ne mora da bude binarno stablo, može da bude i najobičnije degeneriseno stablo, odnosno u pipeline algoritm, gdje će svako od njih moći da radi u paralelija. Da ću da pošaljem dalje vrednost ili ću da obradim ja tu nekakvog vrednost, možda saču vam tu nekakvog vrednost koja cera. Ako da ne mora da bude veći broj ulaza nego što imamo izlaze, možda se desi kao kod ovog ovde pipeline algoritma, vidjet ćemo mi još nekoliko pipeline algoritama, ne vežno će ti viditi moženje matrica, a možemo da naprimo takođe nešto slično. Da ti treba samo da proračunete ako liko na hama čvorova treba da bi mogli da odradimo ekikasno suhradnje nizadužine n. Iel vam treba n-1, ilam treba n i kakvu su oni cipovezan i koji će možda raditi od njih brši. Znači to o tome vi treba da razmistajte. Ovo ti prošli. I ovno sad što hoćemo da vidimo. Ok, nećemo više gledamo filterske procese.