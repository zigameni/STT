 Na predhodnom predavanju došli smo do vdje i ono što je pokazano tada to su biri neki primer i hipotetickih hash funkcija koje ne zadovoljavaju kriterijume zaklitogrnskih hash funkcija. U sva tri pokazana slučaja bilo je potpuno trivialno da se pronađe druga poruka koje će dati isti hash to je jedan od razloga, jedan od zahteva koje ne bih smelji da se dese u kod hash funkcija dakle da bude jako jednostavno da se pronađe neka druga poruka koje da isti hash odnice svori kolizije izm. E sad ćemo da vidimo prvo što su neki zahtevi koje treba da ispunuje hash funkcija kako bi se smatrale za sigurne i kako se meri sigurnosti hash funkcija za neko praktično korišinje u akviru razno raznih aplikacija. Videte ćemo da hash funkcija se koriste za vemo veliki broj različitih aplikacija čak i neke aplikacije koje je izloze izvanog kuk i zaštite poetaka. Takle prvo ćemo da pogledemo malo što su ti zahtevi pa ćemo da vidimo kako konkretno funkcija oniše jedna takva hash funkcija to je sh512 koja se i dan danas koristi kao standardna način za izračunavanje hash i onda ćemo malo prokomentari se ti neke primehne hash funkcija. Dakle kako se u kojim situacijama se hash funkcije koriste praktično da biste stekli osiće i zašte su sve one sposobne. Dakle što se tiče ovih zahteva za hash funkcije tu ima oni su ovde izlistani na ovom slajdu imajuš 1 7 zahtev koji je na narednom slajdu pa ćemo i to prokomentari se ti. Ove prve stvari su relativno trivialne a to je nešto što sam i na prošnom času rekao. Dakle hash funkcija može da se primini na poruku koje bilo koje duži ne. Da vidićemo da u okorju standarda je definisano da postoji neka maksimala većina poruke s tim što su ti vrednosti jako velike i praktično svi filovi koji si dan danas prenosi i koje vi mogli da se zaštite. Ovako nekom hash funkcijom mogu da upadnu u te limite ali dobro o tom potom kad dođemo do konkretnih hash funkcija. Ono što da koji će sam rekao na prošnom času to je da se proizvodi izliz koji uvek fiksne dužine bez obzira na to kolika je ulozna poruka. Ono što se nekako implicitno podrazumevalo to je da je lahko izračunati hash funkciju od neki poruke. I poruke je sada naravno to traje neku vreme i sada to što je ovde napisano da je lahko ne znači uvek baš da je lahko recimo i to ćemo isto ove pomenuti danas kao jedno primena hash funkcija. Konkretno ono majnovanje bitcojina za koje znate da oni koji se ozbiljno bavi tim poslovn nabavljaju poseban hardware i nabavljaju posebne kartice koje imaju u veću procesu snagu i koji su osposobljene da bolje izračunavaju neki stvari. Mekle majnovanje se sastoji od izračunavanja hash funkcija pa sada to se radi mnogo put. E sada ako je to za to potrebom poseban hardware znači da u stvari to nije nešto što je lako ali kada se kaže u ovom kontekstu lako izračunati hash to znači da za neku poruku koje se šalje recimo preku interneta. To vreme je nešto što se meri u dakle bude manji od jedne sekunde. Sad druga je stvara koji mi moramo da urodimo na primjer dvanad badiset i izračunavanja hash evo da bi smo u okrubu blockchaina potvrdili neki blog. E to nije mali broj izračunavanja hash funkcija, nego u tako situaciji je potrebno već je procesu snaga da bi se to urodilo u neko razumno vrem. Znači u ovom kontekstu lako izračunati hash znači može da si izračunati relativno brzo. E sada naravno to ste se već navihli pod tipogljuskih funkcija nešto je lako a nešto je teško. Ono što treba da bude teško ako je hash funkcija kvalitetna to je da kada imamo hash od neke poruke x izračunamo h od x to je h. Za tako izračunutu vrednost hash je teško zaključiti koja je to poruka koja generisila datih hash. I sada ako uzmemo kao pretpostavbu da može da bude bilo kakva poruka, bilo kakve dužine, onda je jasno da za određeno izračunutu hash vrednost zapravo može da postoji prakčno beskonačno mnogo različitih poruke koje će dati taj hash, pošto hash je ima konačan broja potencijanih poruka ako su različite valičine može da bude beskonačno mnogo. Tako da u principu je ta osobina, to je one way osobina, odnosno da ne postoji način da se iz samo hash dođe do originale poruke, ta osobina je nekak uvek izpunjena. Druga svar bi bilo ako bi se ograničiši na to da su uvrste poruke neke fixne dužine pa da onda postoji neka vrsta inverzne operacije i ako su te uvrste poruke, recimo, i ste dužine kao hash, onda bi evento moge da pokuša da napravi neku vrstu inverzne funkcije, ali vidite ćemo zbog načina kako funkcioniš u samih hash funkcija da to zaista nije mogući i to je osobina koja je relativno lakko izpunjena. One što su drugi dve bitne osobine za hash funkcije to su tako zna vik collision resistance, odnosno odporna slabje kolizije i strong collision resistance, odnosno odporna jake kolizije, ako bi mogo to tako bukvalno da prevede malo zvuči rogobatno i sad ćemo da vidimo šta znači ta dva zaakteva. Prvi zaaktev kaže sledeće, ako imamo neku poruku x za koji smo izračunili hash od x, da je teško pronaći neku drugu poruku y za koju kad bi si izračunili onjen, da bi smo dobili istu hash u jednosti kao za poruku x. I ovo je situacija koja veruje da vam je intuitivno jasno, zato što, recimo, ako uzmemo neki primer kako bi smo mogli da koristimo hash funkciju, a to je, recimo da pomoću hash funkcije želimo da zaštitimo neki ugor koji je podpisane izm. 2 antiteta. I u tom ugoru piše da antita ta treba da plati antitetu B 100.000 eur, i sad da antita ta i podpiše takav ugor i oni su se dogovorili, međutim antitetu A se takav ugor baš i nesvijđa i on bi volila da promjeni tu vrednost da piše da on treba da plati 1000 eur ili da ne mora ništo da plati ovo antitetu B. Neče, ono što bih teva neko u tako situaciji, to je da napravi neku drugu poruku u koji će biti neki drugi sadržaj, e sad ako smo prvu poruku zaštitili hashom, ono kako bi on mogu da napravi prevaru, to je da napravi drugu poruku koje će generisati isti hash. E sad to treba da bude njemu jako teško i to ćemo vidi sadan na arduvim slajdovima šta znači to da mu je tako nešto teško, ako je u pitanju palitetna funkcija. A ono što smo videli na kajhoj prošli časa to su oni primeri nekih hash funkcija koje su zaslovanili na onom eksklusivnom ili na cipher block cheningu kod kojih je bilo trivialno zbog greški u samom protokolu da se pronadži za zadatu poruku M, bilo je trivialno se pronadži neka poruka M1 koja može da da isti hash. Druga vrsta kolizija koja može da si desi to je da koji imamo sada njih z nekih objekata koji imamo izračunog hash, znači nekih različne poruke, znači imamo izračunog hash, u tom skupu poruka za koje smo izračunog li hash'eve, ono što žerimo da bude teško stvarivo to je da dve poruke imaju isti hash. E ta to svojstvo se zove strong collision resistance, znači raznika odnosno na ovo prethodno, kod ovog prethodu mi hoćemo za zatačno određeno poruku X pronadžemo neku drugu poruku Y koja daje isti hash, a u ovom drugom slučaju imamo skup, imamo populaciju nekih poruka i hoćemo, ono što je ta osobin na strong collision resistance, ono znači da ako izračunemo hash'eve za sve te poruke, u tom slučaju ne bi trebalo da se desi da bilo koje dve poruke imaju isti hash i vidićete da za ova dva zahtera, za zahtere brojk 5 i 6, da se prosto matematički različ, to izkazuje težina ovog problema, odnosno rezultat je različ, ali o tom potom za koji slaj ćemo to razrešiti. E sa što sliča, sigurnosti hash fungcija, ovde možemo da imamo jedan primer, a to je da ako imamo poruke koje su fixne veličine, znači recimo imamo neku hash fungciju koji zljoda ovako, gde na ulaz dolazi poruka koja je veličine B bita, ovo da oprišem, ovde ima B bita koji ulaze, imamo hash fungciju koja ima N bita. Ako je broj B veći od N, ako je dužina poruke veća od dužine hash, onda takvih poruka ima 2 na B, A hashiva ima 2 na N, dakle hashiva ima manje, nego što ima potencijalnih poruka. E sada ako je hash fungcija kvalitetna, ako je jedan od zahteva, to je taj 7 zahte, koji se postavlja pred hash fungcije, a to je da izlaz hash fungcija bude pse od o slučajem. A što znači da izlaz hash fungcija pse od o slučajem? To znači da ako bi smo napravili fungciju u raspodelaboratnoći pojavljivanja različitih vrednosti hasha, da sve te vrednosti koje mogu da se dobiju od svih nula do svih jedinica, budu jedan primer,
 jednakoverovatno. Dakle da ne postoje neke vrednosti hešava koji mogu da se dobiju iz takve heša funkcije koje su verovatni i koji će se češći dešavati. E sad ako je heša funkcija takva da su sve vrednosti izlzno heša jednakoverovatni i da mogu da se dese, onda ako imamo 2 na b različitih poruka, ono što a imamo 2 na n različitih hešava pri čemu je b već je od n, ono što može da se očekvo je to je da će 2 na b minus n. Ulaznih poruka davat i isti heš, odnosno postojat će kolizije. I ta situacija da ne postoje kolizije, koji heš funkcija zapravo nemoguća. Znači ako su ulazne poruke veće od samo heša mora da dođi do kolizija, ali ono što dobro što treba da bude osobina heš funkcija koja je qualifikuje da se poristi u zaštiti poataka, to je da ne bude trivijalno da se pronađu dve poruke odrećene veličine koje daju isti heš. Dobro, što se tiče odnicijelnih napada na heš funkcija, znači ako govorimo o onom weak collision resistance napadu, a weak collision resistance kaže da ako imamo jednu poruku x koja daje neki heš h od x, da je teško pronacit poruku y koja daje heš h od y koji jednak heš od x. Ono naravno sad ako pospotramo iz perspektive na padača šta će on da radi. On treba da generiše različite poruke y, y1 y2 do neke tamo yn, i da za svak o tih poruka y izračunava heš funkcija. I to će raditi sve do odle dok ne dođe do neke poruke y koje će dati istu heš rednost kao hodix. E sad, taj napadačo on može da bude maksimalo sreće. I može da se desiti da iz prve nabode neku poruku y koja će baš dati isti heš kao poruka y. Prosto to je tako, može da bude kao i nul tri. Neko bude maksimalo srećen i pogodi sedan brojeva na lotu, a neku igro celo život i neko je godje nikada. E, taj koji je srećen može da pogodi iz prvoga neko može da bude maksimalo nestrećen i onda se ako je neko maksimalo nestrećen računa da ako ima dva na m heševa, da mu treba od tom slučaju dva na m poruka različiti i da će posled tog vremena biti i verovatno oče da će on dobiti neku drugu poruku koja daje isti heš približno jednaka jedijec. E onda se zato smatra da je snaga dobrog heš algoritma koji ispunjava ona i vik poližan resistenc dva na m minus jedan odnosno dva na m, to je broj, ukupam broj heševa, polovina. Znači ta polovina je nekde između tog maksimalo srećenog napadača koji iz prve pogodi heš funkciju i onog maksimalu nestrećenog koji iz dva na m to pokuše pogodi tu heš funkciju. Znači ovo je sigurnost koja se odnosi na vik poližan resistenc. Što se tiče, strom poližan resistenc napada, tu je stvar malo drugačija, tu postoji jedan paradox, odmstno jedna situacija koja je poznita iz seori i verovatno oče, a to je tako zvanji brzdej paradox, odnosno paradox rođendana. Nije nikakap paradox, nije reši nije vakom paradox, uprostno to je matematicka čiljenica koja kaže da ako imamo, recimo u nekoj prostoriji određeni broj ljudi, verovatnoća da će dve osobe u toj prostoriji imati rođenda nistog dana, će u situaciji kada je ima anegde koredniz 365 biti 50%. Sada dole možda komfuzno pa ću pokušati malo detaljnije da to izelaboriram šta to praktično znači. Možemo rođendan da posmatramo kao neki naš heš, zato što svako od nas ima rođendan i to ne mislim rođena koju uključuje samo dan i mesic. Dakle nekoj rođen 10. oktobera, nekoj rođen 13. marta kakogod, taj datum je prvo iz jednog granitnoj skupa datuma kojih ima 365 ili 366 u prestopnim godinama i svako od nas to ima. Možemo da došiljimo o taj datum kao neku vrstu heš. I sada ako znamo da ima 365 različitih dana, onda nam zvuči prilično čudno i to je zato se ovo zove paradox da u situaciji kada ima 20 ljudi u jednoj prostoriji. Svega 20 ljudi u jednoj prostoriji, verovat noća da će dve osobe u toj prostoriji imati rođena nisu dana i 50%. Što je delo je dosta visoka verovat noća. E, to 20 se dođe od privike, to je približno koren iz 365, to je 19 manješta pa kažemo da je to 20. Što ovo znači dalje? Ovo znači dalje ako posmatramo sada neku hešfunciju koja ima n bit, koja daje hešveričine n bita. Da ako generišemo populaciju, odnosno skup nekih poruka, za koji izračunovamo heševen, to znači da će verovat noća od 50%. Da ćemo u tom skupu poruka imati dve poruke koje imaju isti. Heš biti 50% u situaciji kada imamo koren iz 2 na n poruka. Koren iz 2 na n je zapravo 2 na n polovina. Tako da, ako imamo hešfunciju koja je, recimo da je hešveričine 128 bita, ako imamo 2 na 64 poruka, u tom skupu o 2 na 64 poruka verovat noće da će dve poruke imati isti heš, odnkmo da će doći do kolizi u tom skupu poruka je već 50%. I to je ono što čini da je zapravo, taj strom collision resistance zakte stroži i teže se ispunjava od onog big collision resistance zakteva, zašto big collision resistance podrozumeva 2 na n-1 da je broj pokuše na padača da naproviniš. Zašto je ovo bitno? Ovo je bitno. Bitno je u kriptografiji, zato što ovaj napadač može da pripremi svoj napad, tako što će recimo izgeneriti variante ugovora ako pričamo ono mu govoru koji je, koji bi napadač te da promeni, zato što hoći da svoju obavezu nekako smanji. I recimo ako je taj ugovor slikan, znači to je neki scan, papir na tog ugovora, ono što ono može da probad uradit, asad skenirana ili PDF forma je nešto što ima puno biti, da može da se, koji mogu da se variraju i da se dobiju različite znači ono može da proba da izgeneriše veliki broj takvih porukla da izračuna hashe ove za njih i da onda kada uspeto da uradi da onda napravi da ima dve poruki koje sadrže različite odredbe ako je zapravo imaju istih hash i da na taj način izbrši prevar. Z druge strane vama to može da bude značinu i u nekim primjenama koje nisu strictno u oblasti kriptografije. Ja verujem da ste vidi u svom do sadašnjemu čpolovanju sigurno čuli za hash funkcije i da je heširanje jedan od metoda kako možete da označite neke podatki u određenim bazama podataka. I ovde imate primer sa desne strane. Ove funkcije gustine u erovat noće za to da dođe do kolizije u situacije i kada se koristi hash koji ima, koji je 32 biti. Naprimera ako koristite neki algoritm kao što je crc32 koji daje hash praklično veričine 32 bita. Ovde vam nešto slično tome daje ovaj grafikon. Znači, ovo ovdje vrednost koje je nekde oko 75.000, to je vrednost za koji se dobija, verovat noć, od 50%. To je vrednost koje je približ na korenu iz 2 na 32, porno iz 2 na 32 je 12.60, a to je 66.35 vrednost. Znači tu negde oko te vrednosti, oko 65.000-70.000, će se dobiti, verovat noć, od 50%. Da će doći do kolizije u tom stupu. E sad, što ovo znači? Dacimo, ako napravite neku bazu, i ta baza je na primjer baza svih, ajde da kažemo, u Srbiji svih zdravstvjenih osiguranika, znači to je baza koja ima nekoliko miliona ljudi, ako bi ste chceli da razlikujete te ljude, onda svakako ne biste smeli da koristite ovakav hash koji ima svega 32 bita, zada što u toj bazi ćete imati kolizije praktično sa verovatnoćem 100%, već negde sa 225.000 ljudi. Dakle, to je jedna stvarija u kojoj treba da povedete računa, a razlik za to je upravo ovaj brda i paradoks. Dakle, kad bude te razmatrali u nekih primjerama, koju hash functije da koristite, u svakom stručaju je bolje koristiti neko koja ima više bita, zato što da smanjuje verovatnoću da dođe do kolizije, z jedne strane, a s druge strane cene koji morate da platite u toje vrema izvašavanja takve hash functije. Dobro, nadam se da je ovo bilo jasno. Sa ćemo vidjeti kako izgledaju same hash functije. Ovo ovde što vidite, to je tipična struktura i hash functije, praktično sve hash functije koje su do danas napravljene i koje se koristite i koje su standardizovanje imaju ovako istu strukturu. Ovo struktur je osmisti i ove i isti Ralph Merkle, u kog smo više puta pomijeli. Toko moho kursa je još nekde 70-80 godina o prošljog veka i prošljog bilenjume. I sad ćemo da vidimo šta ovo znači i šta podrazumeva.
 skulptura, odnosno na koji način izgleda ova hash funcija. Znači, ono što se jedne strane ulazili u hash funciju, to je poruka. I kao što možete da vidite, ono što se sa porukom dešava, to je da se poruka deli u blokove, koji imaju po b bita. Znači, ako je b, na primer, to je primer iz ove funcije, koji će, iz hash funcije, koji će vam pokazati za koji minut, sha 512. Sha 512 deli poruku u blokove koji su velečini 1024 bita. Znači, vredno zove b 1024 bita. I sad ako je poruka duža od 1024 bita, ona će biti podeljena u onu liku blokove, ako liku je potrebno da bi se izračunala hash funcije. Sa druge strane postoje nešto, se zove inicijelizacijoni vektor ili inicijelizacijona vrednost. Vide ćemo kako se to definiše, dakle to je nešto što je samim standardom, samim algoritmom predefinisano. I tu nema neko glutanje, dakle to nije ključ, nego je to fiksna vrednost. I ta vrednost ima ono liku bita, koliko bita ima i sam izlaz iz hash funcije, dakle ovo n predstavlja broj bita hash. Ono što je ključni element hash funcije, to je ovo ovde f. F je tako zvana kompresijona funcija, odnosno kompresijon i algoritm. A zašto se zove kompresijon i algoritm, pa hvaljda je jasno iz samog izgleda onog šta ulazi i šta izlazi iz ove funcije. Na ime, ovde ulazi kao što mošto se vidite b plus n bita u ovu hash funciju, a ono što izlazi iz ove funcije, to je n bita. I ono što imamo, ako imamo x blokova u jednom ovakom hash algoritmu, onda ćemo x puta ponoviti ovu kompresijonu funciju, zanim što će u mesi ovog inicializacijonog vektora, koji postoji u prvom bloku, na ulazi u narjednih blokova biti dovedeni izlazi iz predhodnih blokova, a naravno, ono što je drugi ulaz u tu kompresijonu funciju, to je sam blok, određeni blok ulazne poruke. I ono što je cilj ovakvih hash funcija, ono što treba da se ostvari, to je da ovaj izlazni hash, znači ono što se ovde dobi na kraju, da ta vrednost bude funkcija svakog, bukvalno svakog bita ulazne poruke. E, sa to ćemo vidjeti, na koji način se stvaruje u konkretnom SH pespid banis algoritmu, pa i vidjet ćemo na jednom primeru, kako to izleva. Do danas, kada se govorio, kriptografskim hash funkcijama, postoje dva standarda koji su se pojavili i koji su i dan danas akturni, to jedan od njih je svakog SH, odmstno, secure hash algoritm, drugi algoritm je MD-5, oni su, tokom svog postojanja, imali nekoliko revizija, odmstno, nekoliko različitih verzija. Prva verzija SH algoritma potiči još iz 90-ih godina i to je bila SH-1 verzija algoritma koja imala hash u rednosti dužine 160 bita. Od predviki u to isto vreme je nastao MD-5 algoritm koji imao dužinu hash od 128 bita. I to su, odmstno, to su bili algoritmi koji su se koristili negde dosredine 2000 godina. I onda kasnije, početmu 2000 godina je napravljena verzija koja se zove SH-2 i ta verzija SH-2 imala različite variante ovog protokola, to su ove ovde što mošte da vidite, SH-256, SH-384, SH-512, koje su davale heševe koji či je broj bita na značenu samom imenu ovog algoritma, takođe i MD-5 imao neke svoje revizije. I ove algoritmi se koriste i dan danas, i dan danas se smatraju za sigurne i dan danas ćete ih sresti u mnogi praktičnim primjenama i mošte da nađete i kod, ako vam treba ovakva funkcija, pa da ga je o praktičnom bilo kom<|de|> Alors'skom jeziku implementirati u opiru vaše aplikacije. E onda što se desilo mjelj vremen masto i što, zapravo nije sa simtacu no slide, ovde piše da je poslidnja revizija SH- standarda bila 2009 godine update, pošte evo malo starija prezentacija, da je poslidnja revizija ovog standarda bila 2015 godine i tada je usvojen algoritm koji se zove SH-3. SH-3 je noviji algoritm koji isto ima olu strukturu svih mogućih hash funkcija kao, kao ono što smo je videli na pretodom slideu, ali sam način funkcionisanja SH-3 i nešto drugači. E sad mi ćemo ovde na narodnim slideu lima ću vam ja pokazati kakom funkcionis je SH-5-12, znači to je algoritm koji spada u onu SH-2 reviziju, a SH-3 vam neću pričati, to ću vam objasniti zašto vam neću pričati na kraju ove pričaju SH-2, ali ako nekoga baš interesuje može da nađi u onoj knjizi koji se on preporučujem, može da nađi kompletan opis SH-3 algoritma. Evo sad ćemo vidjeti kakvo izgleda SH-2, pa ćemo biti jastno ove zašto ne bih pričao i SH-3, mislim da ove ne odnogo smislnim. E ovako, znači SH-5-12 algoritm je algoritm koji kao što sam malo prenagovestio, deli poruku u blokove veličine 1024 bita, to je algoritm koji daje hash koji je veličine 512 bita, ovde vam stoji da je sigurnost 256 bita, kada si kaže sigurnost 256 bita, mislite se na onej strong collision resistance koji zapravo kaže da do kolizije možete dođe, saverovat, načinemo od 50% ako imate 2 na 256 razičitih poruka. E ono što je ovim standardom takođe propisano, to je da je maksimala veličina poruka je 1228, ali kao što rekao, to je prično veliki broj koji zapravo ne prestavlja neko posebno ogrinicenje za sam algoritm. Saćemo da vidimo kako izgleda ovaj algoritm, znači prva stvar koja mora da si uvradi sa porukom, to je ona mora da se dotera da bude jednaka celom broju 1024-bitnih blokova. I sad pošto znamo da poruki u ovštim slučaju mogu da budu različite veličine, one mogu da budu od po 2-3 bita, mogu da budu i od po 100 megabytea zalisi šta hoćemo da propostimo kroz heškoniciju. U svakom slučaju redko kaće si desiti da poruka bude baš takva da ne mora da se dopunja, odmog sam standard kažem da čakaj ako imamo poruku koji jednaka inputa 1224 bita tako poruku moramo da dopunimo, zato što ono što ulazi u heša algoritm mora da se drži i ovaj ovdje deo na kraju. A ta i deo na kraju je polje koja označa va dužinu same poruke koje je veličine 128 bita i ovaj ovdje padding tako zvani dopuna, a dopuna se sastoji od prvog bita koji ima vrednost 1 i ono likog broja bita koji je potreban da bi se sad poruka plus padding plus ova dužina uterali u tih n-puta 1024 bita. I onda o te poruke ćemo dobiti ovde blokove m1, m2 do mn, to li koji k'ima i svaki blok će posebno ulaziti u heš funciju. E sad heš funcije zleda upravo onako kao što smo malo prevideli, znači postoji neki inicializacijun i vektor koji je predefini se standardom, li videte ćemo konkretne vrednosti na rednom slajdu. I ta inicializacijun i vektor se dovodi u ovu kompresijunu funcju F. Znači u kompresijunu funcju F ulazi 1200 bita bloka i 512 bita i inicijalizacijun u vektora. Iz kompresijun je funkcije F i zlazi 512 bita onoga što kompresijuna funkcija izračuna. I to što ona izračuna se dovodi na sabiranje po modulu 1264, znači to je ovdje operacija i tako se dobija izlaz iz prvog bloka. Naravno, ako je poruka kratka, onda će se ona sastojati od jednog bloka i u toj situaciji će ovo h1 zato ovaj biti izlaz iz h1 funkcije. Ako je poruka duža, onda će biti n blokova i onda će izlaz iz h1 funkcija biti ovdje. Znači ovoh h1 može da bude izlaz iz h1 funkcija, ali sam u onim situacijama kada je poruka toliko kratka da poruka plus dužina plus padding staju u 1214 bita. U krajnje linii sad ćemo vidjeti kada vam mogu ispričati na kraju. Če biti jedan primer sa baš takom porukom koji je veličine tog jednog bloka, pa ćete vidjeti kako to konkretno izlaz. E sad šta se nalazi u toj kompresionom algoritmu i kako izgleda inicilizacijni buffer, to možete da vidite ovdje. Znači ovo ovdje je vrednost inicilizacijni buffera, to su ove ovde vrednosti ABCD-H koje imaju po 64 bita svaka, znači 8x64, to mu dođe 512 bita. I sad kako su ove vrednosti dobijene, pa ove vrednosti su dobijene tako što su izračnuti kvadratni koren i prvi 8 prostih brojeva i uzete su decimalne vrednosti, znači sve ono što se nalazi i za decimalnoh zarjeza. I to je onda napisan u ovakom...
 hjeksadecimalno mobliku i to se koristi, znači u svakoj implementaciji SH2 algoritma se to upravo koristi kao inicirazacijuni vektor i svi uređe koji imaju implementiran taj software će imati upravo ove vrednosti inicirazacijunih bafere. Zašto su određene te vrednosti? Pa one su određene zato da to deluje kao neka vrednost koja je slučena, a opet ima neki smisl u tim vrednostima, znači datu je neko matematičkoga šnjena, znači nije neko lupio, jer postoje kod desa algoritmo, uvek je postojeva neka vrsta teorija zavere, ili možda stvarne zavere, da oni S-boxovi, da njihova struktura ima je takva da je neko napravio mogućno s da na osnugu strukture tih S-boxova možda može da izvrši nekom prečicom deshifrovanje same poduke. Ovde su stavljene prosto vrednosti koje su deluju kao slučena, a zapravo su dobijene nekim sistemom i to je to, dakle, taj inicirazacijen ivektor. Znači to je ono što sa jedne strane ulazi u taj block F. Sa druge strane sama poruka M, odnosno taj block M, to je ovdje, taj block M će biti rasparčavu nekih 80 delova koji se zovu dugleve i videt ćemo kako se to rasparčavu tih 80 delova. I kao što možete da vidite izračunavanje jednog bloka podrazumeva ponavljanje ovih 80 operacija koja se zovu runde. Znači u svakove ovih rundi se izvrši i ista operacija, videt ćemo i na narodnom slajdu, a ulazi u te runde su delovi poruke koji su na poseba način napravljeni, to su ovde dubleve delovi i plus ovdje k vrednosti kojih ima isto 80. E sad šta su te k vrednosti, odnosno kakostante? Kakostante su opet nekih vrednosti koje su predefinisane samim algoritma. Konkretno u okviru SH2 algoritma izabrono je da su kakostante decimalni delovi trećih kore na prvih 80 prostih brojeva. Znači opet nasliča na način kao ove vrednosti od A do H. Nađeno je nekih matematičkih model koji će dati neke relativno slučajne brojeve, a to su decimalni delovi trećih kore na prvih 80 prostih brojeva. Kao što možete vidite, već ovde u okviru izračunavanje HESHA jednog bloka imate nešto što se ponavlja 80 put. Što znači da postoji potreba da se, da procesor bude zaposlen, da bi izračunila ova ka HESHA. Znači nije nešto što se izračunila u 3-4 procesorske operacije, već je potrebno da on to malo bućka i to je uprovo zbog čega izračunavanje HESHA-va u okviru potvrde nekih transakcija u okviru bitkovem blockchaina od uzima vreme i energiju i na kraju istrujima. Dobro, to su te kakom stante. Ovo svakako morate da naučite za Kolokvijom, jer ćemo vas pitati. A onda imate ovde kako izgleda i jedna ta rund, odnosno iteracija. Narao ne, ja sam se šalio za ovaj kakom stante. Narao, onda ne morate da učite to, to niko normalan. Ne znam na pomet, na razkljuve u situaciji ako on treba da vi napraviti implementaciju HESHA-va alborit, ono da ćete pripisati to iz odgorećih standarda i narao ne, neće nikutom učiti na. E dobro, što ste ti če ove jedne runde, u njoj se dešava svašta, dakle u njoj imate poče od nekih trivjalnih operacija kao što su operacije transpozicije neku bloka. Recimo, ovaj C blok će u narednoj rundi biti D blok, način otičićiće za jednomestu deslo. Onda ćemo kod u nekim situacijama imati sabiranje po modulu 1264, sa ovim ovde, recimo, K vrednostima i sa W vrednostima. Imaćemo neke logičke operacije kao što je operacija majorizacije, koja uzima nekoliko tih ulasnih blokova u obzir. Kao što imate nekih rotacije, dakle to su operacije, recimo, o koja lici na ono što se dešava u simetričnim algoritmim enkrepsije. Imaćemo neku vrstu transpozicije i neku vrstu su učpitucije bita u okviru svake ove runde. I onda se ovo što ovdje vidite ponavlja 80 puta za jedan blok. Imaćemo 1 puta 80 puta ponovljenu ovu operaciju u jednoj rundi. I na kraju, ono što sam rektuvao isto, sama poruka se rasparča u te W vrednosti, ovde možete da vidite na koji način. Prvih 15 W vrednosti je dobijeno tako što se sam blok podeli, izvijen se prvih 16 vrednosti, tako što se blok podeli na 16 delovot, u odpoštosti 64 bita. A onda preostali ih do 80 vrednosti se dobija različnim kombinacijama. Znači koristiti se opet ovde neke operacije rotiranja samih vrednosti, pa onda eksluzivno ili od njih. Teko našto je pojenta svega ove. To je da u svaku umulazu, u svaku i rundi, ćemo dobiti to da je na kraju izluzni hash, neka funcija svakog bita originoj poloci. To je ono što hash funcija treba da ispuni. Ona treba da ispuni to da ako se promeni 1 bit u originoj poloci, te će ta 1 bit izazvat i promenu većeg broja bita u samu hash. Naravno ne svih bita, jer bi onda bilo trivijono pronaći drugu poruku, koje će dati nekodređenu vrstu hasha, ali po nekom nasumječnom slučajnom izboru će neki biti biti promenjeni, ako se promeni 1 bit u originoj poloci. I sad kada sam vam ovo pokazal, mislim da vam je iz ovoga svega jasno zašto ne možemo ni da vas pitamo, kako funcijao niše s algoritem, zato što bi bilo potpunu slu, da vas seremo da učite ovo na pomet, jer prosto previše ima detalja i nema ni neke srhe. Više je ovo da svatite koje je svoj to operacije i kao da svatite da tu postoji kompleksnostu izračunavanju ovih hash funcije. I iz istog tog razloga, znači postoji opis sh3, ali smo ni odlučili da vam ne ispričamo, kako funkcioniše sh3, zato što je to opet jedan algoritem koji je sličeno ovom, je dosta kompleksan i oduze obi dosta vremena, a suština je tri ljudično slična. E ono što hoću da vam pokažem u okviru ovog predavanja, to je jedan primer koji bi trebalo da vas uveri kako funkcioniše sama, sam sh2 algoriti. Ovde imamo jednu prostu poruku, to je ova poruka ABC, koja, to su tri slova, imamo tri slova koja šadjemo, ta tri slova ako predstavimo kao aski vrednosti, to su aski vrednosti 61, 62 i 63 hexadecimalno, ovo je originalna poruka prikazana u binarnom obriku. Šta smo onda rekli, ta poruka je svega 24 bita, ona mora da se dotera makar do viličine jednog bloka kojima 1024 bita i ono što mora da se uradi, to je da se naravno upiša ovo polje l i ovde imate 18 hexadecimalno, to je 24, znači to je dužina same poruke, to je dužina onoga što je koristnj ideo te poruke. I ovde imate odavde, pana dalje, ovde bi smo naravno mogli izračunove, ja sam ne znam tačno, da je gračno, da je granica, ja ću lupiti, ja nemojte da zamirite ako nije tačno, da ovo predstavlja ove leng, polje za dužinu, a sa druge strane ovo ovde je ostalo što vidjeti, to je ove peding koji ima prvi bit setova na 1 i si je ostalicu biti nula. E onda kada se ovako prosta poruka koja ima svega 3 slova, ubaci u SH algoritem, dobit ćemo ove hash. Naravno, ovaj hash vam ništa ne znači, delo je kao neki nasubični niz heksedecimalnih vrednosti, što je i cilj ovako kaša, ajde samo da zapamtimo ova prva četri slova, ddaf ako počin, zato što ćemo sad imati još jedan hash, da se uporedimo sa ovim štasnom dobiti. Znači prva četri heksedecimale vrednosti su ddaf. U drugom primjelu šta se radi? Zamanili smo poruku, poruka više nije ABC, poruka je sad CBC. CBC ima heksedecimalnu vrednost 63, 62, 63. Znači ovde smo imali 61, ovde heksedecimalna vrednosti bila 1, odnosno bila je 0, 0, 0, 1, a ta heksedecimalna vrednosti sad postala 0, 0, 1, 0. Znači zapravo u origini ovoj poruci, mi smo samo ova jedan bit koji je bio nula, zamanili i on je sad postao 1. Sve ostalo isto, dužina je 24 bita, imamo padding i kada smo uzeli taku poruku i izračunali novih hash, dobilismo novu vrednost hash. Ako si sećete prva četri heksedecimalna broja su bila ddaf i predkodne poruci, sad su p316. Dakle, ova poruka delu je da je različina. I ako bi ste uzeli da ju uporedite sa onom porukom koja je bila malo prej, ono što bi se dobilo, to je da je u ovom novom hashu se promenilo 253 bita. Znači, na promenu jednog bita u samoj poruci, u hashu se promenilo 253 bita. Dakle, to je ono što zove efekat labine. Znači, promena jednog bita utiče na promenu...
 velikog broja bita u dolaznih porusu. Drge strane, sam Hash ima 512 bita, znači nekde oko polovine bita se promenilo, nešto manje od polovine. I to je ono što je dobra osobi na ove funkcije, to je jedan od razluga zašto se ona i dan danas koristi. Dobro, došli smo doprime na hash funkcije, ja ću ovde stati. A sada ćemo videti neke primene hash funkcija, koje su jedna od primena, je klasična primena oblasti zaštite poadataka, a to je kako sačuvati loziki, odnosno kako ih sakriti od onih koji bi želili da ih videa nisu ovlošćeni za tako nešto. Mi smo tnumliki sada nekde na polovini ovog kursa, i sa hash funkcijama ostalo još nešto malo, ali prakličnosti čuli sve osnovne elemente gradivne za pradljenje nekog sistema koji će izvršiti zaštite poadataka. I recimo, ako biste chceli sada razmišlete na koji način da sačuvate loziki koje vam trebaju za uluzak u neki sistem, možda bi vam jedan od načina pao na pamet pa dobro čekljš. Čega treba da zaštiti loziki? Treba da zaštiti mu neko ko hoći da vidi loziki, zato što ako vidi loziku onda može da uđi u sistem. Ako treba da zaštiti to da neko ne može da vidi loziku, to je zaštita privatnosti te poruke, odnosno poverljivosti njene. Ako hoće da sačuvam poverljivost poruke, ja bi trebalo da je šifrojna, odnosno da izvršim enkrypciju. I ako biste probali da razmišleti za treba to dobrođete, onda bi šavito značilo. To znači da ako u nekom sistemu imate skup koristnika čije user name-ove imate i imate dnjihove loziki, ono što biste mogli durođiti, to je da šifrojte takam filu kome se nalaze user name-ove i password-i. I da takam šifrovan filu sačuvate na disku. I to delo je kao dobro pristup, ali u stvari nije. A zašto nije? Pa recimo ako zamišlite situaciju u kojoj sada vi, to je vaša čunar, preko koga mene sada ove slušate, nači to je neki laptop ili desna prečunar koji ima sistem na trimmer windows i na njemu imate možda svoje koristicko ima, ali imate još neko koristicko ime i ako bi na taj račn bio zaštićen taj filu ko mi se nalaze loziki, da onda kada bi unesete user name-ove imate se taj filu od ključa, proveri se, uporedi se vaš user name-ove imate, da je kodgovara ono mešto se nalazi u tom filu, ono vas pušte u sistem. Problem je taj što ako je taj filu šifrovan, onda je taj filu šifrovan nekim ključem. A ako je šifrovan nekim ključem, onda se postoje pitanja gdje je taj ključ. I sada ko zamislim o situaciju koje vi morate da taj računar uključite i onda kada se podigni sistem, kada vam se pojavio, ona je i prompta unesete, je user name-ove pasvord, postoje se pitanja, gdje je taj ključ bio u među vremenu, da bi kada vi unesete user name-ove pasvordi, bili da je šifrovan. Pa on bi morao da bude na disku. I to bi morao da bude na disku u otvornom obliku. I sada ko imate na disku i taj filu koji je šifrovan, ali imate i njegom ključ koji je u otvornom obliku, pa onda se postoje pitanje koje smisao svega tona. Dakle, je šifrovanje lozinke nije način kako se lozinke čuvaju. Ono kako se lozinke čuvaju i to važi i za linux, i za windows sisteme, ma da nisu identični način i kako se čuvaju lozinke o njegi sistemima, je da se ne čuvaju lozinke u otvornom obliku naravno, da se ne čuvaju lozinke u šifrovanom obliku, znači ekriptovanom, već se čuvaju hashavi lozinke. I šta se onda dešava? Znači imamo filove u kojima se čuvaju ki hashavi. Kada bi hodjete da se ulogujete na sistem, bilo preko neku vssh, ili bilo preko koristititastaturu i ulaz u računar, ako ste direktno koristite taj računar. Računar će kada vi unesete vaš username i password, potražiti u baziji username vaš, a uvradiće hash vaše lozinke i uporediće taj hash sa onim hashom koji je u samom file. I naravno to je način kako se broši proverati. Zašto je to dobar način? Pa dobar je način zato što hashavi rektismo da su i reverzibilne funkcije, to je neko iz ovog hasha koji je dobijen, ne može da dobije u nazad lozinku, prosto zato što postoji više razlištih poruk, koje mogu da generišu istih hash. A drugi o druge strane, opet taj hash treba da bude takav da mu nije jednostavno dodođe do takvog poruke koje će generisati ovaj hash. E sad tu postoje neke razliki u tom nekako funkcionišu Windows i Linux. Windows koristi i neku dodatnoj inkriptiji u file-ovo kojima se nalaze lozinke, što znači da ima i neke ključeve koji su otvornom obriku čuvaju na sistemu. Pa pošto je Windows proizvod firme, onda oni ne moraju da objave sve detalje, da se to sve nalazi. Međutim, ono što se u praci desi to je da pošto nekog vremena nakon što izveđe neka nova verziya te Windows i gunnosti, pronađe se način kako se dolazi do tih file-ovo kojima se nalaze hashavi se lozinkarna. I postoje alati koji mogu da izvuku hashavi sa lozinkarima. No dobro, ali da vidimo kako to funkcioniše kod Linux-a, pošto je taj način kako se lozinke čuvaju kod Linux-a potpuno transparentan u pitanju i otvoreni kod. Ako je neko od vas i kada radi ono Linux-u ili ako imate neku virtu na mašinu ili rečunor na koji se nalazi Linux, možete dovedati u ovaj etc folder i da u njemu pronađete file koji se zove Shadow. Taj file kada se možete da ga pročitate, to je file koji je tekstulni, znači nije ništa šifrovan u njemu i u njemu se nalaze ulazi kao što je ovaj ovde koji je uokvirim. Znači ovo ovde što vidite, to je jedan red u tom Shadow file-u. Taj red u Shadow file opisuje lozinku za koristnike koji se zove pair. Tu ima nekoliko stvari koji se odznačaja. Ovo ovde plavo što vidite, ovaj najdužji deo, to je hash lozinke. To je hash koji je urađeno osnovu algoritma broj 6, algoritm broj 6 je ovde definisan, algoritm broj 6 je sh520. Zado ono što je specificno za Linux, to je da Linux ima još jedan deo koji se zove SaltPiSol i ono što se uokviru Linux-a računa, to je slajeće stvar. Naravno, pusto je islazite hash funcije ovde hash koji vidimo koji je plaveno boje, a ulaz u hash funciju su dve stvari. Jedna stvari je password, a druga stvari je salt, odnosno Sol. Jedina je razvika u odlusu na ovu što sam malo prispriča, ono što biste očekivali, to je da se računa hash od passworda, a u stvari se računa hash od passworda plus sal. E sad zašto je doda tove Salt, Salt je slučajna vrednost koja se dobija svaki put kada recimo uradite komandu kojem hoćete tromenite loziku, sistem će u tom trenutku odrediti neku nasunimčnu vrednost, to će biti Salt, ono će biti upisana ovde u ovaj file, kako bi moglo da se izvrši provera hasha, i to je način kako radi Linux. E sad zašto je uveden Salt, uvedenje zbog jedne vrste napada koji se zove rainbow napadi, rainbow napad podrazumeva da postoje već file i postoje baze sa hashavima razno raznih lozinki koje se standardno koriste. E sad kako su te baze napravljene, to su baze koje mogu da budu ogromne, oni mogu da imaju više gigabajta različitih lozinki, pa prosto ono što se dešava srema na vremi i što ste čuli da se dešava, to je da u mnogim sistemima budu provaljeni account i da hackeri dođu do user name-ovoj password, i ne samo to, nego te user name-ovoj password je objave negde. E sad kada se to objavi negde, onda sa druge strane neko pokupi sve te lozinke i neko uzme izračuno hashavac i tih lozinki, i onda kada dođe do ovako nekog filea, onda bi prosto po ređenjem hasha i premaloženjem hasha u nekom takom file sa hashavima, mogao da dođe do toga koji je password. E da bi se ta vrsta napada u kome postoje već pripremljeni hashavi otežala, uvedenje ovaj salt kao jedna dodatna nasunicom rednost, zato što kada postoje ovaj salt, onda se mi računa hash samo od lozinke, nego se računa hash od lozinke plus salt, i sada bi neko da bi mogu da napravi rainbow napad morao praklično da napravi takve tabele, rainbow tabele za svaku pojedinačnu salt rednost, na takih salt rednosti ima dosta, i to je nešto što se smatra da je nepraklično i teško. Za raznik od linuksa Windows nema taj sistem salt, ali kao što sam rekao Windows ima neke mehanizme, mehanizme enkriptije koji se koristite u zaštiti lozinke, tek u glavnom ono što je dobra praksa, to je da ne koristite na više sisteme i ste lozinke, zato što ako i posebno da ne koristite one lozinke, ako je na nekom sistemu koji ste koristili, bila provadjena lozinka, na primer nedrono je bilo objeđeno s nekih podaci sa Facebooka, bili provadjeni, između ostalo bi brojevi telefona i imeladresa i takve stvari. Ne znam da li su i lozinke, ako su i lozinke, onda ako je takvam sistem provadjen, onda to znači da će je vaša lozinka kako god da je inventivna i da ste smislili, biti u nekom takvom, u nekom takvom rejmbu.
 zato što se one popunjavoj na taj način. Dakle, jedna od klasičnih primena hash functija je da se koriste za čuvanje lozinki, ne čuvaju se same lozinke, nego se čuvaju hash-evi. Druga interesantna primena je nešto se zove hash-kesh i to je sistem koji je osmišljen tokom 90-i godina prošlog veka, znači pre nekih skoro 30 godina, kada se prvi put pojavio spam mail. Spam mail je neželjeni mail, mail koji niste hteli, mail koji je često možete dobijete i neke phishing poruke, možete dobijete i neke reklame kojvom ne trebaju. Spam obično funkcioniše tako što ti spameri nađu neki mail server koji nije dobro zaštićen, nađu neki domen sa koga kreću da generišu mailove i ono što je njima cilj ako je pitanju, napr. neka phishing kampanji ili u pitanju neka reklamna kampanja, to je da pošli u što je mogući veći broje mailu. Da pošli u stotini hiljada mailova i oni opet koriste bazi mailova iz ovih baza koje budu provaljeni, znači ako je provaljeno 160 miliona accounta na Facebooku, to znači za njih 160 miliona različstvih email adresa, koji onda oni mogu da iskoriste za slanje svojih poruka kakve god bila. I to je njima jako zgodno zako što mi znajo da su to žive imeva adrese koji ljudi zapravo i koriste. Ja onda su ljudi razmišljili kako da se bore proti spam, znači, proti te situacije da neko šalje ogromne koričine mailova sa određenova mail servera, ismistili svoj ovaj sistem koji se zove hash-cash. Eksam kako radi sistem koji se zove hash-cash? On radi tako što, ajde samo još i jedan kora ko nazod, ono što bi takođe trebalo da znate, to je da mailovi pored onog tela maila koji se napisali imaju neki svoj header. U tom headeru se nalaze ona polja kao što su to, from, subject, znači sve ono što znate i nalaze se još neki detalji, ako je neko od vas gledao malo one detaljne opcije u mailu koji dobijete, možete da vidite kroz koje mail server je prošao mail i tako da, i tako da. Znači, postoji taj header u kome se nalazi tehnika informacija o tome koje potrebna mail serverima da bi taj mail prosledili do odgola reće destinacije. E sad, kada imamo header od maila, onda na to dodamo još jednu vrednost koje se zove x-cash-cash i od toga se izraču na hash. Sam sistem hash-cash funkcioniše tako, da treba da se pronođe takva vrednost ovog hash-casha, da ovaj izračunati hash bude manji od neke vrednosti. Recimo, ako se koristi ona istari algoritm, to je u vreme kada je nastavno hash-cash koristit, se ona je origino na sha sa 160 bita, ono što može da si kaže, da to je da, hoćemo da dobijemo takav hash da je manji od 1240. 1240 je broj koji ima 20 podjećih nula, ako sam hash ima 160 bita. To znači da ovo vrednost hash treba da počne sa nizom nekih nula, kojih treba da bude ono liku, koji je određeno ovim n, a da posto ga imamo nešto. E sad, znači, mi hoćemo da dobijemo hash vrednosti, koje imaju tačno određeni ovom, pošto je prostor dozvoljenih vrednosti hash'a, koji se dobije hash-cash' sistemom, 2x20 puta manji od ukuplnu prostora svih hash vrednosti, to znači da će ono me ko formira ovakav mail, biti potrebno da iterira nekde, ajda, kažem u prosiku, 2x10 puta, da bi došao do takvih hash-cash vrednosti, koje će dati odgovarajići format hash. A što to u stvari znači? To znači da kad neko šalje mail, ono mora da uzme i da zaposti svoj procesor, da uradi 2x10 računanja hash'a, kako bi pronasa ovaku hash-cash vrednost, koje će dati odgovarajići format hash'a. To troši procesarsko vrene. Međutima, ako bi šaljete 1 mail, mi pričete sa nekim, komunicirate sa nekim svom prijateljem, imate postavnu prispondensiju i pošeljete 1 mail koji koristi ove hash-cash, za vas nije to nikakal problem. A sa druge strane, ako imate nekog spamera, koji treba da pošelja 100.000 mailova, i za svaki u tih mailova mora da izraču na posebom hash-cash, zato što su headeri različiti, e za njega će to biti problem, on neće imati procesorsku snagu, to odgovarajte. Ovakav sistem se zove proof of work, i on zapravo znači da mi predpostavljamo, da u to mailu nema spama, zato što je neku uložio napor, uložio određenji rad, kako bi dokaze o da taj mail nije spam. Sa druge strane, ona i spamer, on nema vremena da proši svoj proti, ili nema tako proti snagu, da može da određi sve te hash-cash rednosti, da bi mailu mi bili valiti. Što znači da je mail validn? To znači da on je koji dobije mail, ako u to mailu postoje ova hash-cash rednost, on će izračunati ova isti hash od hedera i hash-casha, i ako dobije vrednost hasha koja je takva da počinja se 20 vodećih nula, on će onda verovati da takav mail nije spam, da je to legitima mail. Znači provjera maila je brza, a se druge strane, ono što je, da je prebačen teret, to je na ono da koji šalje taj mail. E sad zašto ja vam priča u ovom sistemu za borbu proti spama, koji se danas zapravo i ne koristi, danas postoje neki sofisticirani i načini, i tako može da se odredi dadije neki mail spam, i postoje razno razne blackliste domena sa koji stiže spamowi, i blackliste mail servera i tako dadje, tako dadje, dakle ta borba je otišao dosta napred. Pa prosto ovaj proof of work sistem, oni od vas koji su se interesuvali malo za to kako radi bitcoin, su sigurno najši na ovom. I upravo ove sistem, hash-cash system, je nešto što je iskorišćeno u okru bitcoinu, da se i to je zapravo uzrok tog majnovanja, da bi se potvrdio jedan od donih blokova, treba da se pronađe jedno ovako vreć. Ali dobro, tu pričo bit kojenu ćemo ostaviti za kraje ovog kursa, onda ću vam povezati sve to i ove hash-cash system, kako funkcioniše i ono što je sledeća stvar u okru ove konkretne prezentacije. Za sad neka ostane ovo ovako, nadam se da je sam koncipt hash-casha jasn, i da je jasno što je tu ono što je teško, a to je da ono i koji šalje mail, koji treba da dokaše svojim radom, da je legit iman učistnik u ove komunikaciji, on treba da iterira kroz ove razne-razne vrednosti tog hash-casha, kako bi dobio izračunuti hash koji ima određeni oblik. Još jedna interesantna primjena hash-casha je nešto što se zove merkle ovo sablo, koji osmislio, opek, taj više puta pomiljenju, njegravljost merkle, on je ovo sablo i patentiralo, ovo je ovo patentiralo, kada je negde pre 15 godino, tako da merkle ovo sablo može da se koristi bez ik problema, i ovo je isto jedna struktura, koja se koristi u okviru Bitcoin blockchaina, pa sada ćemo da vidimo šta je. S tam način formiranja merkle ovoho sablo je prost, znači merkle ovo sablo je binor o sablo hash-casha. I sad obdećemo da predpostavimo da ovde imamo neku bazu, u kojom je postoji ovih osam transakcija, osam nekakvih zapisa. Merkle ovo sablo se koristi, dakle, kod potvrđivanja Bitcoin transakcija, pa ovaj ovde teovi od te 1 do te 8 mogu da budu pojedinačne transakcije, ali o tom potom kad budu vam pričuli o Bitcoinu. Ovde teovi mogu da budu, naprimer, delovi nekog filma koji se skida sa nekog peer-to-peer sistema, da je svaki od tih delova obeležen nekim brojem i treba potvrditi autenticno svakog od tih delova, kako bi se na kraju sklopila jedna celina koja čini taj film. Imamo više nekih delova, više nekih elemenata, kojima treba potvrditi da njihova vrednost nije izmeni. I sad ono što se, kako se formira to, binarom stablo, za svaki od elemenata se izračunavaju posjednih heševi, od te 1 preku te 2 do te 8, za svaki od njih pojedinačno se izračuna heš, a onda se formira binarom stablo tako što se objedini izračuna heš od prva 2 heša. Ne heš samih transakcija te 1 i te 2, nego ove heš te 1, 2, on predstavlja heš od ove 2 heš vrednosti. Pa heš te 3, 4 predstavlja heš od ove ove 2 heš vrednosti i tako dalje, i tako dalje. A onda koristići tu istu logiku, imamo ove heš 1, 2, 3, 4, koji predstavlja heš od ove ove 2 heš vrednosti, i na kraju, na vrhu teh hierarchije, dobijemo jedan heš koji se zove Merklevo Koren, Merkle Rud, koji predstavlja heš ove ove 2 heš vrednosti. I sad ja verujem da je sam način formiranja Merklevo kstavla jasan, dakle tu nema neke mudrosti, i ono što je možda interesant nije, to je čemu ovo služi i kako se koristi. Znači zašto bii neko ovo napravio, pa čak i patentirav kao interesantnu strukturu podataka. Pa ono što postoji kao problem, to je kako potvrditi, recimo, da se neka transakcija desila. Znači Bitcoin block chain predstavlja nijakih zapisa o transakcijama koji se desi. Pera platio Miki 2 bitcojna, Mika platio željku 0,01 bitcojna i tako dalje, tako dalje. Znači svakada transakcija je poseban zapis, koji mora da bude nekako verificovan u okru blockchain. I svakada transakcija ima svoj poseban hash.
 Ako bi smo hteli da u okviru potvrde jednog bloka sačuvamo heševe svih transakcija, to bi značilo da treba da ako tih transakcija ima 5.000, da imamo 5.000 heševa. I onda bi taj blok bio veliki i onda bi porasli bi režiski troškov i začuvanje svih blokov, u kome bi smo svakvu transakciju posebno zaštitili nekim hešom. Umec do toga, ono što se u okviru svakog bloka, u što postoje u okviru svakog bloka, to je ovo merkle, ovo stabil. Izvinjam se, znači, koren merkle ovog stabila. Znači, to je ono što se čuvu u okviru samog bloka. Ne čuvaju se heševi pojedinočnih transakcija, nego se čuva koren stabila koji izveden iz heševa pojedinočnih transakcija. I to je ok, znači, manje prostora smo za uz. Z drugej strane, ako sad neko posunje da se desila neka transakcija, recimo, neko posunja da ovo ovde transakcija se desila ili da je bila baš tako u miznesu, na koji način će on moći da proveri, da li je ta transakcija bila, da li se ona zaista desi? Naravno, on može da izračuna hešo t4, a onda, ono što treba da mu se pošalje hešo t3, hešo t1, 2 i hešo p7, 7, 8, kako bi on moga ove rekonstruiše? Ovu vrednost i na kraju merklerut. E, što je zgodno i ono zašto se zapravo najviši koristi o merkleru o stabila, to je potvrda određene transakcije, zato što je za potvrda određene transakcije, potrebno poslati relativno malo u količinu informacije, znači potrebno je nešto što je srazveno sa logaritam od broja transakcija poslati, kako bi nekog mogu da izraši potvrdu transakcija. Moglibi ste da smislite recimo najvnu metodu i kažete, ok, razumem zašto koću da se koristi merkleru ovo stabila, odnosno zašto je potrebno da se čuva samo jedan heš u neku bloku, u blockchainu, to je zato što, koćemo da malo mesta zaozumim o tom potiru. Ja neću da izračunom ovom celo ovo stabila, delojam i prekomplikovanu, nego ću ja ovo izračunati ovo ovde vrednost kao heš od svih pojedinačnih vrednosti transakcija. Znači uzmem izračunom ove heši 1, 2, 3, 4 do 8 kao heš od ovih 8 hešel. I to jeste jednostavniji način da se izračunom merkleru, koren merkleru ovoj stabila, međutim posle, ako koću da potvrdim ovo transakciju tj. 4, da se ona zaista desila, ja ću izračunati heš o tj. 4, ali onda neko mora da mi pošalje svih ostalih n-1 transakcija, odnosno heševe svih ostalih n-1 transakcija, kako bih ja izvršio prover. Loverita modern je manje od n-1 i to je razlog zašto se koristi merkleru o stabila. Dobro, to su neke interesantne primene heš funkcija, koja je vratićemo se kao što rekao, ješ jednom na ove db poslanje primene, način, na heš-keš i na merkleru ovo stabila. Naravno, na merkleru ovo stabila imaju širu primenu, ali mi ćemo je konkretno vezati za to, kako radi i kako funkcioniše bitcoim blockchain. Ovim smo završili ta ideo koji se odnosi na heš funkcije, a sada nam ostaje da se pozabavimo i jednom, vrlo srodnom vrstom funkcija, to su tako zvanim message authentication kodowi, odnosno MAC funkcije, odnosno kodowi za autentikaciju port. Ove funkcije su veoma slipšnih heš funkcijama, način, oni imaju neke zajedničke osobine, ja ću sada ovde nacrtiati kako izgleda ta funkcija, pa ću prostvoda vam malo objasnim šta su MAC funkcije, ali onda ćemo, tokom ovog preostalog vreme na danas i naravno, tokom naravno časa da vidimo konkretne message authentication kodove kako funkcioniše. Isto kao i heš funkcije, message authentication kodove primaju kao ulaz neke poruke koje mogu da budu, da budu proizvojne velečine. Slično kao i heš funkcije, message authentication kodove formiraju neki message digest ili neki message fingerprint, neki podpis otisak prsta ili kako budu hoćete, ili bošte čak da ga zovete i heš. Formiraju nešto što je fiksne veličine, ima tačno određeni broji bita, što predstavlja oznaku da tako kažem ove poruke, način direktne proizlze iz ove poruke. I sada ako ja ovo predstavimo ovako, vi onda kažete pa koje je to razlik između message authentication kodove i heš. E pa razlik je u tome što pustuje još jedan ulaz, a ta je ulaz u message authentication kodove i ovde, i to je ključ. To je simetrični ključ koji se koristi koja dovi funkcija. Znači zapravo ove message authentication kodove mošte da doživite čak i kao neku vrstu heša sa ključem, jer način funkcije onisanje je prilično sličen. I to smo na prehlednom času, ako se sečete kada smo razmatrali kako se koriste heš funkcije, onda smo pokazali neke šeme u kojima hodjimo da potvrdimo autenticno sporuke, ali pritom da ne budemo žrtva meni da videl napada u kome će na padaž da promeni i sadržaj poruke, i sadržaj heša. Pa smo onda videli one šeme u kojima se uradi heš, pa se onda sve to šifruje, ali smo videli one šeme u kojima kosto je neka taj na vrednost, koja se konkatenira na vrednost poruke kao ona i salt, koji smo malo prevideli, pa se onda izračunova heš. Prime na ovih message authentication hodove je veoma slično i koristi se baš u tim situacijom. I sad ćemo danas malo da započnemo u priču, pa ćemo stati negde na pola puta da vidimo čemu služe message authentication hodove. Kao što reko, mi smo došli prakđično tu negde do polovinja ovo kurse i gotovo smo sve ove ostovne teoristike koncepte, koji se odnose na zaštitu podataka završili. Dakle, videli smo da odkrivanje, sadržaja poruke možemo da rešimo time što ćemo poruku šifrovati. To isto možemo da, pomoću šifrovanje, možemo da sprečimo ovu neku analizu komunikacije, dedin neku analizirav ko'o skim komunicirav, ako se šifrujuju, recimo, IP address'e. Esad postoje neke druge prime, nekoje ne može da reši obično šifrovanje, a to su, to je lažno predstavljenje nje nam reži, to je izmena sadržaja, neke poruke, to je izmena redase da poruka, to je promena vremena kada je nastavno neki dokument. Ove ovde stvari mogu da se reše i pomoćnji alati za rešavanje ovih zakteva i ovih problema su hash funkcije i message authentication kodove. Znači, to je ono če imaćemo se sad da baviti. Ono što message authentication kodove ne mogu da reše, to su ove poslednje dve stvari, poricenje slanje i poricenje prijeva. Ja sam vam rekao malo pre, a to ćemo vidjeti kada bude moratili konkrete še me da message authentication kodove imaju ključ i podrazumeva se da kada se štiti neka poruka da je to simetričan ključ koji postoji na dve strane. Samim tim ako postoji ključ koji postoji na dve strane ne može da se garantuje, odnosno ne može da se spreći poricenje slanja, zato što ako bi neko napravio message authentication kod neke poruke sa takvim ključem, on bi uvek mogao da porekne da je poslao takvu poruku, zato što postoji drugi antitet koji posleduje ta isti ključ i može da gineriši isti takav kod. Ove dve poslednje stvari, znači poricenje slanje i poricenje prijeva, su nešto što se rešava tako zvanim digitalnim podpisima. Digitalnim podpisima ćemo se baviti na narjedne nedelje, na narjedno predavanje kada budemo završili ovu priču o message authentication kodove. No dobra, e sad kako može da se izvrši provera autenticnosti poruke? Znači jedna od načina je hash funcija, ali videli smo da hash funcija sama to ne može da uradi, nego hash funcija mora da bude ukombinovan sa nekim drugim mehanizmem kao što je inkripsija. I takođe videlićemo, dokom ovo pridavanje, da se jednosti hash funcije, a druga stvar su message authentication kodove. Znači to je što treba da uradi, nismo je šuvepis priča. Autenticacija poruka može da se izvrši i šifrovanjem poruke, ali to nije kako bih rekao direktno zaštite autenticnosti poruke. Već šifrovanjem poruke implicitno možemo da zakvićemo da neka poruka nije imeta. I sad ćemo da vidimo, i sad ćemo malo da prudiskutujemo što to znači zaštititi integritet poruke, odnosno autenticnost poruke, zaštititi šifrovanjem. Ovde imamo na ovom slajdu, imamo četiri različite šeme koje smo veći videli, o kojima sam već pričao. Dakle, imamo šemu sa simetričnim šifrovanjem, da imamo dva istrpliča. Pa imamo šemu sa simetričnim šifrovanjem, da se šifruje javnim pljučem, a da je šifruje privatnim, pa šemu sa simetričnim, da se šifruje privatnim, a, da je šifruje javnim pljučem, i na kraju šemu da imamo duplo šifrovanje i asimetričnim javnim pljučem, to smo već disputovali čemu služi svakod ovih šema, ja to neću ponaviti. E sad, kako je veze ovo ima? Znači, ovo sam vam priča u kontekstu zašlite povedljivosti poruke, znači želim da sakrijemo sadržaj poruke, ili kada želim da proverimo od koga je stigla neka poruka, tisatko dovih asimetričnih, imamo razlište variante, kakve ovo je veze ima sa zašlite malutentiršnjosti poruke?
 Pa ima implicitno. Znači, jevo ovako. Zna, kuzmimo ovu poruku M i ta izvor A je šifrovalo poruku M nekim ključem K. Ono što će se ovde dobiti, to je šifrovani tekst te poruke. Ako bi nekod ošao i probao da zamjeni jedan deo te poruke doko ona putuje internetom, ako bi takva poruka stigla do destinacije i ako bi se ovde vršilo desifrovanje, što bi se dobilo? Dobilo bi se poruka koja je cela ili makaru, zavisi naravno od moda šifrovanja koja je cela ili makaru u nekom delu liše neće biti i ista. Znači, poruka će delimićno imati smisli. Pa sad ako je pitanju poruka koja je pisana nekim prirodnim jezikom, onda one koja je dobio ovu poruku će možda moći da počita njen početak, a onda ću jednog trenutku dobiti nijakih bluposti, znači nečega što liše nije tekst. Šta on može da zaključi? Ako je dobio taku poruku, on može da zaključi da je neko probao da izmeni sadržete poruki, jer teško da može da se desi da je poruka delimićno priptovanja pravim ključem, a onda kasnije nije priptovanja pravim ključem. Znači, ako dobijemo tekst koji je šifrovan i koji poslede šifrovanja ili nema smisla uopšte, ili delimićno ima smisla, to može da bude indikacija da je došao do promena sadržaja poruke. E sad, to je tačno i zaista šifrovanje može da se koristi za implement proverv, autentićnosti poruke, međutim, ako malo bolje raznislite kako biste vica to technički izveli i kako biste vi, recimo, automatizuvali detekciju toga da je došla do promene poruke, onda ćeš da schvatite da to uopšte nije jednostavno, zato što ako je u pitanju poruka koja pisa na prirodnim jaziku i recimo neko se poigra i promene samo krajte šifrovanje poruke, je danal ideo. Ono što bi trebalo da vi urodite na dolazni strani, a naravno, hoćete da imate automatizovanu provedu, ne da dolazi da mora neko tamo da čitatu poruku pa da on klikne ručno, da li je poruka prava i di nije, zato što je to sporo, vi imate računare, hoćete da urodite brzo. U takvih situaciji vi trebalo da imate na dolazni strani neki software koji će prepoznati da je u pitanju prirodu jaziku, ću prepoznati da je u pitanju englijski jazik, napim, da je ili srpski jazik. Takvi softwarei nisu savršim, oni naravno da postoje, ali je, znači, implementirati, instalirati takav software samo zato da bi su provjerili autenticno poruke prosto neracionan. U nekim situacijama je relativno lako to provjeriti. Recimo, ako poruka koja se šalje ima neku jasno odrećenu struktur, naprimer mi znamo da dobijamo zip file. Taj zip file na početku ima tačno odrećenu strukturu, on počinje, ne znam, sa pk slovima, pa ima neko zaglavlje koje ima odrećenu formu. Znači ako znamo da dobijamo zip file i ako na dolazni strani pročitamo na početku da je u pitanju taj zip file, onda možemo da zakličimo da ta poruka verovatno nije menja. Mada kao što sam rekao, može da se desi da neko u prenu su promeni zadnji deo poruke, ako se koristi blokovski algoritam, tak i ako se koristi oneg cifret block chaining, početni delovi te poruke će biti uredni. Tako da način provere autenticnosti poruke koje šifrova nam postoji, ali je težak i nije trivjela. I upravo iz tog razloga su djudi razbišali i zaključili da bi trebalo da postoji posledna vrsta funkcija koja će izvršiti prover autenticnosti poruke. Esad prva situacija u kojoj imate tu provere autenticnosti poruke to je nešto što ste radili u okiru mreža 1 ako se sećete. U okiru tog predmjeta, recimo u okiru eternih zaglavlja je postojeva no nešto što se zove frame check sequence. I to je bilo polje u koji je upisan određena vrednost koja je funkcija svih bita u tom eternih frame. Pa ako se promenje neki bit prilikom prenosu u eternih frameu i ako se izračuna frame check sequence na dolazne strani i ako se ne poklopi sa tom frame check sequence vrednošću, onda znači da je frame meni. Stvarno u okiru ip zaglavlja postoji polje koje se zove header checksum koja je izračuna i koja je funkcija svih bita u headeru ip zaglavlja i on služi za ispustvar a to je da se izvrši provera toga da je ip zaglavlje usput meni. Znači taj koncept nije nov, on je postojeva, jedino što ti algoritmi koji se se poristili za frame check sequence i provju u internet headera nisu kryptografski algoritm, dakle nemajte u vrstu kryptografske sigurnosti. Šta ideja sa frame check sequence? Ove imate dve variante kako može da se izvrši frame check sequence. Prva varianta je da se uradi tzv. interna provera greške, a to je da se uzme poruka da se izračuna taj neki finger print te poruke da se oni konkateniraju i da se ovde izvrši enkrypcija. E sada, ono što može da se desi, to je da neko ovde zameni deo poruke, pa sada dal će to imati smisla ili neće imati smisla, može neko prosto da želi tako da vas maltretirati, tako što će da menja poruki koje šadljete između dve entiteta. Na dolazni strani što će da se desi? Prvo će se poruka desifrovati, onda će od toga šta je desifrovano da se izvuče zadnji deo koji prestala frame check sequence, u odnosno na prvi del poruke će izračunati frame check sequence i te dve uredno će se uporaditi. Naravno ako je neko menja o neki deo, ono što će se desiti, to je da ove dve, ova dva finger print neće odgovarati jedan drugom i vi možete zakučiti da je poruka menjena. E sada ova interna provera greške nije racionalna, zato što ćete prover u toga, da se uredno menjao poruku i zvršiti nakon što ste izvršili dekrypciju. Podrazulno je se da je dekrypcija nešto što je procesvarski intensivnije u odnosnu na samu provero frame check sequence, dakle nešto što duže traje, a to znači da zapravo ćete potrošiti neko procesorsko vreme da biste te kodda sa žaljenjem u konstatovali kako je ta poruka menja. Pa su onda ljudi smisledili i ovo drugu variantu koja se zove eksterna provera greške, znači da je se poruka prvo šifruje pa se onda izraču na njej frame check sequence. E sada neko može da i onda se takvo nešto pošeli. E sada neko može da kaže pa dobro, ali neko bi ove sistem mogao da napadne tako što će da napravi drugu poruku koja će generisati takav frame check sequence i ovde će kada se uradi komparacija zaključiti da je poruka u redu, a onda će se ovde izvršiti deshifrovanje poruk i dobit će se neka poruka M1 koja ne odgovara o noj prvobitnoj porici. Tako da nije dan i drugi sistem niso savršeni i u sva koji postoji mogućnost ga neko izvrši neku vrstu denial of service napada da će trošiti vaše resurse i da ćete vi država vršiti deshifrovanje ovih poruka, a da sama poruka neće imati smisla. I onda su ljudi razmišlili kako da se sve ovo reši i došli do tih message authentication kodowa koji imaju pljuš. Pa ćemo vidjeti kako to može da se koristiti. Što se tiče same analize asimetričnom šifrovanja, tu rema ništa nova u odnusu na šifrovanje. Dakle ono što sam rekao, pravo rešenje za proveru autenticnosti poruke su ako zvanim message authentication kodowi i ovde imate različite variante kako message authentication kodowi mogu da se koriste. Imate prvu varijantu, to je ovo ovde, gde postoji poruka koja se šalje u otvorenom obliku, znači ovde nema šifrovanja poruke, ide se za tu poruku izraču na message authentication kod. Znači, kao što smo rekli, da bi se izračun o message authentication kod, jedan ulaz je sama poruka, a drugi ulaz je ključ i taj ključ mora da postoji sa obje strane, dakle to je simetrični ključ. Ono što se prenosi prekomrežit, to je poruka u otvorenom obliku plus taj message authentication kod koji izraču. E sada ako bi nekoh teva da primeni ono što smo videli pod hash funcija, a to je da promeni i poruku, i message authentication kod, ono to ne bi mogalo da urodi, zato što ne poseduju ovaj ključ, a opet za druge strane njemu treba da bude teško, u onom kryptografskom smislu teško, da ako ima određenu poruku da generiše drugu poruku koje će čak i kada ne zna ključ dati isti message authentication kod. Ono da imamo drugu variantu koji istakao prva, jedini dodatak je da je dodatni ključ kako bi se poruka šifrovala, pa se na ovaj način štiti i autenticno sporuke i njena poverljivost. I imamo treću variantu da se poruka prva šifruje, pa se onda izračuna message authentication kod, da smo opet zaštitili i autenticno sporuke i njenu poverljivost, jedinu što je promeljen redo sled šifrovanja cele poruke i message authentication koda, gde ovde u ovaj donješem, ovo donješemo nam omogućeva da prvo izvršimo prover u message authentication koda, pa da onda kažemo, e ako je ovo u redu, onda mogu da izračunam, mogu da vršim desifrovanje, zato što smatra da ta poruka verovatno nije meni. Ali opet tu stoji ove drugi problema, to je da
 bi eventun u akto situacije neko, ali opet mora bi da poznaje ključ za message authentication pod, mogao da probada promeni i poruku i message authentication pod, z tim, što opet njemu treba da bude teško, da u neznanju do tog ključa ka je jedan koji se koriste za proviru message authentication poda, da dođe do takog framework sequence koji će odgovarati ovoj promenjenu i porusi. I zapravo ova treća šema je najracionalnija, najbolja, zato što će uštedati procesorsko vreme, odnosno nećemo vršiti dekriptiju, ukoliko provjerom ustanovimo da message authentication pod nije odgovarajući. I to je šema koji bi trebalo bi da proučite malo ove tri šemi i da razumete koja je razlika između njih i šta svaka od njih donasi. Znači razlika između drugi i treća šema je do tog suštinski su iste, pružeju istu uslugu, ali razlika u tome što u okviru druge šeme, ako neko izvrši promenu poruke, mi ćemo prvo izvršiti deshifrovanje te poruke, sada porukom možda bude i veliki, neki file, baza od nekoliko gigabajta, šta god. Znači izvršitemo prvo deshifrovanje da bi smo te pose toga ustanovili da nije u pitanju validan file, odnosno da je neko nešto petljose ti. Za razliku toga sa drugi, ovde ako bi neko nešto menjio, mi bismo prvo izvršili proveru, autentirno ste te poruke ustanovili da je sve uredu i te ko onda bi smo vršili deshifrovanje, dakle malo je racionalnija ta šema. Dobro, ovde ćemo, sa ovom slajdom ćemo završiti zašto nam ovo treba, mislim da je ovaj predhodný slajd objasnio da imamo pogodnost koristići mesiž autentikejšom koduve posebno u ovom poslednjih šemi. E sam postoje neke situacije kada nije nužno da se zaštiti poverljivo poruke, ali je potrebno da se zaštiti autenticno poruke. Naprimer ako imamo slajnje neke vesti, posebno u nekim kriznim situacijama, ono što logiciju mutno vole da rade to je da pošadju lažnu vesti i da gledaju reakciju koja će se desiti, kada ljudi dobij informacije i počinju da instektivno rebu. Nekad je mnogo važnije obezbeljeti da budemo sigurni u izvor te poruke, da on zaisno stižio od nekog autoriteta koja me treba verovati, nego da se zaštiti tajnost poruke, jer poruka nije tajna, poruka je namenjena svim i treba zaštititi da nekone ne promeni tu poruka. Naprimer poruka može da bude da ne znam u nekoj kriznim situaciji treba napustiti određen i grad i sada neko kaže treba napustiti kragovec, jer se tu desilo nešto neka nesreća, a neko promeni tu poru koji kaže treba napustiti kraljevo, jer se tu desilo nešto. Znači takve stvari mogu da se rade, eako imamo način da zaštiti autenticno stakve poruke, onda na mesišku titi kišu kodujemo gućavoli da se tako nešto detektuje da je neko izmenio poru. Postoje situacije u kojima, rećimo, ako zamistite neku digitalnu arhivu, koje postoje dokumenti koji se čuvaju, ono što znate to je da velo često državne arhive imaju označen za neke dokumenti tajnost koje treba da istekne posto 30 ili 50 godje. Naprimer desise ubistvo Kenedlija i onda ti dokumenti koji su bili u tom trenutku generisani, progla se se zapovedljiva i kaže se biće povedljivi na arhivnih 50 godji. Ako se čuvaju digitalno mobil. I sad po isteku tih 50 godjina, oni kada se čuvaju u bazi više ne moraju da budu šifrovani, ne moraju da bude zaštiće na njihova povedljivost, ali ono što treba da ostane, to je treba da bude ostane, da i nakon tog trenutka ostane zaštita autenticno si dokument. Znači, hoćete da izbermete to da neko sad promjeni nekih istoreski dokument, kako bi utice ono to da promeni tumačenje ono ga što si desilo u prošljasti. Što vidimo da uočete nije nešto što je neubičajeno i da se dešavalo nogo puta u toku istorije, zato što to utiče u kanju i ni na dnevno političke doveđe. Tako da postoje mnog je situacije u kojem je bitno sačuvati autenticnost poruki, uglavom bitno da ta poruka bude na neki način podpisana, ma da mesič od njih išljog kod nije digitanij potpis, zato što viša entiteta ima ključ, vidjet ćemo šta su pravi digitanij potpisi. Znači, mesič od njih išljog kodovit su nam bitni, onda kada hoćemo pre svega da brinemo tome da neku tu poruku nije za meni.
