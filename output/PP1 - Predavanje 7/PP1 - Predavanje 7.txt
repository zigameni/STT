 Lekcija sintaksno upravljano prevođenje. Prvo ćemo definisati pojem translacioni gramatika, zatim ćemo proširiti translacioni gramatike a tributima. Da bi smo dobili atributino translacioni gramatike, to je formalna osnova za definisanje sintaksno upravljano prevođenje, zatim ćemo videti kako proširiti parsere od dnaka vrhu da obavljaju sintaksno upravljano prevođenje u skladu sa specifikacijom koja je zadata jednom atributivno translacionom gramatiku. Pojem translacioni gramatike razmotrićemo gledajući primer ove gramatike od osam smena, vidimo da su smene napisane carnim slovima se, simbola koji su označeni plavim i okvireni u vitičaste zagrade. Znači koj translacioni gramatika skup terminali simbola delimo na ulazne i akcione simbole, ovvi znači što su posebno izdojeni plavo i koji se pišu u vitičastim zagrama su akcioni simboli, ostali terminali su ulazni simbolit, ovojm konkretnom primjelu, ne terminali su veliko e veliko t veliko p, a ostalo su terminalni simboli, znači ulazni simboli su plus zvezdica otvorena zatvornan zagrada, malo a, malo b, malo c, a što se tiče akcija, to su ove sve uokvirene u vitičaste zagrade. Šta se postiža ovim razdvajanjem terminala na ulazne i akcione simbole, dobia se bitna stvar, a to je prevođenje koje matematičke usuštini odgovara vojmu preslikavanja, znači određena ulazna, sekvence koje se sastoji od ulazni simbola, preslikava se u odgovarajuću akcijalnu sekvencu. Naša gramatika u ovom predhodnom primjelu na svom ulazu opisuje infiksne aritmetičke izraze, sa operandima malo a, malo b, malo c, sa operacijama plus i puta i u potrebom zagrada, i jedan primjer takvog izraza bi bio ovaj A plus B u zagradi, što se množi sa C. Ovo su infiksne izraze, infiks i znači da se operator nalazi između operanada, običajeno kad ljudi pišu znači aritmetički izraze pišu u toj infiksnoj notaci, a može da se koristim postfiksna notacija, gde se prvo pišu operandi, pa onda operatori, znači equivalentan izraz ovom infiksom izrazu bi bio ovaj izraz AB plus C puta. Ovde vidimo da su u pitanju akciji, ovi simbolji. Ova konkretna grammatika prevodi, gada dođe recimo malo a na ulazu, na izlašće bi te emitovan, odgovarajuće akcija malo a, a kako postižemo da infiksni oblik prevedemo postfiksni, tako što akciju za operator pišemo tek kada prođe operanti, znači recimo ovde E plus T, pa tek onda znači se emitoje na izlaz operator plus D, da smo ovu akciju plus stavili odma iz ovog ulaznog znaka plus, dobilibismo na izlazu potpuno isti oblik kao na ulazu. Zanimljivo je da u izlaznim akcijalnim simbolima nemo zagrade, bez obzira kakvi su infiksni izrazi, ako upotrebljavaju zagrade za menjanje, al tako priorite to operacija, u postfiksnim izrazima zagrade nikad nisu potrebno, znači bilo kakav infiksni izraz sa zagradama, može se prevesti u postfiksni izraz bez zagrada. Ovoj primjer nam je pomogao da definišemo translacionu grammatiku. Malo formalno je gledano kako se odvija to preslikavanje ulaza na izlaz, možemo prikazati preko translacionog stabla izvođenja, translacionog stabla izvođenja je vrlo slično o nem, plasićom stablu izvođenja i u principu njega konstruišemo na osnovu ulazne se kvence na oraj način kako smo konstruisali, znači izvođenje i stabla izvođenja, samo što se u translacionog stabla izvođenja, kada se naznačava primjena neke smene. Ovde recimo videmo u korenu i neposrednih sljetbenic i korenu su E plus T i akcija plus. Da je u pitanju ova ovde grammatika i primjena prve smene. Znači E je bilo u korenu, a njegovi neposrednih sinovi ovim redom kako so jedan i na desnoj strani smene E plus T i znači unosi se i uvek kad detektujemo primjenu neke smene, unose se i odgovarajući akcijoni simboli. I jednom kada za zadati ulasut konstruišamo kompletno translacino stablizvođenja, što znači da će u njegovom korenu biti startni simbol, a u listovima možemo imati samo terminalne simbole, bilo ulazne, bilo akcijone. Sequenco aktivnosti dobijemo bilaskom, znači ovog translacionog stablizvođenja, sleva na desnoj i beleženjem simbole u listovima. Ako zapeležimo redom sve listove, dobit ćemo tako zvanu sequenco aktivnosti. Ako i sequence aktivnosti uklonimo akcijone simbole, dobit ćemo ulaznu sekvencu, znači ono što dolazi na ulazu parsera, a uko i sequence aktivnosti uklonimo ulazne simbole, a znači preostano samo akcijoni, dobit ćemo tako zvanu akcijnu sekvencu, koja u stvari predstavlja preivot date ulazne sekvence. Znači ovdje vidimo da je ovo stabl odgovaralo jednom složenijem infiksnom izrazu i da tom infiksnom izrazu odgovara ovoj ovde postfiksni izraz. Nije bitno za ovu definiciju translacina grammatika, ali vada da, mali komentar, zašto nam je nekad zgodno prevoditi ove infiksne u postfiksne izraze, pa za razlik od infiksnih izraza koji su ljudima lakši za baratanje, postfiksne izrazi su lakši za kompjutere, jer recimo, ako treba dizračunamo vrednost izraza, a on je zada to vam postfiksnom obliku, onda je dovoljno uvesti jedan stek vrednosti, znači jednu first in first out strukturu, da je, ka čitamo, redom ove elemente postfiksnoj izraza sleva na deso, i kada najidemo na operand, odnosno vrednost, stavljamo ga na stek, a kada najidemo na operator, ako u pitanju, znači recimo binarni operator, onda skidamo posljednje dve vrednosti s vrha steka, primenimo operaciju i rezultat operacije stavljamo na stek, i takvo vrlo lako odredimo vrednost izraza, što bi dosta teže bilo isprogramirati kad je izraz u ovom infiksnom obliku. Saćemo uvesti pojam atributivno translacioni grammatika. Videli smo da je vrlo zgodno uvesti akcije, jer time definišamo znači prevođenje. Način kako se jedan jezik može prevesti u drugi izlazni jezik, kao skup tih akcijonih sekvenci. Međutim atributi nam daju i novu flexibilnost, mogućnost da se u nutaronog stabla izvođenja prosledjuji dodate informacije među pojedinim čorovima putem vrednosti atributa. Atribute, pridružujemo pojedinim grammatikim simboli, u zapisivanju grammatike, da atribute pišamo uz grammatikim simbol kao index do nji index u simbol. Tako ćemo videti da, sastanovišta toka prenose informacija gro stablo, atribute delimo na dva tipa atributa, to su tako zvanih sintetizovanje atributi, koji prenose informacije od listova stablaka korenu, to jest odosno na gore, i nasleđeni atributi koji mogu da prenose informacije od korena stablaka listovima. Primjer atributivno translacione grammatike je jedna grammatika od četrismene, koja ima neterminalne simbole veliko s i veliko a, a ulazde simbole malo a, malo b i malo c u ovoj četvrtoj smeni, a kao akcijone simbole, ovo vidimo, znači sve ove simbole sa viditim častim zagradama, ovo je c, ovo je d, i f, i u četvrtoj smeni ovo je. Svi ovi grammaticki simbole po menutim maju neke atribute, atributi su znači navedeni u indexu u simbol i imaju svoja imena. Za grammatiku se često navode tipovi po jedinačnih atributa. Precimo ovde navedeno da neterminalne, ima dva atributa, da je prvi atribut u ex sintetizovan, drugi nasljedjen, takođe grammaticky simbol a, ima dva atributa, da je prvi atribut sintetizovan, drugi nasljedjen i navedeno je da su atributi akcijoni simbola nasljedjen i primjetite da notacija omogućava i da se piše ovoj atribut. Ako je atribut dva nove, vidite časte zagrade ili da se atribut piše u unutravite časte zagrade, to je u srštini sve jedna. Ako imamo atribute moramo znati, ako smo rekli da su atributi vrednosti, onda potrebno je znati kako odrediti te vrednosti i to me služe atributivna pravila. Atributivna pravila pišu se u z grammatike smene, nači mi ih ovako najčešće pišemo odmah ispod određene smene, znači pišemo pravila zaracuna nje vrednosti raznih atributa koje se pojavljuju u smeni. Recimo, atribut pi dva dobija vrednost atributa, znači to je kopija vrednosti atributa pi jedan i takođe ovo je neki skraćen je, oblik vidimo da isto vremeno i pi tri i pi četri dobija ju tu vrednost atributa pi jedan. I tako dalje u ovom konkretom primjeru sva pravila do dele vrednosti atributa su prosta pravila kopiranja, znači direktno se kopira vrednost nekog drugog atributa, ali to u ovom slučaju nemora biti slučaj, znači nismo ograničeni u tome kojom funkcijom je povezani vrednosti izvorišnih i odredišnih atributa, to može biti proizvoljno složeno. Funcionosno implementaciji kasnije parcera procesora, to može biti proizvoljeno fragment program skog koda. Ono što je bitno za grammatike to je da moramo se pridržavati određenih pravila pri pisanju, znači atribute i njihovi pravila, da bi cela grammatika imala smiso. Evo već gledo je, če ovaj primjer navešću nekao tih oznovnih pravila, pa ćemo kroz naredne slajdove da kažem imati svata pravila, znači koja uvek moraju biti zadovoljena i koja se zovu osnovna pravila konsistencije grammatika da bi imala smis. Znači, prvo, ako neki grammatik simbol ima neki broj atributa, sve njegove pojave u grammatici, let si mohovo s pojavljuje na levin strana, prvi i drugi smene, također se pojavlje na desni strani prve smene i na desni strani treće smene. Znači sve pojave određeno grammatickog simbola moraju imati isti broj atributa ako smo ovde naveli dva tributa, onda i nasvim drugim mestima mora biti dva tributa, oni ne moraju biti isto imenovanje, ali moraju biti pod tipu isto sve pojave i ste. Znači, svuda prvi atribut ovoga je smora biti sintetizovan, drugi atribut nasređen i ako kažem, ne moraju svude imati isto imene. Sreće pravilo odnosi se na to kada određenima tributima dodeljujemo vrednosti. Tako sintetizovanje matributima određujemo vrednost, kada se oni pojave na...
 na levoj strani smene. Vidimo da prvi atributo desije sintetizovan, to je ovo P4, i to znači da mora postojati pravilo koje definiše kako ćemo o tom P4 dodeliti vrednost. Isto važi i za te jedan da je sintetizovan, al pošto se on pojavljio na desnoj strani smene, njemu ne dodeljujemo vrednost. Mi vidimo da u pravilima on figuriše na ovom mesto, ali on je izvor, možemo da koristimo njegu u vrednost, ali dodela vrednosti, znači mora postojati samo za sintetizovanje atribute na levoj strani smene. Komplementan opravilo važi za nasljeđen atribut. Znači ako neki atribut nasljeđen, onda njemu moramo dodeliti vrednost ako se pojavljio na desnoj strani smene. Znači videli smo za drugi atribut, recimo, S, da se tretera kao nasljeđen, to recimo znači da ovo, ovo pojava, ovaj P2 atribut ovde, mora imati pravilo kako nosavdređuje vrednost i za isto ovo pravilo određu da P2 dobija vrednost od P1. Znači za svaki nasljeđen atribut kad se pevlja na desnoj strani smene, mora poslediti pravilo za dodelu vrednosti. Recimo, za K1 on jeste nasljeđen, ali pošto se pojavljio na levoj strani smene, znači njemu ne određujemo vrednost, ali naravno možemo da ga koristi. Koja je još, znači ta pravila postoje, atributi ulasnih simbola trajiraju suve kao sintetizovanih, to jest, znači nikad im nedodeljujemo vrednost gramatićkim ovim pravilima, nego njihove vrednosti objezbeđuju leksički analizator kroz vrednostnih deo ulasnog tokena. Znači tu je veza sa tokenima i rekli smo da token je obično zapis o dva polja klasa i vrednost, znači klasa određuje koji je u pitanju terminal, a vrednost u stvari i onda određuje njegov sintetizovanih atribut. Takođe svakoj smeni pridružuju se pravile izračunavanje vrednosti za tributi simbola koji se pojavlju u to i smeg. Nemogu se koristiti niti računati atributi simbola iz drugi smeg. Znači dosta je bitno da svak pravila koja pridružimo jednoj smeni koriste isključivo atribute iz te smene. Znači ne sme ovo pravilo uprvo i smeni da koristi atribute iz četrte smene. Inače pravile uvek imaju neke sve izuzetke. Na primer ovih alati za generisanje parsera i jaki kup omogućuju pod određenim okolnostima da u stvari pristupate i atributime iz neki drugi smena, ali to je jedan mehanizam koji je s jedne strane ograničen pod određenim usmima, a z druge strane vrlo je nesiguram, zato što ako kasnije menjate grammatiku može lako da vam se desi da poremetite ta pravila tako da, čak i ako alat to omogućava, dobra praksa je da se zadržimo na ovo teoriskom ograničenju. Nastavljamo sa, znači, osnovnim pravima konzistenci atributivne grammatike. Znači atributi se moraju slagati po broju i tipu za sve pojave istog simbola x, ne moraju i po imenu. Za svaki sintetizovanja atribut koji se pojavlja na levoj strane smene mora postojeti pravilo za računanje i onu sušni ni može zavisiti od nasljeđenih atributa sa leve strane i od bilo koga tributa sa desne strane smene. Komplimentarno za svaki nasljeđenih atribut koji se pojavlja na desne strane smene mora postojeti pravilo za njegovo računanje i on može da zavisit od nasljeđenih atributa sa leve strane smene i od bilo koga tributa sa desne strane smene. Dodatno pravilo koje dosad nismo pominjali, znači vrednost nasljeđenih atributa startnog ne terminala mora biti u napred zadata. Zato što prosto nema smene gde možemo te vrednosti navesti. Tako da to je nešto što dolazi kao neki ulazni parametar parsera u napred zadata. Takođe, znači vrednosti, tributa ulazni simbola se neračuna i upravili malo ovim grammatikim, nego moraju biti u napred zadate odnosno moraju i dostaviti kao što reko smo tokenizator kao vrednosti i da je ulazda do tokena. I pošto smo videli primjer jedna atributino transracione grammatike koja zadovoljava sva ova pravila konsistencija mi ćemo videti kako izračuna tri vrednosti atributa znači objasnićemo upravu koristeće ovaj primjer grammatike, uzet ćemo i primjer ulazda sekvence koje se sastoji od ovih osam ulazni simbola i u svaki simbolu navedeno je i vrednost njegovog atributa. I dodato rekli smo pošto startni, neterminal, sima nasleđen atribut moramo u napredi isto definisati njegovu vrednost i neka to bude jedinica. Prvo je potrebno za zadati ulaz konstruisati stablo izvođenja to je transracionalna znači stablo izvođenja, vidimo da se pojavljuju i akcioni simbolima da samo ulazni simboli definišu da kažem strukturu stablo stablo odgovaro ovoj grammatici sa 4 smene poslu potrebno smena za a poslu opet u potrebnja na isto prva smena za s i malo ovdje nedosledno pisane ovdje napisano veliko ce ote malo, celu sušti njih radili s oistim znači simbolima. To je za ovaj zadatu ulazdu stablo izvođenja kako možemo da se uverimo da jeste to za tu sekvencu, pa tako što obiđemo ovostablo izvođenje i redom sleva na desto popišamo sve listove a b pa se spuštamo dole a b c l tako a b a b c došli smo do ovde pa onda ide b c c i to je to b c c konstruisali smo stablo izvođenja i na koraku naznačimo sve što inicijalno znamo, znači sve što je u napreza a to su znači tributi u listovima ovih ulazdi simbova i takođe znamo drugi tojens nasređenja tribut korena startnog neterminala i sad je potrebno izračunati v rednosti preostalih atributa koju sistematiku koristimo, moramo da idemo kroz celo stablo i razmatramo primenu svakke smene koje je primenjena u stab taj redosled i da ćemo krenuti od korena prema listovima ili obrnuto nije važan, samo je važno znači sistematike obići celo stablo čvor po čvor za te unutrašnje čvorove koji predstavljaju prime sve nam i možemo krenemo od korena i to predstavlja primenu prve sve nekoje ovde prepisana primenjujući ova atributa i napravila računamo v rednosti atribut znači mogu biti izračunati sve v rednosti za koje su poznate ove izvorišni deopravila predstavljamo atribut ulaznog simbola a p1 je jednak jedan možemo izračunati p2, p3, p4 p4, recimo sintetizovan i atribut na levoj strani ovdaj ovdaj ovdaj prikazano da p4 dobija v rednost od p1 i tako dalje, možemo značiti da je p3 jednako 1 p3 je drugi atribut ovoga akcije c zatim p2 isto jednako 1 to je drugi nasleđen atribut ovoga s sve na sve strani smene to je ovdaj ovdaj čvor s pa njegov drugi atribut k1 je drugi nasleđen atribut od svoj na mjesto poznat jednak jedan tako da na mjesto poznat i k2, k3 s1 je atribut ulaznog simbola b1, 2 tako da na mjesto poznat i s2 zatim t1 je prvi atribut od ovoga s na desnej strani sada t1 nije poznat ovoj trenutku tako da ovo pravilo ne možemo primeniti to jest ne možemo izračunati t2 i konačo r je 1 a mjesto tako nije poznat ovo a na desnej strani nije nam poznat vrednosti r je 1 tako da ne možemo izračunati je 1 u opšten slučaju nećemo uspeti već u prvom prolazu izračunati sve vrednosti zbog toga, mi kad jedom prođemo kroz celo čvor s pa čvor vraćamo se ponovop, a pčemo ponovop razmotriti koren u drugoj iteraciji i svaki drugi čvor i tako dalje, znači ponavljaćemo te prolaskje kroz tabla iterativno dok postoji bilo kakva promena i dok dalje računanje nije moguđe o konkretom našom primjeru moguđe bilo izračunati značu u konačnom pro iteracija sve atribute i ovde je navedeno, znači kompletno stablo, to je sad atributivno translaciono stablo izvođenja ako popišemo sistemat sve listove stablo, dobit ćemo sekvencu aktivnosti ako iz sekvenca aktivnosti izostavimo sve akcije, ne simbole dobit ćemo ulaznu sekvencu, a ako iz sekvenca aktivnosti, zostavimo ulazne simbole a akcije ne simbole dobijemo znači izlaznu sekvencu koja u stvari predstavlja prevodi, vidimo da i ovde i akcijoni simbole imaju konkretne vrednosti svojih atributa pretvun i primjer atributa translaciono-translaciono-gramatike bio čisto formalan, nismo možemo davali nikakvo značenje samo nam je poslužio da objasnimo osnovne pojmove a evo sad možemo videti jedan primer tipa sintese translaciono-translaciono-gramatike zada ta je jedna ulazna grammatika koja nema atributeniti akcije koja ima 3 smene intiger se opisuje kao digit i za čega sredi mor digit i sad smene 2 i 3 opisuju mor digit kao u stvari niz od 0 ili više ovih digit terminal u suštini, intiger je opisan kao sekvenca od 1 ili više ovih digit terminal dalje se nastavlja postavka treba dodeliti atribute ovoj gramatici tako da ne terminali simbol integer ima sintetizovanji atribut jedna kvrednosti celog broja koji ovaj simbol generiš pri tome treba predpostaviti da ulazni simbol digit ima atributi jedna kvrednosti odgovarajuće cif mi ćemo dati 2 različita rešenja čisto da si ilustruje znači da je moguće koristi različite vrste atributa u prvom rešenju koja je inače možda lakše za svatanje pa samim timi češće se primenju koriste se samo sintetizovanje atributi rečeno je prema postavci da svaki terminal to je ovo malo digit ima atribut koji predstavlja vrednost odgovarajuće cifre mi ćemo, znači taj atribut nazvati val i u svakom poja ovog terminala digit dodat ćemo index u val i znači to je ta jedna cifra z druge strano, ono što je dodatno rečeno to je da ovaj start i netreneno treba da ima atribut koji će na kraju da sadrži vrednost celog broja mi znači treba da vidimo kako na baziji tih podataka dalje izračunati vrednost broja, ako gledamo samo prvu smenu mi imamo prvu cifru i ostatak broja koji je reprezentovan ovim neterminalom moratičic da bi izračunali kompletnu vrednost broja mi moramo poznavati vrednost ostatka broja koji čine sve cifre mimo ove prve cifre i moramo poznavati koliko cifara ima i tada možemo izračunati vrednost celog broja po formuli
 Padajno je cifre puta njen težinski kojeficienta, njen težinski kojeficient je osnora brojnog sistema na mesto te cifra, odnosno broj preostalih ovih cifara, 10 na P, dp broj preostalih cifara i plus vrednost o statka broja. Znači podrezumevo broj u decimalom brojenom sistemu, to nije posebno naglašeno u postavci. Na taj način mi računamo vrednost celog broja i pošto vidimo ovaj atribut je na levoj strani, to je i este sintetizovan jatrib. Pri tome smo znači dodelili ovom netrvinalu moro digit dva nova atributa, znači jedan predstavlja vrednost dela broja koji njime predstavljen, a ovaj drugi atribut predstavlja broj cifara, to znači da i sve druge pojave ovoga atributa, to je ova pojava, to je ova pojava i to je ova pojava, moraju imati po dva atributa i sad nazivamo ih onako kako nam odgovara. I još da razmatimo da smo završili sa prvom smenom, jesmo, pošto u principu i ovo će biti sintetizovan jatributi, znači ne moramo ih računati, pošto je moro digit sa desnoj strani, to ćemo već imati znači kada gledamo prvu smenu, znači ovdje se računa samo veli. Međutim, znači ostala su druge i treća smena i u druge i treći smeni uveli smo znači ove atribute za mor digit. U drugej smeni, znači situacija sa ovom vrednošću v, koji treba izračunati, znači vrednost tog dela broja koji je reprezentovan celom desnom stranom je vrlo slična situaciji kako smo računali ovaj veliju, znači uzet ćemo ovu ovde cifru i njenu vrednost val, ovnožiti stežinskim kojificientom koji je 10 na broj preostalihovi cifara P1 i dodati dostatak broja v1, na taj način smo način, znači isto kao što smo odračuli veliju, ovde dobijemo ovde v sintetizovanje atribut na levoj strani. Šta je još moramo računati, moramo računati ovo P, pošto je to sintetizovanje atributi nalazi se na levoj strani, P je prosto broj preostalih cifara na desnoj strani plus 1 za ovaj ovde tičić, znači P je P1 plus 1, time smo izračunali sve sintetizovanje atribute na levoj strani, ovo drugo su isto sve, znači ovo se na računa, ovo se dobija sa ulaza, ovo je isto sintetizovanje atributi, znači ne računa se nego smo u svaru koristili vrednosti, tako da smo završili s drugom svenom. Preća smena je još prostija, treba isto izračunati znači vrednosti V i P, pošto je ovo smena koja završava u suštini izvođenje, znači opisuje broj koji se sestoji od nula cifara, znači broj cifara ne nula i vredno samo broje nula. Moje preporu kada načratate za neki konkreta nula zrecimo 123 atributivno stabilo izvođenja i odredite vrednosti svih atribute za vežbu, da vidite kako ovdeg, pošto su u pitanju sintetizovanji atributi, tog vrednosti ide od listova ka koredostab. Međutim moguće je i drugačije rešenje koje poved nasleđeni koristi sintetizovanje atributi na malo drugačiji način računa vrednost broja. Ono prvo rešenje računa tu vrednost cifru po cifru, zdesna na levo, znači prvo smo imali, prvo nula kad nema cifara, pa prva cifra 3, pa kad se doda cifra 2, znači sleve strane to je 2 x 10 plus 3, jednako 23, pa kad doda jedinica znači sad opet sleve strane to je 1 x 100 plus 23, znači jednako 123. Međutim moguće, znači tako u jednu konstantu računati sleva na desno, znači prvo imamo cifru najviša težine jedinicu, pa sad kada dojemo sredneću cifru dvojku kako računamo, znači prosto treba samo pomnožiti sa ostavnom brojenom sistema, znači 1 x 10 plus 2 i dobijemo 12, tako smo znači drugu cifru pridružili, sad kada dodajemo sredneću cifru, znači uvek se ono predkodno samo množi sa ostavnom brojenom sistema, znači 10 i dodaje srednica cifra, znači 12 x 10 je 120 plus 3, jednako 123. Znači tu se računa sleva na desno i nema stepenovanja. Kako se realizuje taj način računanja? Ano što već smo imali zadatopostavkom, to je ovaj valo od digiti i veliju od integer, ono što u ovom rešenju je drukčije, to su naravno atributi ovog neterminala mordigit. Ideja je sledeća. U ovoj prvej smeni još nećemo ništa računati, jer tu imamo samo onu jednu najvišu cifru. Rachunanja treba da prenesemo do druge smene, sada pošto je to u suštini prenos naniže kroz tablu, pošto ovdje koren ovoj mordigit je naniže u stablu. Znači da bi smo preneli vrednost prve cifre, uvodimo jedan atribut i koji je nasleđen, zašto je nazvan baš i, zato što je engleski termine inherited. Kroz ovaj nasleđen atribut i njemu dodeljujemo vrednost ove prve cifre i u suštini to spuštamo u drugu smeno. Kasnije ću pro komentari sa te ovej drugi atributec. Znači zato smo samo preko i preneli u drugu smeno vrednost prve cifre. Šta imamo u ovoj drugoj smeni? Imamo znači preko ovogo ovde i, to se dolazi sa leve strane, znači prenetu vrednosti z prve smene prve cifre i imamo val, to je sada vrednost sledeće cifre zdesta. I rekli smo, znači treba izračunati vrednost koji predstavljete prve dve cifre, tako što pomrožimo znači ovo prenetu vrednost o 10 i dodamo ovu tekuću cifru val. I time dobijamo vrednost koju dalje prenosimo niža, nistaablo. Pošto ako broj ima više cifre, abi u stablo će biti više puta primenja na druga smena. I sada znači treco smena će opet biti reprezentovan ovim, a preko ovog i jedan prenosimo ovo vrednost koju predstavlju prve dve cifre. Onda znači uvek se ta preneto vrednost množi se 10 i dodaje se tekuću cifra i dalje se, nači prenosi vrednost opet preko nasljednog atributa. Ise dok li ide to prenosi, pa sve do kraja samog broja kada se primenjuva treća prazna smena. I u treća smeni mi u stvari imamo, pošto smo isprocesirali, ceo broj ovaj nasljednji atributi u stvari ima zahtavan u vrednost kompletno broja, znači finalni rezultat. Međuti šta tu jedino smeta, to što se odna straži da finalni rezultat bude pridružen startom, netrmenu, to je skorenu stabla, a mi je u stvari ovo epsilo nje jedan od listova stabla. Znači mi imamo finalnu vrednost, ali ono je na potpuno drugom strani stabla, znači u listu, a ne u korinu. I šta onda možemo da uradimo? Pa možemo koristeći sintetizovan atribute, tu vredno samo da iskopiramo skroz, znači u nazad od tog lista, kakorinu, kako to radimo, tako što uvodimo drugi, znači sintetizovan i atribut. Neterminalu, mora tičići svim njegovim pojavama, i onda, znači prvo u ovoj treće smeni prosto iskopiramo, znači vrednost i u s, i to isto ponovimo, znači u drugoj smeni, znači ono što nama to olazi kroz, znači u s1, dalje će k vrhu stabla biti, znači kopirano kroz ovaj sintetizovan atribut, o desno, odnosno s će dobiti vrednost, o desnjavn pošto je sintetizovan i znači učinamo nešto je na levoj strani, a koristimo nešto je na desnoj. Isto to se radi i u prvoj smeni, s tim što ovde, znači vrednost ovoga s koja dolazi, znači odole iz stabla, dodeljujemo ovom finalnom atributu velju i tako smo znači konačno doveli finalnu vrednost do korena stabla. Znači opet preporučujem da za jednu konstantu 123 nacartante kompletno stablo izvađenje i odredite vrednosti svih atributa da biste jasno videli kako se prenose vrednosti. Finalni deo lekcija bavi se sintetizovanim prevađenjem od nakva vrhu, to je s načinom kako iskoristiti ove atributino translacijne grammatike u parsiranju od nakva vrhu i konkretno kako proširiti šift reduce parser koji je bio prepoznavač ulaza sekvence davao je samo logičnu vrednost ispravna, neispravna kako proširiti da, po red tog da kažem izlaza da je i neka bočne efekte u smislu izvašavanja akcija koja mi zadamo u okviru atributino translacijne grammatike. Da bi mogli atributino translacijnu grammatiku primeniti u tom botom app parsiranju. Uvesti neka od dodatnoj ogrančenja u samu grammatiku, vano njih ostavnih pravila konsistencije, a tad dodatnoj ogrančenja odnosno se na smešta i akcijni simbola i to ogrančenje ima konkretne ime poljuska translacijna grammatika i drugo ogrančenje je vezano za atributei grammatike i to drugo ogrančenje se zove esatributivna grammatika, sad ćemo definisati oba ogrančenja, znači poljuska translacijna grammatika zahteva da se akcijni simboli pojavljuju isključivo na samom kraju desne strane smet. Ako imat akcijne simbole u smeni onda desno od njih ne sve postojati nikakav drugi simbol koji nije akcijni simbol, znači dozvoljeno da ima tredcimo dva akcijna simbola na samom kraju desne strane ili je dozvoljeno da kažem da bude samo, znači da ne bude drugi simbola, da bude samo akcijni i jedan ili viša, znači to u sluštini kada isukljano akcijno simbolo to bi gila prazna svena. Međutim, znači ono što ne smet, to je da neka druga vrsta simbola terminal ili ne terminal bude i za akcijnog. E sad, šta ako naša grammatika ne zadovoljava to ogrančenje, pa nije veliki problem, zato što je moguće lako naći grammatiku koja opisuje iste nizove, a zadovoljava ogrančenje, znači uzmimo napr. da imamo neku smenu gde akcija nije na samom kraju, nego imamo nešto desno od akcije, onda postoje da kažem dve variante transformaci, uprvo i varianti, mi ovaj ceo deo, menne prefix desne strane koji završava zakojučno sa akcijom, odvajamo u novi neterminali simbol koji dotat nije postavio u grammatice, znači odima novi neterminali simbol, ovaj deo smene a, y, opisujemo taj neterminal tim delom smene, a onda u originali smeni prišemo a, y, uvodimo taj novi neterminal, i tako smo u dove jedne inicijale smene koji smo uklonili, dobili dve u kojoj vidimo da se akcija pojavljuje na samom kraju desne strane. U drugoj varianti možemo isto uvesti novi neterminal m koji se dotat nije pojavljimo u grammatici, ali njime zameniti samo ovu akciju, znači na taj način je izvući iz ove smene, znači u originali smeni umesto akcije pišemo taj novi neterminal m i onda pišemo smenu za m koja sadrži na desnoj strane samo tu akciju y. Ova druga varianta transformacije koristi se automatiki u kup alatu za, znači, generisanje parsera, tako da vam to omogućava da vi kad koristi te alat, znači vi možete staviti akciju sredinu desnoj strane smene, ali treba da budete svesni toga da alata automatiki radi o ovu transformaciji.
 Znašto je bitno biti sve stanite transformacije, zato što možete imati takav efekta da recimo imate neku gramatiku koja nema nikakvih oni paracerski konflikata i vi sad slučajno nakrano naravno dodajete kad realizujete vaš compiler nakrano do dodajete akcije i deoprezno dodate akciju. Znači ako dodajete akcije na same krajeve smena nećete nikako pokvariti gramatiku, neće se ništa desiti, međutim ako neopreznu nekim situacijama dodate akciju u sredinu smene, ne obavez doali, znači nekim situacijama može da se desite od jednom se prijave paracerski konflikti. To je prosto zato što se s gramatike ustvari promenila, što je ovo kad uklonite akciju, to je jedna prazna smena. Znači u gramatiku koji uvede novi netrvina, ali nova prazna smena, tako da ovaj to može, zavisno kažem od pozicije i ostatka gramatike i pozicije, ove akcije može da dovede do konflikata, tako da nekada ustvari vi sami da biste takav konflikt razrešili, možete ručno ovaku transformaciju s provestvim, ili znači u generalno je dobro kada se ustvari desiva konflikat, ste upacili akciju, znači nekada u sredinu desna strana neke smene koja još nije jedno značno prepoznat od strane parcera, da parcer u tom trenutku kad dođe, kad prođe ovo a da zna jedno značno doje u pitanju ta smena, nego ako još uvek on ima nekoliko smena u opcije, onda znači upacivanje akcije u jedno otismena može da izvzove konflikt, znači kažem jedno od preporoka u takom sluče ili da vi sami primjenite u drugu vrstu transformacije koja daje malo druga čiju, da kažem onda sliku ili da prostorazmotrite da malo pomerite levo ili odnosno češće na desno još u akciju, u akciju, recimo ako je sakrije ti za nekog terminalog simbola, obično može da prođe bez konflikata, znači malo mora se eksperimenti sada ako se desi takva situacija, kažem treba biti sve sam zašto dolazi do takve situacije. Drugo ograničenje koji smo rekli da se odnosi na tribute grammatike je da grammatika da bi mogla da se procesira botom aparsera, moha biti esatributivna. Gramatika esatributivna ako su svi atributi netemlani simbola sintetizovanji, zatim ni jedan sintetizovanji atribut ne može da zavisli od drugog sintetizovanog atributa i ste pojeve simbola u grammatici i konacu da nasljeđenja tributi akcija i simbola smaju da zavise samo da tributa oni simbola smene koji su levo od tog akcijonog simbol. Od svih ovih ograničenja najvažno je ovo prvo ograničenje, znači da prosto koji netemlila ne možete koristiti nasljeđenja tribut. U praksi to jeste jedno ograničenje ali u sve situacije znači mogu da se reši isključio sa sintetizovanim atributima, nekad u uvođenju neki dodatni struktura, podataka i kolekcija prosto može da se razreši situacije kad bi vam normalno i način trebali nasljeđenja tributi, tako da sve može da se reši s sintetizovanim atributima. Ovo drugo ograničenje potpuno je onako sporetog značaja, u suštini ako recimo imate na levo istraje nekoj smene, znači neki simbol koji ima dva atributa i b to drugog ograničenja samo kaže da ne znam a, ne sme zavisiti od b, ni b o dašto, normalno su učin, in ne koristi se li kad a i b o će u suštini zavisiti od atributa sa desetj strane te smene. I vidimo da nasljeđen atributi jedinom mogu u akcijinim simbolima da se pojavi i oni prakčno ima način ovo ograničenje koje ovdje navedenu. Jedan konkrata primer i jedne grammatike koje zadovoljava oga ograničenja je, evo dat, na ovom slajdu i vide ćemo, osim što možemo proveriti da su ograničenja zadovoljama i će u stvari iskoristiti ovaj primer da, vidimo princip prošireňa jednog parcera od nakavrhu da obavlja, znači atributimu transfacio specifikcijranu ovakvom grammatiku. Ova grammatika ima tri smene, ima samo neterminal e i možda u mnijenom opisu znači reći, osim što je zadata grammatika, evo šta je u suštini delu postavke, data je satributima pojadnika transfacio grammatika, prevodi izraz u nis, sastavljeno da to ma ed, satributima pqr i mult kao multiply pqr, gde su pqr respektivni ukazatelji, na levi operand, desni operand i rezultat operaciju tabeli simbola, što je nekakav eqvalenta s empresnom kodu. Nov i ulaz u tabelu simbola generišanom pozivom funcije neke njute kao new table, entry i kaže atribut tokena i je ukazateljna tabelu simbola na simbol koji odgovara tokenu i. Ja ću otići par slajdova u napred, da vidimo u stvari kako funkcioniše parser koji se napiše na bazije ove grammatike, znači, evo primer na ulazu ako dođi ulaz njih zizrazi koja opisuje ova grammatike ima i specificio syntaxu i da imamo plusi puta, ali su zagrade uvek opavez, znači čak i tamo gde nisu neobhodne, znači 1 plus a puta 2 u zagradama. Lexički analizator pošto sama grammatika, što se tiče operand, da ima samo i koji opisuje i konstantne vrednosti, eventoljno neke promenjive, onda znači tokenizator bi dao ovakave u suštini ulaz parseru, znači i 1 plus i 2 puta i 3. Šta su ovi 1, 2 i 3? To su redni projevi ulaz u tabeli simbola, gde su opisani ovi operanti? Znači, recimo, prvi ulaz opisuje konstantu 1, drugi ulaz tabele simbola opisuje promenjivu ve, imena a i treći ulaz u tabeli simbola opetopisuje konstantu vrednosti 2. Čo ovo je sve ulaz u parser? A šta treba da bude finalni izlaz parsera prema ovoj grammatici? Evo finalni izlaz, možemo vidjeti na ovom slajdu. Parser ona i izraz, znači 1 plus a puta, tako ulaz je bio 1 plus a puta 2, treba da prevede u suštini u neku vrstu akcije. Ne sequence koja poceća pomalo na neka kava semberski program, znači koji kaže, prvo treba pomnožiti operande koji su opisani drugim i trećim ulazom tabele simbola, a to su, znači, promenjiva a i konstanta 2. I medju rezultat se stavlja na mesto koji je opisan u četvrtom ulaz u tabele simbol. U vidimo nekakvu promenjivu koja je nače nije postila oregrano ulaz i koja se se stanovišta prevođenje i komparera takve vrste promenjiva koja komparer internu uvede se za u privre mene promenjive temporari, za to ovde ima tip t, nije tip v, to je koristnička promenjiva nego tip t kao temporari. Znači, interna promenjiva i ima neko svoje ime t1. Vidimo da je parser doda ova dva nova ulaza u tabele simbola o značenu žutom i svaki od tih ulaza je dobijen pozivom o ne funcije njute. Znači, u sluštini poziv funcije njute pravi novu privremenu promenjivu t i dodelju je nekde u tabelu simbola. Znači, neko imaju i dodeli i stavio je u tabelu simbol. Znači rezultat ovoj prvog multipla i znači, taj medju rezultat se čuva u ovom t1 i onda ide druga akcija koja kaže da sa treba perandu opisanu prvom ulaz u tabele simbol, a to je konstanta 1. Sabrati sa operandom opisanom u četvrtom ulaz u tabele simbola to je ova temporari promenjiva t1 i rezultat smestiti u podredište koopisanopetim ulazom tabele simbola to je opet nova privremena promenjiva, vidimo t2. I u sluštini znači to je ta obrada koji očekujemo da uradi parser na bazi ove grammatike. Znači da emituje ova dve akcije da alocira ova dva nova ulaza i da ona izraza znači isprevodil nijez ovih akcija. Ovo je kao jedan compiler u malom jer u sluštini i posao compiler je upravo to ona ne računa vrednost izraza nego emituje ovo možete svatiti kao neki vrste de abstract-ovanog mašninskoj programa koji opisuje znači kako će se u runtime u računati vrednost izraza. Ja sad vraćemo se nekoliko slajdova. Videli smo znači šta je ulaz. Sada da vidim kako proširiti potisni prepaznavač da bio obavljavo traženu atributinu translaciju. Principroširenje je vrlo jednostavan. S jedne strane imamo one simbole steka i u implementaciji prosto treba predvide ti da simbole steka sadrže i polja za atribute. Znači uvesti za svaki simbol steka u sluštini neka vzapis koja ima ono liko dodatni polja, koliko ima vrednost i atributa. Znači vrednosti svih atributa će biti poznati odrnutku gada parcel u cvom toku rada stavlja neki simbol na stek. A praktično, ostatak parsera samo treba izmeniti u toliko što se proširuju akcije redupcije smene. Znači sve drugo je isto, samo što, da je akcije reduce za svaku smenu proširujemo računanjem svih atributim i pravila te smene koje su i način spokone poljski translacije, znači skoncentrisana na kraju smene. Znači kad prepoznajemo smenu, računamo sva njen atributim napravila i emitojemo akcije one simbole navedene u toj smeni na izlas. Evo, za ovaj primer, parser koji ne prikazujemo o nu potisnu i kontrunu tabelu, on može da se napravi gramatika relativno trivijalana i taj parser nije velik, to možete vi samo stano za vežbu da uradite, ali prikazujemo samo jedan deo parsera koji se menja, a to su ove nove proširene reduce akcije i kako sad izgledaju ovi zapisi za gramatike simbole. Znači vidimo, recimo, evo prvo da se skoncentrišemo na pojedine gramatike simbole. U zadato i gramatici videli smo da ne terminal e ima jedan atribut, a akcije one simbole imaju po 3 atributa, dok ovi, recimo, terminal je otvrna zagrada plus, zatvrna zagrada nemaju atribute, takođe terminal i koji predstavlja operandi ima jedan atribut. Znači kad budemo proširili parser, e će u stvari sad biti reprezentovan ovim zapisom, gde prva komponenta označa o identite stack simbola, druga komponenta za togde razdveno catka s tom linijom, znači predstavlja vrednost njegovo godgovarajućeg atributa, takođe ako ne gde se i pojavlju je kao stack simbol, imađemo komponent u kojoj određuje, koji je simbol i vrednost njegova godga tribut, ovi drugi stack simbol, oni samo predstavljaju svoj identitet, nemaju atribut. I sad konačno proširene reduce akcije, ovdje su prikazane na jedan specifican način, vizualno stanjem stacka prenego što se sprovede akcija i stanjem stacka pošto se sprovede akcije, stanjem parserskog stacka i dodatim opisom šta ide na izlas, to je ovo output. Reduce 1 akcija, da po novost se podsetimo grammatike, prva smena ima na levoj strani e, na desnoj strani otvarno zagradu e plus e, zatvarno zagradu akciju et. Kako izgleda i šta se dešalo u okviru?
 redupcije te prve smene. Kao što znamo redupcija, smena očekuje da će na vrhu steka zateći redom znači ove simbole steka otvorenu zagradu E plus E zatvorenu zagradu. Znači akcije, oni simboli ne idu, pošto su oni na samim krajevima smena, oni nikad ne idu na steka. Znači oni se ne nalaze na steku, na steku se samo nalazi otvorenu zagradu E plus E zatvornu zagradu, tako što je na vrhu steka zatvornu zagradu. Znači šta treba rediju sa akcija da uradi? Pa da uradi znači skidanje sa steka svega ovog, to je 1, 2, 3, 4, 5, 5 simbola se skida sa steka. Zatim potrebno je izračunati ova tri atributa ove akcije, emitovati sa output akciju na izlaz. Inaciu u program skorjelizaciji šta znači to o emitovanje na izlaz, pa može buklavno znači zapis u neki izlazni fili ili čak može da znači da je ovo ed neki poseban metod funcija koji će biti pozvanu u tom trenutku. Znači sve to može da se tumači kao emitovanje na izlaz. Sa stvarim parametri mejst' 1, 2, 3, znači bitno je da se ove vrednosti poznaju u tom trenutku emitovanja. Takođe znači biti izračunata ova vrednost P i znači ovo će biti skinuto sa steka i posle toga će ovo i E sa svojim znači ovo izračunati P, biti stavljan na steka. Znači sve je to vizualno predstavljano ovo ovom srikom. Pre akcije, reduce na steku, znači stek je tako prikazan da je vrh steka gorepno steka dole I sad vidite, ovdje redom imamo sa svim desto u smeni zatvran za grada, samo vrhu steka. Znači skine se sve ovo zagljučno sa ovom otvorenom zagradom i na ovaj ostatak steka reprezentovan s ovinem tačkicama stavlja se leva strana smene. A šta je onda vrednost P? Vrednost P se dobi ovim pozivom, znači, nu temporari funkcije. I osim što se ta vrenuz dodeli P, ona se istovremeno dodeli S3. Znači ovdje nema dva ražda poziva nu temporari, nego samo jedan poziv nu temporari, znači, ja se vrenuz dodeli i atributu P i ovom atributu S3 akcije ADD. Znači, ovdje to znači, ono tako što ovdje piše ta vrednost nu temporari, takođe, ovdje vidite. Znači, ovo je nova stanje steka, a ovo ide na izliz. Reduce akcija drugi smene, skoro identična, ovo i reduce jedan akcij, samo što je ovdje u mestu plus stoji puta na steku i takođe u outputu, mestu add stoji multipli sve drugo isto. I konačno, treća smena jednostavnija, na dešnjestvenjem bilo samo i, i onda skine se i, stavlja se i, i iskopira se ovaj atrib, vrednost atributa, znači, i, postaja atribut od P. I to je prikazano ovdje, znači, ovo je pre akcije bilo i sa vrednošću, er posla akcije e sa vrednošću, er i nema nikakog outputu. I kad znamo, sad znači, kako smo proširili parser, možemo kažemo, opet bez konstrukcije parserjski tabela, znajući kako rade ti shift 3D use parserji, ovdje je konstruisan 1, 3 srada ovog parsera za ona i, primjer, ulaza i1 plus u zagradiji 2 x i3 parser će obaviti radu 15. Koraka radi će shiftovanja znači sa ulaza sve dok ne formira desnu stranu neke smene, a prvi put će to se desiti kada na vrh steka potisna u konstantu i1, onda će prepoznati da može to da redukuje primjenom treće smene u e1, onda će nastavljati shiftovanja sve dok ne dođe dolog i2 na vrhu steka, kada će opet primjenom treće smene to pretvoriti u e sa vrednošće atributa 2. Slično, tome će ovo i3 pretvoriti u e sa vrednošće atributa 3. E sad kad bude prvi put shift ovo desnu zagradu, prepoznaće čita ova ideja u zagradiji e sa atributom 2 puta e sa atributom 3 u zagradiji, sve to će zameniti redukcijom druge smene sa 1e i do deliće, znači pozdivom nju te novi temporari, a na izlašće emitovat i prvu akciju multiplaj po što ovdje bilo puta, e sad kad dođe ova druga zagrada se izlaza i kad se formira ovo u zagradi e1 plus e4, prepoznaće prvu smenu redukovati e emitovat će ovo akciju ADD, internetno će pozvatio na nju temporari i dobiti ovo pet i kada na vrhu stekamu se nađe taj startni simbol samo, a na ulazu da smo došli do kraja ulaza u radiće akciju accept, znači u suštini izlašće biti da se je sekvenca ispravna i prihvata se, a kao počni efekat će biti emitovane ove dve akcije. Znači to odgovara ovoj slici konačnog izlaza. Upotreba abstraktnih sintaksnih stavba u kompajlera. I ako bi se mnogi iz zadaci kompajlera mogli izvršiti u jednoj fazi putem sintaksno upravljanog prevođenja zastavog na atributivno translacionih grammatikama, savrevene software-ske prakse obe schrabruju implementaciju već je uroja različiti funkcionalnosti u jednoj komponenti kao što je parser. Zadaci kao što su semantička analiza konstrukcija tabele simbola, optimizacija programa i generisanje koda zaslužuju za seban tretmanu kompajlera. Ako se sviti zadaci smeste na jedno mesto, u specifikaciju semantičkih akcija grammatike rezultojići kompajlera je teško razumeti, proširiti i održavati. Zato razmatramo design i primenu strukture podataka poznate kao abstraktosintaksno stavlo, koje će služiti kao centralna struktura podataka za sve aktivnosti posle parsiranja. Cilj sintaksnu uvrđanog prevođenja se tada svodi samo na izgrađanju toga abstraktosintaksnog stavla. Najčešće se u procesiranju izgrađenog abstraktosintaksnog stavla koristi projektni šablon posetilac engleski vizitor. Taj šablon bezbeđu je efigasan obilazak stavla i razdvajanje algoritama od strukture nad kojem se operiš. Nove vrste procesiranja različiti kompajlerski prolaz i mogu se dodavati bez menjanja postojeći klasa koja definišu strukturu, dodavanjem novih posetilac. Uzećemo jedan tekući primjer da ilustrujemo tehniku abstraktnih sintaksnih stavla i uporedimo je sa tehnikom sa atributivnom translacijom. Radi so jednostavnom primjeru kalkulatora za ostavne celobrojne aritetičke izraze sa ostavnijom operacijama sa biranjem od uzivanjem noženji deljeće. Gramatiku koju ćemo koristiti prilagođene parserima od naka vrhu, imamo neterminalne expression term i factor, celo izraz opisanje smenama za expression, prva smena se koriste jako se koriste operacije sa biranjem od uzivanja koje su preko ovoga neterminava ad-op zajednički predstavljenje, a ako nema sa biranjem od uzivanja onda se expression menja sa term, a term u izraze ubacuje operacije, moženja i deljenja. Naravno ako nema nitih operacije onda se term direktno predstavlja faktorom, a faktor je konstanta odnosno terminali symbol number. Prvo ćemo videti implementaciju čistog prepoznavača koji samo prepoznaje sintak su izrazane, radi nikakvo procesiranje. Dovoljno su 3 file, prvi file je specifikacija leksičkog analizatora, ima extensio Lex, i pošto vi pruvčavate jaflex alat posebno na vežbama, nećemo se mnogo zadržavati na ove specifikaciji. Prvo sve se stavlja u ovaj varianti primera u paket parser sve file-ove, import je potreban da bi se scanner razumeo sa parserom, znači od parsera dobija ovu klasu symbol koja reprezentuje tokene, znači on će da ovaj scanner će da komuniciraju i generisaće se interface da može da sledžuje tokene cap generisanom. Parser ovdje niz regularnih izraza i kako se koji prepozna, vraća se odgovarajući symbol, znači ovaj klasni deo tokena, vidimo da scanner ignoriše razmake i konačno ako ne upali ni jedno od ovih predkodnih pravila, default pravila za neprepoznatih symbolna ulazova da se na izlazu ispiš odgovaruća poruka u grešci. File-sa ekstenzijom kupje specifikacija sintaksnog analizatora i on će biti procesiran od strane alata kup generatora parsera. Imamo deklaraciju paketa gde će se nalaziti svi file-ove smešteni, manje više pravoliniska specifikacija, znači deklariše su koji su gramatici terminali, koji su gramatički neterminali i onda ide niz smena. Ljava strana smena od desne je razvojena sa ovedveduva točke i jednako, a ako imamo više smina sa istom levom stranom, da ne bi stan opisali levu stranom, možemo kao skraćenicu staviti uspravnu crtu. Znači, ova druga linija isto smena, expression i expression add opterm. Niz tih specifikacija smena sa istom levom stranom završava sa tačkom zaraz. I tako vidimo da ovdje ona naša polazna gramatika predstavljena u kup specifikaciji. Na dalje imamo java klasu calc koja sadrži glavni program koji će instancirati. A otačo da vidimo, znači ona istu paketu parser mora da importuje kup runtime klase, tako da i kada se pokreće prevedeni program, mora u klas path putanji, postojat odgovarajući kup v10k.jr file. Pošto ćemo nešto ispisivati na izlazom, možda ne ovom primjer oli kasnije, znači imamo ovaj drugi import ovih io paketa javinog. Znači, glavni program instancira file reader nad ulaznim argumentom. Znači, programu ćemo zadavati ulazni file iz koga čita izraz. Zatim će da instancira scanner koji će jaflex alada napravi u obliku ovey yy klase i njemu se prosledžuje nači ova instancirani file reader. Zatim se instancira parser, to je isto tako automatski generisa na klasa parser automaton kup, i njemu se prosledži u je instancirani scanner. Zatim je samo potrebno aktivirati parser, tako što na objektom p pozovemo metod parse ili debug parse u ovom primjeru pozvanja debug parse. I to, kako izgleda struktura file-ova na disku na sajtu uzovu lekciju, nači će te i kao prilog sve ove izvorne file-ove. Znači, za ovaj prvi najadnostavni primer, prvo imamo zajedničke delove za sve primere, to su znači alatku.
 u oblikove jararchive za generisanje parsera, alato JFlex za generiskanje skenera, obješnjenje o ostomlji komandi koje ćemo mi videti ovoj elekciji i ovaj ulazni filo koji ćemo koristiti u primerima je sad u ovom folderu parser ovo prvog primera su ova tri fila koja smo upravo obješnjavali. Znači da biste primere preveri i pokretali, dovoljno je da startujete terminal. U lekcij su svi primeri dativu linux syntaxi da se koristi kosa crta da razdvoji foldere i dvo tačka kada se navodi lista putanja. A na Windowsu se samo koristi obrnutak kosa crta i tačka zaraz. Da biste pokrenuli sve ove primere, dovoljno je znači da sa sajta idk.java.net skinete recimo ako radite na Windowsu referentnu implementaciju i da kjave za Windows to je zip file koji raspakujete u neki folder na disku recimo c.jdk.15 i onda da biste mogli da radite sa java compilerom i java runtime, potrebno je samo da podesite putanjovo primere za Windows. Znači set path folder desite raspakovali javu, pa bin pod directorium. Na početku zatim tačka zaraz da razdvojite i stari sadrežaj ove path promenjive. Znači posle zadavanja ove komande možete proveriti sa java c.compiler.verzion ako vam se znači ne prijavi nikakva greška znači da imate sve spremno za rad. Esad ovaj prvi primer znači šta sve trebu raditi, treba izgenerisati scanner to je ova komanda koja vam se znači poziva ovaj J-flex. I c.t.cd znači da želimo da rezultate rada J-flex, odnosno ovaj file y y.lex java, smesti u folder parser, a takođe poštu se ova cela komanda zada je izkorena, primera Lex specifikaciju će naći isto u folderu parser. Znači prva komanda generiše ovaj izvorni file y y.lex java. Druga komanda je da se izgeneriše parser, izvorni file parser na baze one kup specifikacije, znači zadaje se ime ovoga jara koji sadrži u palat, isto ovde se ne piše samo c.t.cd, nego c.t.cd zdir da sve izlazni file ide u folder parser i ulazni file je ovakup specifikacije koje se isto nalazi u tom folderu parser. Znači u tom folderu parser ova komanda će kreirati parser.java i sim.java, to je definicija o nekla se Konstantysim, koje posle koristi skener da vrati rašte to kene. Deo izlaza kada se pokrene parser je izvešta i o radu parsera. Važno je da narao nema nikakvi grešaka, ovde se nabraja neka statistika o grammatici koja je urađena i ispisuje se da su odgovarajući izvorni file napravljeni. Zatim treba java kompajlerom prevesti sve java file koje smo dobili. Ovo je polazni kalk.java, potrebno je staviti klas path je tekući folder, to je korajn folder iznad foldera parser. Ovo je stoj dve tačke, na windowsu obi stelo tačka zaraz pa naveden jar file od kup alata on je neopkodan da bi se našao runtime klasa od koji parser zavisi. I sad ona što prevodimo je u folderu parser kalk.java. Dovolj na ova jedna komanda i da se navede samo ova jedan glavni java file, java kompajler je dovoljno pametan da nađe i sve ostale povezane java file i prevodi ih u klas file koje će isto staviti ovaj folder parser. Posito smo spremni da izvršavamo program, program se izvršava kada se pokrene java runtime, znači sad nema c, nego samo java, ovoj klas path je isti, kao što je ovde bio, pošto i runtime su potrebne ove neke pomoćne klase parsera. Parcer.calc sadrži main i navodi se u las.txt, u file u las.txt nalazi se samo ovo 3 plus 5, nema ni enter, nego direktno znači završen tekst oni file može naravno da se promeni primer u ovej prezentacije korišćen uvek ovoj ulaz i pošto smo tamo pozvali debug.parce, znači dobit ćemo 3 srada parsera, o čime suveravamo da parser zaista prepoznaje gramatiku i vide ćemo znači ovo svaki korak reče o shift 3d u zela iler jedan parseru, tako da vidimo odgovarajuće akcije koje takav parser radi i naravno ako je sve u redu, evo, izrašće biti ovakav, ako bi došlo do neke syntaxne greške u radu parsera, poziv me to da parse bi bacio iz uzeta, pošto mi to ne hvatamo u glavnom programu, znači program bi završio sa exceptionom u sluči syntaxne greška, ovo i primjer da bi bio dovoljno jednostavan nije uzima u obziru obradu od greške. Prelazimo na sredeću fazu i sredeći primjer, a to je prošlenje parsera se mantičkom obradom, želimo da naš kalkulatora čuna vrednost izraza. Ova obrada se može specificirati sledećom atributivno-translacionom gramatikom, znači onu polaznu gramatiku, smene su potpuno i ste, samo znači dodajemo atribute i atributivna pravila. Neterminali expression term i faktor dobil su jedan sintetizovan i atribut, koji predstavlja, znači vrednost dela izraza opisanom, datom, smenom i neterminal. Evo možemo krenuti od najjednostavnih ove pete smene, znači kad je izra samo nekakva celobrena konstanta, scanner će nam dostaviti vrednost konstante kroz ovaj atribut terminala number i potrebno je samo atributivnim pravilom to iskopirati u atribut ovog faktora. Naravno ako se faktor direktno menja sa term, reče samo okopiranja atributa, takođi u smeni dva kac e expression direktno menja sa term, radi se samo okopiranju vrednosti atributa. Jedin malo zanijansu komplikovanje procesiranja je kod smena 1 i 3, znači kada imamo sabiranje, znači imamo dva pod izraza, prvi je predstavljene sa expression, drugi je predstavljen sa term, znači kada vrednosti pod izraza dolaze, pošto reču sintetizovanja matributiva, znači bi će već smeštene u ovoj atribute e i t, i onda potrebno je uzavisnosti od toga koja operacije je u pitanju, a tu informaciju prosleđujemo iz, recimo, smena 6 i 7, tako što uzavisnosti toga koja je smena 6, onda će sintetizovanja atributa ovog neterminala add op dobiti string add, inače će dobiti string subtract, i onda kroz ovoj atribut op, znači njegom možemo ispitati njegu u vredno, u potrebljanu osabiranju ili oduzimanje, pa uzavisnosti od toga, nače koje bilo osabiranje, sabraćemo vrednosti e i t, i upisati u atributera, a koje bilo oduzimanje, naravno oduzećemo t o d, i upisati u er, vrlo analogno je urađeno za smenu 3, samo tu su pitanju operacije, množenja i deljeć. Znači, ovoj atribut od transfacijnogramatikem smo specificirali kompletnu semanitiću obradu koja naš kalkulator treba da radi, i sada vidimo kako se to programski realizuje. Praktišno nam trebaju i ste, oni filovi koje smo malo čas imali, znači to je specificacija leksičkog analizatora, ovdje je sada dato izlaz iz programa koji poredi tekst one filove, da se tačno vidi kako smo izmene u specificaciji skenera načinili, dobro promijeli smo ime paketa, sad je to paketa tributi, i jedina suštinska izmena je da u ovom pravilu koje prepoznaje konstant u taj instancu tok-symbola, to je znači koji klasa symbol reprezentuje tokene, taj token sad ima dodatni, to je onaj klasni, rednosni deo tokena, znači prosleđujemo instancu klase java klase integer i yy tekstam daje naravno tekstualni deo konstante koji je onda konstruktor integer konvertu je u naravno binarno vrednost, nači kroz ova javati integer prosleđujemo iz generauparser vrednost konstante, što se tiče specificacije sintaksog analizatora, tu su promene najveće, prvo moramo naravno uvesti atribute za terminal number, nači to je u specificaciji terminal pre imena terminal, a nači terminal ili neterminal imaju atribut, nači navodi se odgovarajući javati, to mogu biti ugrađeni javati, kao što ovoj number ima, nači tip int, ma da vidimo da posle mora, nači se prosledi integer, a neterminali, nači isto njihova tributi upravo java klasa integer i oni moraju da mislim da to i mora na nivou neterminala, svakako kad budemo treći primer, radi li vide, da na ovo mestu, kada se koristavite rastan sintak, stavila mora biti klasa, izvedena, iznaravno, nekada se java obđit, kao što sve klase po defaultu to rade, nači ne može biti primitivan tip podatak, a znači njihovo je korišćem primitivan int, nego integer koji to je klasa, koja oklapa, taj primitivan tip int i expression term i factor, imaju atribut tok tipa, a add op i mull op imaju java string, tako da se reprezentuje koja operacija je prepoznata. Sve ne sad imaju jedan novih delo koji se ranije nije pojavljivo i koji ovde vidimo, naravno, da je označen posebno da je dodat, a to je delo koji počinje sa ovoj vitićastom zagradom dve tačke, i završava sa dve tačke zatvorenom vitićastom zagradom, to su tako zvanje semantike akcije, i znači s mene koje treba da obave neku semanticku obradu imaju te semantike akcije, da se pocitimo botom appar...
 Prirodno prihvataju te akcije na samim krajevima smena i ovom primjero koji je dovoljavao da se mantičke akcije budu na samim krajevima smena. Alatku dozvoljava da akcije ne budu na samim krajevima ali rekli smo onda dolazi do one automatike konverzije, grammatike da se dodaje onaj novi neterminali, da su stvari takva akcije izvlači onda u posebnu smenu internu sve. E sad semantičke akcije, koriste i atribute pojedinih simbola sa desne strane smene i onda moramo imenovatite te atribute. Recimo, ovaj speni expression se menja sa terminalom, taj terminal ima atribut koji se zove t, znači piše term 2.t, znači to je ime tok atribute i usećamo se još iz one atributino translacione grammatike, pislalo je da u slučaju te druge smene treba samo iskopirati vrednost TUR, to je ovde naravno realizovano semantičkom akcijom result, i jednako te. Ime atributa na levoj strani se ne zadaje pove konvenciji 2.i me atributa, nego o leva strana ime njenog atributa uvek result. Jedinu malo služenju semantičku obradu imaju one smene za sabiranje i množenje, to je ovde ova svena kojima na levoj strani expression, na desne strani ima expression sa svojim atributom E, ed op sa svojim atributom pod nazivom op i term sa svojim atributom pod nazivom T, i vrednost atributa na levoj strani result se računa tako što se izraza. Ove u stvari programska implementacija ovog ovde izraza. Samo je malo komplikovanija, zato što moramo koristiti ona java tip integer i vršiti konverziv iz onog primitivnog inta. Kada imate integer, treba vam ta primitivna intvrednost, onda se koristi metod intvelju, a kad imate primitivnu vrednost, treba vam objekat integer, onda naravno iskoristite odgovarajući konstrutor. Kompletnu, tu semanitričko obradu smo ubacili u grammatiku i na taj način vidimo da se malo i za komplikoval. Ove file je bio vroj eleganthan i pregledan samo grammatike smene, a sad je to nekakva kombinacija smena i neko gjava koda za procesiranje semantike. Naravno, ovom jednostavno primjero to je šuvek dovoljno jednostavno, ali zamislite neki veliki compiler za neki veliki kompleksan programski jezik, kao što recimo c++, kome treba na desetina i stotina hljada linija koda, zamislite se o taj kod na neki način smešta na jedno mesto i još pomešta sa nekom grammatikom koja ima na hljade smena. Znači bilo bi vrlo nepregledna. Kako izgleda kalk klasa u ovom slučaju, osim što je promenjen paket, takođe ovdje sad pozvano čita početa kesti kao rani instanciranje file reader, instanciranje scanner, instanciranje parsera dostavljam u se scanner i poziv metoda u prvom primjero je bilo debat parse da bi dobili tress rada parsera, međutim u normalne uslujimo se poziva metod parse koji radi celoprocesiranje, samo ne ispisuje tress rada na standardom izlazu, sad nam to ne treba, nego ovo što je ovo dodato, to su posljedne dve linije, funcija parse nam vraća kao svoj rezultat ako uspešno završi parsiranje, dobit ćemo rezultujići objekat ko me pristupamo putem ovog usluštini interfacea simboli, interface simboli iz kupram tajma, prestavlja ustvari ona i simbol steka sa njegovom semantickom rednošći, usluštini to je taj simbol odgovara praktično startnom neterminalu grammatike po završetku parsiranja i možemo dobiti preko s.value sadržaj onog atributa koji smo definisali, pošto smo mi definisali stati simbol i expression i definisali smo da on ima atribut tipa ovog integer, s ovim custom možemo iz ovog simbola s dobiti konkretnu finalnu rednost njegovog atributa i onda ga ispisati kompletna niz linija za generisanje, genera generisanje parsera, prevođenje svih fileva i izvršavanje programa, i da je tako što zadajemo tako java, klas path, glavna klasa, ulaz, praktično će ispisati, na čak ulaz bio 3 plus 5, na izlazu će se ispisati rezultat 8. Evo možemo to u krajnjelini i kratko videti, znači ovo je sad window z mašina pa se vidi i malo druga čija, samo da nađem da ne bi kucal od početka, znači oza primer parser, rekli smo prvo generisanje scannera, znači ovo šta je ustvari realan ispis, znači scanner kaže da u krajnjelini da je naprave ove file yy leks.java u folderu parser, znači sledeće je da se generishe parser iz ovo kupfila, znači tu je malo veći ispis, na kraju ono što sam rekao i opet vidi se koji izvorni filovi su generisani, znači rekli smo prevede ovaj file calc.java koji smo mi sam i napisao, ali to će inicirati prevođenje svih ovih drugih generisanji povezanih java filova, znači ništa ako je sve u redu, nema nikakve prijave greške i konačno startovanje ovog našeg primera, znači ovo je najjednostavni koji da je trace rada parsera, a sad vađ da redom ide ovi filovi za ovaj primersatributima, znači prevođenje ovo klexičkoj generalizatora, zatim prevođenje parsera, zatim prevođenje compilerom svih java filova, tu on javlja nešto deprecati, dalito nije, ja koristimo naj aktonu verziu jave 15, alat jeste stariji malo, ima već godina, tako da li sve radi bez problema i konačno startovanje, smo chceli da vidimo primera sa atributima, znači zadajemo ulaztačka.txt, znači ispisuje samovrednost osm. Nastavljamo dalje, da uporedimo znači pojmove konkretnih i abstrakti sintaksnih stabila. Konkretno sintaksno stabilo smo pominjali u kontekstu parsiranja i rekli da ono strikno odgovara v gramatici i izvođenju neke konkretne ulazne sekvence. Za našu gramatiku u kalkulatora i u ulaznu sekvencu 3 plus 5, prvi radu parsera odgovara sledeće konkretno sintaksno stabilo, u njemu čvorovi odgovaraju neterminalima, a primena neke smene, recimo ove prve smene, gde je ove izsabiranje, odgovara čvoru u stabilu i njegovim neposrednim sinovima i tako dalje kasnije se ekspresno menjase term, term se menja sa faktor, a da bi smo došli do prvog broja, faktor se menja sa number na sličan načinu i u ovom delu stabila, ali nismo krenli od ekspresno, nego samo term factor number, naravno, onaj ed-op se menja u konkretnom primeru sa terminalom plus, tako da način kad povežemo listove stabila, vidimo number plus number, to je ono što dolazi iz genera. E sad koncept abstractog sintaksnog stabila. Izraze bi smo mogli opisati zna to jednostavnijom gramatikom koje opisuje njihovu suštino, a suština izraza su operandi i operaci operatori. I jedno od takvi gramatika je prostog gramatika koja ima samo jedan jedin tip neterminala ekspresno i ima sve ove smene, znači, da uvedemo pojedinačne operacije i konačno ekspresno može biti samo jedna celobrojna konstanta. Znači, ovakvom gramatiku možemo opisati izraz 3 plus 5 i dobit ćemo još jednostavnije stabila sa manje čvorova nego u predhodnom primeru. Znači, ovakvo uprošćeno da kažemo sintaksnom stabilo koje samo suštinske elemente reprezentuje koji su važni posled za obradu za semantiku, nazivamo abstractim sintaksnim stabila. Naravno, možemo se primjetiti da bi stabilo moglo biti još jednostavnije kad bi se objedinili u suštini svaki od ovih ekspresno sa ovim čvorom koji je neposredno ispod njega, što čak može u nekoj realizaciji programskog možete zamisliti, doćemo kasnije videti da ekspresno neka bazna klasa, a onda recimo, da kažemo konkretne mogu biti izvedene klasa, tako da ustvari instanca čvora stabila može biti ovde objedinjena. Znači da imamo samo 3 čvora, tako da 2 čvora su u vrednosti, a jedan čvori operacija što bi onda baž bila najkonsiznije izražena semantika izraza. Medjutim, šta je u stvari pojenta svega ovoga? Znači da abstrakta sintaksta stabila koja uprošćavaju konkretna i ostavljaju samo elemente važne za kasniju semantičku obradu, znači one su manje gobima i jednostavnija za svatanje da kažemo, i samim timi kod koji vrši semantičku obradu može biti konsiznije f-i kasnije ako se koristo ovost abstrakta stabila, nego ako se koriste konkretna stabila sa svim detaljem. Problem sa uprošđeno gramatikeom je dvo smisajnost u ovom primjerovi činjenica da ne specificirá asociativnost niti prioriteta operatora. Znači, ta i detalju gramatici nisam reka ovaku gramatiku ne biste mogli provući kroz kup, alat jer bi vam prijavio različite shift-reduce konflikte. Kroz rani je primjera, znaši, vi objašnjava, prva smjana koji imaju i ovdje i expresson, i ovdje i expresson, u suštini odmah ubacuje dvo smisajnost. Znači, ne možemo direkto koristiti ovaku gramatiku, među tim, ideja i sreć ako za prsiranje izvrza koristimo početnu gramatiku i parser, a zatim na osnovu konkretnog stabila izvođenja za sekvencu koje struišemo, znači, nakradno uprošđeno, to je abstrakno sintaksno stabilo, rešili smo problem dobijanja abstrakno stabila. Abstrakto stabilo možemo dobiti ako odgovarit će akcije za konstrukcije i povezivanje čvorova, stabilo ubacimo kao semantička akcija u početni parser za konkretnu sintaksu. Među tim, ostaje problem u opšte...
 U slučaju mapiranja konkrete sintakse, ako ne razmatamo samo naš prijanj, jednostavno prijanj kalkulator, nego zamislite da imamo zadatak da napravimo compiler za neki odbiljan programski jezik, nači mi moramo posebno definisati abstractnu sintaksu tog jezika, moramo odvojenu, naravno definisati konkretni abstract na sintaksu i manuelno ubaciti u parser sve te semantičke akcije da se konstruiše abstractnu sintakstnu tablu iz konkretnog stabla. Nači kad je u pitanju neka složena sintaksa, onda je to delu jako sve to treba ručno raditi, delu je kao veliki posao koji onda anulira prednosti korišnjenja abstractnog sintakstnu stabla samo po sebi. Međutim alternativni pristubi bio da si skoristi počet na konkreta sintaksa jezika i automatki izgeneriše abstractno sintakstnu stablo koje u tom slučaju nema mnogo abstractsije. Recimo mogu da se u ceku delovi konkretnog stabla izvođenja od izabranog čorana niže, ako nemaju semantički značaj, ali prednost ovog pristupa je da može da se skoro potpuno automatizuje, znači u zminimale intervencije na polozne gramatici automatiske mogu da se izgenerišu sve potrebne strukture podataka za dalje kompajrevske obrade. Ovoj pristup imenjenje proširivanjem standardno kupa lata i to je osmišljeno upravo na ovom kursu i realizavano kroz jedan diplomski rad kolege Dušana Stankovića pre više godina, a mi upravo taj prošireni alat kup koristimo i za projekat na kursu i zato je to u suštini i vama sad važno, jer ćete praktičan da je oraditi upravo na ovaj način, a u nastavku predavanja ćemo primeniti ovaj pristup na ovaj primer kalkulatora da bi smo videli samu suštino pristupa. Ovo je sad treća varianta primera sa abstractimu sintaksnim stavnom, da vidimo kakve smo izmene pravili u onim filovima od koji smo počali, znači imamo specifikaciju scannera i on je potpune isti kao kod variante s attributinom trasecima, znači samo dodajemo to canu number da vraća ili tako brojnu vrijednost konstante, što se tiče specifikacije parsera, ona naravno mora da pretrpi izmene i zgodnije gledati u odnosu na polazno variantu čist parser koji nije imao nikakvu semantičku obradu, u ovoj varianti u suštini specifikacija parsera trpi manje izmene pogotovu, znači u pitanju kompleksna semantika kao u compiler, znači zove mali primer deluje da ovde postoje neke znate izmene, ali što je veća semantička obrada, videli biste da u stvari su to prilično minorne izmene u samoj specifikaciji parsera i grammatike, znači dobro menjamo opet packet je sad je asset, ovde kao i rani je, pa što je ovu odnosu na čist parser, znači dodali smo da to can number ima tribu ceo broj, i sad po novo expression term i factor, neterminali imaju svoj semantičke atribut, rani je smo ovde koristili direktno integer, znači onu standardnu java. Klasu međutim, ovaj prošleni kupima to ograničenje da ako bi upotrebili neki primitivan tip, ili tipove kao što su integer i string, znači oni mogu da se upotrebe, recimo, ovaj add op i mulop mogu oni vraćaju, znači tip javas stringa, međutim tada alat seče abstractno stavlo, znači to možete da uradite na ovim krajevima, ovde ideja da stavlo malo uprostimo, tako što nećemo eksplicitno u njemu reprezentovati ove smene kad se add op menja sa plus, nego ćemo prosto samo izvršiti, znači to su jedine semantiće akcije koje su ostale, da se ovom add opu dodeli rezultujići atribut, i u suštini vide ćemo da naše abstractno stavlo i nema add op kao poseban čvor, nego će se on samo prosto dodavati kao atribut ovih čvorova u kojima se on kasnije javlja, znači to su expression i ova smena gde se upotrebljava add op. Dobro, da se vratimo na suštinu, znači za ove grammatike neterminale koji imaju svoje reprezentacije u abstractno-syntaxo stavlu, atribut mora biti neka izvedena, znači koristička klasa, pa smo mi dodali, pošto nam u suštini treba panitima samo jedan cel obroj, ali kažem to mora da se realizuje tako što moramo da uvedemo jednu klasu, i sad tu postoje dve variante, jedna varianta koja nije privenjena je da ova klasa prošiluje, ona, ova klasa integer i onda bi smo morali obezbediti i konstruktor, pošto integer nema default konstruktor, međutim, ja sam ovdje uzel krenu ovim putem da u suštini ove variu bude kao neki zapis, znači nema nikakve metode, nego ima samo javno dostupan celobrojno polje v. I znači, tako ćemo pamtiti semanitški sadreža ovih naših neterminala u abstractno-syntaxo stavlu, za ove druge netermine rekli smo oni neće ni imati svoj reprezentacije, znači malo ćemo skratiti konkretno-syntaxo stavlo, i sad ide ona specificacija grammatike sa smenama. Ta ideo specificacije trpi jednu vrlo malu izmenu, naravno i dalje mogu će koristiti po želji semanitške akcije, ali to ovdje je samo, ajde da kažemo, specijalno slučaj kad želite da malo skratite stavlo i da u toku parsiranja da kažem prosledite, dobar će podatke do delova stavla koji ostaju, jer kako što sam rekao, znači u abstractom-syntaxom stavlu recimo, e dobiše neće imati svoju posegnu reprezentacije, znači moramo nekakve vrednosti iz njegovih smena ako postoje, još u toku parsiranja proslediti do nekog čora stavla koja ima semanitšku reprezentaciju, a to je, kažemo, ovdje u prvoj smeni, ovo pojava edop. Međutim za ove normalne, znači to je specijalno slučaj, ali normalno slučaj znači da će smena imati svoju reprezentaciju abstractom-syntaxom stavlom i onda ta reprezentacija mora da se imenuje. Ovde dodajemo u svaku o tih, normalnih smena koja će ostati u stavlu, imeno je mojih na taj način, što i na samopočetku desna strana smene, u zagradi stavimo ime smene koje mi odabiremo, proizvoljno danas asocira na neko znacenje smene, recimo, single expression ako se c-expression svodi samo na term, a adišanje ako se pojavljuju oni operatori sabiranja ili oduzime. I tako dalje, sva kao dovi smena koja će imati svoju reprezentaciju stavlu dobia svoje ime. Još ćemo u nastavku detaljno razmotriti kakva u stvari struktura tog syntaxom stavla, ali prvo da vidimo još što u ovim našim filovima koje smo pisali, u primeru koji niso automatski generisani, što još imamo kao sadaržaj file, ka lk, java, osim što je izmenjen paket, ovo je opet u odnosu na variantu chisparser, način, varijanta chisparser je imala ovih prvih nekoliko, način do poziva parse, dobro u varianti chisparser je bio debug parse poziv, očigljeno komparaciju nisam baš striktu radi u odnosu na taj file, nego sam uzeo chisparser u kojem je pisalo samo poziv p.pars, pa je ovo prikazano kao deo koji nije promenjen, je sad, način, ide ona ideo koji su stvari odnosi na sevantiško obradu i sve ovo nad zelenom su stvari ubačene nove linije. I kako smo već videli orijenti sa tributima, to je da ako parse uspešno zavaši rad, mi dobijamo kao povratnu uvrednosti iz metoda parse, stack symbol koji odgovara o nom startnom simbolu grammatike, i to je, način, njemu pristupamo preko ovoga interfacea simbolu iz javaka prantima i rekli smo onda s.value može da nam da se mantiški sadaržaj do varianti, ovoga proširano kupa lata, značin, kad se uključa abstract nosintaxa stabla, onda uvodi se posebna klasa u abstract nosintaxon stablu za svaki neterminal koje ima isto ime kao neterminal sa početnim velikim slovom, tako da pošto se neterminal zvao expression, nam je alat znači zgenerisao tu klasu expression da predstavi startni neterminal u abstract nosintaxon stablu i onda je sveli u stvari možemo da kastojamo na objekat t klase. E sad znači to je u stvari koren abstract nosintaxon stabla. Ako želimo, znači, sada da obrađujemo abstract nosintaxon stablo, tipično je da za svaku obradu obezbedjujemo poseban ovaj vizitor koji u građena znači obrada čorova stabla i onda nad korenim čorom stabla pozovemo odgovarajuću traverse funciju, alata automatki generiše dva moguće i teratora znači se obiđe stablo od naka vrhu, znači listovaka korenu ili top down, znači da se prvo, to odgovaraju o nim post-order i pre-order ili tako bilaskima i struktura podataka, znači, mi želimo ovdje da način kako računati ili tako izraz odgovara obilasku stabla od naka vrhu. Tako da, znači, to, ajde da kažemo i terator ovoj traverse funciji, proslajđujemo odgovarevići vizitor koji specificira šta ćemo raditi u svakom čvoru kada dođemo pri obilasku odgovarevići čvor. Naravno, našo semantičko obradat će se svoditi na računanje vrednosti izraza i mi u ovom čvoru x-pression koji reprezontuje startni neterminal, uveli smo taj semantički dodatak je prekove klasse value, tako da će taj čvor videćemo automacki generisornom kodu, imati member, znači, polje value koje public vidljivosti i onda ovdje jošivamo, ovdje ovoj konkretan u instanci klasse value, moramo reći, ovo je ste za nijansu, ajde da kažemo, neelegantno, ali na taj način moglo je naravno da se to sve oklopime todama i šta ja znam, ali prosto tako ovdje odabrano, nači preko tog instanci klasse value i njegovog polja value u ovom objektu koji u abstractno sintakson stablu reprezentuje koren i čvor, mi ispisujemo u suštini finalnu urednost izraza, takođe ovdje ima još jedan ispis, a to je da se ispishe celo stablo u svom tekstolnoj reprezentaciji automacki generisan kod, nači za prakajčno svaki čvor stabla automacki generisuje i ovu to string metod, i kad se...
 da on pozove nad koranim čorom, ispiše se izgled kompletnog stabla, to ćemo isto videti u nastavku. Znači, već sam pomenuvao da mi moramo te vizitori da specificiramo i zato u odnosu na sve ove predkone primeri, ove primeri ima još jedan dodatan file četvrti, koji mi luchno pišemo to ovoj aritmetik vizitor.java, ali njega će boku prvčiti malo kasnije kad bude zgodno. Kako u ovoj varianti primera prevodimo i pokrećemo program, prvo što se tiče generisanja skenera i parsera sa podeškom za abstractno syntaxom stavlo, znači generisanja skenera ide na potpno isti način kao ranije s tim što je sad, znači folder ovaj asset, a generisanja parsera ima malo više ovih parametra komandelinije, znači, kao i ranije naravno poziva se java, ovoj crtice jare ime ovog kup alata, dest dir smo imali kao i ranije, znači da svi generisani file idu asset, je sad ovo su dva nova parametra komandelinije, crtica asset, asset, nam u stvari govori ime paketa u koje znači zato je generisane klasse, abstractno syntaxom stavlo, to su automatice generisa i na java klasse, i ovde je samo na ovaj način se naznačuje da trebu baciti u te java file, ono package asset, i konač ovo crtica bil trije važna opcija koja govori proširenom kup alatu, da, sto je kažem prošireni kup alat, znači to nije standardni kupo rakoka kako ono opisan, nego možete naći na sajtu predmeta u delu sajta domači zadatak, način se nalazi dokumentacija za ovaj prošireni alat kup, i plus ovaj znači lekcija, predstavite isto jedan pokušaj da se objasni sušti na alat, znači rekli smo bil trije važna parametra komandelinije koji inicira generisanje svih, znači potrebnih klasa za reprezentacija abstracto syntaxom stavlo, i naravno ovo je ona i ulazni kup specifikacija, ovo ja sam dao sliku, znači foldera, i da se vidi da kao rezultat ovi komandi i naovo je bilo na početku, u kajim uklavnih klasa sam dao su uklavnih klasa, i od koji smo krenuli, to je lekcija, kup specifikacija parsera, kalk java, i aritmetik vizitor, ova četri fila su uklavnih klasa, sve drugo je automatki izgenerisan. Ipsam ipsam lekcijava je skener, i je jaflex alatom izgenerisan Veryflex. Inači smo i rani je pominjali, sim java je ona i file koji služi za synchronizaciju između skenera i parsera i koji generiše kup alata automatki, zatim parser.java i parsera automatki. I pa se ovi filovi su tatri fila i ipsam i ipsam lekcim i parser su bili u raniim primerima jedini filovi, koji su bili automatki generi se, ne sada ovo primjera u sasota, imamo još gomilu drugih filova, prvo kalkasad bil.kup, može da izviozove intre, i to je radni file, da će njega potpuno zanemariti, možete ga naravno pogledate, ali ne treba ga nina koji način editovat, i ni ti on ima neku posebno život van ovoga da kažem glavnog fila. To je u stvari prilagođeni file i na bazi ovoga, u koji su ubačene semantičke akcije za izgradnju abstractog syntaxom, stakblatog o kompersiranja. Tu nas je ovaj prošeren jalat, oslobodio posla da mi smišljamo kako ćemo izgraditi syntaxom stavlu. Dodatno samo, znači svi drugi filovi koji su ovde po ovaj video, ako ja još nisu vam pomenu, su u stvari filovi koje reprezentuju abstracto syntaxom stavlo i osnovne obrade, projektni šablon visitor. Evo, sad ćemo videti o čemu je rečimo. To su filovi syntax node, visitor, visitor adapter, to su razne klase interface. Expression, turn factor tu to prepoznajmo, to su imena gramatickih neterminala, addition, multiplication, single, expression, single, turn, constant, to su imena o njih smena, znači svaka smena je zasužila posebnu sobstvenu klasu i to sve znači predstavlja podrešku za abstracto syntaxom stavlo sa obilaskom čorova po visitor šablonu. Svi ovih filovi su automacki generisani i ne sve se u njima ništa ručno menjati, jer će te izmene biti uklonjene pri ponovnom pokretanju kupalata, značeku bilo šta menja, to onom polaznom kup filu uvek mora da se ponovno pokrene kup palat i generisani filovi će biti prvo obrisani pa posle tako iz generisane nove varijante. Bolje nego gledanje samog koda generisanih filova je gledanje klasnog diagrama prvo koji prikazuje znači statičku strukturu ovoga abstracto syntaxnog stabla znači klase expression, term i factor odgovaraju neterminalima u grammatici one implementiraju interface syntax node i time obezbeđuju obilaza kstabla ali ove tri klase su abstractne klase i one se ne instanciraju direkno tokom rada parsera ove klase na dođem nivou a to su addition multiplication, single expression, single term i constant odgovaraju imenovanim grammatickim smenama svaka od njih proširuje klasu neterminala kojem smena pripada koji je znači na levoj strani smene takođe primetite da nema neterminala add up i mull op znači oni nemaju svoje klase niti smena za njih ovih delovi parsersko stavla neće se pojaviti u redutuji ali informacije za ovih smena su korišnjeni semantičkih akcija u parseru prosleđene smenima u kojima su add up i mull op pojavlju i zapamćenje u poljima odgovarajući klase klas addition ima to polje add up koju stvari tipa string kad baš gledamo tu klas addition ona se jedne strane obezbeđuju informacije od esto i strani smene kroz svoja polja, jedna desna strana smene jer tako bi li su neterminali expression u suštini tu imamo 3 polja koji predstavljaju reference odgovarajući a za expression i term su u stvari reference na odgovarajući ovaj objekte koji su ove klase takođe ovaklasa klase smena obezbeđuju konkretnu implementaciju accept metoda kao dela šablona vizitor i implementaciju iteratora kroz tablo traverse to je svijet automatski generisan kot koji mi ne moramo da radimo u opštenj slučaju šablona vizitor obično se recimo ovi iteratori ne stavljaju ovaku istu klasu kažem kao samo stavlo ali nam je zbog jednostavnije korišljenje i manje ovi generisani klasa prosto stavili smo da to bude deo samih ovih asut klasa imetod to string koji može da nam bezbedi izpisivanje stavla praktično rezultujuće abstraktog sintaksnog stavlo nastaje kao rezultat rada parcera procesiranja konkretno gula zabijeća struktura sastavljena od instancji primenjenih smena od instancji ovih ovde klasa ovom donjem redu posebno se generiše interface vizitor koji ima po jedan vizitor metod za svaku vrstu čora vidimo kako za ovde čvorove koji reprezentuju neterminali i za čvorove koji reprezentuju smene po jedan vizitor za svaku vrstu čora i automatski generisa na klasa vizitor adapter koja implementira interface vizitor obezbedjuje prazne vizitor metode tako da nemoramo vizitor metode koji nemaju nikak u semanitiću obradu ali obezbedju nastavak prolazka kroz stavlo i na ovom diagramu jedina klasa koja nija automatski generisa na kojem mi moramo da napišamo ova klasa arithmetik vizitor takle klase uvek nasleđuju se iz ovog vizitor adapter i tu samo redefinišemo one metode za one čvorove koji su nama zanimivi gde imamo neku semanitiću obradu prenego što pogledamo taj arithmetik vizitor na ovom diagramu klasu da vidimo znači ovo je objektni diagrama spraknog sintoktog stavla za konkreta nulast trip usp. po završetku prsiranja parsev rača referenci na koren ove asatostrukture ona je sastavljena od instanci klasa koje predstavljenju imenovane smene sa informacijama o levoj strani smene nasleđenim iz bazne klase prikazanje znači sadržaja i stavla pošto se aktivira prolaza kroz stavlo od nakavrhu videli smo da se ovoj main funcij pozove traverse botom appi teratur ove vidimo da ove vrednosti objekta value su već izračunate znači to je po završetku rada tog iteratora aritmetik vizitor je poslednja klasa koja je ručno napisana koja još nismo proučili ovde se nalazi kompletna semanticka obrada a u ovom primero to je računanje vrednosti ulaznog izraza reprezentovanog ovim asat stavno taj vizitor je nije z ovih visit funcija koja je sredefinisane pošto nasledujemo vizitor adaptera on ima reklismo prazne implementacije tih vizitora redefinišemo vizitor je gde nam treba neka semanticka obrada kad se poseti odgovarajući čvor onda se radi semanticka obrada ovaj slide i sledeći slide isto prikazuje razne ove vizitore ja še vam odeteljno sve vizitore ali rec ona smena vezana za adišn je dovoljno da možda zavređuje posemno obješnjenje znači metod vizi dobia objekat tegu čvorak o svoj stvarnijar argument čvor addition ima pođa za svoje sinove u stablu i oni su već obiđeni kod bottom up prolaska do tih pođa se dolazi preko ovih getizra znači da na 10 str. me ne su expression i term oni je su u generisonom kodu da kažemo dobro i praksiji
 o programiranja, znači privatni su poljapa sa geterima i seterima njima pristupa. Ove metodi značunava informacijani sadržaj tekućeg čvora to je stvrednost value objekta. Na osnovu vrednosti value objekata u sinovima koji su već obiđeni u ovom trenutku, pošto ovom botomapp obilazak i na osnovu vrste operacije, znači to dobijemo opet iz ovoga, znači isto imamo add-of polje pa get add-op pa njegova vrednost je string i onda znači ispitujemo da li u pitanju sabiranja ili oduzivanja i raču najma znači ovu rezultu juću vrednost. Treba primetiti da prva stvar koja se radi ovom vizutoru je da ovo polje value koje smo rekli da je opet sa public pravima pristupa i onda možemo da ga direktno nisu napravljani geter i seter nego samo. Znači direktno opristupamo polju i moramo instancirati novim value objekat to je zato što u generisanom expression ne vam ovde možete sami pogledati kako izgleda automatski generisana klasa recimo ili addition koji nasleđuje iz expression ali mislim da se to naladi to je samo nasleđeno polje znači iz klasa expression i tamo se u stvari taj value objekat ubodi tako što ko stoji samo jedna automatski generisana linija public znači tip veliko value ime polja malo value jednakon null znači kada instancirati u stuštini u klasa addition ovo polje value je null tako da mi da bi smo zaista pamptili objekat value uvek moramo znači pri dolasku u čvor prvo instancirati objekat value zanimljimo recimo ovom vizitevom kad pričamo o tome pošto je tu direktno to je smena koja na levoj strani ima expression na desnej strani je term i mi tu ne moramo instancirati posebano objekat value nego samo praktično preuzimamo referenco pošto smo veći u okviru term instancirali znači ponekad možemo preuzeti postojeći referencalo ovdje pošto nam treba novima među rezultat na bazi postojeća 2 znači od ova 2 postojeća objekta value u njihojim procesiranjem pravimo novi objekat value znači u ovom primjeru s liča način ještvora možemo zadati komande za prevođenje i pokretanje znači prevodimo samo onu kalktačka java glavnu klasu java kompajorom ali to će prevesti sve ove ostale generisane java fileove i konačno pokretanje na potpuno isti način samo sad je paketa sad nači isti ona je ulazite x t 3 plus 5 i ono što će ispisati ova varijanta rešenja je prvo finalni izlazni rezultat 8 a zatim kao posledica ono ko poziva tu string metoda nad korenom abstract x intact x tablet praktično će nam ispisati ajde da kažemo linarizovanu tekstolnu predstavu stavla u obliku nekakve hierarchijske liste gde vidimo da je koren stavla addition unutar toga način na prvo nivom imamo single expression add single term to je u suštini evo upravo ovo znači add jo o u suštini nije poseban čvornego ispisuje vrednost ovo ga member ajde znači taj tu string je dovoljno pametan automatski izgenerisan da zna da ispisa ovo add nači kao vrednost kao ima sadržaj čvoraj međutim je tjede jo što ne zna da ispisaj košto tu string metodi ne pozivaju to je možda nekog nečenju implementaciji značeku mi smo navelio na dodati informacije nista držane veli objekat način ne poziva se tu string za velju tako da to ona osmica što ispisana je posljeća toga što smo mi ekspresetno ispisivali za koren i čvor međutim ponegde na nivou ovih konstanti to je pošto nema onog nižeg dela stavla to je isto kao i ovaj adopt direktno member način u onom generisanom kodu pa će ispisati 3 i 5 konstante to se u stvari vidi u ovom ispisu znači da su konstante 3 i 5 ekspisane ispisane sa tu stringa ova kažemo osmica nije došli iz tu string nego posebno ispisam eva možemo probati ovde ja sam cao taj primer iskopiro lokalno i da vidimo varijanta sa asat evo znači generisanje s genera zanim generisanje parsera i abstract syntax stabla ovde zanimljivo ovaj deo je dodat a st extension nači po tome vidite da nije standardni hxt nego da smo aktivirali ovu extensiju i on ispisuje koliko je file ova nači to uvek treba proveriti malo da vidite da ste dobiljano što ste očekivali posle toga znači prevodimo compilerom sve java fileve nači opet da je malo neko upozarenja, al to nije ništa strašno i evo sada znači primer AST pokrećemo za ulaztačka txt i dobijemo upravo ovo što sam ja i u prezentaciji ubacio i sad u zaključku postavlja se pitanje da li je ova varianta abstract syntax stavnom koja delu je na prvi pogled značit odsloženije a to je ovo s atributima bar u ovom primeru i akcijama vredna tluda je sad za ovaj prost primer da je ovo dosta komplikovanije ali kod uzbiljnih primerna, svaki semantiški prolaz odvojio bi se pisanjem posebnoj vizitora i kup file ne bi se ni na koji način opterećival i još da napomenem da je ovo bio samo na elementarniji primer korišćenju ovoga alata a znatno složeni primer to je projekt što kompletan compiler sa syntaxom semantičkova analizom i generisađen koda za jedan podsku piezika mikrojava nalazi se u okviru vežbi na sajtu predmete i to je mini domaći znači to je jako važan primer koji treba da proučite pre nego što budete radili vaš projekt
