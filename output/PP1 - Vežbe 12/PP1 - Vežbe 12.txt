 Kako imate nekakvih pitanja, pišite slobodno vamo na četlu, a da ja krenem s gradivom za poslednje 12. Kajste je, jaš bilo iz progomizgih prevodeje? C'e je? E, tema naše danšnje, naše danšnje krasve će biti u svarim neka po izvošnjeno ukruženje, to je to da ćemo se sada baviti malo i progromskoj mjezikom paskal koji ste veratno već zaboravili, bese tamo nekde na prvoj godini, ali aj dobro da krenemo tako se prvim dodatkom, pa ćemo pokazati odmok na tom prvom primjelu šta ideje šta ćemo sada od danas ovde zapravo razmatriti. E, alga, projzda datak. I dobili smo ovde sa stranja tako nekakav paskal kot, kažemo na mode danam ili tako dat nekakav program koji je napisano na jeziku, reći ćemo slično paskalu, da krenemo ratura bude baš paskal, možda bude bilo koji jezik za koji će važiti sa ta neka pravila koja ćemo reći. I posmatram u trnutak izvašavanja programa, nepo srednopred prvo povratka i sada neki tamo kredidure R, vide ćemo za pojitu trnutak. Prevoda prestaimo izgled oblasti za steka lokaciju promenivih podprestup, i rekostakom da se za glavni program pravi aktivacijuni zapis. E, sad, učeli se reć na dosta predmeta, sigurno šta znači šta je taj u svariji aktivacijuni zapis, kako su svariji pozivaju nekakove procedure, šta se tu uredom pakopakuje na stack, ali ajmo samo da pogledamo zbog čegu uzimamo paskal kao primer i šta nam je to interesantno kod jezika paskal. Pa, biće nam interesanto to što je, na primer, kot paskala, možete imati definisenu jednu proceduru u nutar nekakve druge procedure. Ovdje ja, na primer, imam samo definisane procedure RTQ, ali videte ćemo kajsni reću zadatku 2, da na primer, u nutar svaki od ovdje dne procedure, vi možete definisati neku novom procedur. I to može ići u tako u proizvodnu dubino, dakle, možete i definisati kod ikogod koćete, tako jednu u druge. I tu će sam da javljati neka problem. Ajmo da pogledamo sad odmah i šta se ovdje daš o ovom našem programu. Dakle, mi, ovdje sad, karna odmah u ovom programu, kako izgledaju, kako se pišu, da se potetimo malo paskala, zb. ovo je našo tako gledaný program gore, koji standardno ima ta jedna argument, autkut, i ovdje dole njegovo telo, dakle, ovdje dole beginient, to je i odnaceno ovim komentaram ovdje program B. Mi, ovdje, zapravo, pozivamo proceduru Q, ovoj procedura ovdje, i u nutar te procedure Q tu se poziva procedura R. Procedura R to nabija ova procedura R ovdje, i ona sad tu ima nekako svoje rekursivno pozivanje pod neka kem uslovo. Sad, šta ugodimo mi ovdje šta će biti novo i zašto vopštovo sve spominjam. Ako pogledamo glavni program ovdje kada kažemo A je jednako 3, mi ovdje stvari kao ovo A koristimo ovu gore globalnu promelju, to je ovdje integer koji je detini. Ako pogledamo proceduru Q, opet imamo ovdje nekako A je jednako 2, međutim to A tu se tramutno odnosi na ovo lokalno A, u nutar ove procedure Q. Ako ukliko pogledamo proceduru R sad da ovdje koristimo ovdje nekako A, koja A sad da koristimo tu? Pa ne ovo iz procedure Q, nego koristimo ovu A al tako iz blavnog našeg programu. I to će biti sad ideja, to ćemo rešavati već ideja ovog našeg današnjeg časa, a to je slijedeći problem, da je ovdje sad u nutar ove procedure R, treba da pristupite nekako i promeljivo i A, međutim to nije vaša lokalna promeljiva, nego je sad kog u ovom konkretnom slučaju globalna promeljiva, ali znamisli te da je možda to čak i promeljiva neke vaše okružoviće procedure. E sad, šta mi imamo kada pakovamo? Znajmo odmok to da prikažemo ovdje, dakle ovu pravo imate ovdje ispisano sve na ovom slajdu što se mi ga pričao do sad, a odijemo jedan dodatak. Dakle kako izgledao naš jedan aktivacijni zapis, to jest jedan poziv nekakve procedure do sad. Pakovali smo prvo nekakve parametri procedure, dakle oni su išli prvi, i sad smo pakovali, al tako to je radlo, ona metoda iz koja je pozivamo nekakvu drugu metodu ili funkciju, proceduru kako goto otvorite, zatim je ona stavljela povratno adresu, gde treba da se ratimo iz nje, i onda se čuvala, al tako, nekako polje kontrolne reze i ispod njega su išle lokalne promeljivite nekakve procedure. I sad, ako pogledajte ovdje, ja ovdje kada pozivam ovu pu, došao abih al takvu proceduru ku, kada pozivam r, ovdje al tako se obi se pakovalo na stack, međutim kada dođete ovdo u ovo r, kom a vi treba da pristupite, vi treba da pristupite nekakvom a, koje se nalazi otakvo u glavnom programu, zamislićemo da je glavni program kao što je piše, tamo ima svoj aktivacijun i zapis. Znači da bi ste vi onda iz ovoga r, morali preko koja polja kontrolne veza, otakvo da se vraćate u proceduru ku, pa zatim da se vraćate koj je skroz nazad otakvo u glavni program. Ideja, kojih pristupnih veza ovdje, je sledeća. Za razliku od kontrolnih veza, čija ideja da vi u stvari imate nekakav nazoji pokazivač na onu na aktivacijun i zapis procedure iz koje ste došli u tu tekuću proceduru, ideja pristupne veze je ste da imate neka pokazivač na proceduru koja vama direktno okružujeće kada statički gledate kod. Dakle, ako gledamo sada o ovdje, šta će biti kontrolna veza o ovdje, čemu je kontrolna veza kada imate u proceduru ku? Pa tu kontrolna veza treba otakvo da nam služi da bi smo znali kasnije da se vratimo vama u main. Kada dođemo do ovoga era ovdje iz ku, kada pozovemo eš, tu namo tako tako kontrolna veza služi da se mi nas nekako vratimo tako i da dođemo nazad do ovoga ku. E, međutim, ova naša pristupna veza, koji ćemo uvesti kao novopolje uunotar jednog aktivacijunog zapisa prihli kom poziva procedure, je služiti da nam kaže koja je to, kada mi statički gledamo program, nekada ga izvašamo, nego kada gledamo, kada bukvalo ovako stanete i gledate ovaj program ovde i posmatete na primver proceduru ku ovde. E, ova pristupna veza treba da pokazuje na aktivacijunog zapis njenu direktno u kruživicu proceduri. I to će, naravno, u ovom slučaju, ove biti glavni program. Međutim, na primver da imate neku proceduru koja je ovdje unutar ovaj procedure ku definisana, njena pristupna veza bi pokazivala na ovod našu proceduru. Pa ćemo sada vidjetel tako šta će tu desedes. Ano, rednom, da imamo kako sad izvoda ovaj naš program ovdje. Kredli smo da i glavni program ima svoju aktivacijunog zapis, tako da njegova aktivacijunog zapis će izgledati ovako. Idemo redno ovde se strane će ovo ostaviti, kako izgleda jedan aktivacijunog zapis, s kojem rednom se išta stavlja na tek. Dakle, rednom, da idu parametri, pa ta pristupna veza povratna adresa, kontrolna veza i onda lokalne promelje. To se tiče glavnog programa, posmatra tuvek, kako on izgleda da klima jedan parametar. E, ovo je parametra odkut, njegova pristupna i kontrolna veza su naozati, što tako izglednjega ne postoji ništa, povratna adresa ovdje narodno postoji polje, ali to polje nikad nećemo koristiti, i tu postoji nekakva glavna promeljiva, to je ovo ovde naše A. I ovo je jedan aktivacijunog zapis, to je to bi bio ta aktivacijunog zapis naše glavnog programa. Šta se dalje dešlo? Ni u glavnom programu, ovo A postavljamo na 3. Dakle, koja A se u stvari postavljamo na 3? Pa ovo ovde, gdje nam je trenutno base pointer, pa base pointer trenutno pokazaju novu kontrolnu vezu ovde, tako da ćemo ovde i globalno i promeljivo, i A ovde zapravo pristupati koja o tako BP, pa on dol tako ispod dole, svoj naoziti dakle BP-2, jer nam u tako steka rasteka nižima adresama dolem, dakle, ovaj se naozina BP-2. I tu ćemo mi postaviti zapravo, da ćemo upisati 3, a zatim pozivamo proceduru Q. Dakle, u sledećem koraku, ovde na već sada piše 3, a pozvali smo proceduru Q, da je u sledećem koraku, da piše 3, a pozvali smo proceduru Q, ona nema parametre, tako da ovoj prvi del goril tako se neće pojaviti, formiramo polje pristupne veze, reka smo treba da pokazuje na aktivacijon i zapis okružujuće procedure, pošto nam je sada i glavni progran se konaša kao nekada po procedura, onda ću crari ova pristupna veza i kontrolna veza, dakle, jedna i druga će pokazivati ovde. Ode codna da svo graničim, dakle, u što se piše polja pristupne veze, tako da je na početak aktivacijon i zapisa, ali ja ću koristiti ovu varijantu gde u stvari to polje pristupne veze pokazuju stvari na polje kontrolne veze tako toga aktivacijon i zapis, u principu moš da koristiti jednu i drugu varijantu. Pristupna veza Q pokazuje da je od tako njena direktno kružujuće procedura, kada statičkih gledamo u stvari ovoj naš glavni progran. Povrat na adresa nekako smo je formirali i kontrolna veza, kontrolna veza će uvepokazivati na aktivacijon i zapis procedure iz koje smo pozvali u proceduru. Dakle ako smo Q pozvali iz ovog mejna onda otak u kontrolna veza pokazuju na taj men. Ostaljamo naravno prostor za lokalnu promenivu, to je ovo A ovde, krenutno otak u njegu u rednosti su vidim smetni postari. Zatim, u telu procedure Q, kada kažemo A je jednako 2, mislimo naravno na lokalnu promenivu A, onda trte procedure Q, tako da i njoj pristupamo odmah direktno odnosno na base pointer koji će sad aprikazivati otak u ovoj. Uvijisvamo otak u nekakvu dvojku a zatim pozivamo R. Pozivamo R, kaj u ovdje, otak u dvojku smo upisali pogledate proceduru R, nema, ako argumente, dakle nema parametara, pristup na veza, sada ovde, rekli smo pokazuju na direktno okružujuću, statički gledanom. Statički gledan direktno okružujuće oko ovoga R je glavni program, tako da vidite dola crvena linija i te gore na glavni program. Kontrolna veza i još jednom ponavljam, uvek pokazuju na pozivajuću otak u proceduru, pretkodnji aktivacijan i zapis na steku, tako da vidite da ono rewards. Nema niko kre lokalne promeljive unutar ovoga R, ako pogledate imamo samo ova tri polje otim, nema parametara i nema lokalnih promeljivi. E sad, ako pogledamo sada ovdje u ovom trenutbu kada uđemo u proceduru R, koje promeljivo ja mi sada ovde pripravimo, pripravimo, rekti smo malo preto u stvari promeljiva, a ova gorila tako iz glavnog programu. Evo sad ovdje i obešnjenje, zbog čega treba ova naša pripravna veda. Zastavljamo je u stvari u velika o polje je.
 koristili samo ono našu kontrolnu vezu, tako, način evi smo mogli komući njezbog četa. Naša kontrolna veza u proceduriji TERP pokazuje na proceduru Q. I ako bi smo došli do procedure Q i koristili tu promeljivo A, vise da ta promeljiva A u stvari je u stvari lokalna, tako koja je u proceduriji Q nije ona koja nama treba, to je u stvari gore globalne. Mi bismo mogli ovo da rešimo tako što bi smo išli jednom pa drugi put, tako preko dve, ove kontrolna veza dobore, međutim, moga nam je lakša tako da imamo u pristupnu vezu i da direktno preko nje odemo tako gore i onda tako pristupimo ovom golju A povrti. E, sad, sad, sada se vzedešava, kada kažemo A1 koA-1, dakle ja ću menjati ovu ovde, tako da će sve ovo smanjiti na 2 i bi će ponovopozvanu rekursivno tako ovo moje R, tako da vidite, ovde i gore ovo se smanjuje na 2, a ja imam još jedan aktivacijne zapise za proceduru R. I sad ako pogledajte ovde, kontrolna veza pokazuje na predkodni aktivacijne zapise opet, pristupna veza, kažem, na direktno okruživću proceduru. Zamislite sada ovde, odi se A smanjilo na 2, ja sad ponovot ako smanjujem A još jednom i pravim noviji aktivacijne zapise za kaj još jednom i sad ovde kada dođete, kaže, dali A različno od 1, više nije, tako da ovde je kraj i odi bi smo sada krenuli za sa vraćem. Ali zamislite sada da ovdje i za ovog ifa, naprim. prenegošno krenete sa vraćete, treba da pristupite nekako tome A. Da nemo ove pristupne vese koja vas slodi direktno gore u glavni program, vi bi ste morali brajite šta, morali bi ste preko 1, 2, 3, 4 o tako kontrolne vese da se penjete ovde gore skroz dok ne dađete do glavnog programu. I pri tom to ni ne možete nikako ispratiti, tako da zapravite da ovde nam je neophodno tako ovo naša neka pa pristupna vese da postoji. E, vi ovoj problem nećete, naravno, imati u projektu vašem, zbog čega? Zgledo što mi prva svar ne dozvoljavam da jedna procedura bude definisana u njutru drugi, to je smeka profumucija globalna, ne može biti definisana jedna o tako drugoj, a druga svar je jeste ta što mi je lokalna ili tako i globalne promeljive na različit način u fari dokrotama, to je naše globalne promeljive se ne nalaze na onom našem steku, nema i tamo na steku procedura, već i globalne promeljive nalaze u nekako ove oblasti, static data, tako da mi ove problem tamo onda nikada nećemo nima. Ali generalno u nekim programskim jezicima se tako nešto može resavati, tako da je to danas ćemo malo da poprit ćemo i o tome, pa vite sad kako se na primer resava taj problem. Ove data je broj 1, je bio o tako samo slikovitu da sad pokažemo tako na nekom malom primeru, kako se sad formiraju te pristukne reze i gde on je zapravo pokazali, vite da sad u ovom dodatku ovdje sve on je zapravo pokazali na gore glavni program, zato što imamo samo proceduru R i proceduru Q koja se nalaze na otaku nute u njutru tog glavna program. Ajmo ne zadatek 2 pa da imamo sad za tako nešto malo kompleksnije. Ove data je jedan malo veći paskal program i ovdje se od nas traži da nacatamo izgled izvašno ceka isto koji malo prej sad pristupnim i kontrolnim vezom u trutku za posvašavanje data paskal programa ne posredno prej prvo pogradka iso procedure neki tamo, pa se budete koje i smatram da glavni program ne posebno je aktivacijan i zapis. Dakle može zvudet i ova varianta na primer i kod paskala, pa da tako da onda nema aktivacijanog zapisa za glavni program, a samim tim i onda ove procedure B i C koja se nalaze na prvom nivog otaku nute neće imati to svoje polje pristupne rese. Već, to imati samo one koje su dalje otaku nekada na nekom većem nivogu, a ne na ovom otaku nultom nivogu. Danje nas pita i ovdje otaku koju urednosti spisuje program i da napišamo osemblješki kod koji predstav da prej od neke narede. Ali hvalje prvo da pogledamo šta se deša u ovom programu ovde, tako ja sam ga namjerno malo bojo da bi ovdje otaku bilo možda malo jasnije kada pogledate, imate nekakog glavni program i unutar nega je definisana nekakva procedura B koja naprima i još jedna dodlika jezika paskala koju je da nesrećemo toliko boš često, jeste da kao argument procedure može se javiti nekakva funkcija, to jest možete proslediti nekakva funkciju kao argument. I ovdje taj argument smo nazvali H i kažemo to je nekakva funkcija koja vraće integer a primal tako jedan integer. I tako funkciju možemo proslediti ovi proceduri B. Nebitno što ona radi sa tin. E, a zatim ovdje imate proceduru C koja unutar sebe ima definisano jednu funkciju F koja odgovorat vaštomegora što zahteva procedura B, da to je jedna funkcija F koja prijima int i vraće int. I imate jednu proceduru R koja sada ovdje vidite poziva ovo gore B tako što mu prosledi ovo funkciju F kao argument. E, telo procedure C je zapravo da samo pozove ovo R ovdje a ov tako glavni program poziva ovo C. Ajmo redno da vidimo još jednom, dakle šta radi glavni program, glavni program ovdje ako pogledajte, poziva ovo tako proceduru C. Procedura C je ovo ovde procedura, to je ovo nije na telo, ostavit će se M na nulu i pozove se E. Ako se pozove R to znači go se poziva ova procedura ovdje. Tato procedura opet postavlja nekakva M na 7, kasnije ćemo da imamo koje je to N, ali šta ona dalje radi, ona poziva B i prosledžuje F. Dakle ona poziva ovu gore proceduru i njoj prosledžuje ovu funkciju F koja je sada ovdje kao argument, vidi, ustvari, ovo je argument H, a onda ova procedura B ustvari poziva to H, što će zapravo biti ustvari poziva ovog F koje ste bi ustvari prosledili kao argument. Ovo ovako u stvari izgledaju u sad tine kao pozivi sad ovo. E sad mi treba redno vidimo kako se crtao nej stack za ovdje što smo mi na crtao, ali da imamo šta će na kraju ovaj program da ispise i plus da vidimo kako izgleda sendoški kod koji će biti prelod ove naredbe ovdje. Dakle još jednom prisetit ćemo se rezultat nekakve funkcije na jeziku paskal se ovako u stvari praki. Dakle kao da funkcije, vidite, ovo je F, funkcije se dove F, kao da funkcije i našto dodeljujete. Dakle, ovo bi bilo kao da stvoradili return M plus N. Ajmo, redno, vidimo šta se dajimo šta se dešava. Dakle, retismo za, glavni program nemovo aktivacijon i zapis, njega ne kreiramo, što ovači da krećemo odmah onda od procedure C. Dakle, ono što radi glavni program je ste poziva proceduru C. Ako pozivamo proceduru C, al tako odgore, vidite, ona nema nikakvih argumentata, reklismo procedure B i C neće imati polje pristutne vezi, zato što glavni program nema svoju aktivacijon i zapis. Kontrolnu vezi smo postavili na null, ovo tako košto, tako nema toga aktivacijonog zapise gore glavnom programa. I ako poglama procedura C, ima svoju lokalnu promenivu M. Lokalno promeniva M njen u vrednost, koji je šovek, neznamo, tek smo pozvali ovo našo proceduru C. E sad, pa imamo dalje, šta radi procedura C? Procedura C postavlja M na nulla, i to koje M, če onda ta procedura C zapostavlja na nulla, pa to svoju, tako, naravno, ovo lokalno ovde M. I ona onda dalje poziva proceduru R. Pozivamo proceduru R, ako pogledamo procedura R, nema al tako argumenta, tako da argumenti se ovdje ne pojavljuju, međutim polje pristupne veze ćemo sada imati, zato što to polje pristupne veze treba da pokazuje na direktnog ružuću procedura, to je procedura C. Oko da, ajmo odmog, danacatam obde strelice i kontrolna i pristupna veze će pokazivati na proceduru C. Ovratno, u dresnih smo stavili i ovo naša procedura R, opet ima svoju lokalno pramelivu koja se listu zove M, i vidite da ovdje ćemo te k sada tom M dodelit ili tako, ovo nekako brhoj se dao. M. Dakle, kad ovdje u nutar procedure R, pristupamo ovome M, pristupamo al tako direktno ovome ovde koji se naozio, opet, kažem na DP-2, i zatim, da se pideš što što. Kako ovde smo postavili, ovoga to se sedam. Gledajte sada, pozivamo proceduru B i proslajđujemo je koal parametro ovdje nekako F. Kako da prvo ovde što se javlja, i jeste ta parametra i to je stvari na ta naša funkcija F. To je ovdje zelojna funkcija. Nju proslajđujemo kao regument ovi proceduri B gore. Međutim, uz to što šaljimo od tako adresnu gdje se naozi ta nekakva funkcija, mi moramo da pošaljemo i o tako pristupnu vesu. Kako je tu pozivni sad realizamo, nećemo se pašu zalaziti direktno u to, ali ovde nam je potrebno da znamo da je to funkcija F koja je otvari ova funkcija ovdje i da znamo da je njoj direktno okruživit će procedura otvari procedura C. Tako da vidite da ovde u to F ja sam nacrtal tako da ide i ta pristupna vese u staj parametr se šalje i da je pristupna vese, to je otvako pokazuje nakon trodno vese ove procedure C gore. E sad procedura B, pošto smo reka i procedure B i C se nalazi direktno ovde otakon na prvom njegu u glavnom programu, i onda otakon na isto kao i ova procedura C nema svoju pristupnu vesu, leći izaparametra odmah i do povratna adresa i kontrolna vese. Kontrolna vese naravno pokazanja na proceduru R ispoje ovo B u svarih pozvano i ako pogledamo procedura B ima svoju lokalnu promeljivu M. Idemo dalje, sad što se daša ovdje, ove postavljamo M na 3, koja je M pa to je ovo lokalno u trb'e, tako da ću ovdje biti upisano 3 i pozivamo H od 2. Dakle, zapravo pozivate ovo funkciju ovdje koja je prosljeđena kao argumenta, to je otvariova funkcija F. Dakle, ide ta parametr 2 na stek, ovdje smo reka što postavili smo onu trodiku, parametr 2 smo stavili na stek i sada pozivamo u stvari funkciju F, to jest ovu funkciju ovdje dole. Postavljamo pristupnu vezu, ali na ono što je stavilo ovdje, dakle, pristupna veza se postavlja da je to u stvari procedura C. Znači, procedura C je direktno kruživit će funkciju F, postavljamo tako povratnu adresu i, naravno, kontrolna veza se postavlja da ide tako na onu našu proceduru koja se pozvala, to je procedura B. Tako da, ovdje crtamo ovako. I to bi bio taj trenutak, kada mi dolazimo do ove naše funkcije F. I, kada sve što stvica, tjetanja nije tu sada našto preterno, drugači u odnosno nošta ste videli malo presem ovog delu, ovdje u tako kako izleva kada...
 da prosleđujemo nekakvu funciju kao argument. Dakle, rekli smo u uz funciju, šaljemo i njenu pristupnu vezu i onda kasnije kada se ta nekakva funcija pozove, da pristupnu vezu se koristi ta u stvari koja bila i prosleđena. E sad, kažem volamo, od nas je trašao u zadatku sada da mi, unutar ove funcije f, napišemo sendverski kot koji predstavlja prevo dove naše narebe o. Dakle, kako se sada računo ovo m plus n? Kako, napim. znamo da su nam stack pointer i base pointer trenutno ovde dole. Dakle stack pointer i base pointer pokazuju na ovo posledne polje na ovom mom stacku ovde, to je s novom kontrolnu vezu poslednju u ovoj tapef. To je s novom mom stacku. E, amo sad redo. Ako gledajte funcju f, ovo n znamo što je, dakle to n se javlja ovde direkt u funcije f, dakle to n je u stvari parametar te naše funcije f i to je u stvari od vojka koja se nalazi ovde na stacku. Njučemo lako da dokatimo u odnošno na base pointer, ona se nalazi na 2, 4, 5. Znači svako polje zuzima 2 byte, tako da je komera i do ovog parametra zapravo bp plus 6. E, međutim, koja je m ovde sada koristima? Ako pogledamo ovu našu funcju f, ona nema svoju lokalnu promenju unijadnu, što je vidimo ovde dole ispod na stacku, a treba da iskoristi neka koa m. Nemada ka argumenta, nemada ka lokalne promenjile, znači gledajte direktno okružujuću proceduru oko toga f. Direktno okružujuća procedura toga f je ovo c. Dali ta procedura c ima nekako svoje m? Ima, evo go ovde, što znači koristit ćemo to m2. E sad, kako doći do tog m2? Pa tražimo aktivacijenizapis procedure c. Kako ćemo tražiti aktivacijenizapis procedure c? Samo ćemo istopliste procedure f pratiti polje pristupne vese. Polje pristupne vese od naša, tako ove funkcije f, evo go ovde i ako pogledate gde nas vodi, polje pristupne vese ove naše funkcije f, vodi nas skroz gorel tako do direktno tako procedure c. I ako pogledamo na proceduri c, ona narodno ovde ima ispod odmah svoju lokalno promenljivu m, koja trenutno ima vrednost 0. Tako da, kako ćemo mi pristupiti tome m gore? Uzmimo prvo polje pristupne vese i ovdemo tako skroz gore, a zatim se samo spustimo za dva ispa. Tako da, ajmo redom, šta je treba dovredim zapravo? Pa, da bih dobio prvo polje pristupne vese. Gde se pristupna vese uvek nalazi, to moš da odmah ti da zapram, če to i rču vek se ređete ovako, pristupna vese će su svako i funkcije i procedure ili kako god da ih zavete, nalaziti na bp plus 4, jer iznad kontrolne vese će se nalaziti povratna adresa, a iznad povratna adresa će direktno biti i pristupna vese. Tako da, što ja ov neki registar, napr. ovde di, snestiti bp plus 4, to jest polje pristupne vese. Svo polje pristupne vese ima vrijednost u stvari ove adrese ovde gore, a meni poštu treba ovak lokalna prameđiva m, koja se nalazi na pomeraju minus 2 u odnosu na ovo, ja onda kažem u registar ax dohvati di minus 2. Dakle, još jedan, u odnosu na base pointer treba mi prvo polje pristupne vese, to je za pročitam šta ovde piš. Ovde će pisati u stvari ova adresa ovde gore. Dakle, adresa kontrolne vese procedure c će biti zapisana u polju pristupne vese funkcije f. Ja prvo dofati imam tako tu adresu kontrolne vese procedure c, koja se nalazi u odnosu na tekući bp na plus 4 pomeraju, a onda kada imam polje kontrolne vese procedure c, da bi dofati o njenu prvo ovu prameđivu m, u stvari samo radimo tako minus 2 pomeraju i imam sam u tako u registar ax, upisao ovo m ovde koja u stvari lokalna prameđiva procedure c. E sad, da bi to m sabreo sa n, recimo n i u stvari ova dvojka oddiliti parametr funkcije f. Parametr prvi funkcije f ću se nalaziti na pomeraju plus 6, tako da smo rekti radimo ad ax bp plus 6 za pro pomere. Dakle, na 2 će biti povratna adresa, na 4 nam je kao što smo i videli, već bila pristupna veda, a na 6 nam se nalazi ovo parametr n, što je u stvari ovno ovo vretno ovde dvaj. To bi bio kod koji je potrebno izgenerisati. Kastin ćemo imati još neki primer sa malog generisanja ovog koda, a stval tako treba da ispisuao je naš program, pa idemo da pogledamo i to. Rekli smo f je jednako m plus n. Parametr n je u stvari ova dvojka ovde, a m rekti smo pratimo gore skroz, odlazimo do procedure c i koristimo ovo m ovde nula. Tako da ovi program zapravo da ispisuje 0 plus 2, iliti odgovor, tako bi bio dva. Dakle, ne koristimo ovo m ovde iz procedure b koja ima vretnost 3, ne koristimo ovo m iz procedure r koja ima 7, nego ovo ovo da iz procedure c. To bi bio drugi zadatak, ako malo smo gore sada ovde, malo smo ovde zako zakomplikovali ovo priču koji smo imali u korom zadatak. Ako imate neko pitanje, ako nešto nije osnovu slobodno ve prekidaite, slobodno kucajte ška goda treba, možete suključite sve. Ako ne, ajmo onda dalje na zadatak 3. A treći zadatak će da nam se bavi istim ovin, isto ovo što smo imali da sad, samo što ćemo sad na trećem zadatku da pokažemo opravo ono što sam malo prinajavio, a to je da, ako pogledamo sad, imamo proceduru main, dakle ovo sad predpostavljamo da je ovo sad del nekakog paskal programa, na primer, imamo proceduru main. Unutar nije definisena funkcija neka pa m, a zatim, unutar funkcije m, imamo definisena funkcija u p, q i r. I onda sad tu ona jedne drugo poziva i mi nećemo sad uoziti u to, da smo namerno samo stavili neko kod, ali meni potpuno nebitno sad u tako šta taj neko kod radi ili šta bi ovo na kraju ispisalo, to nije važno, važno samo zima sad kako sam rekuzivio i kako se formiruju sve ove naša tako neko prepristupne veze i slično, a onda ćemo na ovom primeru odi pokazati još jedan problem koji se javlja čak i kada imate prepristupnu vezu, pa ćemo uvesti i jedan novik konci. Nadrdim ovoj treći zadatak, pa ćemo da da prajimo pauz u kosa njekom. Kažemo, redom, po toj našo su zove stavlo aktivacije, neka pokrograma. Stavlo aktivacije znači da vi u svariji crtate stavlo kako su pozivaju neka preprosedura ili funkcijno trtog programa. I ovde sad kod meneći to i inčim tvare je prvo linijski, dakle to stavlo bi bilo, imali bi smo samo jedno, o tako jednu grama, o tako nije stavlo, nema nikakog grananja zapravo, nego direktno sveki čvor bimo samo jedno potom, kada ću ga prikazati o napom sleva na des. Šta se deso? Prvo što radimo u glavnom programu, pozivamo m od 157, dakle pozivate funkciju m od 157. I sad, možete da gledajte ako hoćete, ovu možete da mi verujete na reč, ova funkcija m je o njenom telo ovdju, zavisno, tvoj parametra, to je o glavnom 157 koji smo pozvali, će biti pozvan na p, q i lj, verujete mi na reč, da će biti pozvano q od 52. Kada dođite u q od 52, pogledajte telo funkcije q i vidite da ona pozivava ponovom m za prosledženje parametra plus 101, da se biće pozvano m od 153. Pa mi sad da onda opet verujete na reč, da kavaj se vdajo njih nivажno, ovdje bi se naravno selikutkući izdrčno, ali i videli šta ko su tu poziva, ako je parametra funkcije m 153, onda ona poziva zapravo sad ovde p od 51. Ako pogledajte p, p će ponovog pozvatio ovo m i to sa i puta 2 minus 1, verujete mi na reč, da je to m od 101. I na kraju ako m ima argument 101, ona će pozvatio u stvari r od 33. R od 33 samo radi ritrem, ne pozivan jednu drugu funkcioni proceduru, što znači ovde se zaustavljamo. I ovako izgledaju ti moji pozivi, koje ja sad treba da obratim. Dakle upravo ovim redom ofte. Mene radi sad ovde, krenam da radi moji zadatak. Ne zanima šta je telo koje od ovih funkcija, ja sam ih samo ovde sad na sljedećem slide-u pobrojo, čisto da bi smo znali gde se koja nalazi. Ima se tako imate main i čisto ovde da vidimo da prvo ide m, a da su u notarnega p, q i r. Kad koja poziva poju, to ćemo sad mi redom dope kazujemo na osmogu, što se na pjednog slide-u već vidi. Ajmo reta. Procedura ovo naša main, ima svoju pristupnu vezla, ima svoju pogratnu adresu i ima svoju kontrolnu vesu. Nema, ali tako nikakve argumenta o naša procedura, nema lokalne promenjive, tako da samo ove 3 pođe ovate. Samo smo rekli tamo, rekli smo prvo se poziva m od 154. Znači pravimo aktivacijini zapis za proceduru m, ide prvo parametr 157 i zatim ide ove 3. Standardno pristupnu vezla, povratna adresa kontrolnu vezla. E sad, kontrolnu vezla će narodno pokazivati na proceduru main gore, jer i ona je i pozvala, rekli smo kontrolnu vezla uvek ide na predkodnji aktivacijini zapis na steku, a pristupnu vezla će da pokazuje na aktivacijini zapis procedure koja je mene direktno okružuje. To je za proceduru m, ovdje je sad to funkcija m, ali nije nije nekako ne možno, za funkciju m, direktno njen na okružujeće je u stvari ovo main. Tako da će zapravo i jedna i druga u ovom slučaju ove i polje i pristupne i kontrolnu vezi pokazivati na aktivacijini zapis ove naše procedure main. Međutim iz ove naše procedure m, šta se veš avad alje, mi pozivamo q od 52, dakle, m poziva q od 52 i ajmo sad, kako treba od izgleda aktivacijini zapis ove procedure q, dakle imamo parametar 52, standardno sva 3 polja. Kontrolnu vezi naravno pokazivaće na aktivacijini zapis procedure m, a gdje će pokazu i pristupnu vezi, a hajda pogledamo, dakle, funkcija q njen na direktno okružujeće je u stvari funkcija m. Tako da će i ovom slučaju ovde i jedna i druga polja, otakvo i pristupne i kontrolnu vezi će pokazivati na u stvari proceduru m ili funkciju m. Šta se dešava dalje? I zove naše procedure q, mi pozivamo proceduru m ponovno, dakle, m od 153, ovo će sad biti druga češta. Dakle, mi smo trenutno proceduri ili funkciji q i iz funkcije q mi zovemo u funkciju m, to je naravno dozvoljeno, možemo tako nešto uradimo i onda kako ćemo...
 Kontrolna viza će pokazivati na ovu funkciju k. To će ostati istu. Kontrolna viza i dalje pokazuje novi predkodni aktivacijni zapis. Međutim polje pristupne vize moramo da postavimo tako da pokazuje na direktno okružoviću. Košto smo pozvali funkciju m. Nije na direktno okružoviće je otvarija procedura main. Tako da polje pristupne vese se vidite ide skroz goril tako do ovog našega nekako mogmejna. Tu je narodnova argument 153. I z ovoga m ovde da se prisetimo tamo pozvali smo p od 51. To je pozvali smo tako u funkciju p od. Kontrolna viza narodno će pokazivati novu našu proceduru m. A pristupna viza, ta isto tako da je tu proceduru m. Zato što okružoviće funkcija od ove naše funkcije p ovde jestu u tvari to nekako m. Tako da i jedna i druga pokazuje tu. Zatim to p po se prisetimo tamo je pozvalo u tvari ono m ponovu od 101. I opet se da je što vada istapriča kao i malo pre. Dakle parametr stoji, jedan pristupna viza što je direktno okružoviće ovi proceduri m. Pa to je u stvari ono je naš main tako da idemo skroz gore. A kontrolna viza narodno na predkudno pozvali. I konacu me kraju ovako, r33 pozivamo, r33 se nalazi unutar ovoga m. Tako da pošli smo ga iz m i pozvali i pristupna i kontrolna viza pokazuju na ovu proceduru m ovde. E sad, ajde, ovde trebalo bi dovo jasno. Ako njih baću se pogleda, pak sad, nakon jednog gleda ne trebalo bi da se uklačite. Ako ne, vićite pa ćemo da ponavljamo što god bude trebalo. A ovde sad da vidimo šta je sad problem, čak i ako koristimo ovo pristupne vese. Dakle, rekli smo, polje pristupne vese smo uveli da bi smo izbiljali sada dan, na primer u koliko vi sad ovde. Ajmo da je prikažemo odmah šta bi bio problem na primer. Ako želimo sad da iz procedure r, da pristupimo nekoj lokalnoj promeljivo. Dakle, zamislićemo na primer da ovo naša procedura main ima nekako lokalnoj promeljivo. Da nema pristupnih vese, da šta bi smo morali da radimo? Pa, već sam rekl, tako morali da bi smo napratimo ove naše kontrolne vese. I onda bi smo morali iz r da se vratimo u m, pa iz m u p, pa iz p u m, pa iz m u q, pa iz q u m. I onda iz m u main. Dakle, da pratimo brda nekakvih kontrolnih vese. Da ne bi smo to radili, mi smo radili šta. Uveli smo polje pristupne vese, da bi smo videli koja je nam i direktno ukružujeći. I onda se peliti direktno tako na ono proceduru koja je oko nas. E, međutim pogledajte sad šta se sad ovde opet sad dešalo. Ako bi ste iz procedure ili funkcije r, chteli da pristupite nekoj lokalnoj promeljivo ove naše procedure main. E onda bi ste morali da pratite dva ova polja pristupne vese. Zbog čega. Zato što ova procedura r ovdje nam je definisana u notor ovoga m, a to m je onda tek definisana u notor ovoga main. Dakle, ako pratim polje pristupne vese procedure r, vidite da me ono vodi ovde do naše procedure m. A zatim, ako pratim polje pristupne vese procedure m, onda me ono vodi gorel tako skroz do ovog maina. I sad, sad onda zapra vodi do ovoga, mošte da zaključite. Ok, nije strašno ako ja sad budem preko te dve pristupne vese mora da izeng ko gore. Međutim važi jedno pravelo ovde sad, prveni se ovde kako bih ja otišla zapravo do gore, a tu ovdje uvodimo pravelo sveće. Grovi pristupnih vese koje ćemo pratiti je jednak razlic i leksičkih nivola na koji se nalaze procedure. Sato zapravo znači. Prvod procedura main nam se nalazi na nekom nivou x. Preći ćemo da je to na primjer nulti nivou. Prvod procedura n ili funkcija n se nalazi u notar nije, to znači da je ona na prvom nivou, a ovaj funkcije p, q i r se nalazi na drugom nivou, jer se ona nalazi u notar funkcije otako m. Ako je main na nultom nivou, a f na drugom nivou, to znači da vi morate da ispratite dva ova polja pristupnih vese da bi ste stigli do gore. Esa zanisite da imate više, naprima neki dublji nivod, da ste odunutar ovoga r definisali još nekakve funkcije u notara i da onda tek pristupajte nečemu tako što je lokalno za ovom main, li bi ste onda morali opet da pratite sad al tako dosta ovih nekakvih pristupnih vese da bi ste došli u stvari do nekakve promedlji. E, da bi smo to izbegli tu da se prati više nekakvih pristupnih vese, ovuodimo sad al tako jedan još novik koncept pored tih pristupnih vese, to jest imenemo te pristupne vese nekakvim display-na. Tako da ćemo isti ovaj zadatak ovdje broje 3, odraditi i u varianti 3a, pomoću tako zvanih display-a. Znači, ćemo sad znači da imamo što ste display, nije ništa kompliko, ono ne mora te dobrinjete, da kada isti ovaj program ovdje, isto ovo stablo moja, na reći ćemo ide stablo aktivacije, tako se to i način zovema da ovo da nije baš u obliku stabla, isto ćemo ovo sve dovorjedimo ako kažemo koristimo te display. Šta je ideja sa tim displayima? Dakle, koji smo imali pre problemi? Problem koji smo imali, jeste da, ono to rove funkcije, er, želimo da pristupimo na primjer nekoj lokalnoj promeljivoj, naprimer procedure main. I onda je to od nas zahtevalo da se mi vraćemo skroz, kroz sve ove naše ukružoviće funkcije, procedure dok ne dođemo do te neke procedure koja je nam stvari treba. To naravno bi izizkivalo, videli smo tamo da pratimo određeni broj pristupnih reza i ne želimo to da radimo, nego želimo da direktno možemo da pristupimo tome nečomu što nam u nekom trenutku treba. Kako je to moguće? Pa ako samo pogledate, u svakom trenutku, dakle bilo koja funkcija da se trenutno izvršava, a recimo naprimer da se izvršava funkcija R, ako se izvršava funkcija R, da li mi možemo nekako da znamo koje su to njoj direktno okružovići procedure? A naravno da možemo. Dakle, ovo R njemu direktno okružovići na nivou iznad, ako je R na nivou 2, na nivou 1 znamo da je sigurno tako ovo naše nekako M. U ovo našem konkretnom slučaju ovdje kako smo izvršavali program, jer vidite da je M u stvari pozvalo to R. A da li možemo znamo koje pozvalo to M s alzako nivou a iznad, to je šta je oko tog M, pa to je stvari nekako, ovo je našo dnej, možete vidit našo, ovo je naša alzako procedura M. Tako da, ideja ovi displaya jeste da ja u svakom trenutku za svaki od nivoa koji postoje, dakle koliko godno bilo da imate, naprimer, ode konkretno ja imam nivoa 0, 1 i 2, ideja displaya jeste da vi i za 0, i za prvi, i za drugi nivo pamptite koja je to trenutno aktivna alzako procedura ili funkcija na tom nivou koja vam treba. I onda konkretno bi bilo šta dok se izvršava R, meni treba da display 0-og nivoa ima pokazivačno aktivacijne zapis procedure M, display prvog nivoa će imati pokazivačno aktivacijne zapis funkcije M, a display drugog nivoa će imati pokazivačno aktivacijne zapis funkcije R. E sad, ok, znači kako će izgledati ti display, ajde krenemo da radi moj zodatak, ovo ovak, znači display je ćemo mi, ovo nasleđećem taj del i prikazemo, display je mi u stvari čuvam u nekom statičkom delu tamo najčešće memorie i zapravo za svaki od nivoa mi zapravo čuvamo po jednu display. Ja se mi hovi da indiksiru da se za nivo 0, za nivo 1 i za nivo 2. I tu, naravno, reko sam da u njima čuvamo te kuće vrednosti. Dakle, te kuće vrednosti koja je to te kuća procedura na tom nekom nivou koja se koja je al tako opružuće našo i koja se izvršava. Ako čuvamo te kuće vrednosti, to znači da ćemo mi, sada na primjera ako ovde nešto piša o ovom displayu 1, ako u njemu nešto piša to znači da ćemo nešto pregaziti. Pa ne mogu samo da ga pregazim da što će mi kasnije možda u nekom tronutku zatrebati, tako da onda zapravo radimo šta. Nije iz našeg aktivacijenog zapisa kada pozivamo procedure izbacit ćemo kontrolne ove pristupne veze, dakle njih koji smo veli tamo njih ćemo da izbacimo, nećemo koristiti njih, nego ćemo onda dobrodimo sada šta. Umešta da koristim te pristupne veze i ako koristim display, ali onda u aktivacijenog zapisa u baculjem svedreći. Znači svaki put kada se pozove neka funcije ili procedura, imate standardne aktivacijenog zapisa i kada se formira, kada se formira base pointer i kada se tako iz tag pointer i base pointer dovedu do pokazili na onda jednu te istu polni, onda ćemo na aktivacijenog dole pre, u aktivacijenog zapis pre lokalnih promenjivih sačuvati staru vrednost display na tog nivoa te procedure koja se trenutno pozima a u display ćemo stvari obisati našu procedur. Sada ovo zvućemo možda otlako confuzno, alajno kruzo i primer pa veratno ćemo biti jazni. Dakle šta se dešalalo ovdje kod nas? Rekli smo display nultog nivoa, kažem, nulti prvi drugi nivo, u startu upitnici stojen ne znamo tako šta se o njima nalazi. I onda kažemo ovde sledeći. Kažem, zapantimo gore pogratno adresu i kontrolnu vezu. Pristupne veze sada ne ima, procedura main nije imala argumenter i onda kažem, ispod kontrolne veze stačuvao ovaj stari sadažaj displaya nula. Dakle, display sa indeksom nula, al tako na nultom nivo u to što se nalazi, to sam tu sačuvala, a zatim ovde upišen u display da se trenutno na nultom nivo izvašava procedura main. E sada, ajmo redom, dalje šta se dešava, pozivamo funkciju m 157. Kako izgleda taj poziv? Dakle, vi, stavite parametra 157, idu povratno adresa i kontrolnu veze. Kontrolnu veze isto kao i da sači će pokazivati al tako direktno na aktivaciri zapis ove procedure, iz koje smo pozvali u proceduru m. Šta onda radimo? Gledamo na kom se nivou na ovo funkciju m. Funkciju m se nalazi na nivou 1, tako da smo ovde čuvali stari sadažaj displaya 1, a onda u display 1 ovde upišemo u stvari da je to m 157, to je upišemo u ovde adresa. Ili ti adresu kontrolnu veze, ove naše procedure m, ali bažno ovi pozivamo c 157. Idemo dalje, iz m se pozove q. Šta se dešava tu? Ide parametra 157 povratna adresa, kontrolnu veze, q se nalazi na drugom nivou. Ok, ono je u notar ove funkcije m, pošto se nalazi na drugom nivou ja saču vam, stari sadažaj ovog...
 displaya sa nivoga 2 šta goda je tu pisalo i tu upišem da se trenutno izvršava funkcija Q i vi to odstavda pišal tako Q od 52. Pasno je sada dobija, sada možemo i ovde da se zustajimo na primjeru ovom trenutku i da pogledamo, ukoliko sada iz ove procedure Q, mi želimo da pristupimo nekoj lokalnoj promenjivoj, napr. procedur i Q, to bi smo tako pitali direktno odmog dole ovde ispod u odnosu na polje kontrol na veselje. Ako želimo da pristupimo nekoj promenjivoj, ove funkcije M, nibi smo samo pogledali ili tako display prvog nivoa i vidite, da tu piše M od 157, to je su bi smo imali adresnu ovog ovde polja, a ukoliko želimo da pristupamo nekoj lokalnoj promenjivoj procedure N, nibi smo samo pogledali display 0-og nivoa i onda onda su svario oddaj do polje ovde kontrol na veselje. Tako da u svakim trenutku, za svaki nivoa znamo odmah u svakog gdje da tražamo otvarit gdje se nalazi ovdje stavlje kontrol na veselje. Ne moramo da pratimo nepristupne veselje da se pomoću njih, raćemo ka gore, nego direktno samo pročitamo, ovdje stavlje ovdje stavlje kontrol na veselje. E sad kako su oni menjaju sada, svarali dalje procedura Q. Procedura Q poziva M od 153, vleda saču ovdje se desi. Dakle, ide parametra povratna adresna kontrol na veselje, e sad M se nalazi na prvom nivo. Znači da treba da sačuvamo stariji sadrži display sa prvog nivoa, display sa prvog nivoa odcvario ovdje sada naše M od 157, to je ovdje ode pokazivačna aktivacimizapis prvog poziva procedure M, što je odcvario tako ovi drugi naš aktivacimizapis ovdje gore u listi, ovdje ovdje. E, njegovo u vrednost sačuvamo na ovom steku ovdje, dakle ovdje se čuva to M od 157, to je spokazivačno ovu kontrolnu veselj, a onda u display ovdje od 1 upišamo M od 153, t.e. upišamo ovaj 0, lako ovo novo polje kontrolne veselje. I sad zajde dalje opred, način ako pozajamo P od 51, što smo radili, tako, što se dešava tu, dakle, P se nalazi na drugom nivou, dakle, unutar ovaj funkcije N, tako da čuvamo stariji sadrži registera od tako display na nivou 2, to je ovdje kod 52, to sačuvamo ovdje na stek, a onda u ovih display ovdje upišamo stvari da je tramutno top P od 51, dakle, da se tramutno na drugom nivou izvašava P od 51. Opet imate da se iz P pozvalo M od 101, ja na steku sačuvam staru u vrednost, to je M od 153, a zatim u display 1 upišamo stvari da je tu sa tramutno pozvalo M od 101. I, kako poslednjal, tako, imamo pozvalo R od 33, ja al tako na steku sačuvam stariji display na nivou 2, a njegova vrednost je u stvari pokazivačna P od 51, to je pokazivačna kontrolnu vezu poziva procedure P, što je ovdje ovdje naš aktivacijen izapis, dakle, to tu sačuva, i onda ovdje pregazim i napišam, tako da je tramutno R od 33. I koji smo problem malo preimali, malo presmimali problem, to je šta smo razmatrali, šta bi se desilo ako bi neko iz procedure R pokušao da pristupi nekoj loklanljno i promeljivo i Maina. Pa šta bi on trebalo dopročita? Svom bi trebalo da pogleda, tako na kom nivou se nalazi ta procedura i očiji u loklanljnu promeljivu želimo da dokatimo na nutom nivou, dakle, samo bi smo iz statičke, statičke delove memori, je dokatili ovoj display nula i onda bi nam odmah rekao, gde se nalazi polje kontrolnu vezu procedure Main, i mi bi smo samo onda pročali, napim, neko loklanljno. Zbog čega je potrebno da čuvam ovdje na steku stare sadreže ovih vrednosti? Zato što? Zato što sada, kad se vratimo iz ove procedure R, slanja se ove aktivacirne zapiste naše procedure tu i onda bi trebalo da restauriramo vrednost displaya na nivou 2. Kako se to zapravo radi? Pa prenego što se vratite iz procedure R, ovo je vrednost ovde koja piše, al to je ovel tako pokazivač na aktivacirne zapiste procedure P, to je snijeno ko oziva za 51, a to je u stvari ove aktivacirne zapiste ovde, znači jediniku imamo za proceduru P, da je ta vrednost tu se u stvari restaurirala, tako i ponovno se postavlja display 2 da pokazaju u stvari na taj aktivacirne zapiste. Ima ćemo sad jedan zadatak da se malo poigramo i satim. Znači, što smo znači, na časli ješ jednom da sumiram prošli sve, prvo što smo radili, jeste da ako bi ovo R stjelo da pristupi loklanljno i promenljivo i maina, prva varianta li bilo da se prate sve kontrolne veze i to bi bilo od tako ovoliku kontrolnih veza, koliko vih vidite ovde na cestu li. Druga varianta je bilo da smo uvelili tako pristupne veze, pa bi druga varianta bilo da pratite noliku pristupnih veza, koliko je razlika između nivola na kojima su definisane te nekih procedure, a onda kao najbolje varianta uveli smo tako ove naše display i onda smo reka da direktno iz svake procedure možemo pristupati loklanim promenljivima svih tako naših okružvećih procedure. I naravno ovih display o ovde ima, ono liko tako koliko imamo nivola, to je sve do koja dubine se ide, a sada tako definisane funkcija jednih u nutrb druki. Ajde, na pravićemo sad jednu pauzu, pa na primer sad da nastavimo, ajde, pošta, ja imam jednu i eno laboratorijsku vežbu ovde, ja bih znamo ovde da napravimo jednu malo dužu pauzu košto sad imamo svić grupa, pa ajde da nastavimo u 1,30, na pravićemo pauzu nekih 18 minuta, ako imate neka pitanja, slobodno kucajte, pa imam još do odradi dva zadatka i da se svetamanu klopite tu taj slod do dva. Ilimate neku pitanja, možda odmah ili... Dobro, ako nema te, ja se napislite u četu, dakle nastavite u 13,30. Pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa, pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa pa Do Vadom
 Dobro, evo me nazadil, se čuvamo, možemo samo da mi potvrdi, jeste i dalje tu. Biloko. Da. Dobro, drago mi je. Dobro, nista, ajmo, smo imali nekih pitanja, nismo, dakle, verujem da je sve jasno, tako da, ajmo onda dalje na zadatav 4. Ovo smo zelošili. Zadatav 4, ovo se što smo radili do sat, imamo ješi jedan primer samo što sada ovdje nećemo trpiti, tjera da smo sve ovako izgledalo, nego sad imamo samo display ovom zadačku i treba da prikažemo sad, običe stvarno ostavlo aktivacije i kako se meni u vrednosti display. Ako koristimo tako to statičko okruženje za ne lokalne promenje, verjalizavano display, na tako ko to pisati ovdje vam u zadatku. I naravno, oddje sad naglašano, ma da to i podrežnamo da se display uvek nalaze u statičkom delu memory. Ajmo, što imamo sad ovde za pravo ovom programu. Dakle, imamo tako nekako glavni program koji sad ima proceduri, onda smo ih namerno i nazvali ovako da bih sada moh znali o nekomi nivou nešto, pa sad imate proceduru P10 i P11 ili P1, 0 i 1, 1, 0, tako, pa onda imate procedure P2, 0 i 2 i 1 i onda imate proceduru P3, 0. Dakle, da kalbna se je trenoslu naziva procedure znatim, na kom nivou se ona nalazi. E sad, kako znao, ovo sad, sablu aktivacije stvarno, kada pričemo o tom sablu, pa izgledače ovako. Zavoj naš program to, sablu aktivacije izgleda, tako, sto mi prvo, pozovimo tako proceduru P10, ovdje, gledače glavni program pozivamo proceduru P10, idemo do procedure P10, to je ovdje, ona poziva proceduru P20, tako da te njenu tijelu ništa drugo ne radi, nego imamo samo P20 poziv. Ako pogledate P20, ono poziva prvo P11 argumentom 4, dakle, to je onda ovo je čvor ovde koji smo natratili, P11 radi ništa samo se vraće, tako da vraćemo se nazad, znači, što radimo, pozivamo P30, dakle, se procedure koje pozivate iz jedne procedure, će biti na istom nivou, dakle, dođe, u stvari, biti čvorove i ovte braća od ovom našem sablu, tako da pozivamo P30, i gori imamo P30, pozivamo P21, koja ne radi ništa, i P11 argumentom 2, koja opet ne radi ništa, tako da ovako bi izgledulo sablu aktivacije za taj neki naš program. Dakle, deca, u svariji nekog čvora, u svariji sve procedure i funkcije koja u svariji taj, za nekog koja u svariji procedura poziva. Ono što nas nazima, ovo, što nas zanima, ovdje jeste, kako izgledaju display u konu trenutku, tako da, ajmo sad da ispratimo redom, kako će se oni zapravo menjati, u početnom trenutku, kako distvara zapravo prvo imamo, pa imamo 3 display, ovdje, na nivou 0, 1 i 2, ili ti odislo, znači, 1, 2 i 3, sve jedno, ako go to koćete, u glavnoj hindeksiram 0, na nivou 0, 1 i 2, i sve jedno, u konu trenutku imaju nekakva redom vrednosti i kreće da se izvršava ovoj našom program. Kajmo, da, idemo, pozivamo ovdje proceduru P10, znači da, prilikom pozivamo toga P10, poštu se to P10 nalazi na 0, distno i 0, ću svariji sadržati adresu tako aktivacijenog zapisa te našele procedure P10, to je s njenom poziva. Zatim, istog P10, možemo gledamo sablo aktivacije, možemo gledamo kod, pošta gozđelite, poziva P20, P20 se naravno nalazi na drugom nivou, tako da se menja display u tako drugog nivou, i tu sad evidentiramo da je trebno pozivana procedura na drugom nivou, svariji P20. Zato to P20, ljite sad ovde poziva P11 sa argumentom 4. P11 se naravno nalazi na prvom nivou, tako da tamo najdu, naravno, na steku bi smo mi sačuvali ovo stara ovdje P10, a menjamo vrednost display na nultom nivou i kažemo da je na nultom nivou trebno pozivana tako procedura P11. Ja sad pošta to P11 znađa nikoga ne zove, šta sam da dešava? Prilikom povratka iz ovoga P11, znači na kraju tog P11, mi restauriramo vrednost, ovog display ovdje, to je sve steka pokupimo ono sačuvano vrednost, a to je svariji P10. I u niju svariji sad kad smo se vratili iz ovoj procedure P11, ovdje u proceduru P20, znamo da je naša tako trebno kružovića procedura, upravo ovo koje pisa ovdje, to je otakuna nultom nivou P10. Dalje gledamo šta se dešava i za tog poziva P11, poziva procedura P30, znači da meni nivo display otaku drugog nivoga, pošta ono otakuna drugom nije nulti nije prvi nego drugi, nivo otakuna procedura P30, ona dalje poziva P21. Dakle, ovo P20 se sačuva na stek, a aktivacijun izapisto je s adresa aktivacijunog zapisam P21 se stavi u display 1, odet u proceduru 21 i se odmah tu završava, znači da poziva vršetku te procedure tu, da je stavirala sama stara vrema sa steka, a to je zapravo ovdje P20. Svi ovdje ostali odopravo, se ne diraju uopšta, da kredira se samo one nivole koji trenutno pripada ovo procedura koje se mi nalazi. Dakle, procedura P21 pripada ovom drugom nivou ovdje, tako da samo taj nivol tako tu imamo menjati. Kada smo se vratili iz P21, poziva se P11 od 2, tako da je to na prvom nivou, tako da čuvamo ovo P10,
 11 je trenutno tako na nullto nivou, izvašite proceduru P11 i kad se vratite iz nje, naravno opret, restorirate ono vrednost staru koja je bila i ovne sad pa nadalje, otako se samo vraćamo iz procedure. Prvo se vratimo iz procedure 30, tako da se procedura 30, zako restorirate se stara vrednost, a to je svar jeva i neki upitnik, koji je bio pre, zatim se vraćamo iz procedure 20, ne restorirate sam tako i nije na predkodna vrednost, i zatim se vratimo i iz procedure 10, tako da na kraju display ostano sa onim vrednostima koje su inicijelno imali, sad tijelta nije nivašno koje su, koje su na vrednostima u zadatku. Dakle, ovo je zadatak je bio samo čisto, da vidimo još jedan primer, kako bi ste ti display imenjali, videli smo na predkodnom zadatku, kako su oni, gde se čuvaju te njihove vrednosti tamo na steku, pa kako sam je to zauprav opostaljite, na sajto predmetu, oni materialima, tamo imate jedan veliki zadatak, koji ja danas, naravno, neće raditi ovdje, nikad nismo nistigli doležitimo, taj zadatak je ogroman, tako da svako ko vam savjetom da njega pogledajte, dakle u njemu nemate ništa što ja nisam pričao, da će sve ovo već naopostaljite, to je ali jedan malo veći zadatak, gde imate još i one delo sa generisamim koda, ako postoje display, da prebukamo kako bi ste sada dohvatili neku promenju u neke procedure, ako sad tu njemo mogu realizati, ono sad display. Dakle, ništa speciflno samo ba se pogleda na taj mali del, a ja ću onda za danas još zadatak broj 5, taj zadatak broj 5 će biti 1c program i tu ćemo se još malo sad igrati sa ovim generisanjem, tako 1986 assemblerskog koda. Kar zadatak 5-a, imate o tako neku kamen, koji pozivajuva funcju F1, ono ima tu nekoma 3 argumenta abc, ima dve lokalne promenljive dr, a onda se pozivaju f2 datle, koje ima neku lokalnu promenlju wa i bukvalno sam radirne do takori trunjet. Ono sad pokažemo samo, čisto kao jedan primer, ovdje sad da je tako dato da se potstimo malo i toga, za programski jezik C, kako će sad izgledati njegov stack i kako ćemo sad za njega generisati ove assemblerskie instrukcije, a iznađu oslo pokazat ćemo i ono instrukciju enter, pa ćemo da ima sad tako, abi ona radi lov u ovu situaciju. Dakle, tačka a kaže, na cetam, o kakvim zna, stack prije prvog povratka ism funcije. Ja ću odmah na cetati, pa ćemo tako da prokomentariša. Mi izmeni napozivam u tvari ovo F1. Dakle, argumenti se pa ćemo sad toga da se pristetimo, koji je zika C, mešta je tako znađu u lev. Dakle, prvo se smiješta, al tako C pa B pa A. Znači, prvo, poslednji argument, pa onda al tako skraja kako četku, A, izmjede oslo gajder razlog tome, možemo i obmačiti da spomenemo ovdje, pa zbog čega tako, zato što kada budete sad da pristupali i tim argumentima, u odnusu na, na primer, base pointer u toj, base pointer ću stvari pokazivati, u tako ovdje, da pise kontrol na veza F1, tako da gledajete u odnusu na taj base pointer, kako, gdje su oni sad da na oze, pa vidite sad da, kada posmatrate njih, oni ovdje tako u tim, baš redoslavnom koji mi treba da budu, dakle, A, B i C. Da biste ihvitali redoslavnom A, B i C, morate nastak da ih ubacite kontra redoslavnom, to je C, B, A, to je iznađu ostavom. Razlog zašta je to tako. Pesnate, ove na alona god je zika C, nemao taj moment da jedna funkcija se definiše unutar neke druge funkcije, tako da nisu potrebne, nije one prisupne veze, nije display, nego imamo samo povratno na adresu i kontrolnu vezu. To znači da, kada pozivat ovo F1, spakuju su sva tri argumenta, spakuje se povratna adresa i onda tako kad uđimo u funkciju F1, formira se ovo polje kontrolne veze, pa ćemo sad vidite i kako, i zatim se alocira prostor za ove lokalne promenljive D i R, ovdje indeksiraju redomo na kako su i navedene u nutar, te nekakve funkcije. Zatim smo iz ovoj F1 pozivali ovo F2 opet košto nema argumenta, to odmah pakujemo povratno adres u tog F2 i kontrolnu vezu u tog F2 a zatim poštim u jednu lokalnu promenlju ovo A, spakujemo i tu lokalnu promenlju. I sad ovo bi bilo situacija kako izgleda taj stack pre nego što krenemo da se vraćemo iz ovoj F2, znači kako izgleda, tako što base pointer znači u ovom lokalnu lokalnu promenlju ovdje pokazujemo na ovu polje kontrolne reze on se ne menja, a stack pointer će vse šetati gore dole u zaviske su i toga šta se na stacku nalazi, pa između osalo goval lokalno promenljivo koja se nalazi na stacku, nastera da stack pointer pomberimo za jedno polje do listu, znači da ostavimo jedno mesto za tu promenljivo. I sad, znači se prisetim ovog ovdje, dakle ja ću prikazati samo za jezik C, a kažemo vićite onda baciti poglede na taj jedan da biste to radilo, ali tako imam, mislim, čak i neki del, malo još još i ovako pa skala, tamo pa kažem, e tu bacite samo pogleda ako ono nije bilo najjasnije ovde onda vidite tamo još. Kaže za ovdje prikazani program mi sad treba da izgenerišemo osm. 286. asemblerski pod program koji je kvalenta na ovome ovdje. Pa ćemo onda redom ovak. Što se tiče funcije f2? Sam mi zapravo treba dovedimo sada ovdje. Kada pričamo ovom osm. 286 arhiteturi, dakle i ovom delu ovdje koji se malo prispomeni o kojoj formiranja kontrolna vese, uleg će nam se na početku svakje funcije javiti sveće. A to su ove dve instrukcije. Dakle, puš, BP i muv, DPSP. Zašto? Znači, ovo polje kontrolna vese nije ništo drugo, nego taj registr base pointer. Dakle, njegu u vrednost ovom instrukcijom puš, ja zapravo stavim ovdje na stack i to je u stvari ova kontrolna vese ovdje f1. Zatim, kažem, base pointer, kada sam sačuvo njegu u predkodnu vrednost koja na primjer bila negdje kozna bori d je onda kažem da taj base pointer beba do pokazu o ovdje. To je zduzme tekuću vrednostu tako mokr stack pointer. Isto se desili ovde, opogledajte ovde sada. Kada smo pozvali ovu funciju F2. Dakle, kada smo ušli u F2, a to upravo jesna ovaj kod koji ti sreno to vidite, išlo puš, BP, dakle, sačuva i ovdje kontrolna vezu. Mub BP SP, vidite, dakle, Mub BP SP, BP se nasla, našao tu gde i SP, međutni spok čega SP ovde sada dole, zbog sledeće o instrukcije koje usledila, a to je SUB SP2. Dakle, SP spuštamo dole ispot, a lociramo stvari prostor za koliko već prmeni rijo ovde i na munutr f1. Spokljemo jedno prmeni, ovdje ovdje tako 2. Dakle, SUB SP2. E. I onda na dalje šta su da je daša, ovdje smo predpostali sada u zadatku da smo, na primver, povratno vredno sraček koje zregistar CX, mogli smo uzmete IAX, C1. Kažemo ovdje, Mub CX1 i nakon toga idu standardne dve instrukcije kojima se vraćamo u stvari iz neke funkcije. Koje su to, koje su to dve funkcije. Kaže, Mub SP, BP. Dakle, prvo sve, obispo intero tako pokazuje na polje kontrolne vese. Ispo to polja kontrolne vese, će se naozitil tako, e. na primver, neke lokalne a ako se vi vraćete iz neke funkcije, to znači da vam te lokalne primveri vise nisu potrebne i sad košto ne znamo koliko ih je bilo, ovom instrukcijem u SP, BP ovo SP dovoljimo naziv dovolj do ovog base pointera, što znači da smo u dole sve buhvala samo zanimarili, obrisali sve. I u tom trenutku, u stek pojenter pokazali na isto što i base pointera, to je polje kontrolne vese. To je su je sačuvana stara vrednost base pointera. Tako da ćemo instrukcijem pop BP, stinuti stara u vrednost base pointera i time base pointer i u stvari vratici da pokazuje ovdje negde gore. Ako smo to skinili onda se stek pointer se li goren da pokazuje novu povratnu adresu i mi zapravo instrukcijom rekt idamo i tu povratnu adresu i vraćemo se u stvari na instrukciju koja je al-taq se nalazi na to je adres i kuna koje pokazuje ovu poljeva. Tako da panetimo samo da kreva svake putka da se uđi u neko po funkciju i do ove sve al-taq instrukcije puš BP da te sad člove sara u vrednosti ima u BP SP naravno iz njihoj odma slediji instrukcija sub SP pa al-taq u kuliko imamo lokali kremeljnjivi puta 2, a ovdje dolel tako na kraju svake funkciji se javite o muve SP DP, dakle samo kontra varianta. Tako odimate puš BP a doli imate pop DP a ovdje gore imate muv DP SP a ovdje imate muve SP DP kako samo je sve izvrnu tako pogledate u rikverci, tako da odmotavamo sve sve nazeleno što smo uradili do dativi. Kako će izgledati ko za funkciju F1, dakle prvja dne instrukcije će bati izgledati. Puš BP muve BP SP Zatim imamo sub SP 4, zato što imamo i ovdje i ovdje, i ovdje, i ovdje tako da ozimamo 4 ovdje i dalje. Kaja ovde sad, treba dizarčumamo A plus B. A i ovaj naš argument, koji se nalazi ovde i njemu ćemo pristupati u odnosu na base pointer. Base pointer će pokazivati ovdje A plus 4, znači muva XBP plus 4 je pamelje. A gdje nam se nalazi B, pa B nam se nalazi ovdje na pamelje u plus 6, tako da u stvari imate BP plus 4 i BP plus 6. To će biti taj izbir. Gdje treba da smestimo taj izbir, koji smo sad do napravili u registro AX pa treba da ga smestimo u D. Gdje se nalazi D? Pa D je lokalno promenivat, dakle se nalazi ispot. Dakle lokalno je promenivat ćemo mogu biti sa negativnim pameljemu odnosnu na base pointer i ovdje se nalazi u stvari i odnosnu na base pointer na minus 2. I onda kažemo muv, BP minus 2 vrednost ooga AX koja smo izračunali od. I onda ovdje kažemo pozivamo ovo funkciju F2 nači pišemo ovdje kol F2 Nakon toga standardne dve instrukcije koja sam vreku da idu na kraju i naravno i ovo ret koji im selva ako vraćemo iz ovoj funkcije F1. I onda se nalazi u stvari i odtajimo kod za to instrukciju Što se tiče mejna rekl smo od šta treba da spakvamo tako redom ove argumente na stek i to pazimo da ih uvek pakvamo zdestno na levo tako da ne možemo direktno da kažemo pušta
 tri, nego suve kradni move ax3 pa pušta ax, i onda imamo i za dva i za jedan, dakle spakavimo sve argumente na stek, ozavimo funkciju f1 i ovdje koristimo konvenciju gdje će uvarao i pozivovac ovdje biti zadužen da sve to sve te argumente zapravo i sponjel tako sa steka, tako da kažemo ovo tri, dva i jedan koje smo stavili na steka, kažemo sp6, to je sp penjemo tako u gore, tako uspanjemo te tri vrednosti koje se nalaze na steku ovom ovdje instrukcije. I to bi bilo to što se tiče ovog generisanja koda za našto primer u ovom. Dakle ništa o tako ništa, pretero na komplekste. To se triče trećih dela ovog našeg zadatru ovdje, on će biti veoma jednostavno, dakle ja neću sada ovdje ovde kono osve kucati, kaža ovdje treba da napišemo istu osmrnjeste, osmrnjeste, osmrnjeste, osmrnjeste pod programa equivalenta na ovom našem programu, ako se koriste naredbe enter i leave. Tako, umestu da ovo radimo ovdje ovako sada neke delove ručno, možemo da koristimo ove instrukcije enter i leave, i pa on ne zapravo radimo leave, ću svariji raditi ovoj delo poslo naš dole, ovako ovoj restoriranje, ovako vrednosti base pointer, a enter ću svariji raditi ovoj delo pridlikom uloska u nekog funcju. To znači da ovu puš dp, move dp, sp, i ovdje ovdje sad, te ovoj poslo tu će da nam odradi u stvari instrukcija enter. I to, kako onda to zapravo izveda, pa to će onda zapravo izvedati ovako. Dakle, ja mogu da se vratim nazad, pa sad zapokražemo šta je tu izvedala, to je skako je to izvedala, dakle, puš dp, move dp, sp, i ovo sad, na jednom i na drugom mestu, i ovamo move sp, dp, i pop dp. Sve to menjamo, ovo dole menjamo jednostavno instrukcije leave, instrukcije leave će raditi o tako taj del ova račinja, stack pointera na base pointer i restoriranja base pointera, a instrukcija enter biti zadužena da. Sačula svar urednu z base pointera, ovdje tako da nam base pointer postavi, znazim, kad se treba to nalazi stack pointer i plus ovdje vidite, sad da, da, mi zapravo ovim prvim argumentom njoj kažemo, ono što smo malo predadili ovdje, komuće ovaj sabi instrukcije, to je koliko prostora, jedna stacku potrebno alocirati za ovdje tako lokalne promeljivo, pa s ovdje bilo izvojke česvorka, tako da ovdje imate enter 2, ovdje enter 4. Ovo je drugi argument ovdje, koji vidite, koji je ovdje, na rebe enter, li u stvari leksički nivon, al tako na kome se nalazi neka funcija. I sad, kod nas je ovdje to leksički nivon, naravno, uvek nula, zato što se radio jeziku C, u ovom zadatku, to je, reka smo, jeziku C ne možemo jednu funcju, definisati unutar neke druge, tako da, ako uvek će ovde biti nula, okoliko bi se radila paskala, pa koristili al tako ovo za paskala, onda bi smo ovdje tako mogli, sada imamo i neke druge rednosti uzaristiti toga koji smo funcjuli proceduru postavljena. Onda bi, ovdje enter instrukcija al tako bilo zadužena za još neki posao, tako tamo u posadnih, al tako to je zna nekako formira, ono polje pristukne vese i bi, ukoliko al tako koristite, ono je distvoje, da onda sačuva rednost karu distvoje i da postavi novog rednost distvoja. U svakom suče, ovu instrukcija enter bitaj posao obavilo za vas. Dakle, to bi bilo, ovdje, še jedan krat, primer kažem, jedan tamo dostavreći imate pa pogledajte na siteu kažem predmetov materialima, gde imate sad pokriveno sve tol, tako najoša, najoša, malo kompleksni. Ome bilo to od mene pa ovako jedan slide za kraj i bi meni sad kažete, dalje ima nekih pitanja ili ćemo mi lepo da privodimo u kraju druženje što se tiče progranjskih i prevodila sa jedan što se tiče veš pje. Ja lijemo neko pitanje za bilo šta su se tiče gradiva, koje smo do stada odradili ili organizacije, bilo čega i slično. Ia, vesitnice samo. Dalje je ok da u projektu kada radimo printi rit, da za bolje vrijednosti vi pišemo i učite oman u lju 1? Da, zbrozlikaj. I koliko traje odbrana? E, to je sad malo teško pitać. Kako traje odbrana? Odbrana i inicijelno i ltebi trebalo da traje dva sata, međutim to su uvek malo oduži, poštu su uvek svedena to, a dajte nam još 10 minuta izlično. Dakle, što se tiče odbrana, evo dajdem mogu sada... Evo, ovo se isnimam pa ću dokacim tamo, pakno neko apet bude gledao, može ja to iznam. Što se tiče odbrana, evi kada dođete na odbranu, dakle na odbrani da biste uspešno odbranili projekt, mora da radi javni test, mora da radi tajni test, koji će gobiti tamo kada dođete i mora da radi modifikacije koju damu u tom terminu. Dakle, modifikacija mora da radi u potpunosti. Nemože da radi deo, evo vidite, pogledajte ovo ili pogledajte kodifiršno, mora da radi. Akko ne radi modifikacija javni test i tajni test, nećemo uloziti u to, ništa se desava, ni ni ti gledajte, šta ste donili, dakle to je uslov da bi smo gledali last projekt. Testat, to ume da potrejam, da je pa i do 3 sata, ali preko 3 nebitrek. Naravno, ima ljudi koji tu modifikaciju završi za pola sata i odklučila. Ili me želim ni pitanja? Amo tu sam još minut neki pa, ako ne budete imali ništa, onda ćemo pa lako da se razilozimo, onda videli s treću planu, imamo, dakle, ako se ne varam, ajsemo da se poceti. Trebalo bi da je 20-tog planera na odgram na za ier smera, 21.00 za esi, ali nemojte me držete za reš, da ću vam sutra poslati, mislim da sutra mi ističe, ono je roka koji sam prvi naveo, pa kad gude na prvej raspored, da postoću vam, odmah ćete videti kad. Ispit je 22.00, sad nisam gledali zašla satnica, ali u svakom suču i poslavam je kolegjenica, maj o formu pa ćete nju popuniti i onda ćemo objaviti tačno kad će šta biti, pošto moramo, držimo nadoknadu k2 za esi i nadoknadu kolopijoma za ier i držimo tako standardni ispit, tako da to je sve malo sad kompleksnije ielite nego ina, pa ćemo, onda mi poslati zapravo kad će šta biti. Što su tiče toga i da, i ako gude te gledali ispit od predkodnih godina, kažem, ove godine njih nisam značajno, ale ću ćuš to zanotpomeni mi to, promene ćao malo format, pa poštu sad ispada da u javnoru radite i jedan kolopijom, uz avisnosti skolka se smera, ili ona isp jedini kolopijom ili k2 na esi, i ispit, onda smo smanjili broj zadata, kad vam se neopterješimo mnogo, tako da ću ispit u javnorskom i februjorskom roku, imati 5 zadata, a kolopijom ću imati 2. Kaja kolega, dali su tajni testovi s ličnijavnim? Pa da, miš, to je to, sam ovaj event, ono možda je još na neki drugi način, da ću ti testiram u isti. Da ne bude da ste sad prilagodili samo svoje rješenje, da vam vam rade javni testovi, pa je to, či su da ne isprobamo na još najma. Što se tičano alternarnego operatura, za koji ispapakal ove godine, dakle za njega, a ako koristite ono pojednostavljenu gramatiku, onda slob budu da napišite svoj test, ili samo izbacite iz onog našeg testa na ideo koji, onda više ne podržavate, a mi ćemo jelite za odbjerno ubezberiti testove koji imaju. Nešto što bi trebalo tako da radio, onda nekrati prešin. Ili vam još neko pitanje? Ako ne imamo ništo onda frešnji praznice, u danas tako naša domaća nova godina, pa sve najbolje vam želim u ovu godine i kažem da se vidimo u bar do kraja godine bez maski, ako je moguće to s imao, želim u ovu dana. Pa ništa onda da se vrlo, da se vrlo, da se vrlo, da se vrlo, da se vrlo, da se vrlo, da se vrlo, pa ništa onda, ako budete imali još neki pitanje, da imamo, ok, ako ne rade za funconosnije tajne testu, koja je kraj odmah. Ne, ne, ne, način, čak je ako vaš projekt, kad ga, ne znam, doćete na odbjerno, ne radi vam tajni test, možete vi slobodno da popravljate našto u svom projektu i za vreme odbrane, ali naravno, jelte vreme za modifikaciju vanu testu. Tako da treba da vredite i modifikaciju, onda i da ispravite to, ja na to on naša svoj vana ne radi za to vrema. Tako budete imali neki pitanje, slopodno pišite, ali je to, ja vas molim za malo razumevanje u ime svih kolega, pošto smo ovi danas da isto dosta oterećeni, tako da ja si trudim da odgovorim na mevlove, što pre mogu, ako nekada me budete malo sačekali, eto, u naprece iznijala. Nisto, brugu, imam 6 grupa za ispiti zrečunorskih mreža 2, tako da, zurnika. Ne, podaj mi čak na slajdu i piša u rečunorske mreža 2, zvajaš se moj slajd preuz, zato vidim, sva tog predmeta, eto, izvinjamam, si na to mi ispravit ćemo i to. Je li imaš neko pitanje? Vljude, od se sad se pojavljuju neki ljud od danput, a ja završava. Je li ima neko, možda, neko pitanje dovi što su došli? Ali... Tako, ako ne, ništa, onda, ajmo, polako da se razilazimo, pa se onda... A, da, manja kaže, kako ti za atakla može, da je dođi iz JFlex, Epo, to morate piti te koleginjec maju koja država, taj je del, ja neću da vrati zadatki iz prve polovine pusla, moji zadatci će biti iz druge polovine pusla.
 Ne manacav. Ako nešto budete lemalo kažem još, pišite pa, ja manav se vraćemo vamo polako na laboratorišku vežglu pa, učite, spremajte se pa se vidimo onda za ko i da. Pa značim.
