 Dobar dan, dobrodošli napredavanje na predmetu konkurentno i distribuiranu programiranje. Ja sam zahrnirad Ivojelic, ja temo ovog danasnjim časa je rad sa monitorima. Kako monitori rade u pozadini, timi ćemo se baviti danas na prvom času, odnosno kako monitori mogu da se iskoriste da odrade neki posao koji smo do sada videli. Nakon toga ćemo krenuti monitori da koristimo da rešimo neki konkreta synchronizacijon problem. Hodjemo da vidimo kako iskoristiti monitor da odradimo neki posao. Nećemo se više baviti time kako monitori rade u pozadini. Želećemo da iskoristimo monitor da odradi nešto za nas. Da rešimo problem čitalaca i pisaca, prezvođača i potrošača, filozofa koji rucavaju ili berberina koji spava ili kružnog toka ili neke raskrsnice. Više različnih problema koji ćemo rešavati koristići nekoliko teknika koji ćemo videti da postoje kod monitora. Neki tekniki je univerzalne koji se mogu premenivati svaki put. Neki tekniki su prilagodženo u suštini monitorima koji imaju samo jednu uslovnu pramenljivu. U ostalim slučajima nisu toliko praktično. Oni će raditi i u ostalim slučajima, samo što neće imati zadovoljavajuće performanse. U slučajima imamo veliči broj uslovnih promenjivih, neke posloje možemo odraditi znatno jednostavnije. Da ćemo videti da li neke posloje možemo odraditi znatno jednostavnije. I kredjimo da radimo s ovim ovdje našim monitorima. Chod ćemo da vidimo što je to, kako se to koristi. Videlj smo da postoje monitori koji imaju dve discipline. Jedna disciplina je signal and wait, druga disciplina je signal and continue. A kako radi beša monitora? Monitor možete zamisliti kao jednu klasu. Instancete klase ima mogućnost da se pristupi njenim promenjivama, jedino koristići neke metode. Ako pristupimo bilo kojoj metode monitora, mi dobijemo ekskluzivno pravo pristupa čitavom objektu. Niko drugi nema pravo pristupa datoj instanci objekta. Mi zaključavamo datju objekata. Kada budete gledali kako se to radi u javi, videte u debug režimu rada, kad budete ušli da stvarno tamo ima isrtan mali ključić i piše, ta i ta nitje zaključala datju objekat u datom trenutku. Niko drugi nema pravo pristupa datom objektu. E to je i ovde slučaj. Kada neka počne da radi, taj dobije ekskluzivno pravo. Dok ne počne da radi, videli smo da se taj neko nalazi u ulaznom redu čekanja. Čeka pravo da postane jedno. Pristupajte pravo da postane jedini koji smedaj da pristupi datom monitoru. Kada neko dobije to ekskluzivno pravo, prelaziji u sledice stanje, to je stanje exekjuting. U stanju exekjuting naš objekat je zaključan i prestaj da bude zaključan tek kada ove kojima ekskluzivno pravo kaže ja napuštam ekskluzivno pravo pristupa datom objektu. Kako napušta ekskluzivno pravo pristupa i osnovni način kako se napušta ekskluzivno pravo pristupa je završi se monitorska metoda. Završite posao koji radite i zađete iz monitora. Ko onda ima pravo da nastavite da radi dalje, nekako se nalazi u ulaznom redu. Visto o slobodilu rekliste, ja više ne držim zaključan objekat, neko drugi ima pravo da pristupi da traži zaključavanje datom objekta. Nije više moje. Drugi način kako može da se napušta ekskluzivno pravo znači je tako što odete i pozovete metodu wait na nekoj usnovne promenjive. Metoda wait koj usnovne promenjive se dosta razlikuje u odnosu na metodu wait na cemaform. Metoda wait koj usnovne promenjive je blokiruća momentalno napušta te ekskluzivno pravo pristupa i prelazite ured blokiranih na datu i usnovne promenjive. Koj cemafora je s lična situacija u slučaju da je s interna semforska promenjiva bila jednaka nulij. Ali koj cemafora ako interna semforska promenjiva bila već od nule, vi se ne blokira, to znavašno nice ne blokira, nego nastavlja dalje se radom. Toga koj monitora nema. Ako kažete monitor usnovno promenjiva.wait, kraj, nit je za blokirana počevo togter notka. Nema istorije. Ne posmogatara se kod usnovnih promenjivih istorija, nego samo ono što je od togteru notka, pa nadalje. U slučaju promenjive se ne inicializuju. To je red čekanja. A dobra, znači mi sada možemo da pređemo ured blokiranih. I sad je pitanje, ok, a kaćemo mi za čisto greda blokiranih? Ima dva načinu. Odnosno dve implementacije koji ću mi posmatrati, jedna je za disciplinu signal and wait, i druga za disciplinu signal and continue. Ko discipline signal and continue, koje postoji u programskom jeziku java i koji ću mi koristiti, kada nekodredi signalizaciju. Našan it iz liste blokiranih prelaziv entry q. Pa će nekad u budućnosti kad nemam blagije veze kad doći na red. A druga disciplina je signal and wait. Onaj ko kaže signal, kaže, ja napuštam eksklusivno pravo, ja idem u red koji čeka da dobim ponov eksklusivno pravo, a onaj ko se budi, je garantovan oprvi naradi koji treba da se izvršava. Ako postoje nekoko koja zablokira, a ako ne postoje niko, metoda je bez bilokakog efekta. Tu sad postoji jedna podvarianta, ako će biti kada taj poksmo mi probudili završi s poslom, nitko je treba da nastavi. Ako ne znamo ništa o tome, onda tu mjemo najnormalnih u signal and wait disciplinu, ne znamo koji će biti prvi naradi, dolači se neko iz entry queue-a. A postoji još jedna podvarianta, to je signal and urgent wait. Mi probudili nekog, a kada taj neko završi, mi nastavljemo dalje sa rato. Ne idemo u entry queue, nego idemo u onaj prioritetni red. I mi smo preko dne nedalje. A videli kako može da se napravi implementacija svega toga, koristiti te prioritetne redove. Odnosno semaforobične. A po kigama ćete dosta često pročitati da su te ustunepromenjive, tako napravljene da rade po FIFO principu. Ieste, to bi tako trebalo da bute. A onda kada dodete u prvi programski jezik, u kome znate to da primjenite, a vidite da one NISU napravljene po FIFO principu. A tako da kad budete rješavali zadatke, nemojte su oslanjati na to da postoji ugradjen FIFO redosled, a po kome neko može da se bude i blokirana datu i uslu noj promenjuvi. Možete ćemo o to moći da realizujemo tako što ćemo mi da odredimo redosled kroz određene prioritete, ali kažem nemojte se oslanjati na to da imate ugradjen redosled. Ako treba nešto garantovati od ugradjenog redosleda po kome FIFO nema ništa. Znači morate da garantovite čak i ako imate ono što ćete imati u realnom programskom jeziku, a to je neki redosled. Možda ti neki jezici mogu da vam daju i varijantu očete FIFO ili očete FAST. Ne znači da FIFO nije braz, nego samo da može da se nađe neko malo bržen rješenje. I mi smo, kažem, predkodni put razmatrali kako nešto napraviti ukoliko je semofor osnov programiranja na dato i platformi. Ali ako semofor nije osnov programiranja na dato i platformi, nego je osnov programiranja monitor, monitor je starim, primjeri za to je programski jezik java. Pitanje je kako napraviti semofor koristici monitor. Možda je nekihma lakše da programiraju koristici semofore, ne vremmem da tako nešto može da bude. Mi si može biti lakše ako imate već goto o rešenje koje neko drugi napisao. Pa onda vi samo izkoristiti to rešenje i prepevate ga koristici semofore koje ste napravili pomoći monitora. Ali to rešenje u suštini nije prilagođeno za dati programski jezik, jer u tom programskom jeziku tako napravljeno sve da monitori budu stari. I sad koji ćemo da vidimo kako napraviti jedan semofor koji ima dve metode. Metode su signal and wait i imamo kako nam treba ustanik promenjih. Evo ovdje imamo jednu usnovnu promenji. Ajde da vidimo, ovdje već imate gotovo parče koda. Ja neću kucati, njegovo ćemo u samo proći kroz datu parče koda da vidimo šta se ovdje rati.