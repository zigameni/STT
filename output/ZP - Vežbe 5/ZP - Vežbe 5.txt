 Dakle, kao što rehao, da spomenemo, istekovo takmičenje kao jednu lepu priliku gde ne samo da možete se takmičiti u poznacenove ljude veći da naučite nešto novo. Dakle, ideja takmičenja odnosno celog projekta, jeste da od 12 do 14 aprila imate priliku da na nekoliko stručnih predavanja na temu cyber security, odnosno cyberbezbednosti, naučite nešto novo o oblastima kao što su bezbednosti weba aplikacija, krađa podata, karanjivosti aplikacija, greške prirazvoju forenzika digitalna naravno. Onda neke specipicnosti zlačenja podatak iz virtualnih mašina analiza malwarea i tako dalje. Dakle, stvarno, jednom širok obseg stvari ko možete da naučite novim predavanjima i dakle, kao što vidite, oni traju 3 danu od 12 do 14 aprila. Nakon toga se održava 24-časovnih hackaton 14 i 15 aprila, dakle, uokviru 24 časa, gde studenti u timovima od maksimalno 3 člana se takmiče u jednom izazovu, opet naravno vezanom za sam cyber security, gde pred znanje u suštini nije neophodno, dakle ako se niste bavili ovim takmičenjima, ako niste gledali, kako izgledaju ova takmičenja, to ne treba da vas brina jer pred znanje nije neophodno sve što se traži na tim takmičenjima, ćete naučiti u ova 3 danu na stručnjim predavanjima. Naravno, postoje i nagrade za najbolje timove, dakle od nekih security gadgeta do nekih vouchera za online kupovinu i nagrada poput stručnih praksiju oblasti cyber-sigurnosti, tako da sve jako lepo ovde osmišljeno i za najbolje sledi taj neki skup nagrada, a najbolji tim, sad nisam tačno siguran da li u pitanju jedan tim ili više timova, u suštini mogu da prođu dalje u sledeći krug ovog takmičenja, takmičenja odnosno da prođu u krug takmičenja koji su država na nivou Evrope gde petniz gradova iz Evrope, odnosno petniz timova, iz Evrope se takmiči u jednom zadatku koji ima concept capture the flag, dakle prosto nekako morate da dođete do te nazovi zastavice koja predstavlja rešenje nekog problema ili više tih nekih problema. Prijave za takmičenje traju do 7. aprila u ponnoć, dakle i za takmičenje, i za stručna predavanja možete se prijaviti samo za predavanja, samo za hackathon ili i za predavanja i za hackathon, a sve dodatne informacije u kuliku su vam potrebne možete da nađete na svanično Instagram ili Facebook stranici bas istek challenđa Belgrade ili da kontaktirate njihovog PR menadžera, dakle Saru Martinovski, imate ovdje na slajdu njen mail, u koliko želite da je pitate nešto konkretno, ali koleginice mi reksla da možete da ih se javiti na neku društvenom režu, koliko vam je lakši, u koliko vam je potrebno neka specificnada informacija da kažem, da vam brže prosto odgovori na to što vas interesuje. Ako imate neko pitanje, okoliko možete sad i nas da pitate, mi ćemo vam odgovoriti u koliko znamo, s obzirom da mi sami ne organizujemo ovo takmičenje, nego smo prosto chceli da vam ukazemo da ono postoji, da je odlično organizovanu i da kao asistenti sa predmeta na kojem se bavimo sajber sigurnošću, da prosto vam kažemo da je ovo odlično prilik, da naučite nešto novo i da eventuolno je to u stakmičenje pobedite, da obijete neki nagrad, deplasirati se dalje i tako dalje. Tako da ako imate neko pitanje, slobodno si uključite u poziv, pa pitajte, ako umemo da vam odgovorimo, reći ćemo vam odgovor o odmah, ako ne umemo da vam odgovorimo, onda bolje pitite saru nakon časa. Da, da ima neko pitanje. Dobro. Dobro, to je to što se tiče samog takmičenja. Što se tiče samog takimčenja, mi sada prelazimo na lekciju kojem ćemo se baviti danas. A u pitanju su algoritmi toka podataka koje smo da kažem spomenuli više puta u toku predhodnih časova, danas ćemo se pocetiti još jednom šta su to algoritmi toka podataka i kako su oni razlikuju od blokovskih algoritama koje smo do sada učili i onda ćemo vidjeti konkretna 3 algoritma, odnosno konkretna 2 algoritma, jedno pobljšanje ovog drugog algoritma, kao primere nekih algoritama toka podataka da vidimo kako oni radi od prilike koja je ideja izanjihovog dizajna. Nakon toga nakravi časa ćemo se baviti malo i generatorima pseodoslučnih brojeva, jer je to nešto što je često potrebno ne samo kod ovih algoritama toka podataka, nego generalno u aplikacijama koje se bave bezbednošće, što za generisanje nekih ključava sesije, što za generisanje nekih non svednosti i tako dalje prosto ovi generatori pseodoslučnih brojeva su dostabitni i ovde je zgodna prilika da ih spomenemo okviru ove lekcije. Dakle, kao što reklo, prvo ćemo se baviti samim algoritmima toka podataka, da vidimo da se pocedimo šta su, jer pričali smo već više puta o njima, onda ćemo da vidimo te konkretne primere u pitanju su RC4 i algoritam, Salsa 20 i njeno poboljšanje čaca 20 algoritam. I nakraju da vidimo generatora pseodoslučnih brojeva, odnosno da vidimo razljipu između generatora stvarno slučenih brojeva i generatora pseodoslučnih brojeva, a onda da vidimo neke konkretne generatore pseodoslučnih brojeva, kako oni funkcioniši, koji ideje iz-a njihovog dizajna. I kažem, i ovo je nešto što ste isto učili u toku vašeg školovanja na ETF-u, konkretno na predmetu ISP, tako da ovde ćemo se pocediti u suštini tog koncepta generisanja pseodoslučnih brojeva i videti možda još neke detalje koje tamo nismo videli. Pa kao što smo reklji, algoritmi toka podataka su algoritmi koji porukon ne enkriptuju po blokovima kao blokovskih algoritmi, nego bit po bit ili byte po byte. I u suštini ovde možemo da ih predstavimo na ovom jednom slikom, gde vidimo da prosto sam ključ algoritma u suštini ne kombinujemo sa, sa, direkno sa porukom, nego je ključ ulaz na sam algoritm ili na neki generator pseodoslučnih brojeva koji nam onda izbacuje niz nekih bitova ili niz nekih byteva u zavisnosti koji je tipa algoritm, dakle koja veličina podataka sa kojem radimo. I onda taj izlas generatora koji zovemo key stream ili ključ toka kombinujemo na neki način sa porukom i u konkretnom ovom primjelu na primer prosto ksorujemo taj key stream sa našom porukom i na taj način dobijemo bit po bit ili byte po byte te neke šifrovane poruke. U ovom konkretnoj slici s obzirom da je ksoru operacija inverzna sama sebi u suštini istim ključem na ulaz ovog generatora pseodoslučnih brojeva, bi smo dobili isti key stream, tako da ono što je potrebno raditi pri tekripcij, jeste da sad u kombinujemo taj ključ toka sa šifrovanom porukom, odnosno bit po bit ključa toka, bit po bit šifrovanet poruke ili byte po byte i dobijemo nazad plain text. Tako da u suštini, ovo je neka skic odprilike ideje i algoritama toka podataka, sad naravno svaki algoritam radi na neki svoj način, ali u suštini, ovo je neka generalna ideja. Sad, ovi algoritmi najviše ličena, one time pad, šifre koje ste slušavi na predavanjima, mi smo ovde verovatno spomenuli i na vežbama, pri čemu u one time pad šifri se koristi stvarno neka slučajna sekvenca podataka i na taj način imamo stvarno najviši nivote neke zaštite. Dok se koji je algoritama toka podataka u suštini koristi pse od o slučajna sekvenca podataka, odnosno sekvenca podataka koja je dobijena na osnovu nekog algoritma, ali je taj algoritm tako napravljen da na izlaz u samo algoritma ta sekvenca podataka koja je dobijemo sekvenca bitova ili byteva, nama deluje slučajno, odnosno prolazi većinu nekih testova slučajnosti koje ćemo videti kasnije da postoje i samim ti moglo bi se za njih reći da stvarno nekako jesu slučajni, ali s obzirom da u pitanju algoritam naravno istim...
 i ključem bi smo u suštini uvek dobijali isti taj tok podataka, zato ga navzijemo pseudoslučenom sekvencom podataka. Kada pričamo dizajnu samih algoritama, tok-a-podataka, ono što moramo do sobina da razmotrimo prilikom dizajna samog algoritma, je su sledeće sobina. Sa jedne strane, pošto izlas generatora je nije z nekih pseudoslučenih brojeva, koji će sigurno u nekom trenutku krenuti da se ponavlja, jer je on dobija naostno u neku algoritma, onda bi bilo dobro da perioda ponavljanja tog izla zabudeš što veća, da bi se smanjila mogućnost kriptoanaliz. Dakle, prosto ako na izlazu imamo, ne znam, brojeve od 1 do 10, naprimer i oni baš u tom nekom poradku se dobijaju, bilo bi dobro da stvarno svih 10 prvo brojeva nekako izlađu, prenego što oni krenu da su nekom trenutku ponavljaju, ili da na neki drugi način još viša do 10-ih brojeva na izlazu dobijemo, prenego što krenu da se ponavlja cela sekvenca na samom izlazu. Sa druge strane, ovo što sam sad opet malo preispomenuo, sam izlas generatora pseudoslučenih brojeva treba da liči na pravi slučan tok-podataka, odnosno, ukoliko je na samom izlazu veličina podatka nivoa jednog bita, to znači da bi u suštinju nekom najboljem idealnom slučaju broj nula i jedinica na izlazu tog generatora trebalo da bude jednog, odnosno na jednoj periodi ponavljanja trebalo bi od prilike uniformno da nam budu raspodeljeni sve moguće vrednosti koje može generator da izgeneriše. U slučaju, naravno, tok-podataka veličina jednog bita, jednog broj nula i jedinica bi trebalo da vidimo na izlazu posle nekog vremena, a u slučaju da nam je veličina podataka nivoa baita, trebalo bi u suštini svih 256 mogućih vrednosti koje možemo da naprijemo od jednog baita da se pojave sa podjednakim učestavnostima nakon te jedne periode. Dakle da nam prosto taj izlas bude uniporan da bi prosto to što više ličilo na neki pravi slučajan tok-podatak. I naravno kao što bi smo mogli da vidimo nove slici u suštini sam ključ, od samog ključa zavisi sam izlas generatora, tako da onej napad koji može ovde da se desi, jeste brute force napad, tako da treća osobina koja mora biti sigurno razmotre na prilikom dizajna ovakvih algoritama, jeste da sam ključ bude dovoljno velik da se ti brute force napad ispreče. I rekli smo i na prošlam času kada smo radili aizda od prilik 128 bita za veličinu ključa, danas sa svim dovoljno da sprečimo brute force napade. Dobro. A sad ako ispoštujemo sve ove osobine za ispravan design samih algoritama tok-podataka, onda ovi algoritmi tok-podataka mogu da obezbede takvu sigurnost koja je reda veličine sigurnosti koji imamo koji imamo koji donih blokovskih algoritama. Međutim, prednost samih algoritama tok-podataka jeste što su oni u glavnom brži, vidjet ćemo na primerima da operacije koje se vrše na samim podacima i samim ključevima o ovakvim algoritmima su dosta jednostavne. Dakle u glavnom su neke operacije koje se jednostavno implementiraju na raznim architekturama. Dakle da sovi algoritmi s jedne strane brži, a sa druge strane takođe zahtevaju dosta manje napisanog koda. Vidjet ćemo kada budemo radili RC4 primer, on se bukvan opiše u nekoliko linja koda. Najzgled deluje jako jednostavno, ali opet nekako pruža dovoljnu veliku sigurnosti kao i ovih blokovskih algoritma. Ali naravno, ono što ne sme nikako da se desi za razlik od blokovskih algoritama, jeste da se ponovi ključ koji se koristi za dva različita plain texta. Jer kao što smo i pričali na predavanjima, a malo spomenuli na vežbama, ono što može da se desi ukljiko ponovimo dva i ista ključa koji imamo ovako neko skicu, jeste da na izlazu imamo naravno isti tok podataka, što znači da ako mi u suštini koristimo dva različita plain texta, mi ćemo stvarno dobiti dva različita ciphertexta. Al ako se domognemo tih ciphertextova, ono što možemo dohradimo, to je snapad koji ovdje možemo dizbrćemo, jeste da ukombinujemo ta dva ciphertexta, da ih naprimer ksorujemo i da praktično dobijemo isti rezultat kada smo ksorovali ova dva plain texta. Jer je korišćen isti ključ, a mi to naprimer znamo. Tako da ukoliko postoje neka ponavljanja u samom plain text, naprimer ukoliko je plain text neka kreditna kartica ili neki informacija koji imaju neki pattern, gde se neke stvari ponavljaju, mi prosto ovim ksorovanjem možemo da skvatimo gde se dešavaju ta ponavljanja i nekako da kryptoanalizom prosto smanjemo sebi napor da dođemo do originalnih poroka. Ili prosto smanjemo obsek ključeva koja moga tu da bude skorišćena, neki manji obsek koji možemo poslje opet da napadnemo nekim brute force napadnom. Dakle da za razlik od blokovskih algoritama ključ ovdje nesme nikako da se ponavi, to moramo nekako da obezbedimo nekim dobrim generatorom ključevi, da ćemo ključevi se onda u glavnom generišu, nekako na slučajan način. Sa jedne strane, ovvi blokovski algoritmi su u glavnom koristi u aplikacijama koje rade sa nakle blokovima podataka, to mogu da budu neke file transfer aplikacije, aplikacije koje rade sa bazama podataka, email sistemi i tako dalje. Dok algoritmi toka podataka u glavnom rade u aplikacijama koje zaktevaju intripsiju podataka bit po bit ili byte po byte i to su u glavnom neki komunikacijoni kanali i neke veze na webu, dakle negde da se nekako sve šalje serijski. Međutim, naravno, jedni i drugi algoritmi se koriste i u jednim i drugim tipovima aplikacije, videćemo sledaće nedelje kada budemo radili modove funkcionisanja da prosto i jedni i drugi algoritme možemo nekako da prilagodimo našim potrebama u toj nekoj aplikaciji, ali o tom potom. Iel imate pitanje u ovom trenutku koje je vezano za same algoritme toka podataka? Dobro, kažem, sada ćemo uraditi nekoliko primera ovih algoritama, videćete oni su jednostavni za razumjevanje, ali opet nekako dovoljno moćni, danamo bezbedne dobru sigurnost. I prvi algoritm koji ćemo sad ospomenuti jeste rc4. To je algoritm toka podataka koji radi sa podacima veličine baita i ima promenljivo veličinu ključa. Dakle, veličina ključa u suštini može da varira od 1 do 256 baito, dakle, zavisi od našeg potreba. U suštini sam algoritm se svodi na neku nasumičnu zamenu mesta i veoma je jednostavan, dakle, nasumičnu ovdepine permutaciju treba da piše. I koristi se u raznim protokolima kao što je Wi-Fi Protected Access protokol u secure shell ili u Kerberosu koji ćete raditi na predavanjima. Tako da, prime na samog algoritma je velika, a ono suštini funkcioniše tako što je ovaj ključ koji nam je veličine od 1 do 256 baitova koristimo da inicijalizamo neki vektor stanja koji značavamo sa S koji je takođe veličine 256 baitova uvek. U suštini, taj vektor stanja inicijalno sadrži sve osmobitne vrednosti. Tako da, taj vektor na nulltoj pozici sadrži vrednost nulla, na prvoj pozici sadrži vrednost 1, a na 255 i pozici sadrži vrednost 255 u decimalnom formatu. Tako da, svim mogući brojevi od nulla do 255 se nalaze ovom našem vektoru stanja inicijalno. A onda, u suštini, našim ključa nekako treba da izmješamo taj vektor i na neki način da izlačimo jedan po jedan element iz tog vektora koji će da budu praktično ti elementi koji predstavljaju naš tog podataka na izlazu tog generatora. Ono što se desao, jestli da se u svakoj iteraciji generiše ta jedan byte koji predstavlja ono što je izlaz samog algoritma, pošto smo rekli da radi sa podacima veličina byte i onda taj byte po byte šalje negde i nekako ga kombinuje sa porukom. Kao jedan od byte ovog vektoru stanja, dakle na jedan sistematica način se on bira, a nakon svakog tog izbora se vrednosti ovom vektoru ponovno nekako izmješaju. E sad kako to konkretno funkcioniše, sada ćemo da vidimo. Dakle inicijalno, osim što se u svakoj iteraciji generatora,
 u jednoj for petlji u kodu možde lakši da razumete, inicijalizujemo taj naš vektor stanja, tako što prosto na poziciju i ako nam for petlji do 0,255 stavljamo baš vrednost i. Dakle, to je onaj vektor koji se malo prespomenu, ima svih 256 mogućih vrednosti i veličine baita u ovoj svoj reprezentaciji vektor. E dobro, e sad, ključ nekako koristimo da izmešamo inicijalno taj vektor prenego što krećemo da ga upotrebljavamo. Međutim, u suštini pošto ključ može da bude promenljive veličine, onda nekako treba da formiramo vektor opet od 256 baitova koji nekako zavisi od tog ključa. Tako da, u suštini koristimo ovaj neki privremeni vektor t, gde ako nam je veličina ključa 256 baitova, onda se prosto cijel taj ključ kopira u vektor t. Dakle, jedan po jedan baitci kopiraju u cijel ovaj vektor. Ali ako je veličina ključa manja od ove maksimalne vrednosti za veličinu ključa, dakle, manja od 256 baitova, onda u nekom trenutku potrebno da ponovimo deo ključa jednom ili više puta. Ovo nas pociće na ono vizinerovo shipru gde prosto ponavljamo naš ključ, stavljamo ga nekako ga pišemo iznad našeg plain texta pa isto i ovde prosto Sam ključ ponavljamo smještamo ga u vektor t, pakko imamo još mesta, imaćemo koja je veličina ključa manja od 256, onda opet krećemo od starta samog ključa i kopiram ga u vektor t. Ono likoputa koliko je potrebno da se vektor t popunje. I sad u kodu to bi izgledalo ovak prosto i samog ključa na poziciji i uzmemo vrednosti, pri čemu tu poziciju i nađemo starta k predeljenju sa veličinom samog ključa, da bi smo prosto nekako krugno vrteli sve vrednosti i samog ključa i kopiram ove neki naš vektor t. Onda kad smo formirali vektor t na osnovu ključa, on se koristi da se inicijalno permutuju sve ove vrednosti u vektoru stanja s. Dakle na neki način se prosto sad sve ove vrednosti iz stanja s mešaju, a na osnovu ovog vektora t. Kako se to radi? Pa tako što svaki element vektora s menjam u nekim drugim elementom vektora s, koji zavisi od odgovarajućeg elementa vektora t u tekuće iteraciji. Dakle svaki element vektora s od 0-og do 255-og popetnjamo neku for petlju, menjamo nekim drugim, toh znači menjamo mu mesto sa nekim drugim elementom takođe u istom tom vektoru s. E kako se taj drugi element bira? Pa tako što se sberu praktično neke 3 vrednosti. Vrednost predhodne pozicije na koji smo našli element sa kojem ćemo menjati ovaj naš tekuće element pa samu vrednost tog jelementa koji menjamo i samu vrednost koja se nalazi u ovom privremenom vektoru t na poziciji i. Na taj način naravno sve radimo po modulu s 256 da bi smo lepo indeksirali šta treba. Na taj način dobijemo poziciju na koje ćemo naći element sa kojim menjamo naš tekući element i vidite u for petlji prosto ovde sa leve strano ovog svo pa će se naći u nekom trenutku svi element i tako da svaki element će da se izmeša sa nekim. Dakle u opštom slučajne mora da se desijali nijedan element neće ostati na svoj poziciji, on može da se vrati na svoj poziciji u nekom trenutku ali u suštini svaki element će da odeneviti. A ovaj drugi element biramo na ostnu u ovog indeksa koji dobijemo na ovaj sistematican način. Kada smo izmešali sad ceo taj naš vektor s, onda na dalje ključu opštene koristimo. Dakle mi smo sad izmešali taj vektor stanja i njega koristimo sad bez ključa da na izlazu izbacujemo byte po byte koji onda ksorojemo sa porukom ili šta već drugo radimo. Dakle nekako ga kombinuamo sa porukom u glavnom je to ksor operacija. Kako se to radi? Pa opet nekako biramo jednu vrednost iz vektora stanja u svaku iteraciji, a onda dodatno nakon te iteracije još jednom nekako menjamo mesta u tom vektoru stanja s. Kako biramo koji element ovog vektora će da nam bude ono što nam generishe zapravo i algoritm u jedno iteraciji. Pa u beskonočne peti naravno dok hne izgenerisamo sve što treba, zavisi od veličine same poruke koju šifruemo. Na neki način biramo indexe i jot koje koristimo da ponovom malo izmešamo ovo naše stanja. Dakle, svako iteracija algoritma mi malo izmešamo to stanje. A ta dva elementa koja smo konkretno upravo izmešali, uzimamo njihove vrednosti, sabiramo ih i naravno opet nađemo statak predeljenju z 256 zbog indexiranja i dobijemo poziciju u ovom vektoru s na koji se nalazi baš, na koji se nalazi baš vrednost koja se dobija i dalje koristi za ksor operaciju sa sledećim bajtom originavnog teksta. Dobro, samo da pitan košta mi je prvo pisalo da mi je koneksija slaba, da li mi je dalje čujete, odnosno, da li vidite u sliku? Treke u listu. Da, sate čuvamo, u jednom momentu ja nisam čula, a nisam bila sigura da je do mene ili je do teba. Dobro, dobro, a dok li ste me čujete? Pa, i od, i od se nije čulaka se je bišnjavo, dakle, kako se formiraju. Da, dobro. Dakle, u sluštini nisam ni objasnio kako se konkretno formiraju i od samo sam reku da se na neki način formiraju i oni se koriste da prosto indeksiramo neka dva elementa u našem stanju i onda im zamenimo mest. Dakle, prosto da bi smo s uvaku iteraciji malo ponovog izmješali pe o naše stanje, a vrednosti koje se nalaze na tim mestima koje smo upravo indeksirali, sabiramo da bi smo dobili poziciju naravno sve po modulu s 256, poziciju na kojem se, na koje se nalazi prosto vrednost koja se dobija ovim algoritmom koja je izlazi iz onog generatora i koja se dalje ksoruje sa sledaćim bajtom originalnog teksta. Dakle, mi ovdje generišamo poziciju u stanju, i na toj poziciji dobija mohu vrednost k i kaže ovde dalje ona se koristi za ksoru operaciju sa bajtom originalnog teksta. Dakle, sve ovve algoritmi funkcionišu tako što vi izbacujete bajt po bajt ili bit po bit koji se dalje ksoruju sa samim tekstom, ovdje suštini tekst u ovom algoritmu opšte nefiguriše nikt. E, kako se dobijaju i ot pa i se dobija, dakle, i prosto ide redom od nula pa do 255 i onda u nazad, a jot se dobija tako što prosto predhodnu vrednost samog jota, sberemo sa vrednošću elementa koja se nalazi na poziciji i u vektoru s i sve to ponovopomodulu sa 256 dobijemo tu poziciju jot. Tako da nekako nasumićno dobijemo te pozicije malo mešamo sam vektor i opet nekako na osnu tih elementa dobijemo konkretnu poziciju na koji se nalazi vrednost koju generišemo i na taj način funkcioniše generisanje samih bajtova u RC4 algoritmo. U suštini, ove RC4 je donedavno se smatrao dozda sigurnim algoritmo, dakle, nakon nekoliko analiza napada, na RC4 pokazalo se da njeda napad nije dovoljno praktičan, ukoliko se koristi ključ čija minimalna veličina 128 bita jer nam to onda on ne mogućava i brute force napad. Međutim, nedavno konkretno u vep protokolu je primećena jedna slabost koja nije bila konkretno vezana z RC4, nego je problem bio u načinu generisanja ključeva koji se koriste u RC4, a generišu se nekakvog vep protokolu. Jer mi smo rekli prosto mi ovde krećemo od neku ključa pa njime inicijali za monaj vektor i koristimo taj vektor da izmešamo ono stanje. Po prosto vep protokolu imamo tu neki propuz da ključeve koje generisao, generisano na takav način da samo onaj vektor stanja koji imamo od svih mogućih permutacija koje tu mogu da se dese, se sveo na neki podskup tih permutacija. Dakle nisu sve bile moguće da se generišu, al to nije bio problemu RC4 protokolu nego u samom vepu koji je birao kako se ključevi generišu i koriste zalje. Tako da je ovo moglo da bude prevaziđeno tako što prosto ti protokoli ili aplikacije koje koriste RC4 će na neki bolji način da generišu te ključeve, pa prosto da uzmun ono najbolje što ima algoritam RC4 pruža, to je da sve moguće permutacije stanja mogu da budu izgenerisan. Međutim, ono što se još blije...
 nekako današnjosti desilo, jeste da je pronadžena jedna još veća slabost samog algoritma, dakle ne sad nekog protokola il neki aplikacije koja koristi ove algoritme koja prosto smanjuje napor za pronalaskom ključa, odnosno svodi ceo opsek mogućih ključeva koje mogu da se koriste na neki manji skup, tako da su oni brute force napadaj mnogo lakši i sad detalje možete zapročitati u knjizi, ali u suštini zbog te fundamentalne slabosti, RC4 se danas sve manje koristi, konkretno, evo 2015 je bilo zabranjeno korist, to jest tada se zabranilo korišćenje RC4 algoritma u TLS protokolu. Tako da prosto opet nekako ove algoritam je bio dugo, imao jako dobru sigurnost koju je obezbeđivao, ali prosto dana se zamanjenim drugim savrmenim algoritmima, pa ovdje ga učimo opet kao algoritam od koja je sve nekako dalje protekla. Tako da ako imate neko pitanje, pišite sad slovanu chat. Sledaća dva algoritma će maja da ispričat, tako da maj, prepuštam to reč da ispriča šta je sad to zanimljivo kod Salsa 20 i Cha-cha 20 algoritama. Hvala, Aki. Dobro, nakon RC4 algoritma, vidi ćemo neke sledaće, tako algoritme koje se korista, ako ili smitijonišu na sličan način. Što znači dakle, principijalno to su stream algoritmi, ovdje sada radim nad nekim tokom podatakom. I dakle, kao takvi, oni imaju, dakle, isti princip funkcionisanja, odnosno na isti način i odakom imaju neki algoritm koji radi odgovariću obradu nad ključom ka ulezni podatkom. I dakle, formira se praktično neći block tog ključa koji se dalje kombinuje sa samom porom. Dakle, to je nešto što je tipično zajedničkom svim algoritmima streama ili parvećini algoritama streama, odnosno prosto neka paradigma koji ovu algoritmi prate. Salsa i čačaka u algoritmi koje danas radimo, pripade to je neku i grupi praktično tih algoritama koji su dobili naziv po različitim plesovima. I postoje naravno u više različitih varijanti. Mi ćemo danas raditi neke osnovne varijante, postoje, dakle, različite varijante algoritama i dakle, ti algoritmi se u principu smatraju povzdanje. Prvi algoritm, konkretno koji radimo, je salsa 20 algoritm. I kao što reku, dakle, osnovna ideja je da taj neki ključ koji se nalazi na samom ozu se transformiše nekako prema pravilima konkretnog algoritma i zatim se kombinuje sa porom. Tako da praktično i u ovom algoritmu nema neke transformacije podataka same poroke, vece sva transformacija radi nad podatacima ključa. One koristi neke operacije koje ćemo videti kasnije i upravo te operacije koje predstavljuju gradivne elementa ovoga algoritma čine da je algoritm dovoljno povzdan. I ne samo dakle sama operacije veći način na koje su oni premenjuju, ali ono što je takođe druga i jako bitna stvar, a to je i sama efikasnost algoritma. Zato što dakle jasno da je kod ovih algoritama jako bitno da takođe algoritom bude efikasan i da se dobro može implementirati. Izbog toga, osim što uopšteno same operacije koje se premenjuju, garantuju nekoj efikasnost pre svega svoje jednostavnosti. Takođe, dakle, postoji neke specificne implementacije za najčešće kajom mogućavaju prosto još efikasnije algoritma. Ok, idemo dalje. Što stiča, dakle, samih gradivnih elementa. Dakle, na početku imamo neki ključ i to je, dakle, ona ulezna vrednost ključa koja se nekako transformiše i na osnovu koja se dobija neki stream ključa, koji se ovde nalazi u formi bloka. Tako da ćemo ga mi zvati kao blok ključa. I ta vrednost na kraji, dakle, koristi se za samo kombinovanje sa elementima fork. Sam blok ima 512 bita i, dakle, on se formira korišćem, dakle, nekih različitih funkcija i teracije, koje ćemo videti nešto kasnije na osnovu kojednih gradivnih elementa. I sad, dakle, ono što ulezi zapravo u transformisani ključ je jedna 256 bit na vrednost ključa, koji prektavlja nekako izgenerisano vrednost. Dakle, za takav i jedan blok potrenom je 256 bita neke izgenerisane vrednosti, koje zapravo prektavlja nekoznat u vrednost ključa na početku. Ostatnog odakle koriste se non s vrednostim. Dakle, to su neke vrednosti od 64 bita koje su, principu, koriste protiv nekih konkretnih napada. Dakle, to su takođe na neki način izgenerisane vrednosti. Zatim, osim, ova dva različitih podatka koriste se takođe i brojači. Tako da u svakom u ovom jednom bloku ključeva imamo 1,64 obiti broječ i taj brojač nam slušli da bi smo zapravo mogli da se pozicioneramo u tom streamu podataka, odnosno, ovde dakle konkretno u streamu ključa, ako bi se efekstno praktično dokvati o konkretan blok u tom streamu ključa. Osim, da člove prednosti koriste se i neke konstant. Sve to zajedno čini ovih 512 bita bloka ključa, koji se zatim koristi u kombinovanju sa savom porkonu. Sava se inače kao algorita može imati nekih n uzestopnih funkcijerom. Gde to je nji prosto parametar i daflavari obilenstvar, međutim, ono što je tipično je upotreba 20 rundi i zato su ove algorita mi je naziva salsa 20, dakle ima 20 rundi. Ali kao što rekli, postoje neke druge variante algoritme. U nas da pokusimo za početak videti, dakle kako izgleda sada ta struktura bloka ključa. Pritam, ovo što vidite na slici je inicijelni blok ključ. Dakle, to je kako se zapravo formira ove bloka ključa od 512 bita na savom početku na osnovu onnih pojedinačnih vrednosti. 512 bita znači da ćemo praktično imati 16 reči gde svaka reča sastoje od 32 bita i predstavljamo mi hovaku kao jednu praktičnom matricu reči. Gde na početku u tom inicijelnom stanju, dakle svaka rečna predstavlja jedan konkretan podatak od onih gradivnih elemenata koja sam malo prenavrat. Kako da, ono što sam rekla je da imamo jedan 256 bitni ključ, što znači doće nam činiti polovinu ovog inicijelnom bloka. I to su ove i atak ovih osm različitih reči koje vidite koje su obojene selenom pojem, nekako razbacene po ovom inicijelnom stanju. Osam to kako imamo dve non-svrednosti, zapravo je otak koji imamo 1,64-bitnu non-svrednost, ali ona je razvijena u dve reči, jer je svaka reč 30-bitna reč, tako da su predstavljene tako kao dve reči u ovom bloku, zanim counter, koji je 64-bitan, tako da ga ponovodelimo na dve reči, i konstanta koja se ovde proteže na 4 reči i poredžena je ovako po diagonali. Ove raspored pojedinočnih vrednosti nije tak tak ko uzet i u principu figuriše u samoj funkciji iteracije i ima utica na sigurnosti samog algoritma. U sebičenu svake poredinočne runde, imamo 20 rundi još jednom, i one su u principu podiljene na parne i neparne runde, zbog tog da što se u principu svaki ovaj blok procesirana na različnju značinu, uz avisnosti od toga, da li se radi o parni ili neparni runde. Moguće je naka modifikacija u algoritmu, po kojem se zapravo neprevidi iteracijacija u odnosuna to da li je parna ili neparna runda, ali na ovaj način takođe doprinosimo sigurnosti algoritma. Razvika je u glavnom u tome da se prostu drugačije obilazi da tako kažem sam blok ključa, sama funkcija koja se koristi u rundi identično figuriše, međutim uzima podatke u nekom drugačijem rasporedu, pa tako kažemo da neparne runde praklicno obrazi u stani ključa po kolonama, dok parne to rade povrsta. Svaka runda koristi funkciju koja se zove quarter round i to je zapravo četvrtina runde, zbog toga moramo primeniti četiri ovakve funkcije. Argumenti funkcija su četiri reči stanja, gde dakle, pošta smo videli da u kupno imamo četiri kolone, četiri brste, tako da te četiri reči zapravo predstavljaju reči jedne kolone ili jedne brste, zavisno od toga, dakle, koja runda je u pitanju, odnosno, da li je u pitanju parna ili neparna runda. Međutim ovako, dakle, plastično gledano, prije nego što uđemo u samo implementaciju ove funkcije, dakle, one prima četiri reči stanja na neke način i obrađu je praktično te četiri reči na taj način, praveći difuziju, odnosno na taj način zapravo bezbeđuju je da samo obrada ovog ključa bude dovoljno sigurna iz razloga koja je kolega Adrijen, da ću pisati prejena. Majmo dalje.
 Na ovom slajde možemo da vidimo da je kako izgleda svaka runda. Što se tiča operacija, odmismo, osnovnih operacije koji se koriste u opuru ovaj funkcije čtvrtine runde, da je to vrlo je bitno da pomenemo koje su to operacije. I to su tri izuzetno jednostavne operacije, operacije sebidenja, operacije ksor i operacije krugnog pomeranja. Sve ove operacije radi na 30 bogitnim rećima. I to je jasno od boga toga što smo videli kako je podeljena naša matrica, odnošno naš blok stanja je otako. I jasno nam je da zbog toga argumenti predstavljuju 30 bogitne reći, a naravno u tom slučaju i sam rezultat operacije takođe predstavlja 30 bogitne podatke. Što zači da kada primenimo svako od ovih operacija, mi takođe rezultat vraćemo u onaj predvijegni obsteg 30 bogitnog rezultata. Recimo u slučaju i sbiranja, dakle naravno tražimo ostata k predjeljenju sa maksimalnom rednošću koje se može dobiti u tom obseku. Ove operacije su izabrenene na jedan specifica način i dakle kombinuju se takođe na specifica način što ćemo uskoro videti na osnovu ove še men. Tako da se zapravo reć o izuzetno jednostavnim operacijama koji je i obezbeđuju i fikasnost implementacije i to genderalno da je samo algoritm jestinno implementirati. A su druge strane, dakle kombinovanje fik operacije i genderalno kombinovanjem argumentata koji se koriste u samim operacijama, obezbeđujemo sigurnost algoritma tima što zapravo pravimo maksimalnu difuziju. Odnosno, trudimo se na neke način da kombinujemo zapravo različite reći, maksimalno to radimo između reći koji se poproslađe sva koje ove funkcije. Dakle, nas funkcije je primjan četiri reći, ABC i D, i na neki način kombinujete četiri reći. I to radi prosto koj sprimenu ove tri operacije. Kao što vidite, ove operacije se nekako periodično ponavdaju svaki put na identičan način. Tako da zapravo svaki put radimo sbiranije dve susedene reći. Tako da u prvom koraku sbiramo A i D, dakle, one su susedne, naravno, ako kružno posmatramo prostolo, sbiramo A i D, vratimo u obsteg vrednosti, tako, i rezultat koji smo dobeli, dakle, rotiramo levo, fiksno, za sedom pozicija. Dakle, ove pozicije, odnosno, broj koji nam označava, zakoliko zapravo rotiramo, odnosno, pomeramo samu vrednost, su prosto fiksni parametri algoritm. Tako da je to ovom slučaj za sedom pozicija. I dobijani rezultat kombinujemo sa vrednog vrednošću reći B. I dobar smo izvršili jedan upisio, tako, u tu reć B, odnosno, abditovali smo tu vrednost. I kao što vidite, dakle, ono što primjećemo da je ove vrednost B, nakon primjene ovog dela operacije, kombinuje svoju predskodnu vrednost i kombinuje vrednosti neke druge dve reći. Nastavljamo na dalje potpuno identičan način. Da hluzimamo sledeće dve susedne reći, što znači B i A, sabiramo ih, vratimo rezultat u obstegi, i zatim rotiramo u levo, sada za dve pozicija, i tako dobijeno vrednost, ksorujamo sa predtodnom vrednošću elementat C i upisujemo upravo u tu reć. Sad da opetak u pogledamo, ozno u čega se formira zapravo nova vrednost ovog C, pa vidimo da u njenom rezultatu direktno utiču i A i B i predtodna vrednost reći C, ali takođe i vrednost reći D, al tako koja prosto figuriše kroz izračunavanje reći B. Na taj način, na izračunavanje, odnosno upis ovog novog elementa, imaju utice sve predhodne reći. I to je isto se dešlova i za sve prostele element. Takla i prilikom izračunavanja reći D i prilikom izračunavanja reći A, uvek sabiramo, dakle neke dve susedne reći za D to su C i D, pomeramo odnosno rotiramo za neki fixni pomeraj, u ovom slučaju to je recimo 13. I nakon toga je o tako k to rovamo sa svojem vrednušću. Vidite da i tuk u slučaju D i u slučaju A, a predhodnostno videli da je takva situacija i za formiranje reći C. Dakle sve ove reći imaju utice u formiranju dakvatev rednosti, tako da obezbeđemo maksimolo kombinovanje različitih reći koja figurišu u ove funkcije. Jedino je tu dakle za samu prvu reću, zbog prosto identičnog načina primene svih ovih gradimih elementa funkcija, čtvrtina iteracije, nismo mogli da iskombinojamo i treću reću, ali je postegnuta velika difuzija na ovakav način. Poprvo sigurnost leži u tome da imamo što više mešanja i da što više nekih ulaznih bita samog ključa figuriše na samom izlozniku. Kada bih smo imali, recimo, funkciju koji slučimo u kombino je tu neku reću, tako i nema mnogu utice među drugim rećima, onda naravno timi prosto imete malo kombinovanja u unutrašnji podataka, ulaznih podataka partom, odnosno dakle jedan ulaznih podatak prosto nema velikog impakta na različite izlazne bite, odnosno podatke. Dobro, videli smo tako funkcija četretina runde i stada, koji ćemo da vidimo kako to izgleda na jednom primer. Pošto smo videli, dakle da se tu prosleđaju neke četiri reći, međutim, mi smo još videli kako se bire i te četiri reći, po kom redosledu s one zakravo uzimaju, a znamo da ne perne i parne runde drugačije tretiraju samo stanje, onda ćemo ovdje uzeti jedan prosto primer, da smo redom nomerisali, dakle, ove reći, koje postoje u našem stanju, da gljemo 16-30 bobiti treći i prosto na jednom primeru smo samo prosledili te reći ovim funkcijama četretine runde i na taj način praktično znamo kako svaka od ovih funkcija u unutra funkcioniše, odako, odnosno, kako radi, tako da samo još da vidimo kako je prosleđuju ovo argumenta i s njim znamo da afle kako funkcioniše u podniječne ronte. Ne perne runde kojih ugupno ima 10 u ovoj varianti algoritma kojih ima 20 rundi funkcionišu, dakle, po kolonama i prosto ove je element a, koji je zapravo prva reć koja se prosledjuje funkciji četretine runde, je uvek određen inicijelnom pozitijom konstante u toj kolone u ovom slučaju. Tako da ćemo, dakle, prvoj četretini proslediti element 0, 4, 8 i 12. Međutim drugoj ćemo prosleđivati iz druge kolone, ali ne od prvog elementu odnosno od jednice već od pozicije, dakle, ove konstante, tako da, 5, 9, 13 pa nakon toga je. U sledeće kolone, dakle, ponovno od pozicije konstante, da, što znači 10 pa 14 pa kružno 2 i 6 i na kraju iz poslednje kolone, dakle, 15 pa nakon 2, 3, 7 i 1. Dakle, gledamo prvom poziciju konstante. Što se tiče parnih rundim, posmatramo povrstama i, dakle, ponovno krećemo od pozicije inicijelne konstante, što znači da, prvoj, ovoj funkciji četvrutine runde prosledžujemo vrednosti 0, 1, 2, 3, zatim drugo je otako počov od petice, što znači 5, 6, 7 pa 4 i tako da, 3, 10, 11 nakon toga, 8 i 9, a 4, 15, 12, 13 i 14. Što si tiče, dakle, samo izvršavanje algoritme, nakon što smo ustanovili kako izgledaju pojedinačne runde, da se sastoja od četiri ovakva funkcija i vidjeli kako svaka funkcija izgleda i kako figuriše al tako samom algoritmu, nakon što smo završili onoliko rundi koliko je predpidženo, mi smo formirali nekvi finalni blok ovog ovdje ključe. Taka finalni blok se na kraju kombinuje sa inicijelnim blokom podataka i dobijem, dakle, blok se na kraju kombinuje sa samom formirom. Dakle, i uš jednom svo procesiranje radi se nad upravo ključem, odnosno blokom ovog ključa kako vidite ovako. I zapravo se na taj način primjenom, naravno, više struku govako u algoritme za svaki del podata kako je odgovara prakčno takom jednom delu streama ključa, formira na kraju je otakva odgovarejći del ključa kombinuje se sa porukom i dobijemo šifrovanu formir. Što se tiče dešifrovanja? Naravno je otakvo, ako se radi u obječnom kombinovanju poruke sa sajim ključem i kada je u picanju ksor, kao što smo i rekli sam na samom uvodu ovog časa, dakle, ključ se ponovog kombinoje se šifrovano porukom i tako dobijemo plain text. Jedino što je jasno da ključ mora biti prosto u istoj formi, kao što iskorišćen i prilikom šifrovanja. Što znači da vi smo u ovom slučaju inicijalno stanje kombinovano sa krajnim stanjem koji dobijemo nakon ovih 20 rundi i samim tim bi smo prošli prozidentično ovakav algoritm u pravljanju ključa koji se koristi i za dešifrovanje, dakle, prosto ne bi smo radili reverzan neki proces za dešifrovanje. Što si tiče, dakle, utip sa jav svakaj u ovdove funkcije prosto nalize samog algoritma, o tome ćemo nešto kasnije kada budemo u ovom svakaj algoritm koji predstave pobljšanje ovog salv sa 20 algoritma, tako da ćemo onda prosto prediskutovati koje su neke razveke tih algoritma za što
 da je uopšto došlo do to povešanja i šta postižamo zapravo ovim segmentimo i zašto su ti segmenti baš na taj način izabredi. Dalimo imate neko pitanje da je nešto prosto ostalo nejasno oko ovog dela kako funkcionišnja sam algoritm. I ako dakle kao što je Akireka od na početku, ono što je dobra stvar ko dovi streamom svih algoritama je da su to izuzetno jednostavnije algoritme i kod kojih prosto ove operacije su prosto jednostavne pre svega zbog epikastnosti, ali ono što je jako bitno je da se postiža dobro sigurnostim mešanjem različitih vrednosti u samom delu koji se odnosi na ključ i dakle da često ako nevamo u potpunosti neku slučajnu vrednosti na početku koristimo i dodatne eksterne informacije kao što recimo u ovom slučaju kombinovanje dakle samog ključa, kombinovanje nosvrebosti koji su na neki način izgenerisanje takođe, ali i kombinovanje određeni konstanti i kombinovanje samo brojača. Hdaj vi prosto vidite da nakon x rundi koliko imamo u samom algoritmu naravno rade se upisji u svakod tih povedinočnih reče dakle da to na kraju budu sasvim neke druge reči koja su izgenerisane, ali na taj način prosto više različitih nezavisnih podataka ima utica je na finalno izgenerisani blok ključe. Dobro, danim imamo neko pitanje ovo. Oče, dobro, osim ovog algoritma imamo još jedan algoritm da prođemo i generatore i ne znam da li se slažete sa tim, ali možemo da nastavimo sada i da radimo bez pauze zato što ćemo nešto rani je završiti danasnju lekciju. Pa, evo, pošto čača pretstavlja dakle jedan konkretno nastavak na samo ovaj algoritm koji smo radili, možda jednostavno je do odmah pređemo na modifikacije ili, ako žalite, možemo da idemo i na pauzu. Ako imate neke žalje, vi slobodno recite. Međovrbom smo dobeli neko pitanje. S, I, S, D, S, R Echo, S, I, B, H, H, L. Aha, dobro, neče što stiče R Echo, S, I, B, H, H, L, na algoritma i laboratorijskih vežbi. Nemamo dakle skraćenu verzi u samih algoritama, već prosto idete proz simulator, pratite kako izgleda, dakle pratite test, pratite ulaz i pokunjavate odgovarit će vrednosti, dobijete neka dodatna pitanja, ali u principu ta vežba je drugačija u odnosnu naove predkudne koji smo imali, prosto i bu ktoga što nemo skraćene verzii algoritama. I jasno je tako, isim da smo imali neku formu tih skraćenih algoritama, kao što bih u sluči koje desa, I, S, D, S, S, onda to kođe bi smo to naravno negde proradili na časuvima, tako da dakle ta poslednja vežba je nešto drugačija u odnosnu naove predkudne i dakle glavni input je i samog simulatura i ono što je potrebno da znate prosto iz samih algoritama. Ok, što se diče, dakle, sada se sledajte pidinje kaže, da li je konstanta deo algoritma, to jest javne ili ona tajne, na koji način se gdje neče. Dakle, konstanta jest deo algoritma i to je u napredi definicena vrednost. I dakle, to je neka vrednost, dakle koja je prosto deo nekih, zapravo pretovi da se penc, laski karaktera neke rečenice da tako kažem, tako da je ona jedan fiksan deo, fiksan deo samog algoritma, ispa situacije sa onim pomeraima. Dakle, to su prosto neke vrednosti koje su izbredane specificno način, s tim da, pod konstante, dakle, prosto samom, dakle, te vrednosti su da bije na osmog u konkretne rečenice, a ako od ovih parametara koji su koriste za rotaciju, oni su na neki specificu način birani da bi to bilo što je fikasnije, o čemu ćemo nešto kasnije malo više pričati. Dakle, ovih konstanta je dakle deo samog algoritma, nije nešto što su principu, nije nešto su principu ne. Inače, kod većine algoritama, o kojem ma pričamo, i kod oni, kod kojih te konstanta i parametri su nešto što je podložno modifikaciji, također, dakle, po svoje vrednosti koje su u napred zadate i koje su bolje zakorišćanje u odnosu na neke druge vrednosti, ako dakle njihovim postavljanjem na ta način doprinosimo sigurnosti algoritma. Dakle, ono što smo videli kod desa i kod ae sa, dakle, iako možemo modificirati, odnosno modifikovati same parametre algoritma i prosto živati, što jeste nešto, dakle, što se radi, u svoje, dakle, neke prethodno zadate vrednosti koje su najbolje za samom algoritam i to tipično imate svuda, dakle, i kod ovih algoritama, i kod generatora pseudoslučenih brojeva, o čemu ćemo pričati kasnijem, je prosto, dakle, eksperimentalno i utvrđeno koje su to vrednosti, koje su prosto bolje, koje figurišu u samom algoritmu na bolje način, što, način, recimo, utiču na stvaranje nekih specificnih rezultata ili na mešanje više vrednosti ili na nekih način doprinositi sigurnosti algoritma, tako da su, dakle, te neke predepinisane vrednosti nekada bolje za samohorišćenje generalno u algoritmama. Dobro, odvečno, da li imamo još neko piste? Nemo. Dobro, je li se slažete da nastavimo sa časom? Mjelimo nekako se ne slaže? Dobro. Ako nema, nikako se ne slaže, onda možemo da nastavimo. I sljedeće algoritmo koji radimo je, ča-ča, 20. I ovaj algoritmo, dakle, predpravlja neku unaprijenje s salsa algoritma, odnosno, funkcionično, slično kao salsa, ali ima neke manje modifikacije. Sa dobra stvar što funkcionično slično, ješto ostane gradivne elemente već poznajemo. I tako, dakle, sam blog ključa se sastoji od isti gradivnih elementom. Samo su, dakle, ti te podinočne reči koje se navazu blog ključa nekako drugače i raspoređe. Takođe, u iteracijama nalaze se funkcije ponovoslične, odnosno, imamo ponovo, ono je funkcije četvrti na runde, međutim, one funkcionične malo drugačije, zbog veće sigurnosti algoritma. Osim toga, dakle, ono što je bilo pojete, da pustoji više transformacija, odnosno da svaka reči utiče na više razlačiti kreći u samom blogu ključa, na taj način, dakle, se pobojšava sigurnost algoritma, a također, malo boljim izborom parametara se postožu nešto bolje performanse, ili u najgora slučaju, dakle, u pitanju su iste performanse, zato što one zabise od konkretnih implementacija za neke konkretne architekture. E dobro, u nastavku ćemo vidjeti, dakle, detalje ovog algoritma i na kraju kao što rego popričićemo prosto razlikama i zašto su baš uvedene takve razlike. Dačne struktura bloga ključa, inicijalno ključa je otako, videli smo se stojise od identičnih elementata, što znači ponovo imamo jedno stanje od 512 bita, znači ponovo četiri reći od 16.32 bita, četiri konstante, osm reći ključa, dve reći countera i dve reći non sprednosti, no i živdje mi, one su sada poredjene na drugačij način i tima što su poredjene na drugačij način, one će zapravo uspoviti da rezonsle zapravo pojedinačnih reći koje se proslađuju ove funkciji četvrtina i teracije, takođe bude nešto drugačije. Hajde da vidimo dakle kako izgleda runda, dakle runda su ponovopodajene na parne i neprne, sličimo kako od salca algoritma, zajedno čine double round, tako da u ovom varianti gde imamo 20 runda i odnosno 20 teracija, ponovu imamo po 10 runda. Svaka runda ima četiri, zapravo, odnosno primenjuje četiri ove funkcije kao što smo videli i do sada. Jedno što dakle te funkcija izgleda malo drugačije, dakle one koristi identične operacije, što znači ponovu imamo sabiranje, ponovu imamo operaciju ksor i ponovu imamo dakle rotiranje u levo. Među u tem sada malo drugačije kombinoje te operacije, a upravo motivacija različite primene ovih operacija je u tome da postignamo bolju difuzio, odnosno da obezbiljimo bolje mešanje pojedinačnih reči stanje. I kako to radimo? To radimo tako što zapravo imamo više upisa u svakod pojedinačnih reči, tako da se sada svaka reča žurera dva puta u mestu samo jednom što je vila situacija kod casa. Dakle, kad kažemo žurera, to znači prosto radi se neki upis u tu reči, ono što možete da vidite na osnovu ovog ove kao nekog mini koda same funkcije, a na osnovu i same šeme, je da prosto postoje dva upisa po svakoj lokaciji. Dakle, ukratko to iskleda vidimo kako. Prvi upis u reč A dobija se na osnovu operarija, zultata operacije sabiranja, opet dve susedne reči, reči A i reči B, tako da se zapravo uzima prethodna vrednost reči A. Nakon toga, reč D se dobija
 kao rezultat operacije kstora prethodne vrednosti tje reći i vrednosti reći A koja je sada, način, abdejtora i način je rezultat je takođe imala utica i reć B. I D se dakle rotira za 16 pozicija. Dakle, ono što možete se da vidite da su ove konstante, nešto razvečite u odnosnu na konstante se malo prei i to takođe nije proizbornu urađeno i o tom ćemo malo prudiskutovati kasnije. Zatim takođe možemo da vidimo, C se formira na osnovu svoj prethodne vrednosti i vrednosti D. Dakle, sabiranje, B na osnovu svoj prethodne vrednosti i vrednosti reći C operacijom SOR, i nakon toga se B rotira u levo za 12 pozicija, a da nadalje se praktično sve, a ovo primenju je još jednom i jedina razlika je što se rotiranje radi za različiti i broj fiksno određanih pozicija u nakret. Inoče sve osto lo je potpuno idejeće. I zada, ono što tu možete da primetite, je da očigledno, relikom prvoga žuriranja ove reći A, dakle, na samo A utiču samo dve reći. Na ovo D utiču tri reći. Međutim, ako pogledamo poslednja žuriranje, bilo koje je od ovih lokacija, odnosno bilo koje je od ovih reći, dakle, na svaku rećima je uticaja sve druge reći. I to praktično više njihovih različitih vrednosti. I time se zapravo doprinosi da čača za razlikvo salsa autoritva ima većim uticaja, da gleda svaki ulezni bit prosto utičena više različitih izlizni bitova nakon primjene ovih funkcija. Izbog toga, ovej algoritam je pouzdani u odnosno salsa algoritam. Dobro. A ako vačemo da vidimo, kak u to je isljeda i na konkretnom primjero. Vrlo slično kao i do sada, dakle, kod nefarmih rundi ponovu idemo po kolonama. Međutim, pošto dakle, ove kontante su inicijalno sada drugačija raspoređene, onda će naravno rednost lecami ih argumentata kako uzimamo i otako, razlikovati se nešto u odnosnu na salsa algoritam. I ovdje ćemo, dakle, u nefarmih rundomog prslađivati ovoj funkciji, čertina i teracije. Element je tako da iz prve kolone uzimamo po redostledu 0, 4, 8 i 12. Takle, polazeći od prve lokacije inicijalno konstante, od takvoj koloni, što je prva lokacija u same koloni. Nadalje zatim 1, 5, 9 i 13, zatim iz treće kolone 2, 6, 10 i 14 i iz poslednje kolone 3, 7 i 11 i 5. Dakle, uve krenuči od prve lokacije gde se inicijalno naozila konstanta u prvoj roti. Naravno, u svakoj narodnoj rundi, u te lokacije su pisuje nešto drugo, tako da to više jasno nije ona inicijalna vrednost konstante koji smo imali. Što zadeče parnih rundi? E jasno je doda, ne možemo u potpanojstki gledati po vrstama klasičnom, zato što ako prvi index nam je određen samom konstantom, onda na ove način, jasno vidimo da u našim bloku imamo u prvoj vrsti sve konstanta, a potom više mi u jednoj vrsti nije jednu konstant. Tako da ode zapravo posmatram o vrednosti po diagonalama, da tako kažem, i onda vidite da se zapravo prvoj ove funkciji četvrtine rundi prosledžuju vrednosti po diagonali 0, 5, 10 i 15. Nakon toga jedna diagonala iznadi i naravno jedno statak, što znači 1, 6, 11 i 12, zatim 2, 7, 8 i 13, i na kraju još da je poslanjej elementi prve vrste 3 i 4, 9 i 14. I na taj način dakle funkcijoniše svaka runda. Nakon što smo završili obradu svake rundel, tako finalno stanje su dobijene identično način, tako što se kombinoje sa onim inicijelnim stanjem i da lje se primenju je nad samom porok. I u principu dakle ta ideo je velo sličen. Tako da odo što su ode promjenilo, ajde, zapravo, prvo da imamo što je ostalo isto, možemo vas sadistva. Znači, odo što je ode ostalo isto, o to da se koriste potpano identičnih gradivnih elementi za blok ključan, od kojih dakle nekih vrednosti su izgenerisane, kao racimo što je slučaj pod inicijalnog ključa, 256 bita, koji se mora naogovareći način izgeneristi. Tako će to je slučaj pod non s vrednosti. One se tipično takođe generiša. Međutim, sama Konstanta dakle se ne generiše i osim toga dakle counter je nešto što se generiše, ali ne na slučaj je način, nego je otako ima neku napredo određeno vrednost. I ti svi elementi je su gradivni elementi ova algoritma. Naravno, dakle u svih vrednosti koje su napred poznate, one su poznate i na stranih da se poroka šifruje, i na stranih da se poroka dešifruje, a za sve ostale vrednosti koje nisu napred poznate, dakle one moraju biti na neki način distribujerane sigurnim kanalima do strane koja radi dešifrovinje, ili dakle neka njihova početna vrednost na osmugu, u kojih se mogu reprodukovat i nedvosimisleno moraju biti distribujerano. Ono što jeste razvečito, to je raspored reči pojedinočnih ublokom. Takođe kombinacija ostavnih operacije, da to našto smo videli je da Cha-Cha primenjuje iste ostavne operacije. Operacije sa biranja, operaciju ksori, operaciju rotiranja, levo. Među u tim na drugačin način, koji obezbeđuje da je Cha-Cha nešto sigurni algoritm u odnosnu na salsa, uprvo, timeš, to je odako čini da svaki ulasni bit ima više utice, odgosta utice, jedna više izlazni bita u krajnjem stani. Dodatno, dakle, ove operacije i u jednom i drugom algoritmos su efikasne, naravno, jevcine je odako za implementaciju, zato su i tako birane. I to je odako, ono što je tako zjaki reklam na samom početku, da se tipično ovi blokovski i strimovski algoritmi razvakuju po tome, što dakle, kod bloka algoritama najviće kompleksnosti i zapravo povzdanost algoritma leži uprvo u samom algoritmu, dok je povzdanost strim algoritmo pošto su javko jednostavni, uprvo u izboru inicijalnih vrednosti na osnovu kojih se i radi sva ova obreda, a nakon doga se primenjujevaju prosto nekoliko, dakle, jevcinih operacija da bi sam algoritam bio efikasan, ali onda su oslanjama na sam izboru ključa. Dodatno u to je efikasnosti i figurišnoj kojeficijenti koji se bireju za rotacije, zato što dva kojeficijenta koje su odebrana učaca algoritmo, predstavljaju umnoške broja 8 i da se radilo s kojeficijentima 8 i 16, koje omogućavaju nekoj efikasnoj implementaciju na polji ima hitekturama, dakle, da postoje dodatna optimizacija, što praklično znači da implementacija ovog algoritma može biti brža u odnosu na salsa algoritm, ali dakle svakako neće biti sporije. Time smo završili algoritme koje smo predvideli za danas i sljedeća tema nam predstavlja prostokrata pregled i generalno pojem generatora sve od uslučenih brojelo i kao što smo već reke da ka to neka tema s kojem smo se veći suustreli, međutim, pošto smo to radili na prvoj godini, onda, verovatno, dadaj život nismo bili sve sni u čemu je tačno značaj upravo ovi generatora zašto nam je naročito značeno da to budu neke ili svarno slučano izgenerisane vrednosti ili najzgled slučano izgenerisane vrednosti, ali da zaista možemo upotrebiti i više resursa kako bi smo dobili te neprdvidive vrednosti da tako kažem. Međutim, sada, nekako verovatno imamo prosto jasniju sliku zbog čega nam je to značeno, jer naravno ako po uzdanost, celog algoritma upravo zavisi od inicijalno izbranih vrednosti, onda je jasno da je to zapravo najbitnija stavka. Kao što vidite ove algoritmi koji radimo crimom pod atakam, sami po sebi nemaju dakle operacije koje će vam osigurati, napraviti zapravo da vaš algoritm bude siguran ako sam ključ nije takav, oni doprinu se sigurnosti, ali dakle glavni gradivni element je zapravo dobro izgenericena neka inicijalna vrednost ključa na ostnovu koje prosto radimo neku obradu tipično i dobijemo neko finalno stanje ključa koje zatim koristimo u samom algoritmu. Dobro, preneko što pređemo na generatora pseodoslučenim projevao, da li možete imete neko pitanje vezano za algoritme koje smo do sada videli? Možete sam pitanje kratko. Pa nisam isplatio, kako ste rekli da se generiše non snova kraja? Dakle, bilo u koja vrednost koja se na neki način generiše slučano ili pseodoslučeno? Oddje se tipično radio pseodoslučanim vrednostima, zato što su uspotvoriti i neki algoritm. Dakle, tako je vrednost. Se ili u potkunosti nekako prosleđuje na stranu prijama nekim sigurnim kanalom, ili se generiše neka vrednost na osnovu koje se može izreprodukovat i baš takova nosilj neka slučana vrednost koja se koristi na drugačiju način u samom algoritmu. Dakle, to je potvorno identično. I ovdje kada budemo pričali o generatorima pseodoslučenih brojva kao nekim algoritmima, tako mi ćemo pričati o nekim inicijom u zadatim vrednostima koje su slučane ili na neki način izabrane, tako da praktično može da se izgeneriti.
 i še deterministički čitav nisih slučenih vrednosti. Ali, dakle, sama neka inicijalna vrednost mora biti nešto što će se na odgovarajući način proslediti sigurnim kanalom, a onda se dakle na osnovu nje algoritm s kim mogu generisati na obje strane slučajne vrednosti, i na daj način će sigurno, pošto se pošto je neki algoritm, biti izgenerisane upravo identične vrednosti, ali se neću opterićivati sam kanal slanja svim pojedinočnim vrednostima. Asma, pala. Super. Imamo još neko pitanje, maš da... Toga. Ako nevom da prećemo da generatore, upravo, dakle, upravo i odgovaram na ovu pitanju, no sa sajim pitanjem, dakle, potpruđujemo zašto su nam biti generator i to je dobar uvod. Dakle. Popravno nam je čisto da izgenerisamo neke slučajne vrednosti u kriptografiju, kao što reko, kto je odkrucijalnog znakčaja u pojedinim algoritima, kao što je slučajal. Kod jakih algoritima, kao što smo videli koji je blokoskih algoritama, sam tjuč čak i da se ponavi. Dakle, to šiprovanje samo bloka podata ka figuriše i u odnosu na bloka podata ka. Ode, dakle, nije tako, ode imamo posebnu obredu samog ključa, tako da je zbog toga jako biznuto to zapravo budu različite neke vrednosti. Tako da je tipično tako u vrednosti i dakle, to su neke non-s vrednosti pa jedan od napoda za koje se koristi non-s vrednost, zazpračavanja napoda je zapravo replay napad. Zatim, ključa visevcije one-time-pad algoritm, kratečno generisanje bilo kakos ljučava u opiru ovih algoritama, dakle, za sve to su nam jaku pogodni ovih generatom. Što se tiče, dakle, samih vrednosti koje se mogu koristiti, to mogu naravno biti zaista slučajne vrednosti, a mogu biti i neke izgenerisane vrednosti. U principu razdaka izmađu, dakle, ta dva je što naravno slučajne vrednosti su potpunosti ne predvide, dakle, ne postoji nikakav determinizam u njihovom generisanju. Međutim, tipično je to jedan skup proces, odnosno, bar skuplji proces, zato što, dakle, te slučajne slučajne vrednosti se dobijaju ili u nekih atmosferskih kojavot. Ili, recimo, na neki način hardware-skim prikupljenjem informacije, recimo, posmatranjem aktivacija određenih stignala, ili tako da. To je sve, dakle, neke proces koji traje tipično dužek, u odnosno, na software-ski proces. A software-ski proces tipično predstavlja realizaciju zapravo neku algoritma koji od ulazne vrednosti, dakle, prosto praćanjem neku skupa koraka sigurno dobijan na izlozu neku vrednost, za koju kažemo da je pse udostločena, a ne spočena. Je sada zbog čega. Dakle, recimo pričali u tome, pa ja nekaj koji podrazume vam da znate, jako je bilo dano, ali da vam vam je vart poznato, da je ostavna razlika u donošto stvarno slučajne vrednosti u potpunosti ne predvidiva, doke pse udostločena vrednost samo na izgledne predvidiva, ali zapravo je nešto što je dobijeno algoritmom, pa je savim tim izuzetno deterministički dobijena. Togada ona zapravo nije u potpunosti slučajna, može se izreprodukovati i to se može koristiti i kao pozitivna, naravna osobina, ali opet dakle, produkuje se na ostavu neku ulaznog podatka. I ta ulazni podatak tipično vrednost je prosto ulaz u takav neki algoritm, generiši se na neki slučajan način i na ostavu njega se formiraju sve druge vrednosti koji god algoritm da koristimo sa generisanje pojedinočnih vrednosti i mi ćemo danas i videti nekoliko tankvih algoritama. Tako da, sa tog nekog aspekta prostu sovcirsko generisanje je bržep, međutim pošto je algoritmsko, one u principu jeste determinističko i jeste predvijedivo. I savim tim vrednosti nisu zaista slučajne, već su samo najzabet slučajne, ali nam je u glavnom dovoljno dobro. I dakle, formiraju se na ostavu ne vrednosti koje se naziva SID i ta vrednost je fiks na praktično za sam algoritm i to je ano baš da sam malo prej reka, prosto ako vi imete jedan algoritm pojim na ostavu jednog ulazna podatka pračenjem nekih koraka, uvek reproduku je iste izlazne podatke, a to je nešto što jeste definicija jednog determinističkog algoritma. Onda je jasno da ako vi na jednoj strani izgenerišete tu vrednost na neki način i prostladite tu vrednost sigurim kanalom do nekom drugog njemu nisu potrebnic svi pojedinačni podacij, odnosno sve pojedinačne vrednosti koji se dobijaju na iznozlu algoritma za generisani brojeva koji je jedan iterativni proces veš praktično svaki taj pojedinačni broj, odnosno svaku tu pojedinačnom vrednost može izgenerisati na ostavu te jedne fiksno zadate početne vrednosti. Često dakle, kao što reku u pitanju je neki iterativni proces koji dakle koristi neki rezultat iz predhodne iteracije da bi generisao naredne iteracije. I u principu to je neki generator ili se radi o neku funkciju koja generiše vse odoslučajne vrednosti. I mi ćemo u nastavku vidati nekoliko takvih algoritma. Što se tiče dobroj hustobina generatora vse odoslučajni brojeva neki smo već pomenuli, u principu ono što je dobro je da bi zapravo ako kažete, pa da ješ jedno metoto reziniramo. Da vam algoritm generator daje vrednosti iz neku obsega znači da budete sigurni da prosto ne postoji neki obsek pod obsek da tako kažem u tom koji ste predvideli koji je prosto zerovatni od neku drugog veći da se podjednako odnosno na uniporni način može generisati bilo koja je vrednost u tom obsegu. Takođe, nekada imate recimo potrebu da baš generisate vrednosti sa nekom specificnom raspodolom, tako da u tom nekom smislu vi možete praktično skalirati kako se generiše, odnosno sam obsek vrednosti, dakle možete skalirati na gvarijiči način, tako da dobijete upravo vrednosti generišate prema nekoj raspodeli koja vama više odgovor. Sa druge strane, ono što je bitno, je ne predvidevoj te lamerata koji dobiete a to znači da prosto neku koo vidi kako ste vi izgjenerisali pojedinačni element, samo na osnovu vrednosti to kojedinačnog pseudoslučenog broja, ne može da pogodi koja će da bude vrednost sledećeg pseudoslučenog broja ili nekih naradnih iz obsega i u kom poradku i to bi bila neprdvidivostu napret, a takođe, dakle, nina koji način ne može na osnovu kojedinačne vrednosti koja izgjenerisana da pogodi od čega ste krenali, odnosno što je bio zapravo sid samog algoritmoštvo, što bi bila neprdvidivost u naset. I jasno, dakle, ako je ceo algoritm deterministički, onda je jasno da počet na vrednosti koju ubiram i na osnovu koje gjenerišamo sve naradne brojeve treba da bude na dobar način izsobrana i za to da plečesto i možemo iskoristiti neki način da dođemo do zaista slučene vrednosti zato što nam nije mnogo bitno, ako smo utroštili više resursa za odabir jedne vrednosti, ali jeste, naravno, ako smo utroštili više resursa za odabir jako mnogo zaista slučenih vrednosti. Kao što rekok, nide ćemo nekoliko odnosno početit ćemo se i to ćemo uraditi vrlo ukratko, dakle, nekoliko različiti generatora vse od slučenih brojeva od kojih je prvi koji povenjemo linearni konkurent i generator i njega smo konkretno i videli na algoritm, a tako da, kao što rekok nije sad cilj da mi naštome znamo, dakle sve ove generatora, već prosto da budemo sveste i ihovih nekih zajednjičkih karakteristika i kako se formiraju pojedinačni elementi. Tako da, ukratko i ovaj algoritm kao mogi, formira vrednost dakle, generiše zapravo niz vrednosti i uzima ono likup se od slučenih brojeva, koliko nam je poltrebno za konkretno nekošifrovanje, recimo, ukoliko ratimo generišemo ključeven. I, dakle, svaki sledeći element formira na osnovu prethodnog prema nekoj formuli, kao što možete videti, gde i konkretno za ove generator, tam formula kaže da postoji neki umnožak koji pomnoži, dakle, neko ako je pomnoži taj element, predkodni dodam u neku konstantu, odnosno increment i sve to vrati u nekih obsek vrednosti, zato što naravno, dakle, ti menjujemo operaciju prosto na nekom vrednostu, zavisno od veličina registra, tako da želimo da vrednost ratimo u taj obsek, ako ono izkoče, da je to učeno izkoče adapt. Kao i za sve ovakve algoritme, upravo ono što sam reklap, postoje neke u napred predepinisane vrednosti, koje stavite vrosto standardizovanje i koje vam daju bolju periodu, da tako kažemo odnosno bolji skup različitih vrednosti, i one se naravno, one su u napred poznate, međutim vradi neki experimentalnih primena i primera, dakle koja možete samostom isprodati, možete puzeti bilo šta za segmenta, ovakvo formule, što znači, ovaj umnožak recimo, uzamo da je jedna s sedom, a one incremente je jednako nola, jasno, dakle prva vrednost uzmemo, način s sedom, pa naravno, vrednost formiramo, ja tako, tako što pomnožimo, ovo a s predspodnom dobiljenom vrednošom, to je 7x5, 7, i sve dakle dodamo inkrenut koji je nola, i dobiljamo sve, da je to pomodulo od 32, i dobijemo sve, da ću vrednost sedam, i tako, dalje nastavljamo da generišamo same ključe, ili da ga generišamo vrednosti koja je poslana neki nakon sve.
 odgovarići koristimo, već u slado se tim čemu smo nomenili izlaz iz ovog generatora. I naravno mogući su i neke druge vrednosti, kada samo pogledamo dakle ovo sekvetcu koje smo izreprodukuvali do problemu izgleda da neki način stučaj, na manju ili već je meri uz avisnosti od toga koja smo kogretne parametre uzeli, naravno prosto što uzmete manje ovaj parametr u okoru koga vrat ćete rezultat, u ovog slučaju u samo 32, jasno imaćete više ponadenja, ako imate neki veliki obsek, dakle to bi trebalo da vam da dosta dobru raspodelu. Ok, sljedeći algoritm je Blom Blom Shab Generator, također smo ga radili i on je nešto skupci generator. Tipično, dakle, opet, radi po neku formuli, tako što nosno u predhodne vrednosti, da je do ovom slučaju quadrira, pa dobijemo al tako sljedeću vrednost, međutim, tipično ovaj algoritm je nešto skupci izbog toga, što, dakle, vrednost koji smo dobili na izlazu svak je iteracija algoritma, ne koristimo kao takvu, već iz nije čupamo neki broj bitak, u potom koristimo da bi smo formirali vrednost ključa. Zbog toga, ovo je generator predstavljate, da se sigurno je i napčin, da je zgenerisate neke zaista slučaje na vrednosti, dakle koje ćete koristiti, kao pozdanije vrednosti. Zbog toga što je jedna momenta kada ste vi izgenerisali sam broj kao utputjedne iteracija algoritma, ostaje još da odlučite koji bit ili koje bite, jer naravno moguće uzeti više bita, ćete uzeti iz tako generisanih brojama. Naravno, dakle što manji broj bita uzmete, imate potencijonu sigurniji algoritm, međutim, ono što ne žalite, odakvod uzmete sve bite, ali onda naravno imate ispori i algoritm, jer vam je potrebno više iteracije da bi ste izgenerisali po jednočnu vrednost. Međutim, ovo je generator se smatra jednim od dosta dobrih generatora. OK, idemo dalje. I još jedan, i mislim poslednji generator koji ćemo videti sada nas, je generator saj od uslučenim brojima koji koristi blokovske algoritme za šifrovanje. Dakle, to je našto što nismo videli sigurno na algoritme, zato što nismo prit ćali na arno algoritme za šifrovanje, međutim, ono što je potpano jasno, je da kada imate neki ulas, dakle neku informaciju na ulazu, što bi vam zapravo bio kao neki sida na početku koji je izbran, i dakle njega koristite u nekom algoritmu koji radi i šifrovanje, a to znači da zapravo taj algoritm radi zapravo neku zamenu i odakvo vrednosti u neku drugu vrednost. Pokom god algoritmu da on funkcioniš, odnosno na koji god način da on zapravo radi preslikavanje konkretnih vrednosti. Ono što dobijete na izlazu je za vak zapravo neka pseudoslučena vrednost. Tako imali ste neki algoritm koji na oznovu konkretnih koraka produkuje rezultat na osnov ulaznih podataka, međutim dakle gledano kao prosto neki black box, to je išta jedna način za generisanje pseudoslučenih projeva. Tako da ove jedno še možemo da vidimo, zapravo koristi triple des algoritm za šifrovanje, odnosno za generisanje pseudoslučenih projeva, i o samom triple des algoritmu ćemo nešto više pričati sledeći put. Međutim dakle, je vecom pomenola i prošli put kad smo pričali, dakle radi se jednostavno otronstru koji primene algoritma u nekoj konfiguraciju, što znači moguće raditi više sproko šifrovanje ili kombinaciju šifrovanja i deshifrovanje. Vešto više o tome ćemo sledeći put, dakle nije neopodno sada za razumevanje toga, kako funkcioniše ove generator. Međutim, ono što treba da znamo je da prosto imamo neke ulazne podatke i da recimo imamo inicijom neke ključeve koji koristimo kao neku inicijalno zadat u vrednost. Osim toga svaki ovaj algoritm šifrovanja ili deshifrovanja i nikakogod mora koristiti još ulaznih podataka, zato što osim samu ključe jasno koristi i neki blok je, tako da mora imati neku eksternu informaciju. Nije nam u ovom momentu toliko bitno što je blok, što je kjuč, već je da zapravo koristi i neke dodatne informacije i to su tipično, dakle neki datum i vreme i još neki ulaznih podatak koji se generišu i koji da kri na samom izluzu ovako jedna iteracija, dakle produkuju, neku vrednost koji će se koristiti u naradno iteraciji, kaj da kod će ulaznih podatak i dodatno je odako, dakle ono što je bioci, a to je zapravo neki pseudo stvucajni broj. Tako da ono što smo ovdje mogli da vidimo da zapravo ove algoritme za šifrovanje koje radimo na neki način možemo da koristimo i kao generator pseudo stvucajni brojave, gdje je dakle, ovo je prosto jedan istandardizovan način, kako možemo da koristimo, recimo, baš triple vessel goditom za generisanje pseudo stvucajni brojava na siguran način. Ok, ipak se dožilo više nego što smo predvideli, da li imate nekih pitanja za algoritme koje smo danas vadili? Nemam ništa nejasno, znači sve bilo jasno. Super, u tom slučaju, dakle, ako nemate pitanja, vidimo se sve nevedeće s novom temom. Ok, onda pozdrav svima, stav. Zvima se, pozdrav.
