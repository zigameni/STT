 Dobar dan! Dobro došli na predavanje na predmetu konkurentno distribuirano progamiranju. Tema ovog današnjima trasa su i dalje monitori. Želimo da vidimo kako monitori rade, kako mogu da se iskoriste za rešavanje nekih synchronizacijonih problema. Do sada smo već videli kako možemo iskoristiti monitor da napravimo semafora. Pri likom realizacije semafora smo videli jednu veoma bitnu tehniku. Ta tehnika je bila slična tehnici koji smo videli kojcemafora, gde smo imali prostadživanje štafetne palice. O tehnika koji smo primenili bila passing the condition. Kojdove tehnike, proces koji je zaključio da nekod treba da se probudi, odradi, posao za tok ko treba da se probudi. Proveri da li taj neko treba da se probudi, ako je potrebno da se probudi, odradi sve radnje koji bi taj inače radio. I samo tog nekog obavesti da treba da se probuti. Ako treba taj ušneko odradi nešto ok, ali odradi sve pripremne radnje koji su potrebne za taj jedan proces. Kod kog monitora je nama ovod interesa? Kod monitora koja ima distitlinu koja se naziva Signal and Continue. Kod monitora koja ima distitlinu Signal and Wait, onog trenutka kad nekog odradi signala, taj neko se zablokiralo. A ona i ko treba da se probudi se probudio. Dobro, da li je to baš u tom trenutku nemam poima? Znači moglio da prođe tu pola sata, znači u ovšte nije specificirano vreme, u absolutnom svojm iznosu. Kod kog se je to proteklo, nego je specificirano nešto drugo, a to je da ni jedan drugi proces nije mogao da uđe u monitor u među vremenu. Kod distitline Signal and Wait je to garantovan. Kad nekog odradi signal, dotrenutka kad se taj neko probodi, prvi je taj koji će biti probodjen. Da će se nešto drugo desiti u među vremenu, neće. Znači mogu drugi da dolaze, ali će svojone biti zablokirani na ntriq, neće uspeti da uđu u nati monitor. Kod distitline Signal and Continue je situacija malo drugačija. Kada mi neko probodimo, taj neko iz liste blokiranih prelazio ntriq. Koja je politika rada ntriqa, odgvori poima nemamo. Ne znam kako rada ntriq, da li on FIFO ili nije FIFO, ništa nije specificirano za ntriq. A ako ništa nije specificirano za ntriq, a onda je pitanje, a šta tada raditi. Moramo onda da se oslanimo na ovu disciplinu Passing da Condition. Da smo videli još neku techniku predkodne nedelje, a videli smo kako može da se razdreši jedan synchronizacijni problem. To je bio problem proizvođača i potrošača i realizovali smo buffer konočno kapaciteta. Dali korisnika uopšte zanima kako je realizovan buffer? Ne. Če korisnika imati svoju metodu. Put e get. Korisnika uopšte nezanima kako je nešto realizovanu. Kad radite sa semaforima, a tu sad postoje dan mali problem, korisnici vide semafore. A ovde je ideja. Korisnik dobije interface, dobije potis. Ovako se poziva monitor. Oprvo se ovo metode zove, posto se ovo metode zove. Korisnik treba to da koristi. Korisnika nezanima kako je to konkurentno realizovanu iznutra. A može da ga zanima? Ok. Koji od ovih ima možda bolje performanse, pa onda nosno u toga instanci i odgovareću vrijednost, odgovareći monitor. Na vežnoma, a koje se odnosi na ovaj ovde predmetu, delu za programski jezik java, videte ćete, imate već te materijale postavljene, a više različiti implementacija istih synchronizacijonih problema. Pa jedno može biti koristiti buffer konačno kapaciteta, drugo može da bude koristjen o lista, treće može da bude napravljena koristiti već blocking queue. Znači ima već gotova neke strukture koje možete iskoristiti da bi ste odradili ovaj ovde posao. Što se korisnik atiče, njemu je sve jedno. Uvek dobija isti podpis. Sad da bi smo želili doodradimo jedan drugi, relativno jednostavan problem, a to je problem shortest job next. Probudi posao koji traži resurs, a najmenju količinu vremena. I ako uzmijete da posmotrate, a koja je razlika između ovo govde i jednog bindernog semafora? Pa možda i nema. Ako imate jedan resurs koji nekome možete dodeliti, ako neko taj traži, taj jedan resurs, čekaj, zato nije bindernog semafora. Jeste, u suštini mi ovde želimo da napravimo bindernog semafora i kredjimo od suštini vrlo slične implementacije koji smo imali koji bindernog semafora. Što je bindernog semafora? Pa isto što je bindernog semafora samo što ona naša promenjiva koja kaže, u kom stanju može biti internasemforsko promenjiva, intiđerska nije celobrenovrednost, nego je abulijana, može biti truljifals. I to je ovde istorealizu. Znac, pratite paralelu. Realizacija semafora koristiti monitor i resenje problema short is job next. Čekaj, što onda imam metodu? Imam put, imam get, odnosno request i release. Code metode request. Šta traži? Tražim eksklusivno pravo, pristupa datom objektu, jednom jedinom koji imamo. Dobro, čekaj, a kada ću akoristiti taj objekt? Nekad. Šta sam sad rekao? Ja ću nekad izvan monitora koristiti objekt. Kako je te monitor? Treba lepo isprojektovati. Koji deo se odnosi na synchronizaciju, a koji deo se odnesno nešto što nije synchronizacija? Nama ovde deo koji se odnosi na synchronizaciju je realizovan tako da to se upakovanu u neki monitor. Ostatak koda koji neko drugi treba da napiše, nemojte stavljati u monitor. Doćiće dobi iz prepletanja koda koji neko treba da zove i da piše, a da to nije ista strana. Kada pravite monitor, napravite monitor i kažete nekam, evo ti monitor, ovako se koristi. Nemoj ništa raditi uunutar monitora, zablokirajte sve ostale. I koristnik u suštini tu ne mani neki način kako bi mogu da radi, zato što je dobio samo potpise. Zato i nemojte vi kad budete pisali sve synchronizacijune probleme, kad budete ršavali na ispitima kolokijima. I kad budete nešto radili ne samo na ispitima kolokijima, kad vi budete programirali, nemojte mešati deo za synchronizaciju i deo koji treba da se bavi nekom obradom. Trudite se da ta dva dela budu potpuno razdvojena. Ako ipak nekako možda to mora da bude isprepletano, onda to možda treba realizovati koji je zistit ći odgovarajući u uključne. Uključi u kolbek, odgovarajući u povratnu metodu gde će neko da vam prosledi objekat, kog ćete vi pozvatit iz tog monitora. Onda kad vi procenite da je to pogodno. I onda vi možete proceniti, čekaj, što bi ovo ovo bilo u monitoru, možda ta skostrukcija treba da izgleda se malo drugačije, kad znate kako se nešto koristim. Dobro, znači mi ovdje imamo dve metode. Jedna metoda je request, daj mi resurs i druga je release, vraćam resurs. Što bi mogu da liči na signal and wait koca ima fora. Ali ovde postoji još i jedan mali dodatak. A taj mali dodatak se odnosi na to koliko jedinica vremena, ja želim da koristim neki resurs. Koliko jedinica vremena, želim da koristim neki resurs. Sve ti je pitanje, a kako sa to čudno realizovati? Ajde da vidimo, kako je napravdja na ovo rešenje. Pratimo logiku, koju smo imali kod semafora, koji je realizovan koristići monitor, koji je koristio tehniku passing the condition. Proverimo, da li je semafor slobodan, odnosno da li je resurs slobodan. Ako resurs slobodan, nema šta da se zablokiramo. Ako resurs nije slobodan, zablokiramo se. Kažemo da želim da na čemu da se zablokiramo, na ovoj usluvene promenji. U suštini, kod objekno-orientisanog pristupu bi bilo turn-touch-cal-weight, a ovdje imamo još jedan argument. Taj argument je koliko jedinica vremena želim da čekamo. E, ovo ovde rešenje ovako napisano, sasim lepo radi za slučaj da mi imamo monitor, a koji ima uslovne promenjive, kod kojih možemo da postavljamo ovako nešto. Sada sam sada rekao, je lovo može svaki pude se primeni ili ne. U javi nemoš. Znači, u javi ovako nešto ne bi smo mogli dorealizujemo, zato što uslovne promenjive u javi, ako im postavite neku vrednost, a one će raditi nešto drugo. One će čekati neviše od toliko jedinica vremena. Ovo se blokirati i neće se sortirati prema argument.