 U prve lekcije o parciranju odnaka vrhu videli smo konstrukciju na jednostavnih ShiftReduceParcera klasse LR od nula. U nastavku ćemo razmotriti složenije klasse ShiftReduceParcera. Prvo od njih je tako zvana SLR1 klasa koja dolazi skraćenicu Simple LR od 1. Kod ove tehnike, parser će konsultovati tekući ulaz kada određuje korake rada. I time dobitake što se smanjuje broj potencelnih konflikatu kontroni tabeli koja sada ima oblik pune matrice. Znači vrste su određene stek simbolima, a kolone su određene ulaznijim simbolima, to je s terminalim simbolima grammatike. Osobno ideje je da se redukcija neke smene izvršava samo ako je tekući ulazni simbol iz skupa follow od x. Pričemo je to jedan ovi pojem koji ćemo sada definisati. Znači za svaki neterminal definiše se follow u skup tog posmatranog neterminala x kao skup terminalnih simbola koji se mogu pojaviti neposrednoj za x u bilo koji je sentenci onoj formi izvedenoj iz ove forme, znači gde je startni simbol grammatike i za čega sledi end marker. To je prikazano i do njem formu. Znači ako se u bilo kojoj u izvođenju neposrednoj za x može pojaviti terminal, on se ubacuje u njegu follow skup. Definicija nam lišta je nekažu o tome kako ćemo računati follow u skupove. Da bi smo izračuni follow u skupove moramo uvesti pojemove poništivosti neterminala, također i pojem tako zvanih first skupova neterminala. Neterminal x je poništiv ako i samo asoko se iz njega može izvesti prazna sekvenca. Poništivosti možemo generalizovati na sekvencu grammaticky simbola, znači sekvenca je poništiv ako i samo ako se sastoji od nula ili više poništivih neterminala. Kako računamo znači poništivost, tako što analizirajući grammatiku formiramo skup neterminala grammaticky koji su poništivi. Znači inicijalno u taj skup poništivih neterminala P stavljamo sve neterminale koji se pojavljaju na levoj strani prazne smene, pošto prazva smena direktno uznoku e zamenu P praznom sekvencom. E sad sledneći korak je da se razmatraju ostale grammatike smene, či je se desne strane sastoji skluče od neterminala, a pri tome se leva strana ne nalazi već u skupu P. Znači ako su svi neterminali desne strane već poništivih, onosto već se pojavljaju skupu P, onda i levu stranu smene dodati u skupu P i ovaj postupak treba ponavljati svedog postoji promena u skupu P. Skup P, za neki proizvoljane neterminal P, predstavlja skup svih terminali simbolje kojima može početi sentencjalna forma izvedena iz X. Znači iz X primjenom smena vršimo jedno ili više. Zamena i ako u onome što izvedeno iz X dobilno tako da počinja nekim terminalom, onda znači da je taj terminal u skupu P od X. Znači, skupove je mogući generalizovati na čitave nizove, grammaticki simbola sentencjalne forme, znači neka alfa, jedan takav niz koji se sastoji od n, neki grammatickih simbola. Oni nisu nožno, a1 na 2 su proizvodnih grammatickih simboli, nisu nožno, jednaki naravno. I predpostavimo da u toj sekvenci simbola prvih i simbola znači od a1 do ai predstavlja poništive neterminale, znači 1.cqnc dobijemo ka uniju 1.cqnc svih simbola, sada jevo kraja sekvence zaključilo sa prvin koji nije poništive. Znači 1.a1, unija 1.a2, unija i tako dalje do 1.a i plus 1. Naravno, božemo definisati 1.cqnc terminale, znači 1.cqnc skuplnjegu terminalo sadrži samo taj terminal. Znači to su sve bile definicije, znači da vidimo kako se operacijona računaju 1.cqnc za neku gramatiku, inicijalizajemo za svaki neterminal 1.cqnc na prazan skup, zatim redom idejči kroz gramatiku, razmatramo 1 po 1 neterminal i sve smene sa levom stranom, znači to gov'o predstavlja taj neterminal x. Znači za svako od tih smena, ažuriramo 1.cqnc, tako što u 1.cqnc dodajemo 1.cqnc dnesne strane. Znači kad prođemo 1.cqnc, imamo i ažurirane 1.cqnc, više neće biti svi prazni, i sad ako je znači bila promena bar u 1.cqnc, cjegopostupak ponavljamo, znači ponavoprolazimo 1.cqnc i tako dalje sve dok postoje promena u 1.cqnc. Esat kad smo definisali po ništivosti 1.cqnc neterminala, konačno možemo objasniti, ili definisati računjanje follow-skupova grammatickih neterminala. Prvo što se tiče start-on neterminala, njegov follow-skup uveksadrži marker kraja ulaza sequence, što u suštini ovo pravilo ako dodajemo 1.cqnc u smenu proširujuću na neki način, ne mora posebno ni da se istakrali, znači to je nekakav specijalan slučaj. Esat, znači ide opšte pravilo, znači za neki proizvan neterminal x, posmatramo sve grammatike smene, na čiju se desnoj strani nalazi x. Znači za razlik od frskupova, da smo obračili pažnju na smene, da se x nalazi na levoj strani, ovde znači posmatramo smene, da se x nalazi na desnoj strani. I sad recimo da je neka smena, koja ima na levoj strani nekod y, a na desnoj strani, negde u sredini, znači prex ovo alpha može biti niz od nula ili više grammaticky simbola i za x ovo beta, može biti niz od 1 ili 0 grammaticky simbola. I sad uz avisnosti od toga, da je ovaj nastavak izda x kraj desne strane beta poništiv ili nije. Imamo dve variante formule. Znači po prvoj varianti u follow skup od x uključujemo skup first te sequence beta, u koliko ona nije poništiva, je sada koja beta poništiva potrebno je, znači, malo da gledati i za beta, tako da u first skup od x uključujemo, i first od te sequence beta, ali dodajemo i elemente iz follow skupa leve strane smene, znači to je u sluče da je beta poništivo. Zašto je to tako? Či ako beta je poništiv ili ne postoji u opšte, recimo da smena završava xom, ako bi smo izvori da u nekom izvođenju startnog neterminala možemo i za y dobiti neki terminal t, odmah i za leve strane smene y, prostom zamenom, u mesto y stajemo od eštu stranu koja alfa x ako nema beta, onda bi se znači t našlo odmah i za x, tako da znači sve što može da se nađi za y, automatki može da se nađi za x ako je beta poništivo, izbog toga znači sve što je u skupu follow od x i y, uključemo i u skup follow od x. U z ova pravila nekad je potrebno nači prooći kao i ovim predhodnim algoritmima više puta kroz gramatiku iterativno dok se follow skupovi nestabilizuju značinice, stavimo sve follow skupove prazne, zatim prođemo kroz gramatiku, izvedemo prema pravilima koja smo upravo objasnili nove vrednosti follow skupova i ponavljamo sve, znači po potrebi više prolazak kroz gramatiku sve dok makaru jednom follow skupu postoji promena. Evo odmah ćemo videti, na primeru znači sve ovo što je smo dosad objašnjavali, zadate gramatika, sa startnim simbolom maku ja ima 7 smena, vidimo da ima i prazne smene, znači 3 i 5 i ima neterminale veliko a, veliko b, veliko c i terminale simbole malo a, malo b i malo c. Znači žalimo da odredimo follow skupove za svaki neterminalove gramatike. Prvo idemo na određivanje poništivosti, znači rekli smo u skuponištivi, hinićelno stavljamo neterminale koji imaju prazne smene, to su a i b na osnovu 3 i 5 smene, a zatim još pogledamo za preostali neterminal c, dali slučajno ima smenu koja bi na dešni strani imala samo veliko a i veliko b, pošto takve smene nema, znači c je uvek ima i terminal na dešni strani, znači c je nije poništiv, nego su samo a i b poništi. Zatim računamo first skupove, za neterminal a, gledamo znači 1, 2 i 3 smenu i gledamo čime počinju njihove dešne strane i to stavljamo, znači first, dešne strane smene stavljamo u skup firstoda. Znači prva smena počinja malim a i tu u jednoj završamo pošto terminal nije poništi, znači ne gledamo iz njega, znači dešna strana first skup je, sadrži samo malo a, prve smene. Zatim iz druge smene na isti način, u first skup od neterminala a stavljamo malo b, je sa treća smena je prazna smena, znači nema ni jedan symbol, samim tim first skup, prazna sekvenca je prazan skup, znači treća smena ne doprinosi ništa ovom skupu first od veliko ga i završavamo znači sa a i b. Ovde je namerno malo olaksan u ovom primjeru računanje first skupova, ali na vežbama će biti malo težih primjera, gde je dešna strana može početi neterminalom, pa u tom slučaju je malo više napora treba za računanje first skupova. First skup od neterminala b dobijemo gledajću 4 i 5 smenu i samo iz 4 smene, dači to je malo a, na početku 4 smene, 5 smene, prazna ne doprinosi ovom skupu first od b. Konacno first od c, na b. 67 smene sadrži malo b i malo c.
 završili računanje F-skupova, sada se posvećemo računanju follow skupova, pošto je A startni neterminal, rekli smo da u follow skup startnog neterminalu vek treba ubaciti end marker. Zatim gledamo da li se neterminal A pojavljio negde na desnej strane, neke smjende nema ga, znači time smo završili sa A i njegovim follow skupom. Prelazimo na neterminal B, gledamo gde se sve B pojavljio na desnim stranama smjena i to su prva, druga i četvrta smjena. Znači na bazi prve smjene, proje ova linija, follow B u sebe uključuje first od onoga što se nalazi, znači u prve smjene izab E to je C, znači first od velikog C. Dodatno gledamo da li je veliko C po ništivo, vidimo da nije, tako da time završavamo, znači to je ono formula gde su uzima samo, znači first od onoga što je izab E u smjene. Znači to je bilo ova linija za prvu smjenu. Za drugu smjenu, ova linija znači određuje šta doprinosi druga smjena u ovom skupu follow od B, znači izab E se ne nalazi ništa, B je na samom kraju druge smjene, znači uzimamo first od prazna sekvenca, znači uzimamo follow od A i u nja, pošto je izab E ostatak poništiv, uzimamo follow od A. I konacu, iz četvrte smjene, znači to je ova treća linija, ovo je i načo zna kada je follow od B nackup ovog skupa, to je su sebe uključe elemente ovoga što je na desne strani, znači na bazi četvrte smjene follow B u sebe uključe malo B i pošto malo B nije poništiv, tu je kraj što se tiče četvrte smjene, E sad hat podvučemo sve ove treći linije, možemo konacu da napišemo da je follow u B, znači je jednako stvije, pa sad uniju svega ovoga što je bilo na desnim stranama, znači first od C, unija follow od A, unija malo B. E sad to možemo odmah izračunati, first od C, malo B, malo C, follow O, smo već našli end marker i još dodatno malo B, znači sve u svemu to su simboli B, C i end marker. U konacu da skup follow od C, gledamo u kojim smenama se C nalazi na desnej strani, to su prva i šesta smena, znači z prve smene, pošto je C na samkranu i desne strane, ona u sebu uključuje follow od A, znači to je ovo poslednja linija, a na baziji šeste smene, follow u C u sebu uključuje follow od C. E sad ova linija na musuštini ne daje nikakuposebno dodatno informacije, u svaki skup naravno sodrži sve svoje elemente, tako da u suštini možemo da je zaštiv, i izračunamo skup follow u C kao, da je jednak skupu follow od A, odnosno samo end marker. I na taj način smo dobili sve follow u skupove i resili ovoj primer. E sad kad znamo da izračunamo follow u skupove gramatickih neterminala, konstrukcija SLR1, parsera je jedan prost dodatak na konstrukciju LR2, kako je stavljamo u stavljima, u stavljima, u stavljima, u stavljima, u stavljima, u stavljima, u stavljima, u stavljima, na konstrukciju LR0, parsera, znači praktično, karakterisno je automata SLR1, potista tabela je identična kako da LR0, parsera, u suštini, u ovnim postupku modernije konstruišemo potistnu tabelu i jedina razlika algoritmima se svodi konstrukcija LR0 i SLR1, parsera svodi se u konstrukciju kontrolna SLR1, tabele pošte potiste su identične, je sad što se tiče kontrolna SLR1, tabele znači za njenu konstrukciju u dovoljanju nej karakteristične LR0, automata i follow skupovi neterminala i sad za vrstu neku v kontrolne tabele, mi ćemo pogledati skup, oni helernula konfiguracije ili itema iz odgovarajućeg stanja karakteričnog automata i određuje vrstu, a kolonu određuje neki ulazni simbol X koji je i skupa gramatikih kontrolna tabela ima kolona koliko ima ulaznih terminali simbola uključujući i marker kraja ulazna sekvenca i sad ako skup itema S sadrži, i konfiguraciju ovog oblika da je tačka ispred malog X učio i koloni posmatramo ulaz kontrolne tabele onda to u suštini ulaz kontrolne tabele u vrsti ve i koloni X treba popuniti akcijom shift ako skupa itema sadrži neku konfiguraciju da je tačka na samom kraju desne strane i dodatno važi da je X u follow skupu leve strane takve smene onda ulaz kontrolne tabelu u vrsti ve i koloni X treba popuniti akcijom redukcije upravo te smene naravno ako u pitanju ulaz nulta smena, redukcije, nula isto što je accept i konac ulaz i koji ne potpada i ni potpravilo 1, ni potpravilo 2 treba da budu popunjeni sa reject akcijom prestanka rada uz odbijanje ulazne sekvence u koliko gonja pravila na jedno značno dređu akciju za svaki ulaz kontrolne tabele grammatika pripada klasijela rjeda naravno mogu se do 10 oni shift, redukcij, redukcij konflikti na isti način kada o delar nula parsera obješnjavali primjer konstrukcije rani smo za ovu grammatiku sa 4 smene kojem smo dodali ovu proširujuću nulta smenu konstruisali LR nula parser sada određujemo follow scupove grammatike za ovaj proširujući neterna, pošto ostakni neternafo follow scup je end marker zatim follow scup od s ovde sve može izračunati u follow scup od s idu zarez zatvorena zagrada sve treba sistema otvore i izračunati preko poništivosti ovde nema poništivih neterminala i preko first scupova možemo čisto proveriti koreknost follow scupova vidimo da za s pojavlju je end marker u ovoj nultoj smeni i za s pojavlju je neterminal r u drugoj i treći smeni čim je može r po 4 r može da počne sa zarezom i zatvorenom zagradom da je u pitanju follow e s, vidimo da i follow od r isto što i follow od s što opet sledi zove druge smene pošto ovde r na savom kraju druge smene rekli smo da to onda pravilo da follow od r u sebe uključuje follow, leve strane smena follow od s i vidimo da na kraju stvari dobijamo da on jedak follow od s zarezatvornom zagrada i end marker u ranijem primjeru konstrukcija L0 parsera za ovu gramatiku smo dobili karakteristično L0 automat to je ona iteronortivna konstrukcija sa closure 0 i go to 0 operacijama i to je znači ovaj automat, vidimo koji su itemi u pojedinim stanjima takođe su uvedene one skraćene oznake pojedini stanja ovde samo prikazujemo kontrolnu tabelu slr od 1 parsera i kontrolnu tabela obliku koristeće ove skraćene oznake prikaze ovo je automat dobija se potisna tabela a znači jedino što je sad novo u ovom primjeru to je kontrolna tabela slr od 1 parsera kontrolna tabela treba naravno da ima vrste označene svim ovim stanjima karakterističnoj automata a kolone opet treba da odgovaraju gramatikim terminalnim simbolima u vaj gramatici u pitanju u marker kraja ulazna sekvence malo a otvorena zagrada zarez, zatvorena zagrada to su kolone i sad kako ona pravi la diktiraju znači da gledajući karakterističnoj automat i dodatno konstručitit ći follow u skupove akcija šift se stavlja gde god je kratka ispred odgovarajući u ulaznak simbola recimo u ovoj startnom stanju šift će biti u koloni malo a otvorenom zagrado takođe smo rekli da se akcije redukcije neke smene stavljaju kada u odgovarajućom stanju je item sa tačkom na samom kraju recimo u startnom stanju nema itema sa tačkom na samom kraju smene tako da nema nilidiju sa akcija međutim vidimo recimo već ovoj s0 stanju koja znača drugu vrstu odnosno ni tu ješ nema tu je šift međutim onda u stanju marker kraja sa indexom 0 vidimo da postoji tačka na samom kraju to je ona nulta proširujicio smena tako da u stvari u toj vrsti se rade redujusno u odnosno accept e sad možda je zanimljivije videti recimo za stanje a1 i smenu s se menja malim a to je smena koja ima s na levoj strani a rekli smo da je follow od s zarez zatvorana zagrada i end marker u stanju a1 potrebno je u kolonama zarez zatvorana zagrada i end marker staviti rej redujus to je smena 1 smenja malima vidimo evo u vrsti a1 u kolonama zarez zatvorana zagrada end marker follow od leve strane smene 1 stavljamo redujus 1 redukci u prve smene stavljamo u stavljima stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1 stavljamo redujus 1
 na bazile vih strana, proverite ove kolone i da jeste stavili te rediusakcije, jer one ne smiju biti u kolonama koje nisu u follow-skupovima odgovarajućih neterminala. Ovde vidimo su neki ulaz i ole kontroneta, bela ostali prazni, to su oni ulazi koji čipodpadaju podano pravilo da u stvari su reject, znači po konvencijmi često ne pišemo eksplicitno, reček nego ostavljamo prostoprazan ulaz, da ne bi optenećivali da bi bila preglednija ta bela i rostini najveći broju ulaza je često u pravoridža. Zdreme smo izložili SLR od 1 metod prasiranja, sada ćemo objasniti jedan generalni metod prasiranja, la lr1, i imamo uvodni motivacijunik primjer da vidimo šta su u nedostaci SLR od 1 metoda, koji inače jači od ono galernula, na primer možemo imati gramatiku sa praznom smenom, što u lr0 metodu nemamo i tako dalje, međutim, SLR i jedan metod ima svoje ogrančanje, evo posmatrem ovu relativno jednostavnu gramatiku, u kojoj osim ove prošljujuće nute smene, ima dva neterminala veliko s i veliko a i tri smene, znači ovdje je u sluštini gramatika tako konstruišedana i to čini situaciju zanimljivom, što znači veliko a se pojavlju je u nadesnoj strani smena za s, i to tako da donekle kontekst razvijedit, čitu smislu da u prvoj smeni se izave veliko ga pojavljuje terminal malo a, a u drugoj smeni se izave veliko ga pojavljuje terminal malo c, to odmah znači da mi možemo da zaključimo da je follow scoop od neterminala a, upravo, na baziti smena gde sa pojavlja na desnoj strani, ovu buchvata malo a i malo c. I sad posmatrajimo samo jedan manji deo karakteristickog automata, znači koji odgovara ovo i gramatici, ovo startno stanje, znači tačka na početku nulte smene i zahvaljući closure nula operaciji, potrebno je dodati znači smene za s, tačka na početku i zbog onda ove prve smene, ljude ima tačka odma ispreda veliko ga, moramo dodati o u smenu za a, i znači ovo je scoop finalnijsku pa idema u startnom stanju. Sad posmatrajimo izloz na grana po b, znači to je rezultato nego u tu nula akcija, ova grana treba da bude označena malim b, ona ide u neko stanje gde, znači prebacujemo ovdje zanimljiva situacija, imamo dva itoma gde tačka neposirno ispred malog b, isprava načinja da se oba ova itoma prebacu ovo na ovo stanji i da se tačka samo premesti i za malog b. Ovo stanje je konfliktno stanje, zato što o pravilu za shift, pošto se tačka nalazi neposirno ispre c, znači u vrsti bx i koloni c treba da se stavi shift, međutim pravilo za redukciju smene kaže pošto imamo ovaj item gde tačka na samom kraju, znači treba redukovati ovu treću smenu, a to znači treba staviti reduce 3 u sve kolone koje su u skupu follow da, a to su a i c, i znači za ulazta b le u vrsti bx i koloni c dolazi do konflikta, isto vrena bi trebalo staviti shift akciju i reduce 3 akciju, znači reće o shift reduce konfliktu. I mi zaključemo da je nemogući teoristi konstrujiti slr1 parcel i da grammatika ne pripada, to je klasija slr1, međutim sada se postavlja pitanje, pitanje je ptali je da kažem o neuspehove procedure konstrukcije suštinski za ovu grammatiku ili je to više posledica da kažem nekih nedostata ka je slr1 metad, o čemu se radi na ime. Ako mi posmatramo šta se dešava kad parcel radi i ako on zaista treba da preduzme redukciju, znači reduce 3 akciju, šta to znači? To znači da parcel rekli smo reduce akcije skidanje sa steka desne strane smene, to je stoniliko simbola koliko ima desne strane smene, u konkurjenom slučaju jedan simbol i u suštini parcel kad radi na vrohu steka bi se našlo ovo bx stanje. Kada parcel skine znači to bx stanje, on bi dobil ovo stanje na steka, jer od atle da kažem sa shift došao do bx u nekom predhodnom koraku shiftu i ući b na steka. Kada je no steka da bi se završila reduce akcija, prvo smo skinuli bx sa steka, došli do startnog stanja i sada je potrebno na stek potisnuti stek simbol koji odgovora o ovom simm levoj strane smene velikom a. Potiskivanje velikog a u ovom stanju bi parcer vodilo u neko novo stanje koji mi nismo ove prikazali karakterišno automata sa svojim itemima, to bi bilo ovo neko stanje iz kojeg bi se išli z ovog startnog stanja po izlaznoj grani veliko a i koje bi u suštini imalo osle tačku i za velikog a. Međutim šta možemo uočiti? To veliko a, odnosno redukcijom t3 smene, mi ustvari nastavljamo prepoznavanje ove o ovde prve smene, grammatike odnosno upravo ovog velikog, znači ta leva strana smene ovo ovde veliko a, jer mi u tom trenutku još nismo stigli do ovog drugog velikoga, znači to je sigurno jednoznačno ovo a iz prve smene. Međutim vidimo da i za toga stoji malo a i onda se postavlja pitanja zašto onda u opšto ovom stanju bilo potrebno da se akcija reduce radi ako na ulazu dolazi malo c. I odgovori je upravo taj, znači ovde suštinskog konflikta nema i parser bi sa svim korekno radio da se uvrsti bx i koloni malo c stavlja isključivo shift, znači u suštini akcija reduce 3 nikadne treba da se preduzima, jer u suštini ta akcija došla u kontrolnu tabelu, zato što se ne uzima, da kažem, pravi kontekst parsiranja pri ovim follow-u skupima, jer follow-u skup je šta se sve može naći i za velikoga u bilokom kontekstu. Znači u prepoznavanju bilo koje seqvence, znači prosto unija svega što se u bilokom kontekstu može naći. Ali, ako pažljivije, sagledamo kontekst parsiranja a zato je potrebno da uđemo uutar ovih stanja parsera, odnosno karakteristicko automata, znači ako bi smo uspeli da te skupove preciznije definišamo, znači skup svih terminala koji u trenutku ka treba raditi recim redukciju u smeno ovom stanju, znači šta se zaista sve može naći i onda na te kućem ulazu. Znači ako te skupove preciznije definišamo povezujući za stanja karakteristickog automata, onda neke ove konflikte možemo eliminisati. Znači ovo je to obješnjenje. I upravo je to ideja ovih LA LR1 grammatika. Kod njih se, ovo što smo imali kao terminal simbole follow skupova, ti follow skupovi se poznacimo na vada, uvlače u sam automatu njegova stanja i pridodaju, znači ovim itemima ili LR0 konfiguracijama. Dodajemo LR0 konfiguraciju ovu tako zvanu predekciju simbol. P može biti bilo koji terminal simbol i za neki specialni slučaj, P može biti prazna sekvenca, odnosno nedostatak bilo koog terminalog simbola i to se samo koristi kod konfiguracija nullte smene. Znači to je neki specialan slučaj, ali u principu obšten slučaju P je terminalni simbol. I kada upodpunimo LR0 konfiguraciji u lijajtama, to je ona smena sa tačkom negde u okviru desne strane, ovom predekcijanom komponentu, odnosno jednim terminalim simbolom, onda dobijemo tako zvanu LR1 konfiguraciju ili i i t. Znači za primeri jedne grammatike od četrismene plus nullta smena, recimo neke njene LR1 konfiguracije bi bile, recimo za nulltu smenu, namo recimo jednu konfiguraciju, da je tačka na sam početku, a u predekcijanom komponentu smo stavili epsilon, znači to epsilon se pojavljuje u suštini, kao predekcijanom komponenta za te sve item nullte smene, a naprimer za neku drugu smenu, treću smenu smenu smenu smenja sa a, znači imamo recimo tako item da je tačka na sam početku desne strane i naprimer dodajemo predekcijanom komponentu marker kraja ulaza sekvenci, ili ne znam četrtu smenu gde je naprimer tačka na samom kraju, a predekcijanom komponenta je malo, a znači to su samo primeri neki, znači u suštini takvih LR1 konfiguracije ili itema ima poprilično za ovu grammatiku, je sad što je ovdje prikazano ovo podebjenom doljom linijom, jedna u suštini konvencija, a to je da kada imamo više ovih LR1 itema, kod kojih je ova prva komponenta, znači ona LR0 i isti, a razlikuje se samo po predekcijone komponenti, mi možemo jednom napisati ovu da kažem LR0 item, ad. smenu sa tačkom, a sve predekcijone komponente grupisati u skupu, znači to u suštini samo skraće na ozna kad za ova dva LR1 itema. E sad kad smo veli pojem LR1 konfiguracije, nije baš svaka kombinacija smena sa tačkom i predekcijona komponenta smislena. I zato se uvodi pojem tako odzvanih pravilnih LR1 konfiguracije, znači to su suštini...
 kombinacije koje imaju smisli i koje će se pojavljivati kastinje, vidjet ćemo u jednoj vrsti karakterističnoj automata, znači koje konfiguracije nazivamo pravilnim, znači samo ako su ispunjeni uslovi da je ova predikcijna komponenta iz follow skupa leve strane, znači ove smene koja predstavlja na ovom prvom komponentom ili u specialom slučaj koje reču nulto i smenja predikcijna komponenta epsila. Znači samo takve konfiguracije su pravilne i one se usluštini, njih nazanime, ove druge kombinacije ove prve komponenta i druge komponente ne smatramo, znači pravilnim, onočno ne smatramo smislenim, onočno neće se ni pojavljivati ni obradjivati. E sad ćemo objasniti konstrukciju la r1 parsera, međutim pre prelaska na sve te detalje, bolje je možda pogledati, otići malu u napred, nekoliko slajdova i pogledati šta je nama cilj, šta želimo da dobijemo, kao da kažemo jedan među korak iz koga dobijemo finalne one tabele parsera, potisno i kontrolu, sad da dobijemo tako zvanji karakteristični la r1 automat, to je pandan karakterističnog la r0 automata kod ovih predhodnih metoda konstrukcije i taj odnos la r0 i la r1 automata za istu gramatiku je takav da su ta dva automata, kad posmatramo njihove grafove, izomorfno i odnosno potpunos su isti pro i stanje i veze su potpuno iste. Jedina razvike zmeđu la r0 i la r1 automata ovi munutrašnjim sadržajima stanja i to opet odnos je takav da kad bih smo izbrisali ove predikcije, nekomponente, koji se pojavlju i za ovih itema koji predstavljuju s mene sa tačkom, odnosno, la r0, kad bih smo izbrisali sve ove razne terminale koji predstavljuju predikcije, nekomponente, mi bi smo praktično dobili la r0 karakterističnje automata. Znači la r1 automata je od la r0 radliko je samo po tome što su dodate ove predikcije, nekomponente u stanje. I upravo te predikcije, nekomponente se kasnije koriste u mestu follow uskupova za pravila pokunjavanja kontrolneta, belog odnosno gde treba smestiti reduce akcije. E sad da vidimo kako se nači računa ova i karakteristični la r1 automata, pa kad ga je izračunamo da ću ta pravila kako se na bazi njega konstruiše finalni parser. Da bi smo izračuni karakteristični la r1 automata, prvo ćemo naravno konstruisati karakteristični la r0 automata. V već opisanim metodom prekonih klužer 0 i golu 0 operacija, konstruisati la r0 automata. Potom je potrebno odrediti predikcije o ne skupove, to su u suštini o ne skupove koji se finalnom tom karakterističnom automatu pojavlju i za o njih r0 lajtama. Njih inače zovemo predikcije o ne odnosno engleski luka head skupove skraćeno l a i postoji više metoda kako to može da se začuna. Mi ćemo objasniti metod prosledivanja predikcije o ne simbola, odnosno luka head propagation metod. Taj metod prosledivanja predikcije o ne simbolu u prvoj fazi potrebno odrediti tako zvanje spontane predikcije o ne simbola, odnosno slu a, spontane o slu luka head skupove i onni se određuju za sve konfiguracije zatvaranja u svakom odstanja l r0 karakteristično automata. Šta su konfiguracije zatvaranja, to su oni itemi koji imaju tačko na samom početku. Prvo za njih izračunavamo te predikciju vidu ovih slu a skupova. Kako se definišu slu a skupovi? Ako je konfiguracija zatvaranja predstavlja ovog neku smenu koja ima u stranu veliko a, da je u stranu alfa, onda mi znamo da, kao posljedicio neklo užinura operacije moraju se pojaviti u stanju da bi ovo što ova konfiguracija se pojavila u tom stanju s, pretodno je u tom stanju morala postojati konfiguracije koji ima tačko ispred veliko ga. I mi sad nađemo sve takve itemi u istom stanju koji imaju tačko ispred veliko ga. I onda u ovaj slu a skup za ovaj item uključe se svi terminali simbolji iz skupa first od ovog ostatka desne strane ovog item, odnosno ovog gamma. To je znači prva faza, vide ćemo kasnije na primeru, a druga faza je da se od tih sl a skupova dobiju finalni l a, odnosno luka head finalni skupovi svih iteme, tako što predhodno definišamo tako zvane vezeprosljedivanja i ta pravila su ove ovde grafički prikazan, znači postoj, prvi slučaj pravila i drugi slučaj pravila. Vezama prosljedivanja povezujemo pojedinačne iteme u stanjima karakterističnog automata i prvi slučaj vezeprosljedivanja kaže da treba povezati ovaj item koji ima tačku ispred neko grammatickog simbola X u jednom stanju. Mi znamo da, kao posledica onegou tu nula operacije, tako stanje mora imati izladnu granu označeno veliki mix i u odredišnom stanju mora imati isti ovaj item, gde tačka prebačena iza velikog X. I sad znači povežemo direktno ta dva itema ovom crtka s tom linijom koja se zove veza prosljedivanja. U drugom slučaju koji grubo rečeno odgovaro ona i close nula operaciji mi povezujemo item koji ima tačku ispred nekog neterminala i u istom stanju konfiguraciju zatvaranja za taj neterminal. Znači sve konfiguracije zatvaranja za taj neterminal, tada dva itema se povežu, znači ovo je item i jeste dodatonom close nula operacijom, znači kao posledica pojave ovoj itema dodaje se ovaj item. Međutim postoji samo jedan dodaton uslovo, ovo gama mora biti poništilo, znači neće se bezoslovo povezati svi itemi koji su dodati zatvaranjem, nego samo oni itemi koji su dodati zatvaranjem, ako je znači ovaj nastavak iz A gama poništim. Znači ovdje je prosto prikazano, punom crtom su veze među stanjima i one direktno samu povezaju stanje sa nekim stanjem, a ove veze prosledivanja povezaju pojedinačne iteme unutar stanja. Kada odredimo sve one spontane predikcione skupove i kad definišamo sve veze prosledivanja, onda finalne predikcione skupove računamo iterativnim algoritmom koji se svodi na to da stavljamo prvodna su Luka Hed skupovi za konfiguracije zatvaranja jednak i oni im izračunim tim sl A skupovi, a dok su Luka Hed skupove ostali konfiguracija prazni, a zatim koristeći veze prosledivanja prosto guramo da se tako neformalno izrazimo. Znači putem tih veza prosledujem pojedinačne terminalne simbole između raznih tih Luka Hed skupova sve dok postoji neka promera. Ako je jedan skupo vezan vezom ka drugom skupovu, iz izvorišnog skupa prosledujemo kao odredišnom sve elementetog skupa. Evo najkonkretnom jednom primeru da vidimo kako to sve izgleda, ovaj primer je neka grammatika od sedan smena i iz dekog razloga koristje najmalo druga čioznaka za praznu sekvencu, to je lambda, a ne epsilon. U delu literature se umestio epsilon za praznu sekvencu koristi lambda. Malo jeste veći primero do nog koji bi možda bio zgodan za obješnjavanja, ali da vidimo na bazi tok primera, kada ćemo stanje karakterišnog automata, kad je konstruisam lr0 automat, kad su određeni sla skupovi za konfiguracije zatvarenačne sa tačkom na samom početku i kad su ustanovljene ove crtka stelini i odnosno veze prosleđivanja. Evo, znači, automata za ovu ovde grammatiku, koja se naravno proširio nom nullton smenom, to je onda osma, mislim, srednim brojem nula s i end marker. U tomatima puno veza i puno ti skupova, rekli smo, znači, svak je item koji ima tačku na samom početku, on treba da ima ta skup sla. Jedin je izuzetak je baš ovaj item nullte smene, čije sla skup praza. Druge smene koji ima tačku na samom početku, to su te tako zvanje konfiguracije i item izatvaraća, kako smo rekli da se njihovi sla skupovi određuju, tako što moramo naći za item u istom stanju, koji je uzrokovao operacijom zatvarenja da se doda ovaj posmatranij item, a naravno to je za ovaj konkretan primer upravo ova nullta smena, koja počinje, koja imala tačku izbred s, a ovo je smena koja ima na levoj strani s. Zbog toga je dodat ovaj item i to znači, ovo što se nalazi i za s u nullto smeni, ubacuje se, onosno first scoop, toga se ubacuje kao taj sla skup, to je end marker, ili na primer ne znam za ovaj ovde, za ovaj item koji ima tačku izbred velikog b, on je ubačen pošto je leva strana a, on je upravo ubačen kao posredica ovogo ovde itema, koji ima tačku izbred velikog a, i sad treba u sla skupo ovogo donjek, i toma ubaciti sve i skupa first od s. Šta je scoop first od s morali bi smo pogledati gramatiku, da bi smo dredili, to nije baš tako lako, znači vidimo da s počinje velikim a, a opet veliko a može početi velikim b, velikim c, međutim i veliko b, veliko c počinje malim a, tako da jeste, znači first od a je praklično pravo, ono čime počinje s i bc nije,
 I su po ništivi zato što vidimo da njihoje sme ne imaju terminal, tako da jeste samo malo a u skupu First of Death. Ova druga smena nedoprinosi ništa. First of Death. Znači se vratimo na ovaj automat. Zbog toga ovde, zbog First of Death u ovom ovdaj itemu njegom se la skupuje malo a. E sad za sve druge iteme, znači gde tačka nije na samom početku, sme ne inicijalni skupovi, ovvi luka het skupovi su praz. E sad što se tiče veza prosledivonje, rekli smo oni su dodati prema onom pravilu 1 i 2. Pravilo jedan je bilo ovaj item koji ima tačku ispredes, pa onda znači izlazna grana po s, pa novi item koji ima tačku iz s. Znači to je jedan slučaj u postavljenja veze prosledivonja, a drugi onaj koji je posledica onog zatvaranja u istom stanju. Ali rekli smo pod dodatnim uslovom da znači je ovo gamma poništivo, tako da proverimo znači za ovu vezu dalje pravilno uspostavljena. Ovde bi trebalo da je ovo s poništivo i to možemo isto proveriti u grammatici, pošto s ima prazno smenu na če s je ste poništivo, izbog toga postoji ova veza prosledivonja. Dok recimo, ne postoji veza prosledivonja između ovoga itema 0 smene i ovoga itema je prve smene koji je dodat, rekli smo kao posledica y zatvaranja, zato što je izah esi nmarker, nmarker nije poništivo. I sad znači kad imamo sl-a skupove i veze prosledivanje, ono što je potrebno to je da samo ove simbole unut iz skupova koristet ći veze prosledivanja prosledivimo u ove odredišne skupove, znači recimo, ove nmarker ovom vezom ide u ovaj ovde skup, i taj skup ima vezu dalje, nmarker će dođi čak do vede. I tako dalje, dogod mogu ovi simbole da klize po ovim vezama, pova jednom kad dobijevo stabilno situaciju kad nema više promena, dobijamo finalni karakteristični LALR1 automat. Osta je da vidimo kako se konstruiše potisne i kontrolna tabela parsera, a ovaj automat ima sve informacije za ove tabele. Pašto se tiče potisne tabele LALR1 parsera, ona je prakčno identična potisnoj tabeli LR0 parsera, odnosno to je ovaj isti karakteristični automat. Samo predstavljenu tabelarno obliku, pošto smo rekli da je rečo potpuno identično grafo kad se samo zanemari u nutrašnji sadažaj stanja, prakčo se dobije viste potisne tabele i kod LR0 i kod LALR1 automat, znači broj stanja isti, sa sadažaj tabele isti. Lavna razvika u kontrolnoj tabeli, popunjavanje kontrolna LALR1 tabele vrlo slično popunjavanju SLR1 kontrolne tabele, sa jedinom razvikom što se kod SLR1 uzimaju follow skupovi, leve strane smena, a ovde se uzimaju lookahead skupovi u samim stanjima. Znači, recimo, ako je vrsta kontrolne tabele označena sa x ako lona y, onda nepravna potisna tabela, odnosno ako u x imamo item koji ima pačku ispred y, stavljamo shift, a ako u vrsti x u odgovarajućem stanju imamo item koji ima pačku na samom kraju i u predikcijima terminalni simbol y, onda znači u vrsti x i koloni y treba staviti redupciju t, odgovarajuće smene, ne treba stavljati u kolonama koje nisu u ovoj predikciju u uposmatranu i vrsti x. I naravno redupcijan u te smene akcert, a svi ulazi koje nisu obuhaćeni gori impravima, sa dazda Žer i Ćekt akciju. Ako svaki ulazav kontrajneta beli, posljednjego popunja, na vedenim pravilima sadrži jedinstvenu akciju, zadata grammatika pripada klasije LALR1 grammatika i konstrukcija parsera uspešno okončana, usuprotom slučaju teorijski, znači ne možemo konstruirati LALR1 parser, znači isto može da se desi ikode LALR1 parsera, konflikti ono k tipa shift reduce i reduce reduce. I konačno da završimo ovo izlaganje jednim informativnim slidem, koji malo rekapitulira ono što smo do sada radili i uporedžuje malo pojedine kategorije parsera. Prvo, ovo su kao nekivenovi diagrami i kvadrat predstavlja sve beskonteksne grammatika. Nije moguću za proizvodnu beskonteksnu grammatiku konstrukcijati parsera ovi kategorije koje smo mi objasnili. Unutar, znači to da kažem generalno, skupa svi grammatika, imamo ovaj crni krug najveći, označen sa LALR1 klasom grammatika. LALR1 klasa grammatika je parser koji, či u konstrukciju nismo objašnjavali, ako je velo sričan svim ovim shift reduce parserima, nismo ga objašnjavali, zato što konkretni alati, koji se konstruišu u konstrukciji kompajlera, ne konstruišu LALR1 parsere, nego konstruišu LALR1 parsere. Znači, lecimo, ovaj kup alat koji se koristi u praktičnom projektu ovom kursu, konstruišu LALR1 parsere. I u tom smislu je tak kategorija parsera nama najznačajne. Znači, LALR1 parser je ste još malo generalni, znači može dobrati još jedan veći skup grammatika. Vidimo da znači LALR1 parseri su pravilan podskup LALR1 parsera, onda SLALR1 parseri su pravilan podskup LALR1 parsera, a LALR0 kao najuža klasa su pravilan podskup SLALR1 parsera. Znači, LALR1 imaju praktičan znači, LALR1 parser je sličan, znači imaš potisnu kontrolnu tabelu u Shift i Reduce akcije. Zašto se ovom praktičan je koristi pa LALR1 parser za razlik od svih ovih tegorija koje smo bradili i koji smo videli da broj stanja, parsere isti kao ko dove najuže kategorie LALR0 i u principu u odnosnu na vričinu grammatike je da kažem u porediv. Ovo je naji generalijel jer jedan parser generiše mnogo veći broj stanja. U principu može eksponencijalno da u odnosnu na vričinu grammatike broj grammatike simbola raste i u tom smislu zbog velikih parsera nema praktičan. Znači jako bi malo veći skup grammatika obradio. Međutizere, on ima teorijski. Znači u smislu da je to najgeneralni deterministički parser sa jednim predikcijalnim simbolom koji se može napraviti. Šta znači deterministički parser i to su parseri koji u svakom koraku rada najjedno značino dređuju akciju. Postoje generalnih, znači algoritmi koji mogu da obrade sve bezkonteksne grammatike, ali oni su po svoje prirodi nedeterministički. I njihova glavna manja je za razlik od ovi algoritama koje su linarne složenosti, to je zbrzi u odnosu na dužinu ulazne sequence. Generalnih parserske algoritmi, osim što su nedeterministički, su kubne složenosti u odnosu na dužinu ulazne sequence. I zato u principu doskora nisu i mali. Sad postoje neke eksperimenti, ugraduju se joj gompajerskeve generatorje parsera, znači u gompajerske late ugraduju se neki glr, recimo metod pasiranja koji je neki generalizovan i LR1 koji nije, znači deterministički parser. I gde je zbog brzinera čunara i tako dalje da bi konstrukturo gompajera bilo ugodnije, znači ide se na neke manje efikaste metode, ali to još nije neki mainstream primene, tako da nećemo to obrađivati zbog ogrančnog objeva. Akur se ono što očemo obrađivati, to je ova klasa koja na on diagramu naznače nam plavim i koja kao što idimo preseca, skoro sve ove metode koje smo mi dosad obješnjali, znači ima neku presek s njima, međutim, pravilanje pockupovih LR1 parsera najgeneralnih, a to su top down, znači klasa parsera LL1, znači to je posevan metod koji ćemo u nastavku obrađivati, znači u sklopu parsiranja od vrha kadnu i taj metodima prakčan, znači u nekim situacijama možemo da se koristi. Porava kod grešaka kod parsera. Prevođenje se obječane za ustavlja na prvoj grešci ulaznom programu, nego prevodilac pokušava da prina ilasku na grešku u programu TTK, to je grešku odnosno izdo odgovaraću izlazno poluku, koja će poslužiti program ERODA i spravi program, i zatim da izvršio porava kod greške odnosno da određenim akcijama učini nastavak syntaxno-semanticka analize programa moguć sa idejom, da se prođe kroz ceo programski kodi, da se detektuji drugi potencijalne greške. Pritom je se tipično ne vrši generisanji izlazno programu, se ima koja u pitanju u pozorenje tipa warning, običnima nekoliko nivoja, znači ima informacijana poruka u pozorenje, greška i fatalna greška, znači na informacijane poruke i u pozorenja, u principu može da se izvrši kompletno syntax-semanticka analiza programa, gdje u tim na greške i fatalne greške, obično se ne generis i izlazni program, već samo izveštajio greškama, obične greške i fatalne se razliku po tome što parser pokušava da izvrši taj o poravak i završi procesiranje programa kod obične greške, kod fatalne greška obično se rad kompajlera prekida istog trenutka. Pošto smo videli da su parseri zastavati na potistima automatima koji imaju tech, znači akcije za o poravak moraju dobuchat te u obšten sluču i modifikaciju parserskog steka i preostalog ulasnog niza. Malo ambicioznija varijanta je da kompajler proba da koristnikov ula sa greškom popravi uvalidam program, znači se mantički ispran u zgenerisanje prevedeno koda, to je više teorijski da kažem.
 cili nego što praktiči compiler i znači to redko imaju tajnivo odziva na greške programera, zato što prosto ne može compiler garantovanu da pogodi šta je programmer hteo da iskaže odnosno da bude garantovanu da je semantika programa dobra. Da pomenemo i šta ne valja da compiler uvradi odnosno šta nije privatljivo da je dan profesional razvijen compiler kapko da se ponaša pri na iglasku na grešku u koristiškom programu, ne bih smel da pređe preko postojeći greške bezikakve detekcije, zatim u principu compiler ne bih smel da prekine rad, znači da to ispanje da je to neki problem paku compiler, znači da prekine rad sa greškom izvršavanju. Takođe moguće je sobzirno da se radi o tim potistim automatima i steku ako se ne pazi, znači lošo porovak može da je izazove nekako zaglavljivanje procesiranja komparevskog umrtoj petljig, da je se stavno recimo na ekranu prijavlju i istak greška bilo, je primeranek i komercjelni program u vreme kad je C++ bio. Novi jeziki kad su se prvi C++ compiler i pravili tako što su se adaptirali i proširivali postojeći C++ compiler i pa su firme, zet udile da brze izadju na tržeške, znači neki komercijalne firme imale su takve prve C++ compiler koje su imali jako nizak kvalitet o poravka od greški. Definišajtećemo po vas svojstva ispravnog prefixa kod parsera, ali preto ga moramo da definišemo što je to symbol povrede ulazne sekvenci, znači symbol povrede je onaj symbol ulazno knizak nakome parser odkriva grešku, to znači da je parser isprocesirao neki veđutje ulazne sekvence, ovaj prefiks bez ikakvih problema i onda znači utrenutku kada je tekući ulaz symbol ova i symbol povrede, parser znači u svojim onim kontronim ili potistim tabelama odkriva grešku. Ako parser ima svojstvo ispravno kvaliteto prefiks, onda za sve ne ispravne ulazne sekvence, ni simbola presimbola povrede predstavlja prefiks neko prihvatljivo ulazno knizak. Šta to znači odnosno šta je neposedna posljnica, kod takvi parsera možemo modifikacijom preostalo ulaza učiniti ce ulaznje nis prihvatljivi. Svojsto ispravno prefiks je doskodno svojstvo koje nam govori da pri na ilosku na grešku parser nemora da radi nikakav backtracking da se vraća ulaza u nazad, nego samo znači u modifikacijom preostalog ulaza može da učini ce u i svojom stanja, to je ste kada načini ce ulazni nis prihvatljivi, što je ustvari cilj o poravku od greški. Ono što je dobro to je da svi metodi koje mi u kursu u kojima konstruišamo potisne automate parsere, takvi parseri imaju to svojstvo i što se tiče izveštavanje o grešci, od koristi su trenutni vrk steka i tekući ulazni simbolu trenutku greške i naravno običilo se vodividencije o lini i pozici nači ulaznom programu na koja nastupila greška tomora leksičke analizator, po što vam vrši tokenizaciju da vodividenciju i o tome. Poru koj grešci uvek treba malo da se isprocesira od strane pista kompajera, da ne bude samo da se kaže koji tokeni i koje stanje, nego da se malo na bazi tokena i stanja proba formulisati tako prijava da o programmer svati, znači da ga uputini na mesto i uzrok za što je greška nastala. Posle prijave greške vrši so poravak parsera od greške, ono što je nekad ne izbežno prijav poravku od greške, to je da može da se desi da prva greške indukuje još dodatne prijave grešaka koja u stvari u programu ne postoje, nego su posledica prve greške. I u principu, kvalite znači, o poravka ceni si po tome koliko tih ne postoje, znači lažnih dodatnih prijava da i budeš to manje. Jedan najprosti primera, ako bi, recimo, programmer zaboravio da deklariše promenji u X, pa je poslu u potrebi deset puta u nekoj funkciji. Loše bi bilo da se deset puta prijavljuje ista prijava za to X, nego ideja je da recimo, compiler prvo naravno prijavi prvo gorišćenje Xa bez definicija, a zatim, na primeru, usklo po poravka ubaci pri vremenu definiciju X u tabelu simbola, tako da se kasereći budka najđena X ne vrši istete prijavi. Pesad ovo je bilo, znači, obšte nevezano za parserske tehnike, a sad ćemo konkretizovati priču, tako što ćemo razmotriti shift reduce parsere od nakavrhu i kako od njih može konkretno da se ugradio poravak od greške. I zložite mi osnone i najčešće primenjivanje variante, tako zvanog, paničnog, o poravaka engleski termim je panic mode recovery. Znači, tu je osnone ideja da pripojavi greške, parce pokušava da izadji z jezicko konstrukt, dok me je nastala greška, tražeći siguran ulazni simbol, kao što je terminator naredvi ili početna kljušna reška, da je naredvi to mislično od koga može da nastavi normalno parsire. Naravno, postoje i dosta kompleksnije metode o poravka i popravka greške i, na primer, knjiga, fisher, leplan, grafting, compiler je zgodna, što se toga tiče dostar, ecimo, razmatra. De razne kompleksnije metode o poravka. Što se tiče ovog najednostavnijeg algoritma panicu poravka o greške, tu je samobitno uz zadatu gramatiku, definisati skup tako zvanih sigurnih simbola, a u njih obično ulaze znači terminalnih simboli, koji završavaju razne programske konstrukcije, kao što su, na primer, tačka zaret, završava naredba, and, kod nekih jezika, zati marker kraja ulazno-gniza i s tome sliče. I sam, ali koja rita mi je formulisam kroz ova tri koraka, u prvom koraku, kada parser detektuje grešku, se ulaza se redom uklanjaju simboli, dok se neneiđe na neki od sigurnih simbola. U drugom koraku, tada u tom trenutku se sa steka parsera skidaju simboli, sve dok se neneiđe na neki koji može da potisne sigurni simbol na ulazu na stek i kako se to može videti pa po onim skuponi helernula konfiguracija, al to sta njemo radę ima izlaznu granu označenu tim sigurnim simbolom, odnosno, item koji ima tačku neposredno ispredog simbola. U trećem koraku parsira se njese poslednja nastavlja na običeni način. Ovo i osnovno ergoritem način je gova prednosti što ne zaktiva neku posebnom trenutiranje, predstavlja automatizovan i generalan odziv parsera pri pojave greške, jedino što se znači od konstruktura kompajera, traži to je da definiš ovaj skup sigurni simbola, način vrlo malo posla u odnosno na ona i osnovnih posao konstrukcije parsera. Koje su mane, osnovnoga algoritma, on nije neki jako kvaliteta načinu algoritma, njega je glavna mana, inače u na vežbama će biti dati primeri detaljni sa tracem rada parsera pri oporavku od greške povim algoritmima koja ja sad pričom, ja ću ovde samo reći na više nivou, znači šta je mana ovoga algoritma, ovaj algoritm dobro radi kojnestrukturiranih jezika, kao što su, recimo, asemberski jezici, međutim koji jezika koji imaju ugnežde nestruktura, recimo, dovoljno je da imate izrsa ugneždenim otvorenim i zatvornim zagradama ili prostost blok strukturirane jezike, gde, naprim. viti časte zagrade otvaraju funkciju, po onda unutar toga opet imamo neke viti časte zagrade koji neki blok naradbi ograđuju. Mi tada možemo, naravno, definisati, naprim. da je terminator zatvorna viti časte zagrada, međutim šta se deša u toko oporavka, ona ilazi na ugneždenu strukturu koja ima otvorni zatvorno viti často zagrado i sad on bi trebao celu to ugneždenu strukturu da proguta, da bi došao do, da kažemo, primarne viti časte zagrade na kojoj trebao se sikronizio, međutim, on pogrešno će, da će progutati samo početak te ugneždene strukture, znači otvorenu viti často zagrada, onda će se pogrešno sikronizate na prvu zatvornu viti často zagrado, trebao li u stvari da inju preskoči i da onda ide na spoljnu zatvorenu viti často zagrado. Znači, ovaj algoritm nema tu mogućnost da vozi evidenciju tih ugneždeni struktura koja imaju te sigurne simbol. Tako da je smišljeno poboljšana varianta ovoga algoritma paničnog oporavka, gde se pored skupa sigurni simbola definiši takozivni skup simbola zaglavlja, odnosno, header simbola i simboli zaglavlja su komplementarni sigurnim simbolima, da će ako je siguran simbol zatvorno viti často zagrado, da simbol zaglavlja je otvorno viti často zagrado ako je siguran simbol end, onda je simbol zaglavlja begin i tako dalje. I kako glasi poboljšani algoritm paničnog oporavka, znači, dosta je sličan. Ostavno algoritm koraci su slični kao i oni origili koraci 1, 2 i 3, ali male modificacije. Znači, u prvom koraku kada parse detektuje greško, sa uleza se redom u kljenju simboli doksjene naidjena neki od sigurni simbola ili simbola zaglavlja, znači ne preskac će se ni jedna od te dve kategori simbol. E sad u koraku 2a ako je naišao siguran simbol, tada se sa steka parse raskidaju simboli sve doksjene naidjena neki koji može se da potiste taj sigurni simbol na ulaz u nasteg. Znači, taj korak je isti kao najorigan i korak 2a. Međutim korak 2 b je ako je naišao simbol zaglavlja, tada se on potiskuje nasteg i posebno markira. Drugim rečima, on na taj način čini kao nekako lažno, privreme no dno steka i to je povezano sa im korakom 3. Znači, parci danja se poslitoga nastaveno običaj način, način se je redukciju neke smene ukloni, markirani simbol sa steka, prelazi se ponovno na korak 1. Taj korak 2 b i korak 3 su da pri oporavku detektuju i uparuju ugnešdene kontrolne strukture sa simbolim, znači koje počinju simbolom zaglavlja, a završavaju neki psigurni simbol. Izluženi algoritmi su bili sasven generalni i mogu su uvek primeniti kojišift i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift, i uvek primeniti kojišift,
 Međutim, alati iz familije jako odnosno kupovi generatori parsera koja i vi koristiti u projektu imaju malo druga čije određeno poravak od greše koji zachteva za nijan su više truda od konstruktora kompajelera ali samo poravak može da se kvalitet nije urati. Prvo, kakovi parseri koji su i nače ShiftReduce parseri i generisani tima alatima jako odnosno kupovi, kako se ponašaju pri pojavi greša u ulazu. Parsera znači što se tiče prijave greške, pri nastanku syntaxne greške u izgenerisano parseru poziva se funcije yy error koji se prosledio opis greške u stringu. Po povratku iste funcije parser može izvršiti o poravak od greške ako u grammatici postoje odgovarajuće pravila. U suprotnom sama funcija parserska završava rad i vraća nenultu vrednost. Ova varijanta koji sam ja opisao važi za ceovski jak parser, djutim kot kup generisano parsera u slučaju greške baca se izuze tak, znači ta parserska funcija su uvek pakuje u trycatch. Ta situacija da se završava rad parsera je ako nema ugradjenog nikakog oporavka od greške. Međutim ideja je ste da si ugradio poravka od greške koji bi uslušnini sprečio ovaj neuspešan završaj tak parsiranje. Da bi smo kod jakku parsera ugradili poravak od greške moramo modifikovati grammatiku, za to postoji poseba grammatik simbol error. Error je specijalan grammatik simbol koji se pojavljio samo na destim stranama smena i te smene u kojima se pojavi simbol error potpuno se ignorišu kad je ulaz syntaxno ispravana, znači kad nema nikakve greške u grammatice, onda kao da te smene sa error ne postoje. Međutim, one se mogu aktivirati ako se pojavi greška u ulaz. Ostojne ideje je da taj error upari taj neki pogrešan deo ulaza i da mu mogući znači da se pogrešan deo ulazne sekvence proguta i da parser dalje synchronizovan o nastavi parsiranje ostatka ulazne sekvence. Na ovom primjeru ćemo sad detaljnije videti šta sve to znači. Ova mala grammatika koja je napisana u syntaxom obliku kakav zahteva jako odnosno kup parser, a to je da se leve i desne strane smena razdvoje sa dve tačke i vidimo da postoje i nekoliko smena kojima na levoj strani statement. Prost, mena statement se menja se expression i tačka za arese. Ovo je terminal, expression while statement if statement su neterminalni simbol, imamo i posebno pravilo za if statement. Prvih nekoliko smena se odnosi na smene za statement. Jedan na vrsta statement je izraz i expression i statement se završava sa tačka za arese. Sledeća vrsta statement, ovo je druga smena koja ima na levoj strani statement i koristi sa ovoskraćeno opeležavanje uspronaceta da se ne ponavlja. A moglo bi, znači, se opet napiše statement dve tačke. Ali u principu po konvenciji se uvek grupišu sve smene sa istom levan stranom i piše se samo uspronaceta o vrstolive strani. Znači druga vrsta statement je neki while statement koji dađe bi se laboriru u gramatici. Nije data šta je to, zistim se završava tačkom zarazom. Treća vrsta statement je if statement, završava se tačkom zarazom. A if statement je, ovo ovde imamo posebno smeno, znači if pa u zagrad i expression, pa onda statement. Vidimo da tu može biti još nekoliko smena za druge vrste, tih statementa, odnosno iskaza i konačno ova zanimljiva smena koja posebno pojem označena statement pa na desnoj strani error.zaraz. To je ta dodatna smena koja ako je ula sintaksno ispravana, kao da ne postoji, nači ne menja opis sintaksno ispravnih ulaza. Međutim, ako u bilo koja ovoj vrsti iskaza dođe do neke greške, da se na neki način izvučamo do tačke koje će u trenutku kada na ulazu imamo tačko zaraz, prepoznatio o usvenu sa error. I posle toga da, znači praklično parseri zađe izrežimo o poravka i nastavi normalno parsiranje, nači ti automatski generisujeni parseri, kada nastave parsiranje broje da uspeju bar tri tokenada shiftuju, znači sa ulaza na steg, da bi zaključili da je su potpuno i zašli izrežimo o poravku od greške. Evo sad detaljno kako, znači funkcioniše algoritmo poravku od greške kod ovih iakih kup parsera. Znači po detektu onju greške, parserski je da sa steka stanja dok ne dođe do stanja koja ima nepostredano poravku od greške, odnosno konfiguraciju gde je tačka ispred ovo geror simbola. Tada parser počinje preskakanje ulazne tokena do trenutka kada dođe neki koji očekuje i tada nastavlja parsiranje, ali bez izvršavanja semantickih akcija. Ako uspešno procesirala bar 3 tokena sa ulaza, ulaza resetoje na stanje kad je prestalo preskakanje tokena i parsiranje se ponavlja normalno ovaj put izvršavaojići sve akcije. E sad, ako parser nije uspe uspešno izprcesira 3 tokena, parser odbacuje sredeći token sa ulaza i pokušava da nastavi parsiranje. Ako se upokušemo poravka dođe do kraja ulaza ili isprazni parserski stek, napr. nije bilo odgovarićih stanje koji ima o poravak, parser neuspešno završava rad. Algoritm dosta intuitivno radi i za datak je programera odnosno konstruktura kompara i skjuču da se fokusira na togde će ubaciti ove error smene. Da bi se potpuno razume, algoritm preporuka je da prosto probate na nekoj gramatici, znači ukljenete od origina i gramatike, ubacite error smene, namerno postavite testprimere sa neizpravnim ulazima i posmatrate šta će u stvari parser da uraditi. To je jedin i način da se potpunosti, da kažem, svati ponašanje parsera. Međutimo ovdje postoje, znači neke preporuke veći u propratnom pudstvu ovoga lata. Znači to su prosto neka iskustvena pravila gde i kako stavljati, znači dodavati ove error smene. Ono što na neki način emulirao najpenik modri kavari je da se prosto iskoriste opetoni simboli koji terminišu neki konstrukcija, pa da se prosto napiše za tu konstrukciju neka error smena koja na kraju ima taj simbol za koji znamo da završala sve stei, idvante i tako da je. Takođe kod nekakvih odgovor o petonom na prednjem algoritmo, znači kod konstrukcija koje imaju neki početak i neki kraj i u principu mogu i da se ugneždavaju i šta ja znam. Može da se dodajemo ovako smena koja ima tizrazu zagrada, a onda u zagradima dodate. Dodate posljemu smenu kojemu mnog mesto izraza ima error. Znači, u nutar zagrada što znači da ak u nutar ovog izraza nastane greška ide da ćemo se na ovim zagradama sinfronizovati. Koliko ovakvih smena? Znači šta treba odmah reći? Ako su ovi primjeri relativno jednostavni, i ovdje smo dodavali po da kažem jednom neterminalu samo jednu error smenu, vas ništa ne ograničava da na jednu ispravnu znači gramaticku smenu dodate i više ovih error smena. Na primeru, ovom drugom primeru, to do neklet zavisi o toga šta očekujete da koristnik može da pogreši i šta smatrate da bi bio relativno kvalitetano poravak u tim nekim relativno čestim situacijama greška. Zdećem ako smatrate da koristnik često može da pogrešno izostavi zatvorenu zagradu, može da se napiši, može da se doda, znači ovdje kao treća smena, znači smena koja na desne strane ima otvorenu zagradu i ekspresšanu i onda sve stvo zatvorne zagrade piše error. I to me slično, znači u suštini vi na jednu ispravnu smenu možete da imati nekoliko smena sa ovim error simbolom. E sad, dali postoji gornji limit dodavanja tih error smena, znači on nominalno ne postoji, znači neko bi moh gao na deset ispravni gramaticki smena da doda sto ovih error smena, međutim postoji drugi jedan faktor koji limitira da se ne pretera da kažem sa ovim dodavanjem error smena, takođe priječno opasno ododati smenu koja ima samo error na desnoj strani, da nije ograničen da kažem nekim drugim dodatnim simbolom. Zašto? Zato što potencijalno ove error smene mogu da unesu nove, ako stavite na nekom nezgodno mestu taj error, može vam se desiti da za gramatiku koja bez error smena srcki tipa shift reduce, reduce, reduce može vam se desiti da sa od jednom pojave zbog te, doda dodavanja error smena konflikti, tako da to u stvari pomalolimitira, znači mesta gde možete staviti i koliko da stavite tih error smena naravno kažem tu u glavnom radi neka intuicija zdrav razum, dosta dobro i prosto treba malo probanjem steći, osećaj gde i kako dodavati te smene, inače mi u postavci projekta obično tražimo joj, pova kod greške je umeren i relativno precizno definišemo znači šta očekujemo na kakve greške compiler da reaguje ina koji način, tako da vam sugerišemo na taj način direktno gde staviti te error smene. Isto tako ovaj algoritm, znači ima dodatno ovu logiku da se ne prijavljuju, syntaxne greške nepose no pose prve prijave, nego tek pose tri ispravno procesirano loznata oknapa, onovo samoguće o prijavljivanje greška odnosno pozivanje, ona y y rero funct, znači to je opet jedan detail vjadno za napčen rada tih kup parsera, to jest jak, i ovo posljednja stavka isto jedan detail koji nije toliko bitan i koji je u stvari prisutan samo u jaku, znači u c c plus versija lata, a nije o njim kup parserima, znači moguće je na neke način resetovati režim o poravku od greške, ako, znači ovo eror smeni kao semantičko akciju, znači ovaj kod koji je unutar stavljen ovdje na kraj ove smene i u...
 u okvirenje vitičastim zagradama, to je i nače sintaksa jak alata ceovskog. A kod kup java alata stavljala bi se otvrna vitičasta zagrada dve tačke i dve tačke zatvrna vitičasta zagrada. Znače, bila mala sintaksna radika, uvek su prisudne vitičaste zagrade da označe akcije. Videćemo, kasnije da te se mantičke akcije i kada teorijski i budemo definisali. Koriste se vitičaste zagrade da ih posebno označe. To su akcije kada parcer prepozna smeno, preduzima neko akcije. I ovaj ceovski urantiv parcera stavite posebno Rechips Simpson Error Ock. To znači da resetujete taj režimo poravk od grešaka, kažete parceru da smatra kao da je već prošao tri uspešna tokena i da odmah nastavi sa normalnim radom. To može u nekim situacijama specificim da malo promeni ponašanje parcera, ali nije, kažemo, neko ks. značavo samo pominjemo ovde. Ono što je možda najvažno je zapamtiti, to je da i ove dodatne eror sve ne mogu da normalno sadriže akcije.
