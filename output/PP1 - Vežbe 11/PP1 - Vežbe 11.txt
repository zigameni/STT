 abiz goneg welisesana sembnog danela buženima, nenazella prodena sto sl cara меня od analiziraju u več sa chov oko lpujegu, treba da parardseno šten א od slots card Gomownedane trod Opiet controversial mibe tutoajeva ganak ki teali mora se na koультатu da lišeš neveda otopno otopnog 2009 Blindan Si했다 ili whiskey pa iekt' se bo sve lišeš Dobro s ima, dobrošli na ješeran čas. Možu samo standardno prenego što krenem, potvrdu na četu, da li se čuvajmo i da li vidite moji ekr? E, koala kolegi. Niska, prošli časmo završili one ideo koji smo imali vezano za medži kod, pa sam ja ne javio da ću danas se malo osvrtati još manje bazične blokove, koje sam spominja na predkodnom času, tako da danšnji čas ćemo posvetiti generisanju koda za arhitekturu x86 i onda ćemo vidjeti još neke svačice koji ti je bazični blokove, kako ćemo locirati registre, kako ćemo svariji generisa i taj kod. Sada ovaj danšnji čas imam tu da odrlim neka tri zadatka, nakon što objasnimo kako cijela taj ostupa generisanja funkcionišer, tako da to neće trajati celo ova dva dva dva časa, ali ja danas ne bih počinja ovu poslednju oblas koji imamo na kursu, tako da ćemo ostaviti još jedan čas ipak da održimo, možemo da održimo sve četvrta, možemo da održimo u nedelje nakon nove godine, možete vidjeti da se dogovorite, da mi javite kako god želite, meni u potpornosti sve jedno, možemo da održimo ipak sve če nedelje, ako hoćete možete i neki drugi termin da završimo sve topa, da onda do tokom prazmike imate sve tematejali i da možete da se premate za ispit. A ide, ako imate neko pitanje, kucete slopodno na četu za sat, ovdakopra nekako što krenem gradigo, a ja bi samo minut jedan još odvoju, dakle dobio sam gomilo nektih mailova, vezana za postavku projektu zadatka, gde je problemo tako naša grammatika sa ternarnim operatorom. Tako, ta grammatika sa ternarnim operatorom je tako postavljena i jelte i onda je tu bila ideja da vi sada razrišite te neke konflikte koji te se tu javljeli, međutnje pošlo su svan o dostav vas, javilo da ne umete da razrišite taj konflikti s aselvako neko prepromen, reću imate. Očekujte onda da ćemo sada ovih dana, dana sutra preko su, kada je stignem s obdra, onda je ovdakop sa malo uživio, kolaboratorijskih vežbi svega što je ovdakop nas snaži pred kraju. Semestra očekujte da ćete dobiti revidiranu leziju projektu, koji će biti malo olakšan, ta ideja sa ternarnim operatorom, ukliko je neko to već odradio narodno, narodno nije brok. Eto samo to da najedim. Te li imaš neko pitanje i vi mogu ja da krenem sa gradivom za danes? Dostavljamo. Ako nešto budete imali, standardno pišite na četu, a mi ćemo da krenemo ovako. Ideja današnjih časa je da mi sada za nekakoje bazične blokove, a prošli časmo objasniti što je to bazični blok, odredimo kako ćemo generistati kod za ovu našu x86 arhiktiktura. I sad osnovno ideja ovog danesu, čemu ćemo pričati, je ucvario alokacija registara. Kakovi, ukliko imate jedan bazični blok, sada da ocirati registre i kako da smešno se tako promeljivo u te registre. Pojenta svega oga danesu što radimo je da nekako ubrzamo izvršavanje tih nekakvih programa, tako što nećemo uvek, kada nam je potrebna nekako promeljiva, ićiš kroz do memoria i dovlačiti tu nekako u promeljivo, nego gledamo da te promeljive čuvamo u tako registriva neko našeg procesora. Naravno znate već čudiste, nekako mi do predmeta tako do sad, da nam je to tako brže izvršavanje, zato što ako smo promeljivo u registriva, a onda sam im timo tako manji vreme da je potrebno da u stvari dovučete tu promeljivo kada potrebno da odradite nekako ritmetičko operaciju u senja. Esta to. Prvo je vlado tako kada pričamo o ovom generisonju koda, ovdje i to je alakacija i registre, prvo što treba da spomenemo, jeste tako zvaniji život i slaja je u potreba promeljivih. Dakle, u kodiko posmatamo sada neki bazični blok, mi ćemo samo za neke promeljive govoriti da su mrte ili žile u nekom izgav. I sada površte znači da je neka napremeljiva x u nekom izgavu tamo nazvati gov' izgav i da je ona živa ili mrtva. A kada kažemo da je promeljiva živa, to znači da nam njena vrednosti i dalje treba, jer će biti nekde iskorišćena. Kada kažemo da je promeljiva mrtva, onda mislimo da vrednosti je promeljiva nam više ne treba u opšte, zato što o tako do njena svečnije će korišće i će biti u stvari njena novorčunanje. Dakle, majmo sada ovde prikazat ćemo jedan primer, i sada na ovom primeru ovdje ćemo pokazati kako sa to odstvari određujemo šta je tu živ, šta je mrtva. Pa napimememo da posmatram ovaj prvi izgav z gore, x je jednako y plus t. Za svaki izgav mi pojedinačno određujemo kako svaku promeljivu, da li je ono u tom izgav živa ili mrtva. I onda redam ako krenemo, malo prisom objasno tako što znači da živa ili mrtva, ako redam, krenemo za promeljive, pa napimem, promeljivu a. U ovom prvom izgavu ovdje, a napimem, tako da je prvi izgav u bazičnog bloka. Kako određujemo, da li je promeljiva a mrtva ili živa? Gledamo koja je njena sledaće upotreba, gde se ona sledaći put koristi. Ona se sledaći put koristi u ovom izgazu dva, i ako pogledajte, njoj se dodelio i vrednost. Tako da što se tiče izgaz za jedan, da li je mama potrebna njena vrednost do sledaće njena upotreba? Njena sledaće upotreba u stvari upis, tako da njena v tako vrednost vama nije potrebna, i nije potrebna. Zvično, tome pogledajtemo dalje, da je promeljiva d, pogledajte, ona se isto koristi u izgazu dva, međutimo, izgaz u dva, nam je potrebna njena vrednost, da bi smo izračono u ovom tako 5-d. Epovkudiko nam je potrebna njena vrednost, onda kažemo da je u izgazu jedan, ona živa. Sa to oloćemo za sada samo drživati, da li su mrtva ili žive, kasnije ćemo vidjeti zbog čega nam je to potrebno i kako to koristimo za generisani kod. Osmatate dalje, promeljivo x, da je u izgazu broj 4 i vidite, da tako koristimo njenu vrednost, da ka je potrebna nam je ona, ne možemo tako da je samo sponimo negada tamo ide za nemarima, nego moramo da je čuvamo i dalje, tako da kažemo, promeljivo x je živa. Svično, tome pogledajte y, dakle y u izgazu 3 dodeljujete vrednost, nikde o tako nemate pre toga da se koristi to y, tako da kažemo y ne ovde mrtva. Iza zet, ovo je tako karakteristica situacija, što se tiče, promeljivo je zet. Mjelo ne koristimo niju izgazu 2, 3, 4 i 5, ali u izgazu 6, koja je promeljivo zet, imate i sa levi i sa desne strane o ovog znaka i jednakosti, međutim, šta nam je važno? Dalje i dalje trebu da čuvam promeljivo zet? Pa ja da mi izraču na ovo novog zet, ja moram da koristimo na staro zet. Tako da to staro zet, moram da pametim, tako da ovde, tako priorite da jemo obršt na ovo što nalazi sa desne strane, to je, skažemo da je promeljiva zet i dalje živa, ali nam je potrebna njena vrednost, da bi smo izračunali neku sledeću vrednosti doblje tete. Ne sad, to je za početek, o tako da objasnimo samo taj koncept, šta znači u svarim, da su neke promeljive živeli mrtve. I ceo je ovdje koje je na vredanje bio samo tako dobra naš prvi izgaz, ovdje x1 koji y plus zet. Dakle, rekledi smo onda u izgazu broji 1, promeljive b, x i c u žive, a promeljive a i y su mrtve. Bok čegu su mrtve a i y, zato što nako niska za 1, a i y se ne koriste do narjednog puklisa. E sad, naravno, mi ćemo za svaku promeljivu u svakom izgazu računati, da li ona mrtva ili je živa. Tako da ako posmatramo ponovot taj isti bazični blok, da bi smo dredili koje promeljive su žive i koje su mrtve, možemo da koristi moje algoritm koji sam ja malo propisao, dakle da gledate koja je njena svedreća upotreba i onda vidite, da li je u toj upotrebi vini u koristite ili je dodeljeto tako nekako novog vrednost. I u tim je noko nalakša da je izkaz evrađujemo u obrnotom redosledu, tako da je krajnemo od poslednika kaprvo i ono što moramo da znamo, je ste da uvek mora da vađe predpostaka, da mi ne znamo nako novog bazičnog bloka koji posmatramo sada kako će promeljiva biti koristima. To je zdali će se ona sledeći put koristiti za upis ili za tako čitanje. Tako da uveku zimamo predpostavku da na kraju ovog našeg bazičnog bloka, dakle posled ovog dobroj 6 što goce na ozigo izza predpostaka je da su sve one sve ove naše promeljive žive. Tako da, kako određujete to, ovaj ćemo trtati ovako jednu tabelu na pobrojacima sve ove izkaze i u startu grenete tako što kažete dole upitnik je sam poređu ovdje, dakle ne znam kako će one biti korišćene i kada će biti korišćene, ali za sve njih uvodimo predpostaku da su sve one na kraju žive. A odreću ja videti se klasnije kada budem radio te zadatke, dakle mić muvek u zadacima, ovako nekoj tabeli obležavati ovde dali je promeljiva mrtva ili živa i u koliko je živa, označavacim uvek možete su svo na ravno i u koliko je mrtva odnočavacim ovde na mes povog upitnika koja nije na sljedeća upotreba, t.e. u koju miskaz u sljedeći put koristimo tu neku promeljiva. Ovde kažem, košto ne znam kada koristim sljedeći put, porređaćemo tako sve upitnike. E sad, kako je u sve obležavati, i onda u stvari gledate gledate koja je promeljiva se koristio u ovom poslednjem iskazu ovde za sad i vidite ste da a koristim, t.e. potrebna mi je vrednost a, tako da ću ovdje ovdje ovdje ovoga a upisati da je a živu i reći ću a se koristi u iskazu broj 6. A ovod set koristim gledatko i sljedeći sa desna strana međutim rekli smo da je prioritetnije osad desna strana gde nam je set živu, potrebna nam je njegovat vrednost, tako da ću ovom polju visati da je set živo i to da je živu jer se koristi u iskazu broj 6. I dobijemo ovako našto. Sve ostale promeljive koje se ne spominjamo u opšte ovom iskazu broj 6 nima samo prepišate vrednosti koje postoje. I tako se selite skroz doverha tako ovog naših bazičnog blaka. Ako posmatrat al tako ovaj red iznad vidite sada za promeljivo i b upisujemo vrednost u iskazu broj 5 tako da ćemo ovdje u njeno polju pisati da je ona mrt, a x se koristi u iskazu broj 5. Tako da ćemo ovdje za promeljivo x, tako na značiti da se koristi sveći putku, a tako to mi iskazu broj 5. Naravno za b vidite smo značili da je mrtva promeljiva.
 i tako penjetel tako se to do kraja gore. Pogledajte a, u a opisujemo vrednost, dakle a će ovde biti mrtvo, a x i y koristimo tako u izkazu broji Petiri, tako da vidite da x i y se koristimo u četvorci, a nam je mrtvo, zato što dobija novu vrednost u četvorci, tvoje ostale tako prepisujemo. Pogledajte dalje, ovoj tekući izkaz, to je izkaz broji 3, dakle kažemo y je jednak kova y dobija novu vrednost, tako da predkodno mi izkaz u gore, kažemo opet y je mrtvo, tako da ćemo značiti da je izkaz u mrtvo zbog ovog dodelivanja nove vrednosti, tako u izkazu broji 3, sve ostale prepisujemo ka gore, i to se ti trebimo izkaz u broji 2, vidimo da dodeljemo u vrednost ovome a, tako da će izkaz 1 a biti mrtvo, b je biti u izkazu broji 2, b je mrtvo, međutimo, ovde sada koristite njegu u vrednost, tako da će izkaz broji 1, b je u svariji gore biti živ. Dakle, još jednom da panovim, poredžemo dole rednom sve promeljive, kažemo da su sve na kraju žive, i zatim se selimo korok o korok ka gore, za sve promeljive koje se koriste u tekućem izkazu. Ako se njima dodeljuju evrednost, pretkodnom izkazu kažemo da sone mrtve, okoliko se koriste za određivanje nekake nove vrednosti, pretkodnom izkazu kažemo da su žive, okoliko se u tekućem izkazu u ovopšte, nekoriste samo prepisujemo ka gore, tekućem ih u u vrednost. I sada, napr. okoliko pogledate, ovo što smo gledali i malo pre, za prvi izkaz ovde reke smo da su promeljive b, x i c, žive, i ako pogledate to smo ovde sada i dobile ovim postupkom, jer se b koristio u izkazu broj 2, ako pogledate svarno, b, u izkazu 2 iskorišće, no x se kaže koristio u izkazu broj 4, i stvarno vidite da nikde odako preolog izkazu broj 4 ne koristimo to x, a c se koristio u izkazu broj 6, i vidite da ga nikde nemaz sve do ovog njegovog pojavljivanja ovdje u izkazu broj 6. Ako pogledamo a i y, kažemo mrtvesu, mrtvesu dobog toga što ih ne koristimo do njihovoj narednog o tako racunanja nekako njihove nove vrednosti, a kažemo dobija novu vrednost u izkazu broj 2, a y dobija novu vrednost u izkazu broj 3, i vidite da svarno u izkazu broj 2 nije koristio. Tako da vas zadatak prvi, kada krenete da rajte ovo generisanje koda za arhitekturu x86, biti da za svaki izkaz odrevidite za svaku promeljivu, dali ona mrtva i liživa. U prici, u biće nam samo važno da li mrtva i liživa. Njihova svedja će u potrego nam i neće biti toliko značajna kasnije što se biće generisanja koda. To je prve video koji treba da znam. Drugi ideo, ovo se će vam biti jasnije, kada kasnije prikažem i jedan zadatak, kada to se vidimo na primeru, ali moram vrlo na postandrnalu tako prvo da pokažemo šta to se postoji. Drugi ideo ovdje stavimo o tako zvanim deskriptori register. U svaki register koji postoji, mi ćemo panititi koje se promeljive travno na uvaz u njemu. Kada je potrebno na primer za neki iska samo smo imali zx i jedno koji y plus c kada je potrebno da izračunamo vrednost toga x, nećemo odmah smešlati to kada izračunamo u memori, nego ćemo čuvati u nekom registru lokalno i onda ćemo mi za svaki mister u stvari panititi koje su to travno to promeljile u njemu. Kada imam promeljive, govorim u množini, da li uočite moguće stavda da ja imam vrlo u njemu registru. Pa sad ćemo modnu da prikažemo jedan primer, nevno, primjero lako jedan vazični blok, u kome će se tako našto desiti, da vidite kako možemo sad da duštedimo na generisanju nekakvih instrukcija. Da te ja ću odda sada ma pokazati kako izledaju te deskriptori dok vi tamo negde čuvate sebi, registar pi, ja sam ih sad ovde pobrajo indexi 0, 1 i 2 i ako pričemo architetu rx86, ali on trunutku to od tako nije nivажno. Tako da će ja stavio sam ih ovde 3, gledati koje promeljive se nalaze u njim i redno ćemo sad izvašavati ovo pa da vidimo šta će se desiti. Dakle, kaj kviri, kažete ovde sad x je jednako 2. Ja ne moram odmog da upisujem na memoričku lokaciju toga x v rednost 2, nego jednostavno mogu da upišamo registarer 0 v rednost 2 i da zapantim se bi ok, promeljive x mi se nalazi u registruer 0. Zatim dođe sljedeći instrukcija, to je sljedeći izgaz, kaže c je jednako 5, ja onda kažem ok, c je sad na nalazi u registruer 1 i tu upišam vrednost 5. Kada na najdje sljedeći ove izgazovati y je jednako x, ja ne moram sad da ništa zapravu da izvašavam. Dolinom je samo da kažem, na primjer, da se i promeljiva x i promeljiva y na nalazi u registruer 0. I ništa ne moram da generišam odkoda, ništa ne moram da se desiti. Dakle, samo kažem, obje promeljile se na nalazi u registruer 0. Ono što moram samo da pazim, jeste da kasnije, kada se koristi u to y i y, moram dobrati pažne da u tom registruer 0 se nalazi i jedna i druga. Pa ćemo posledi deti kako to tako utiče na u našeg generisani kode. I na kraju kada pogledam, mogu kažem c je jednako y. Ja na kraju mogu da smestimo ove registruer 0, ali tako setri i c je promeljiva. Nikakakod ne moram da generišam, samo kažem, setri se nalazi u tom registruer 0 i taj registar ima zapravo nekakog vrednost 2. Dakle, jer smo x udodelili 2, pa smo rekli y je jednako x, i c je jednako y, dakle registar remula njegova vrednost set 2, a ja sam u tako samodno značuje da se setri i promeljive nalazi u tom registruer. Da, to će nam biti nekakopi deskriptori registara. Pantimo, za svaki registar koje promelja se trenko nalazvo nje. Najče će se to biti samo jedna promeljiva u registru, alo ovaj primjer čisto dredite, da su jednom registruer može nalaziti i višenje. Eft, sveća stvar koji ćemo uvesti, ovde je su nekakopi deskriptori adres. Ode sad radimo obrnutu stvar, da se sve nalazi u registrima i memorijskim lokacijama. Tako da promeljima neka može imati svoju vrednost tekuću upisan u neku svoju memorijsku lokaciju, ali se može nalaziti u jednom ili više registara neka. Pa ćemo i videti kasnije kroz dodatki, ali imamo sad da vidimo da je moguće da su ona nalazi na više nekatnih lokacija, pa da vidimo i kako je tako našto moguće. Eho je novi basicni bog, dakle potpuno novi primjer. I sad da ćemo ode pratiti za svaku promeljivu gde se ona to sve nalazi. I sve sve vada vada naše promeljive će se nalaziti na svojoj memorijsku lokaciji i memorijsku lokaciju u svake promeljive, ćemo značavati s ovih gore primjer, svaka x-primi, primjim, setprimi. Pre početko ovogo basicnih bloga sve se ona ne se nalaze tamo nekdo u memori. E sad, ove gde, ja ću uvjeti prepostavku da svaki put, kad ak korisimo nekakvu promeljivu, da je zapravo dovučamo u nekih registara, poslčimo i vidjeti kako ćemo komensi u koristiti predres. Pisa kada počete izveščona tovo x-i jednako 2-y. Ja moram, na primer, prepostavka da dovučam to y nekako iz memorji u nekih registara. Tako da to y, na primer, dovuči ću u registar, konkretno mislim da je bio registar r1 u koji smo to vradi ovde, i onda ću reći, najmado do povedama, da, da, ja ću onda reći, u grednosti ovoga y se nalazi u memorji na memorijsku lokaciji i ovdego y, ali isko tako sam go dovolj ko u registar r1, tako da se nalazi u registru i u memorji. Ko se tiče ovoga x, ja sam x dobil ko 2-y i ta je rezultat, tu sam sačuva u registru r0. Ono što se nalazi u memorji na memorijsku lokaciji x, nije valid na vrednost. To je neka stara vrednost ovog x-a, preneko što sam ja ovu pisom u vrednost ovog x-a. Tako da ja trenutno čuvam vrednost x u registru r0 i, naravno, moram da pazimo tako da to, ne snedno tako tek tako da obrišemo dazlen, nego da moram tu u vrednost katnije da vratimo u memorji, pa ćemo vidjeti kako ćemo boliti vratimo u memorji. Tako da kažemo, dalje c je jednako 5. To označi da kada dodalimo u peticu neću tu peticu upisivati direktno na ovu lokaciju c primu memori, nego ću samo sebi zabeležiti da c tako više nema valid na vrednostu memori, nego da se na primer sada nalazi u registru r2 na primu. A sad kad pogledajte, kažemo y je jednako x-c. Dakle ja sada odo ođu staciju ipsan je jako x-c, ne moram ni x-c, mi c-c da dovolacim iz memorji, nego samo pogledam i vidim da s x-c nalazi u registru r0, c-c nalazi u registru r2, oduzna je malo tako ta dva registra i na primer kažem sad človom rezultat taj u r1, međutim pošto y dopija novu vrednost sada, sva nova vrednost se nalazi u registru r1, a ona stara vrednost koja je ostala u memorji više nije validna, tako da kažem da je valid na vrednost samo tako u registru r1. I na kraju imamo četvrtu u tako ovu instrukciju, ode kažemo u registru r1, a nemoj imamo y, ali kažem, c-c je jednako y, ono što mogu duradnim samo jeste da ovdje ovdje ovdje samo postavim da se c-c nalazi isto u registru r1, ne moram čatni da generišam nikakav kod, nego samo kažem i y-c se nalazi u tako u registru r1. Tako da, ova dva malo poima, o tako tu su nam deskritori registara i deskritorija adresa, oni će nam služiti samo prilikom generisanja ovog koda, sada za x86, da znamo šta se nalazi u tako dao znamo gdje se ona to se nalaze, u koji mi ona to se registrima i tako da li memorievali na njena vrema. Ako smo veli, ovo šta znači mrtvo, šta znači živo, ako smo veli ove deskritorije ovde, sada onda možemo da krenemo na to, da vidimo sad kako sve rifunktionište taj algoritm. Prej, nego što krenemo na to, šta treba da uradimo? Dakle, imamo neka algoritm koji ćemo zvati getreg, tako se dode, i ono služiti da odredimo u koji registr treba da smestimo rezultat neko giskas. Dakle, ako imamo ovako neka giskas, koji kaže x je jednako y op 5 set, ovo op l, tako se vam predstavljati bilo kakva operaciju koji možemo da izvašimo da li stabilirajne duzime nje množenje nebitno šta je, dakle neko binarno operaciju. Ako je ovako neka giskas, dakle x je jednako y op 5 set, mene zanima gde ću ja smestiti, u koji registr, ću smestiti vrednost toga x. I sad ćemo da krenemo polako da spajemo sve ovo što smo da sadao sako ospomina. Ako izgleda sada ovaj algoritm getreg. On ima četiri nekakva poraka koja morate da zapamtite, a vidite ćemo kroz zadatke, kada prođemo ta tri zadatka biće nam populiziratno intuitive-no. Tako-tako biramo u kompternutku registra. Ali, ajmo reći, dakle, taj algoritm fix smo morate da radi ovako, dakle, ono, kada dobitani ispitu ovaj zadatak da radite, molim vas da ne izmišljate nekakve nove algoritme, nekakve nove optimizacije i slično, nego samo
 ako pratite ove korake koje ja sad budem oddenada. Tako, tada je ovdje sad ovako. Ako treba da izračunam x i jednako y o 5 set, ja kaže prvi korogoro ako. Ako je prameđila y, dakle ovaj prvi naš operant, ako u registru, ako je mrtva uposmatrana linikoda, dakle nema sledeći korištine, ne trebam i vrednost više toga y, zato što sledeći upotreba tog y, će biti njegovo novo računanje, ja onda smem da pregazim vrednosti toga y i da izkoristim taj registru u kome se y nalazi, ali samo u koliko registr ne sadrži drugi prameđile koje suživ. Dakle, to je i pišao od u koraku broj jed. Kako bi zledala jedna takva situacija, aj da prikazam u to pa će na biti jasno. Aj, o sad smo spojili sve ovo što o čemu smo pričali do sad i pogledajte sad. Ako kažem da je ovdje x i jednako y, na primjer, plus set, vidite sad o vrednosti togoga y, u tom tegućem iskazu, ove ja pogledam i mrtva. U kome se nalazi u y i mrtva prameđiva, ne treba mi njena vrednosti iše. Pogledam da se nalazi y u ovom adresnom deskriptoru, kažemo y se nalazi u registru r0. Dakle, jestu r0, ali od tako mrtvoje, ne treba mi liša ta vrednost i ako se ona nalazi u registru r0. Dakle, pogledam dalje u deskriptoru registra, u registru r0 se nalazi samo prameđiva y i nema drugih prameđih. Ovo je idej, ali na situacije, zato što ja onda mogu doroditi šta. Mogu slobodno da pregazim vrednost ovoga y i samo ako ovde bilo plus c, da samo nove registre r0, al tako sa berem vrednost c i to je sve što mi je potrebno. Dakle, u koraku broji 1, al tako idejalna situacija, nam se desi, da prvi operant se već nalazi u nekom registru, da je samo u tom registru, dakle nema drugih prameđivih tu zajedno sa nim i da je taj prvi operant, to je sta prameđiva tu, da je al tako mrtva, ne treba mi njena vrednosti. U tom fučaju, ove algoritme g3, u kome se nalazi taj vaš prvi operant i vić je onda nad tim registru na tu u stvari odraditi ovu nekakvog operaciju o5c, ti reći da se prameđiva x, onda nalazi u tom registru, gde je bilo to y sada, a y, naravno, uklanjam u istog registru, jer il tako mrtva nije imam više potrebno. E sad, to je idejalna situacija i to je o tako koraku broji 1. Međutimo, ukoliko nije ta situacija u pitanju, onda idemo na koraku broji 2 i koraku broji 2, li biti jedna karakteristicka situacija, da se bilo ove zpomeniljiva, ukliko biste imali nekakv vizskaz koji oblika x1 ko x o5c, naprimer x1 ko x plus 7. Onda, u koliko je registar, ne sadrži druge promeđile, vratimo u tako registru u kome se nalazi ovo x. Dakle, ako x u nekakvom registru, ove naš operant dobde prvi, biti x1 ko x o5c, dakle ako x se već nalazi u nekakvom registru i ukliku u tom registru nema drugih promeniljivih, onda vratimo u te registru u kome se nalazi x. Primaš, do to bi bilo ovak našto. Dakle pogledajte sada ovdje imamo iskaz x jednako x opc. Da li x živo ili mrtvo ovde, dakle to čak nije ne mora da vas zanim, ovde samo pogledajte, dakle promeljiva x se nalazi u registru r1, to je prvi uslo, na drugi uslo je da se u tom registru r1 ne nalazi više ni jedna druga promeljiva, već samo ta promeljiva svako x. Eo, vidite kako izla tako neka primer i u ovakom slučaju ovde, algoritm getReg će vratiti, napr. registru r1. I onda ja smem slobodno vrednosti tog registra r1 da odradim ovo o5c, zato što to je ono što ja koću. Dakle koću x jednako x opc, ako na registru r1 uradim, napr. plus toc, u bupanl ov tako tu ću i ostaviti vrednosti tog x i to je ov tako korak broj dvanja. To je druga najbolja ovdje ovta pa situacija koja može da vas zadetite. E sad, ako nije slučaj ni prva, ni druga situacija, onda tako ovaj algoritm getReg će reći sve reće. Reći će, ako postoje neki slučajnog registra, onda ćemo uzjeti njega. Dakle, u koliko ima neke registre u kome se trenutno nalazi ni jedna promenljiva prazanje, uznamo tako taj neki registar i to prvi, ili tako koji nam je slučajnog registra. E sad, tako nije ni 1, ni 2, ni 3, nemani slučajnog registra, onda da vzimo do tačke broj 4 u kojoj sigurno tako pronalazimo registra koji nam je potreban, a tačka broj 4 kaže sve reće. Uznamo jedan od registra i stimimo trenutno vrednost registra odgovarajuće memoriju s ku lokaciju i vratimo od obrani registra. Dakle, šta to ohoće da kaže, ako je ovako neka kada situacija, dakle, sva tri registra su zaozeta u registruar 0, promenljiva d, u registruar 1, i promenljiva c, u registruar 2 su promenljive i, a, i, d. E onda ovako, nekakva situacija da bih dobio registar koji smem da koristim, napimera za ovaj iskaz x, jedna koji cilom o5c, i onda moram da izaberem jedan od registra, i okretno slučujem sam izabro na primer registraar 0, i ovu promenljivu d, moram da staču vam u memoriju. Dakle, ja sam ovde pamitio da se promenljiva d, na vaziu registruar 0, međutim da bih koristio registarar 0, da bih nega ispraznio, ja moram ovo d, da upišam u njegu memorijsko lokaciju, da staču vam tu vrednost, i pe konda otako koristimo ovaj registarar 0. Obravite pažno samo da ovdje je otak algoritm getreg, da bih tam getreg ne govori ništa kako vi birate registar koji ćete otako isprazniti, da bih ste go koristili, to možete sam i da proizboljno izaberete, ja ću kasnije sugeri sa tjenačnog kapusta to bira, ali konkretno ako biste ovdje napr. izabrali registarar 2, onda pazite da su njemu nalaze promenljive i a i b, tako da bih trebalo i jednu i drugu otak upisati u memoriju. Dakle, sam morali bih se da izvršite dve instrucije, da se ova vrednosti do ovog registarar 2 upiše i nam je moriš po lokaciju a i nam je moriš po lokaciju ovog ovdje. D. Ola četri koraka ovdje nam tako jednoznačno odrežuju koji ćemo registar mi zapravo koristiti u otakom nekakvom tiskazu za rezultac. I to bi bio taj neka ka naš algoritm getreg. I sad kada jemo i taj algoritm getreg, onda smo spremni da konacno otakom sad vidimo kako će izgledati to nekako generisani kod. Generisani kod opet za taj neka viskaz koji će biti oblikaj x1 koj y1, koj y1, no 5, 5, istita iskaz koji malo prei ide ovak. Prvi korak je se da pozovemo ovaj naš podprogramu tako to je taj algoritm koji smo malo probjasnili, getreg, i on će nam ratiti neka ka v registar, ja ću ovdje dobro beležiti i koristiti sve vreme koje rx. I to u taj registar treba da bude smešteno rezultat ovog ovdje. Tako y1, no 5, 6 treba da bude smešteno u to je rx i tu će se zapravo nalaziti ta promediva x. Nakon što smo pozvali to getreg, algoritm dalje kaše. Proverimo, da li se ovo naše y već nalazi u tom registru rx. Dakle, ako se nalazi u tom registru rx, odlično samo preskačamo tako korak b2, vidjetimo, koliko y nije u tom registru rx, moramo da generišamo instrukciju move u rx, u baćci, vrednostu tako ovoga y. I sad odesam ga, je označijako y'a, ali odesam, ako značili da je to y'a, tekuća lokacija, gde se nalazi ta promeljiva y. Idealno bi bilo, u koliko se to y neće nalazi u nekom drugom, na primer, registru, međutim, u koliko y nema nam njih da u njihoj drugom registru, svo ćemo vidjeti iz onih adresnih deskriptora, od tako za y, onda, naravno, dolačimo y iz njegove memorijske lokacije. Ako smo dovukli y u taj registru koji je potrebno, onda izvršavam ovu mašnicku instrukciju, tako ovo opet set. Dakle, šta goda je to, sabiranje, dvizima, nješta goda se radi, i to, opet, za ovaj operant dovdje set, idealno bi nam bilo, u koliko se to set nalazi opet u nekom drugom registru, tako da nemo u nekom drugom registru, opet, u tako da uči ćemo ga iz memoriju. Nakon što smo odradili, ovo ovdje, onda moramo sad da ažuriramo sve ove naše o tako tabele koje smo imali, tamo pa onda kažemo, erx dodajemo u adresnih deskriptorze x, dakle, sad za promenju u x, moramo da naznačimo da sa ona nalazi u ovom registru erx, a isto tako obrnuto, moramo da kažemo sad da x dodajemo u deskriptorze registra erx, samo naznačimo tako, promenljiva x se nalazi u registru erx i naznačimo da se u registru erx nalazi promenljiva x, dakle, samo tako dva na različita deskriptora popunjavamo. I kaže dalje, pogledam ovo y i set i kažemo, ako nisu živi u datom iskazu, samo ih obrišamo iz deskriptora registra kojima se trenutno nalaze. Dakle, ako smo y i set, imali u nekim registrima, ali nam dalje, nakon ovo gizka, za sad da nisu potrebni, dakle, vidimo da su mrtvi, onda samo obrišamo ih, o tako, da samo oni više ne nalazi u tim nekim registrimu kojima su bili. Korak vroje 7 se odnosi na kraj bazičnog bloka, dakle, kad obižemo ceo bazičnog bloka i izgnerišemo kod za ceo blok, onda tako izvršavam ovaj korak vroje 7 koji kaže da, na kraju bazičnog bloka za se promenljive kojem nam se nalaze u nekom registru, ali izključivo samo u tom registru i koje su žive, moramo da izgnerišamo tako instrukcije move da njihove vrednosti prepišamo istih registra na njihove memorijske lokacije. I to bi bilo celokupan taj postupak, ali sad kažem najvaksim da mi vidimo na primeru kako su to sad zapravo radi. Ako nešto nije jasno, ako nešto treba da ponavim, slobodno pišite na prepa. Tako izgleda je jedan zadatak iz ove oblasti ozve i šta možete čakivati zapravo na ispitu, pa ovo ako našto. Kaže tekst odrejati koje se promenljive žive u kodu i nosimo u toga generisati koje za x86 procesor i kaže pretpostaviti da se koriste samo registri AX i BX. Oddje smo osvod ograničili namerno na dva registra, jer ako bih smo imali više registra, onda ne bi bilo zanimljivo, tako ubi ste imali neki slobudan da izkoristite tako za računanje rezultatit. Dato je sedam iskaza i ajmo reto. Kako radi to ove zadatke od? Ove zadatke radi, tako što prvo od crta mogu tabelu našu, sve promenljive koji imamo, A, B, C, I, D, za sve njih prvo odredimo, da li su o tako žive ili mrtve. Kvoređete ih red i rekli smo krenete od dnaka gore, ovde su tako na dnut uvek sve žive. Dakle, prepostavljamo da su sve ove korističke promenljive žive. Ukoliko bi ste dobili, prisetit ćemo se predkodnom časa, uklikubi ste dobili ovde sada neke privreme, neproma...
 u promeljivje koji ćemo značavati sa onim t1, t2, t3 islično, e zna njih ćemo odmah predposedevati da se na kraju bazičnom bloko ono uvijek mrtve. Jer ako se setite samo kada smo generisali onaj među kod, te privremene promeljive sluše samo u rutor tog nekakog bazičnom bloko da čuvamo nekako je privremene zultate. Tako da one bi ovde tako bila na kraju mrtve. Ove sve koristite, zničke će biti naravno žive. I sad prepismo idemo ka gore. Pogledajte ovdje koriste se i, c, dakle one su naravno živi, u d se upisuje vrednost, tako da u predkodnom koraku za d pišemo tako da je mrtve. Ove što su mrtve samo smo značavalo u m, ove ostalo da je tako pisalo, sam kada se koriste svećiko. Idemo ka gore, kažemo u a se upisuje vrednost, tako da a će biti mrtve, a b je ovdje koristimo ovde, tako da smo ovde žurilo da se b koristimo čestici, sve je ostalo prepisujemo. Kažete ovde dalje, b dobija novu vrednost, dakle b će biti mrtve, a a i c se koriste, tako da za a i c pišemo da su živimo tako u iskazu broj 5. Idemo dalje, kaže a dobija novu vrednost, a će biti mrtve, a b je ovdje koristimo u iskazu broj 4, ostalo prepisujemo, kažemo c dobija novu vrednost, dakle c će biti mrtve, b se koristimo iz kazu broj 3, ovdje smo žurilo da je živo zbog iz kazu broj 3, ove ostalo je ostalo tako prepisujemo ka gore, i idemo skroz gore, kažemo b dobija novu vrednost, dakle b je mrtve, ove da ove prepisujemo i a kažemo da je živo iz kazu broj 2. Dakle prvi kora koji odalite, jestli da popunite u tabelu šta je živo šta je mrtve, imamo set i iz kaze tu i šta ćemo sad da radimo dajdemo. Ovako zapravo treba da izljavati celo kupno tabela koji ćete vidi, svetlati za ovaj zadatak ovde, a šta će a zapravo pratiti? Za svaki izkaz mi ćemo pratiti u tom izkazu šta se nalazi u registru, a sad koje registre već budemo imali, konkretno ovdje jemo registr AX i BX, i u najvećim brojiskom čeva će to biti u vašim zadacima. Dakle registr AX i BX, ja pametim koje se prameđile nalazi u njima, ovdje repte smo da postojevamo algoritm GetRag i ovdje ćemo pisati šta je algoritm GetRag vratio za ovaj naš tekući izkaz i ovdje u poslednjem koloni ćemo prikazivati koji smo to kod generisali za taj neki izkaz. Krenemo redom, sad ovdje tako da popunjavamo ovo sad kada generisamo kod, naravno videmo od početka kaj u blokaka dole, naravno ovdje ovde informacije će nam služiti ovdje ovdje, tako da li su neke prameđile žive i kada se koriste, da to će nam služiti pri ljubom generisem kod, pa ćemo sad vidimo tako kako to ide reto. U setiče prvi situacije, ovo A je jednako jedan, dakle ne radi su neka kombinarna operator ovedje, tako da to je posledno slučaj i kad krenemo dat, da ovaj naš algoritm GetRag, naravno poštovano ovdje tako uveku opisuje kako se dofata registr i koji će smestiti rezultat, ovde ne možemo koristiti ni korak broj, jedan ni korak broj zva, jer se ne radi o nekom binarnom operatoru, tako da koristimo tako ove treći deo našeg algoritma, taj deo kaže, vratite slobodna registra u koliko posloh. A i registra AX i registra BX su trebno slobodne i tako li će ovde reći da za prvi iskaz koristim AX. Ido je generisanja koda, ovdje u koliko se radi ovom samo ovaj prostoj dodelitu, će biti posebno generisanje koda, ako do naša algoritm koji se mi ovde skraćeno prikazalo, samo četri korak, ako će biti interesantno, ovdje ovdje tako njega svojimo na to samo da svoj izgraši jedna move istruktija. Dakle ovdje ćemo samo reći move AX1. U AX registra upiši vrednost 1 i ovdje smo zabeležili da se u registru AX reotna nalazi promeliva A. Tako, ovo je posebna situacija kada imate samo dodelu vrednosti, nju ćemo posebno obrađivati. Idemo saz dalje, dakle, ovo je sve što ne je bilo potrebno. U svom registra AX upišemo 1, što se pičemo i moriške evokacije ove promeliva A, ništa nismo opisivali u nju, nego smo samo zapantili da se to analazi trenutno u registru AX. Poslopamo sada sledaći ovaj izgazovati. Pode kažemo, B je jednako A plus 2. Šta će nam reći algoritm get-req? Pa pogledamo kako izla algoritm get-req i prisetimo se tamo da njego korak broj 1 kaže, ako promeliva Y, a to je u svari naš prvi operant, što je u konkretnu slučaju ovde promeliva A, ako je u registru. Pogledamo i vidimo da A jeste u registru AX. Kažemo, da li je mrtvo posmatrno i linij kode? Pa pogledate ove za izgaz broje 2, kažemo promeliva A jeste mrtva i kažemo, da li registr sadrži neke druge promelive koje su žive? Ne, pogledamo, vidimo da registr AX sadrži samo promelivu A, i onda kažemo u tom slučaju može da se vrati registr u kome se analazi to. Y to je staj prvi operant, u našem slučaju to je promeliva A, to je, zbogde, vratimo registr AX. Kako izgleda del sa generisanjem koda? Evo je ovde. Prvi korak je, bio da se pozove ove algoritm GetReg. I to smo već odradili, algoritm GetReg je vratio ovde AX. Onda kažemo, okudiko Y, to je naš prvi operant, nije u tom registru koji je vratio GetReg, pogledamo da li je naš prvi operant A se nalazi u ovme što je vratio GetReg, pa nalazi se tako A, se nalazi u AX, da se A ne nalazi u AX, da se u nalazi u AX, pa tako gde se to A već nalazi, međutimo, ovako preskačemo korak broj 1, jer A već je s tu u tom registru. Kaže korak broj 2, generisujemo mažensku instruciju, op, al tako AX set print. To je, skoći da kaže, da sad treba da izvršimo ovo plus 2. Konistimo registar AX, tako da ćemo na registar AX uvraditi ovako add i dodat ćemo svario ovdje kod vojku, pa ćemo to videti ovde. I onda šta treba da žuriramo, da u AX, tako, to je stavlja resultat naš, to će biti ovo naše nekako B, treba da se doda u adresni, to je tu deskriptor registra ovog naše komode, to je sad naćemo reći da su registru AX više ne nalazi i promeljiva A, nego se tu sad na nalazi i promeljiva B. Zato što vidite, da korak broj 4 nam je reko, da ukuliko bilo koji je dovad malo operant u ovom tekućem iskazom, pa to bi bili A, tako da, šta će se sada desiti, ako pogledajte, ja samo kažem, AX2, tako da samo na registar AX dodajem 2, pogledajte sam ovu plus 2, a ovde sada smen da sloni iz registra AX promeljivu A, a da stavim da se tu sad na nalazi i promeljiva B, zgub čega, zato što ako pogledajte, A je mrtvo, a zašto je mrtvo, zato što mi neće biti potrebna njegova vrednost sve do narjednog računanja, a tnjegovo narjedno računanje je tako da sam ovde sada u izkuzu groje dva, slopodno smel da pregazim u tako tu vrednosti. Idemo dać, kažemo C je jednako B-3, pogledajmo sada šta će nam reći algoritm get-req, pa imamo da probamo pregledanog šta ja prikažam, občatno je oblačit će. Dakle, pogledajte uvek prvi operant, gde vam se nalazi prvi operant, da li on možda veću nekom registru, i ako pogleda, promeljiva B, jeste već u registru AX, međutim da bih mide, pogledam u tekućim izkazu, da li je promeljiva ta živa ili mrcva? Ako je mrcva, ozvečno, ako je živa nevega. I pogledajte, promeljiva B, jeste živa, tako da to tu mi ne odgovara, dakle prvi i drugi korak nisu ispunjeni uslovi koji su tu postavjeni, nego korak korak groje 3, kažemo, vratiti slopodno registr ukoliko postoje. Dali po stoji slopodno registr, po postoje naravno vreggistr BX, metranotno praza. E sada, šta nam je rekao, ono je algoritm ukoliko se prvi operant ne nalazi u registru koji vratio getreg, dakle, da li nam se B nalazi u registru BX? Ne. E onda treba da generišamo mašinsku instrukciju, da nekako to B dovučam, ali tako u taj registar BX. To je stiči, če ovdje ovdje u tako instrukcija moveBX, e, a gli pa kaža ovdje, ovo y prim, treba da nam označi gde se to B nalazi. Nama idealno, ukoliko je to B u nekom drugom registru i to i jeste situacija ovo. Dakle, ja sada hoću da bih se ne izregistra AX da prebacimo u registru BX. Dakle, ovako našto ćemo dobiti. Prvo ide moveBXAX a tek onda kada to B prebacimo u registru BX u samostavnoj sada vratom, dakle vidite, kada izgenerišamo to, onda i da ova mašinska instrukcija ovo minus tri, da od tog registra BX u koja se sada nalazi to B oduzmemo u tri. I naravno, žuriramo sve kao što smo imali u klje raditi. Dakle, još jednom. B se nalazi u registru AX međutim živoje, tako da ja njegovo u vrednost ne smet da pregazim. I onda da bih izračuno B-3 ja zapravo prvo to B i za AX prebacimo u BX a to je ovo pravajne instrukcije ovdje. Atim, ovako, tako B-3 računam tako što samo od registra BX oduzmem tri. I kažen, to je jednako C. Tako C, jednako B-3 i onda zapantim samo da smo registru BX sada nalazi promenljiva B. Promenljiva B je i dalje otako ostalo u registru AX i vidite, da njenu vrednostu tako nismo menjali, dakle ovo B-3 smo računali nad registram BX. Idemo dalje. Kažem, odo u koraku broj 4, to je su iskaz u broj 4 A je jednako B plus 1. Dakle, opet on je naš algoritm getRek gleda prvi operant. Dali se B nalazi u nekom registru? Da, nalazi sa tako u registru AX. Dali je B možda mrtvo u tom registru? Jeste, odlično. Dali imajuš nekih promenljivih u registru AX? Nema, super. Dakle, koristimo registar AX dakle prvi kora kova je naša pakogore je ispunjen, prvi operant, je ste u registru? Jeste mrtvo u posnotronili lini koda i registar ne sobrži u druge promenljive tako da će ovaj naš algoritm getRek vratiti u stvari AX. Reći će da može da se radi sa tim registrom AX. Pa treba da odredimo. Dakle, stanam kažel tako algoritm za generisanje koda. Algoritm za generisanje koda će nas prvo pitati dali se prvi operant, to je ovo našer B nalazi u registru koje vrati u getRek, B se nalazi u registru AX, preskačamo kora koji je jedan. O algoritm će nam da reći generišiti mašenskoj intrukciju da odredite ovo u stvari plus 1. Dakle, onda ćemo da prvoraditi samo ad AX1. I šta radimo dalje? Kažemo sada poštu smo AX računali, a dobilismo od getReku ovo
 u vrednost a, ostavljamo hort. Dakle, sada u meztu registru A x se u meztu b nalazi promeljiva a. Promeljiva b smo obrisali iz registra A x, zato što vidite ovde da je ona u tekuće linije i kod ovde brtva, a vrednost a smo izračun ovde ovako u tonu registra. Posmatar te dajte. Peti izkaz ove, idete redan, prvo gledajte one naš get rekt i kaže on opet. Gledam prvi operant, to je promeljiva a. Nelazi u nekom registru, pa je ovdlo tako na ozice u registru A x. Dali je promeljiva mrtva, pa vidimo ovde, jestem mrtva, ne treba mi njena vrednost, vidimo da se već u izkazu brove 6 računa na ovo vrednost, tako da ovo tekuće a, nakon izkaz u brove 5, mene nije potrebna. Dakle, s njemem da pregazim to tu i još što vam moram da provjerim, da li to ima neki drugi promeljivih? Nemna, a je samo u tonu registru A x, tako da će ove algoritm get rekt vratiti ponovol tako A x. E sada, šta nam kaže ove algoritm za generistanje koda, kaže da li se prvi operant već nalazi u registru, nalazi se da ka nije potrebno da ga doblat ću on je već tu, kaže iz generiši mašenskoj instrukciju OP, al tako RX, C, to je oduzmi ovo C. Odakle oduzimam C, pa kako ćemo oduzimati C? Prvomog gledamo gdje se to C sve nalazi i nalazimo ga odmah al tako da se nalazi u registru B x. Ukoliko je u registru, u tomi idealna situacija to je tako naje brže moguće, ako ga nema u registru, onda bih moro da ga doblat ću tako iz memoria, to jest da ga oduzimam sa njegove memorijske lokacije. Ovakor samo izmašimo tako u instrukciju sub A x B x, dakle od registra A x oduzimam vredos registra B x, promenljiva A koja se nalazila u registru A x i ovom izkaz u mrtva, tako da ni ubrišam iz registra A x, A promenljiva B se sada nalazi u tako na njeno mes. Opatramo slereći izkaz, izkaz broje 6 koji kaže A je jednako B plus 1. Gledajte, prvi operant, dalje je u nekom u registru, jeste u registru A x, dalje je prvi operant mrtva, pa nije. Znači prvi operant da mi živ, nesmem da pregazim vrednost u tom registru jer mi treba vrednost je promenljive koja se tu nalazi. Tako da, šta ćemo onda? Onda nam kaže algoritm gdje treb tamo u koraku broji 3 vrati slobodno registra, međutim vidite sada da su registri puni. Ode se nalazi vrednost promenljive B, ode se nalazi vrednost promenljive C, tako da dolazimo do uplutrb B4 korak ovog našega algoritma koji kaže ako su si registri zaoziti i ova dva prva uslova nisu ispunjena, onda koristimo 4, to je spregad izaberimo jedan registar koji ćemo da ispraznimo. To je su promenljivu koja je trenutno u tom registru, sta čuvat ćemo njenu vrednost na njenu memorijsku lokaciju i onda koristimo taj registar tu. U koraku broj 4 algoritm gdje treb, ja sam rekao da ne opisuje kako vi birate sada je taj registar koji ćete zapravo isprazniti, ali ono što je najlogičnije je ste da, ukoliko imate neki registar u kome se nalazi ovaj vaš prvi operant, vidite ode B plus 1 radi, ako se ovo B je veći nalazi u nekom registru, to mi slično kao i korak broj 1 gore, dakle gledamo, da li to B, to je s prvi operant veću registru i da li taj registar ne sadrži druge promenljive, e sad bez obvira što je ta promenljiva živa, i zaberete taj registar, a onda samo ovaj deo ote prvo korak koji kaže, da li je ta promenljiva mrtva u posnotanju linije koda, da je pa postačnje mrtva, okoliko ja sacuamo tako njenu vrednost na memorijsko lokaču i koja je potrebna. Tako da ovde sad da kogledam, treba odvršim a1 ko B plus 1, veo ovo živo, treba od izaberem registar i zabraću registar u kome se nalazi B, to je taj moj prvi operant, i onda ću njegu u vrednost da čuvati u memoriju. Dakle ovaj ovdog u ritam getreg će vratiti ax, ali isto vremeno će on odmah izgenevi, isat i kodi reći će na memorijsko lokače ovoga B u pišit sad daža je registra ax. Dakle da sad ovu vrednost koja se nalazi u registru ax, dakle vrednost toga B, ja smem slobodno da pregazim u ovom korakodu. I šta je onda potrebno duradnim sad, pa kažem, bo sad, vidite sad, zbog čega je lakša da izabere to odmah registar u kome se nalazi prvi operant, da to što onda preskače to je prvi korakod, ovakog algoritma za generisani koda, koji kaže da ako se prvi operant ne nalazi u registru, da onda izgenerisati instrukciju koji će tega doluti u taj registru. E, ja pošto sam baš izabrili registar u kome se nalazi u taj prvi operant, je onda tako preskača moji prvi korak i to mi nije potrebno i sad treba samo tako taj registar da se berem sa 1. I onda kažem, ovde ad ax, tako dodaju 1 i ovde se sad ome stu B nalazi promeljiva a. Slično tome sad izimo i u poslednji korak ovdje, dakle u poslednjem koraku opet, tako jemo a minus c i a i c se nalazi u registrima, međutni vidite da su sve te promeljive narodno u poslednjem iskazu žive. Tako da opet moramo da izaberamo jedan registar koji ćemo da ovdje tako ispravimo da snivimo njegu u vrednostu memoriju pa da ga tek onda koristimo. I opet gledajte, da li imate nekde, da ove prvi operanci nalazi u registru, opet je to registar ax. Tako da šta radimo, braćimo registar ax, na memorijsko lokaciju promeljive a, upisujemo sad režitara ax i onda ovdje tako, kada gledajte, ko je algoritm za generisanje kod, onda će vam reći, sad pošto se a već nalazi u tom registru, samo generišamo ovom minus c. Gdje se nalazi do c? C je se nalazi u tako u registru bx, tako da ono što mi potrebno je ste sub ax, bx. Dakle samo od ovog registra ax, od uzmi vrednost bx i to je u stvari a minus c. I kažemo da se sad tu nalazi promeljiva d. Kada zadašite sve ovdje, samo narodno nikada na kraju ne zaboravite, a to je ono što smo rekli, da ovo je algoritm kaže na kraju bazično gloka, pošto smo završeli do tako c, od taj bazičen blok izgenericali kod, sve promeljive koje se nalazi u registrima i živesu, a to su ovde sad o tako promeljive d i c. Za sve njihova tako generišamo istruksije kojima se čuvaju, njihove vrednosti na memorijski imokacijeno peseo ne nalazi, a to je muf c bx i dl tako iz registra i t. Šta smo zapravo sad odopile ovoj modul tako algoritmima i ovoj sim postupcijima gledanja tih svih dalji su promeljile žive, nisu svi ovi deskriptori registra, promeljivih i slično. Pa dobilj smo sledeće. Ako pogledajte sada ovde, ako liko bi smo imali pristupa memoriji, da smo ovo ovde realizali tako što bi smo svaki put tako pristupali memorijski imokacijima da se nalazi promeljile. Ovoj bi smo tako prvo morali u a da upišemo 1 to i 1 pristup. Zatim u drugom iskazu bi smo morali da pročitamo to asi iz memorije i da upišemo u b to su još dva, dakle 3. Onda odima te 4, 5, 6, 7, 10, 11, 12, 13, 14, 15 u kupno pristupa memorije bi smo morali ovde da imamo, da bi smo ovo sve izročno zelutako, ako ne bi smo gledali da te promeljivo gudu memori. Dakle 15 puta bih ja moram nešto da pročitam ili da upišemo memoriju. Ako pogledam ovo je naš generisani kod ovde, koliko puta smo mi zapravo pristupali memorije. Dakle, ovo ovde su samo registri, edax2 je opet samo registar, moveDx, ix, subDx3 nikde ne pristupa memoriji, edax1 ništa, subDx nema memorije. Evo gode, dakle prvi pristup imamo izkaz u broje 6, da smo u promeljivu b upisali nešto, to je 1, zatim slijedeći pristup memori imamo u izkaz u broje 7, da pristupamo u promeljivu a, i na kraju otakujemo ova dva pristupa, da gudno 1, 2, 3, 3, u mespo 5, da vidim nekatih pristupa mi smo ovde zapravo imali samo 4 pristupa memorije. I ja to vidite opaku, gde imamo tu sad ubrzanje. Ovo što smo sve spomenali u ekonomom časlu, kada smo tamo pričali o nam medju kodu i o nam indeksiranju promeljivih, kako bi smo mogli tako da ih selimo, to je da menjemo redu sred njihovog izvršavanja, vidite da bi sad ovde mogli da se izkoristi za optimizačiju gorišćine ovih naših registara. Ier na primer možda vam se sad da gledajte neka kakav izkaz, na primer izkaz broje 2, možda vam izgodnije da nakon izkazal to broje 2 se izvrši prvo izkaz broje 4, pa tekmo onda izkaz broje 3, zato što na primer jedno od upotrebonog, al tako što smo prošli čas radi, da smo gledali gdje, tako koja promeljiva može, da je koji izkaz može da se presel i to je da se izvrši nekim drugim redasladom. To je rekt, to sam na prošlen čas objeće od oču objasniti, tako da, ovo sada ovdne možete videti primer tog da je, na primer, možda se desi situacije da vam izgodnije da zamenite redosled izvršavanja nekakvih izkazu ovde, kako bi ste optimizdovali gorišćenje ovih registara. Eto, to bi je zadate broje 1, da nemo sada je još 2 nekakva primera, zadate 2 i 3 koji su slični omizu zadatku 2, ćemo još jednom proći kroz ovaj celo mekanizam, a u zadatku 3, ćemo onda samo još posmatrati vrednosti tih promeljivih, gde se šta je naozili, šta imamo u memori, šta imamo u registrima i to bi bilo, to bi bilo to onda za danas nije často. Tako, aj, naprećemo sada jednu pauzu desetak minuta, ako gleda ti imali neko pitanje pišite slobno, pa ćemo dologovati na to posvert pauze i odrdimo tazma primera, i to je sve ne bi trebalo da bude komplikova nova, da je to pravoliniško i samo zapamtite o tako kako izgledaju, to je skako funkcioniša o zvali u ritima i ne bi trebalo kažem da imate problema, bar svali ima zadatku. Ajmo da pauzla neki desetak minuta, pa naprećemo da nasve imamo u 1 i 5. U nekome učinu, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam, da se ne znam,
 Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači. Užite se da se ne znači.
 Pidovom, razpajimo da mi čuvajte. Danas vidite da je moja ekran sa nekodom je potvrdi? Slobodno se je uključiti ako ovdje više nema ljudi sa iera. Pošto vidimo da kolega koji ne malo protvrdio više nije tu. To čuvajte se sve. E, hvala. Dobro, ništa. To je bio zodata groje 1. Nadam se da smo sada svatili šta se tu desilo. Ako i nismo, ajme još dva primjera pa ću voljati na biti jasnije. Kaže dalje ovako, samo trenuta, zadatak broj 2. Zadatak broj 2, slično koje je malo prijatno, samo što ćemo sad odvijeviti još neke karakteristične situacije koje možda nismo malo previdali, pa hajde imo onda što se tako, sada vedešao. Dakle, ista pričak koje je malo prijimate, nekako ih sada niskaza, opet promeljivo A, B i C, nemoge sada promeljivo UD, tako da je malo jednostavnije, i opet o tako pretpostanemo da se koriste samo regisli A, X i B, X. Ja ću onda samu odmah prikazati, ne moramo sad ponovno da prolazimo jedno po jedno, tako, jedan po jedan iskaz da vidimo kako smo rili šta je živo, šta je mrtvo, dakle odmah sam prikazala ovdje za svaki iskaz sada koje promeljive su žive, koje su mrtve, dakle, jedino što treba da vidite samo da svaki put, kad nekoj promeljivi dodajemo, dodajemo tako neko povrednost, ono ću pretkonu iskazu biti mrtv i samim timu, tako to da se ispropagiramo do doberha gori. E sad, gledam urednom opetu kao i malo preregisar A, X, B, X, šta će nam ratiti ono g-track i generisani kod, pričem da ja sad neću prikazivati svaki put, kako izgleda algoritm g-track i ovaj naš algoritm za generisani koda, nego ćemo tako pokušavati sa to sami da odredimo nekako. Idemo rednom i kažemo ovako, u startu ovo g-track šta će da vrati, dakle, i A, X i B, X su prazni i radi sa ovome B i jednako 3, tako da tu odmah ratit ćemo neki prvi sloboda regisar i to će biti regisar A, X i onda odmah izgleda rešemo kod, u A, X, u prišel, tako tu vrednost 3 i u registra A, X, zapamtimo tako da se na to nalazi promeljiva B. E sad, gledamo sajce liniju koda koja kaže A jednako B plus C, šta će da kaže g-track? Dali se prvi operant nalazi u nekom registriku? Nalazi su registra A, X. Dali prvi operant mrtav u ovite kuće lini? Jesite, evo govoda tako mrtvo je. Dali se otak u tom registra A, X nalazi još neka promeljiva? Ne, odlično, da te koristimo registar A, X. Ako koristimo registar A, X to znači ćemo pregaziti vrednost ovoga B zato što je B u ovu lini i mrtvo, tu ćemo onda se čugoti vrednost A i potrebno je samo da na to B dodamo ovo C. Dali to C imamo u nekom registru? Nemamo, odmah ćemo otak u to C do ući iz memorije. Dakle, ovde samo pazite, kada se radi u ovom drugom operantu ovde, njega neću doblačiti u neki drugi registar, nego ću koristiti ga direktno iz memorije, ok? Tako da ovde kažem, iskoristio sam registar A, X. Samo sam na taj registar A, X dodao tako C i to C odmah direktno iz memorije. Nećemo C doblačiti iz memorije u neki registar, pokoristiti taj registar, jer bi to onda otakvo samo zakomplikovalo. Ono što biste vi mogli da radite, jestem da gledajte, da će vam to C biti kasnije, nekde još potrebno, pa da onda otakvo odrađete tu optimizačiju, pa da se to po ovom algoritmu ovde ne radimo, tako da pracimo samo tako, kako kažemo na algoritm, a on kaže dovuci iz memorije ka tipot. Tako da gažemo, dakle, ed A, X, C i ovde smo žurirali, promenile B više nemamo u registru A, X, tu se sada nalazi promenljiva A. Kažemo dalje, B je jednako A minus C. Dali se nalazi prvi naš operant, tako u nekom registru, nalazi se, dalje je mrtav, pa nije, dakle, A je život, ne, ako je A život, da mi potrebno je vrednost toga A i rite do vizku za obroju četri koristim tu vrednost, ako da mi treba vrednost toga A, ja ne smem da koristim registru A, X i da pregazim, to A, nego moram da koristim neki drugi registr. E sad pošto registru B, X, prazno, na noću, na primjera, uzeti njega, i G, T, R, X, C, R, B, X, E sad, ako hoćemo je koristim registru B, X, i da tu saču na vrednost ovoga B, a to treba da gude A minus C, ja onda moram prvo A da upišavu registru B, X, i to A mi se sad analazi u registru A, X, dakle, prepisaće ovo iz A, X u B, X, i zatim oduzimamo C, naravno, opet sa njegove memorijski ovakacije, i onda samo zapotnimo da se u registru B, X, nalazi, promeljiva B. Dakle, rvo moram A da ubacim iz registra A, X u B, X, to je ovama instrukcija mu B, X, A, X, a zatim do toga oduznem C, kažemo sub B, X, T. Zledamo dalje, kaže ovo linija, to je četvrta linija, kaže C je jednako A. Ovo je sad, na primar, jedna karakteristica situacija, gde kada kažemo ovako nešto, pogledajte sad, sad ovde, na primar, promeljiva A se nalazi u registru A, X i mrtvaj. Mjegi ti sve i da je živa, mi možemo slobono tako da ovde zapotnimo samo da se i C i A, kako što se mi ja tamo pokazu, onom primar, u pre, da se jedne i druga promeljiva nalazi u registru A, X. Naravno, promeljiva B pošto je živa i dalje ovom izkazu, ona će ostati u registru B, X, a ovaj algoritm get reći, će reći, tako da se koristi registra A, X. Nemam potrebe da generišam bilo kakav kod, nego samo sebi za beležno da se ovde nalazi promeljiva C. E sad pošto je A mrtvo, zbog toga sam A izbacio iz registra A, X, da A bilo živo, ovde bi su ovom registru A, X našli jedne i druga, da kodde bi pisao i C, da se nalaze tramplatu. Ovako, vidite da ove izkazu, odato je tova linija, kod ovde ne proizvodi nikakav kod, a ni je potrebno izvršiti, samo sam ja sebi ježuriralo, da se tu nalazi C u mesto A. To je isto tu vrenost koja se nalazila, A, X, sada ima to nekakv ko C, a pošto je mrtvo njega sam samo tako smodnije iz drugi registra. Kadažemo dalje, opet još jedna situacija karakteristišna, C je jednako C plus B. Ako pogledamo prvi naš operant, i ovo ovde C i nalazi su registru, međutim bez obciara što je to C tu živo, to je spotrenana na njegova vrenost na dalje, bez obzirana na to, zbog toga što je C samo u ovom registru ovde A, X, ja smenem da koristim taj registar A, X i samo na njega da dodam B, zato što se radi ovoj situacij, gde je rezultat i prvi operant u zapravo jedna tista, jedna tista promenima. Ako da ovde će ovog getregi dalje reći A, X i potrebno je samo na ovom C koji se nalazi u registru A, X dodati B, a B se nalazi u tako registru B, X. Ako da ću samo reći, A, X, B, X, tako samo ih saderije. Znaozi se naozili u registru B, X i ovom tepočim iskazom mrtvo tako da možemo slobodno da go uplanimo i da ostavimo ovaj registar B, X gdje je ovde praza. Gledajte dalje i kaže se A je jednako C plus 1. Dakle, dalje se naš prvi operant nalazi nekdo u registru, nalazi su u registru A, X dalje je mrtva nije živije tako da ne smenem da koristim registara X, ne smem da bregazim tu vrednost. Međutim, imam jedan slobodan registar i nema jednost ovoga A, rečunati u ovom drugom registru, a to je registar B, X što je potrebno dovradim, pa da C dovučam prvu registar B, X odlično je po što se cjel tako nalazi veću registru tako da ćemo ga samo prepisati za X u B, X i sabraćemo ga sa 1. Dakle, move B, X, A, X da C upišam u B, X i zatim to B, X sberemo sa 1 i kažemo tu su sado nalazi A. Ovdje sad da i A i C se nalazi u registrima A, X i B, X u su, međutim, sve promeljive su žive tako da, šta sam reko moj savetje, naravno i ako to neforsir, ono je naš algoritm GATREC jeste da koristite registar kome se nalazi prvi operant A ono se nalazi u registru B, X tako da mi je mnogo jednostavnije da ovo A upišem u memoriju, tamo negde sad čuvam jednom instrukcijal i da onda slerećim instrukcijal samo do ovoga B, X oduzmem ovo C a kako bi ste gandali sad da šta bi se desalo kada biste do to uradili na primjeme uzimali registar A, X ja bih morao jednom instrukcijem da ovo C upišem samo negde u memoriju datim onda drugom instrukcijem da ovo A dovurčam u registar A, X pošto prvo se mora punacić prvi operant a tek onda trećem instrukcijem da oduzmem ovo C i to to C bih onda morao ponov do doblatim iz memorije tako da probajte kod kući sam i sad ovdje konkretno ovako na nekoj situaciji vidite šta bi ste desalo kada biste oslobazili registar A, X a šta bi ste desalo kada bi ste oslobazili registar B, X i narodno, poželjno bi bilo dugo koristit ovo što prizgodi manji instrukcije i manje pristupa memori onda sad kažem koristim registar B, X i to šta treba dovredimo dakle prvo pošto ću koristiti ovo A ovde, to jest pregazić u njegu uvrednost sa prvom uvrednost A na memorijsku lokaciju A upisam sad daža registar B, X a te konda treba odvredimo A-C dakle te konda od registra B, X od uzima registar A, X to je stvoretnost C dakle superi što mi se cijeliće na ozima nekom registru samo ću oduzeti i na kraju ovde zabeležimo da se sad tu na ozima promenljiva B na kraju basicno bloko je šedno kažem ne zaboravljate da sve te promenljile koje su žive koje se naozima registrima sačuvate isti ih registara na njihoj memorijsku lokaciji dataj mu v C, A, X i mu v B, B, X ako pogledajmo sad da kolika nam i ušte da ovdi u ove situacije bila gledajte samo koliko puta ste čitali ili uvisivali neke promenljive dakle imate u prvom iskos u jednom zatim ovde 3 puta, 3 puta 2, 3 2, 3, dakle u konu će biti 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 pristupa ovde promenljivima imate bilo začitanje, bilo zaupis dakle 17 puta smo pristupali memori da nije bilo optimizacija sa ovinom optimizacijima koja smo uveljali odve smo čitali C to je jedno ovde je še jednom čitali C to je 2, 3 puta ovde smo čitali u A to je 3 puta i ovdva uvistana kraja to je 5 dakle imamo 5 pristupa memori umjesta nekakvih 17 17 inicijom to je bilo zadatak broj 2 i što se tiče
 Ovo ove prikazaćemo samo još jedan zlada, kto je jedno ajde da kažem jedan dodatak, no, ove zlada koji možemo tražiti od vas na ispitu. A to je da, pored ovoj osnovnog teksta koji ove prvi pasu sozde za ove neki bazični blok, koji je prikazan desno, prikazete i vrednosti u registrijem i memorijstvim lokacijem otokom izvašavanja generisano koda u svakom trenutku treba da prikazete za svaku prameđevu koja je njeno vrednosti, koja je sadržaju stvari nekog registra, ukoliko su početne vrednosti ovih naših prameđevih date dola, to je da je a1 koj 1, d2, ac c, t os. Dakle, rajicu mi isto što je malo, pretp. ću mu uspud zapratimo još i koju vrednost koja prameđeva ima na kojoj lokaciji. Tako i tim zadatkom ćemo tako da završemo zadatak. Ode sad imate namerno tako ispretombanova i kod ovde, pa hajde da imamo šta se deša. Reklo sam u tako u tartu, prvo, za sve prameđeva za svaki iskaz, odredimo da li su živili mrtve, to smo videli već par, kuta kako se određuje. A, sad idemo redom i pratimo šta se, šta se tako, kako se generiši kod i koje vrednosti se nalazi u registriju. Ja sad odrdu u tartu kažemo registru i x u registru bx, upitnik neznam šta se u njima nalazi, a o memori prameđeva a, b i c imaju vrednost i 1, 2 i os. Idemo redom i šta se sad deša lohti. Kažemo a je a1 koj c-b. Ode sad pogledajte, nakle ovo još nismo imali ovak primjer ovdje, u tartu treba da odredimo a je 1 koj c-b. Ni c ni b ne imamo u registru. Tako da ovako, nekakvoj situaciji, šta će vratiti naravno algoritm getreg, pa vrati će, znako, prvi slobodan registr, a to će na primjer biti registr ax. Zatim ono je algoritm za generisanje koda, kaže da, ukoliko se prvi operamč, to je slovo c u ovom situaciji ovdje, ne nalazi u registru koji je vratio getreg, to je u registru ax, onda ga je potrebno tu dovući. To je srevo da dovućamo c u ovaj registru ax. Nećemo c dovućiti u registru ax, pa ga onda iz bx upisivat ću ax, nego ga direktno dovućemo iz ax u c. To je iz celu tako iz memorijskog vakacije c direktno dovućemo tako u ax. Vrednost c je 8, tako da vidite ovde sada moj registru ax ima vrednost 8. A zatim, izvašavamo operaciju, doduzmem ovo b i to ispo radimo direktno sa tom promenivom iz memorije, to je sub ax b. Dakle, oduzimamo tako vrednost b, vrednost b je 2, tako da kad oduzimamo do 8, 2 dobijamo ovde vrednost registra ax da je 6 i tu se sada naozi promenljiva a. I sad ćemo tako rednom pratiti dalje sada sada i dašamo sa ovim promenljivima ovdje i kako se generiše koto. Dakle, kažem u izko zuprevo je 2, b je jednako a plus b. Dali se a naozi već u registru, da, evo ga ovde, i sada ko bo gleda, to samo ovde promenljiva a, se naozi u registru ax i tu imam vrednost 6, a u memoriji njen na vrednosti 1. Dakle, ja tu vrednost nisam još uvek se čuvalo u memoriju, međutim, ovde što da se dješava promenljiva a je mrtva. Dakle, mene njen na vrednost ova tekuće, vrednost ovo 6. Nije ni potrebno, ja ovamo ne moram da sačuvam u memoriju ovamo, dopišam u mestu 1, 6 zašto, doko što će vreću iskazu 3 promenljiva a dobiti nekako novu vrednost. I koja je onda povijent o toga, da je ovu 6-icu upisam u memoriju, ako ona već na kono toga iskazu dobija nekako novu vrednost od tako menja vrednosti svoj. Dakle, onda kažemo, poštu se a nalazi u registro AX i poštu a mrtvo, ja to A, smjenim da pregazim tu slobodno i smjenim da koristim registra AX tako da će getreg bratiti AX, A, ovo B ću dobiti tako što ću A sabrati sa B. I to ću sabrati sa B direktno iz memorije, to je s ovom dvojkom moradu i onda dobijemo šta. Ako koristim registra AX kažemo samo na AX, saberi B i dobijemo da je AX i onda je AX jednako 8. Dakle, imalo je vrednost 6, 0 sabrali smo sa 2, dobiljemo tako vrednost 8 i tu se sada na ozi promenljiva B. U memoriji i dalje promenljiva B, imam vrednost 2. Dakle, tamo nismo ništa menjali. Kajemo sada dalje u iskaz broj 3, kaže, A je jednako C minus B. Dali se C je na ozi u nekom registru? Ne. Znači šta će nam vratiti ovaj getreg pa svoj slobodna registra BX vrati će nam registra BX. Ono što je potrebno da uradim je ste da prvo C dovučemo taj registra BX i toga doblat ćemo iz memorije a zatim treba da oduzmem ovo B B se nalazi u registru AX. Dakle, da tu idu instrukcije prvo da se BX dovuče C a zatim od registra BX oduzmemo AX, to je oduzmemo ovo C minus B. U registru BX se nalazi promenljiva A. Dakle smo dobili njen u vrednost koja sada ovde vidite 0, tako što smo od ovoga 8 tako oduzeli To je izinjavam se od vrednosti C što je 8 oduzeli sadaža registra AX to je ovo 8 ovde 8 da je 0. U ovom izkazu ovde samo obratimo pažnju još ovo B je mrtvo, tako da to B ćemo sploniti iz registra AX nema potrebe da upisujemo tu vrednostu tako u memoriju zato što B dobia već na ovog vrednostu ovom sveću miskaju izkazu vbred četir to je bilo je mrtvo ovde nije bilo potrebno uvati njegovo vrednost. Idemo dalje kažemo sada B je jednako A-C to je ona podlična tako ona naša idejoma situacija da se ovo i naš prvi operant već nalazi u registru i da je taj naš prvi operant mrtvo to je posnotana linii kova da i da je jedini koji se nalazi u registru BX tako da smijem da koristim u registar BX i samo ću tog registra BX oduzeti C tako da vrednosti registra BX i srbno to nula, A ima vrednosti nula oduzimamo vrednost C a da je vrednost A-C a da je vrednost A-C a pošto je mrtvo njega smo stlonili iz registra BX i tu se sada nalazi B i samo smo tako izgenerizali ode da se odstop BX oduznet C gledajte dalje kažemo ovde A je jednako B-C B se nalazi u registru BX međutim B nam je živo kao što vidimo, odi ima sledeću u potrebu izgazu brove 6 tako da moramo da koristimo slobodan registar slobodan registar AX tako da get registra BX vratiti AX potrebno da prvi operant dovučamo u to AX ajde prikažemo to odma tako da koristimo registar AX potrebno da prvi operant dovučamo u registar AX što radimo move AX BX instruksijom a zatim treba da oduzmem C opet kažem direktno iz memoria oduzima sub AX-T i ovde zabijevo sve značim da se u registru AX a kako smo dobili vrednost ovoga prekli smo B-C dakle prvo smo ovo minus 8 prepisali u registar AX i tu je pisalo minus 8 a zatim kažemo minus C oduzimamo još jednu ovu osmisu tako da de minus 8-8 da će vrednost minus 5 gledamo dalje kažemo ovde C je jednako A plus B dali A imamo nekom registru a da se nam da pregazi njegovo vrednost i dalje ovu vrednost sad da minus 16 ja neću opisivati u memorji dok što kažem A je mrtvo dobiti neko po svoju novu vrednost liskam zubro i 7 nema potrebe da je ovo upisam u memorji dakle po šta se dešala getreg će nam ratiti AX tu će se sad naoziti u tako vrednostu ovoga C pregazit će vrednost ovoga A a kako će se izrpunati pa ta vrednost A koja je bilo tu treba da se sbere sa vrednostu ovoga B o B se naozili u registru BX i ona minus 16 sam sabrao sa minus 8 i dobio u svariji vrednost minus 24 i zna kaj je ovo posledne posledne izgaz nam kažem A je jednako C minus B ovo je ona situacija od avu kada imamo i C i B u registrima međutim obje promeljive sušive tako da ne smemo da i pregazimo preko sam moji savjet preporuka da ovi prvi operant ove da mogu da se naozili naozili se u registru AX i da onda taj registr tu koristimo a to je da onda uvradi moj prvo da nam getreg vrati AX i da sačuvalo u vrednost ovoga C iz registra AX i ovo je sada prva situacija to je s prvi trenutak u celom ovoj našem bazičnom vlogu da ćemo mi nešto zapravo pisati u memoriju ovdje ćemo sada iz registra AX upisati njegova u vrednost na memoriju s lokaciju C ili to ovdje ćemo sada ovsako pisati u vrednost 24 to je minus 24 ako smo sačuvali C sada smem da pregazimo tako vrednost o registra AX zato što imamo sačuvano to C naravno to C ćeći u obrisati iz registra AX i samo od njega oduzmem o tako ovu B oduzmem o tako registra BX i onda će biti minus 24 minus minus 8 i je dativ u stvari minus 6 dakle dodajemo samo istrukciju sub AX BX i tu se sada naozili promeljiva A ako pogledajte došli smo do kraja bazičnom vloga što nam se naozili u registrima u registra AX i BX se naozili promeljiva A i B i on je tu imaju vrednosti minus 16 i minus 8 međutim u memori on imaju vrednost 1 i 2 pošto ja ne znam na kraju bazičnom vloga šta će se desiti sa tim promeljivi da li će ih neko pregaziti prene košne i dodali neke nove vrednosti zbog toga al tako smo rekli da obacujemo na kraju bazičnom vloga instrukcije koji ima čuvamo vrednosti AX i BX u ljihove memorijske lokacije to je u memorijsku lokaciji u promeljive A i u registra AX to je minus 16 al u memorijsku lokaciji u promeljive B treba da upišemo ovo minus 8 tako da dobijemo minus 16 i minus 8 tek na kraju u memori to bi bilo ta tri zadatka i to bi bilo sve što su tiče ove naše današnje teme a to je bilo to generisanje kode za X86 procesu ili imate možda neko pitanje sada ovde ja kažem da krajalo trajalo malo kraće da odredimo tako celog oblasti još jednu koja nam je ostala da ćemo to ostaviti za još jedan čas ja predlažem da taj čas bude sveći četvrtak ako imate nešto protivog koji se neki drugi termis lobodno mi se jari
 Za sljegi četvrtak nam onda ostaje još da odradimo to nekako izvešno okruženje, imaćemo još tu nekako malo generistanje koda i to bi onda bilo sa tim kasom još jednim veš što je predstavlja gradimo u ovog našeg kursa. Ajde, ako imate još neko pitanje, ako ne, time ćemo onda završiti za danas. Dobro, ako ono nešto bude trebalo, kažem, slobodno pišite, vidimo se onda ako neće pa ne budete imali proti u sljegi četvrtak. Kažem za taj projekt izbatićemo u te neki iznene i nisam da vidimo se u sljegi četvrtak. Pozir si.
