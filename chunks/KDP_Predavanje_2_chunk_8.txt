 Kaš memoriju morate da se upiš. Tako da to što smo mi stavili jedno istrukciju, to će svaki put raditi synchronizaciju kaš memorija, ubilj smo malo performance. To se možda ne vidi na prvi proglat. Ali svaki put kada upišete u neku deljenu promenjivu, a vi u suštini morate da odradite synchronizaciju kaš memorija. Sa treba se setiti. Architektura računara, Snoopy Controller. Eee, Snoopy Controller ovde mora sad svaki put da reaguj. Jedan upiše u drugi čili da in 2 lidira ili da upiše tu vrednost koja dolaz. I to svaki put, ovo je zaposleno čekanje. Upiši, upiši, upiši, ne samo to. Nego šta mi radimo ovdje da ponovno? Upišu i vrednost, upišu i vrednost, upišu i vrednost. Bilo trubu, upišemo vrednost trubu i okupiramo magistralu dosta dugo. Ovo je ovde naše rešenje. Radi jednostavno je, ali ima nekoliko nedostataka. A prilikom stalog upisa mi stalu, ukupiramo magistralu pa nedamo drugim procesima da izveću na magistralu. A moramo stalo da radimo synchronizaciju kaš memorija. Tako da ovakvo rešenje i ako radi, nedaje najbolje rezultate. Pa s onda ljudi reklji, ajde da promo da modifikujemo ovo rešenje. Ne želimo, baš svaki pud da upišemo vrednost. Ovo ovde našu promenivu lok, a nego samo ako smo videli operacijom čitanja, da je ta promeniva postala false. Da nikon ne koristi kritičnu sekciju. Tako da ću vi sada ovdje imati dve petlje. U jednoj petli ćemo se vratiti, dok le godje ova promeniva jednaka false. Jednaka trudu dok nekog koristi čim postane jednaka false. Mi odradimo test and set pa probamo da smo mi dobili. Ako smo dobili super, ako nismo dobili, njeg koji je uspio da nas pretekne. Pa ćemo morati da se vratimo našu petlje od uzgore. I to rešenje se onda naziva test and test and set. Ovo rešenje ima za cilj, znatno majnje prljanje performansi cash memoria. Ne želimo svaki put da upisujemo. Šta sam ja rekao kako izgleda naše rešenja, idemo da bonovim? While lock. Skip. Do klje lock ima vrednost true, neko je zaključao. A čim je to postalo false, a mi ćemo da kažemo lock. Test and set lock. Mi smo upisali vrednost, ali mi ne znamo, da li smo uspili da budemo prvi proces koja to odradio. Ako smo uspili, zato što smo bili prvi proces, rezultat saro lock imati vrednost false i mi ćemo preskočiti o while. Ali ako se to nije desilo, onda ćemo ući u ovu ovde u nutrašnju petlju i kažem, opet ja moram da čekam. Dok lego od lock ne postane jedno ko false. Čim lock postane false, ja ću da probam da upisam kao prvi. Tu vrednost, ako ja ću mi probati, nekaj nije garantovanu da ću ja uspiti. Zbog toga ovdje moramo da stavimo while. A kad pravite rešenje, nemojte sam mozavljati ovu ovde while, lock, skip i onda prvi darin je red test and set lock. I mislite odradili ste poslo, to je to, nema dalje. Ne znamo da je to ispravno rešenje, jer je moglo da se desi nakon našeg while'a, a pre našeg test and set da uleti neki drugi program, neka druga instrukcija i da se to sve promeni. Tako da o tome treba voditi računa. Šta smo odradili, šta smo promenili odnosno prošli put? Znatno smo redukovali broj upisa u cash memory. Mi sada u cash memory upisujemo samo ako je predkodno bilo jednako false, upisemo v jednom vrednost true i onda ponov očekamo dok ne godne postane vrednost false. Znači nije kao malo prošli put. True, true, true, true, true. Znači samo popunjavamo za, znači zakrčili smo magistralu, upisom iste vrednosti i još moramo da synchronizujemo sve ove naše cash memory. Ubilismo performancje. A nismo dobili nikakva značen efekt. Ovo rešenje znatno bolje. Znatno smo smanjili broj tih upisa, gdje da njedniput samo to promenimo, to je jednom po promeni vrednosti sa true na false. Kada se to desi, onda ćemo i mi da odradimo postao. Nakazam, e sad smo mi okupirali, ako smo mi prvi super završili, smo nećemo više, ako nismo bili prvi, onda se ponovraćemo i čekamo. Znatno je bolje ovo ovde rešenje koji se naziva test and test and set, u odnosu na ono prethodno rešenje. I ako je kod malo komplikovanje, znači tamo su imali jedno vile i to je to, ovdje imamo 3 vile, no suštiri moš se napiši sa 2 vile, ali ovde napisano sa 3. Dobro. Ovo je bio prvi uslovni synchronizacijan algritom ko smo mi radi. Ovo je algritom, je zahtevao, jednu specijalnu instrukciju, to je bilo specijalna instrukcija test and set. Dali ta instrukcija postoje na svakom računaru, odgori ne, ne postoje na svakom računaru, ali postoje dosta tih instrukcija koje mogu da nam omoguće synchronizaciju. Jedno takvih instrukcija je swap, usko ćemo videti kako izgleda swap, ali to veratno mi sami moš te zamislite. Šta radi swap? Zameni dve promenjive, atomski, zameni. Znači imate vrednosti u dva registra, nekoli dve memorske lokacije, atomski se to zameni. Nikod drugi nije mogu ništa da menja, znači samo zameni te dve stvari, i to je jedno od prvih, stvari koje napravdje nam pomoću toga možemo da simuliramo ponašanje ovog test and set instrukcija. Sada hoćemo da vidimo nekoliko bitnih synchronizaciju njiha algritama. To će biti Petersonov algoritm, vidićemo Bakerie algoritm, vidićemo Ticket algoritm, vidićemo Andersonov algoritm i CLH algoritm i neke njihoje variante koje takođe imaju svoje imena. I kred ćemo sa prvim synchronizacijem algoritm, to je Tai Beraker ili Petersonov algoritm. On je nastava nekih od dek 80-i godina. To sada će ima 40, schora 40 godina, ako nastava algoritma. Ideja koji je ovdje algoritma, je da ne moramo da koristimo bilo koju specijalnu instrukciju. Hoćemo da koristimo ovako nešto na bilo kakvom procesoru. Ako nam ovini računaru nisu dalje ni jednu specijalnu instrukciju, mi kažemo, hvala, možemo i bestok. Alcilia algoritma je da synchronizuje veći broj procesa, čak i ako nisu dostupne nekih specijalne instrukcija, da prvimo da naprejmo mi sami tu synchronizaciju. Ideje krenućemo, krenućemo, kred ćemo ponov od onoga što smo već imali. Vamo dve promedljive. To su IN1, IN2. I ono što smo maloče srekli. Što smo rekli za ovu ovde čude, zašto beši ne radi. IN2 je skip in 1, 1, 2. I ovogo ovde drugog reda, while in 1, skip in 2, 1, 2. Zašto beši ovo ovde ne radi, što smo rekli? Može se desiti da se proces 1 izvrši ove prvi red, proviri kuji vrednost ima IN2, IN2 ima vrednost true, false iznijemo se, tako da on može da pređe na sledaciji red, ali zamistimo da ga tu zaustavi skeržuvar. Pošto nemao predstave kako se skeržuvar ponaša i kada će neki proces biti zaustavljen, i koliko je vam poslao radi u nekom trutku. Verovatno će su ono 1000 izvršavanje 10 da radi sve kako treba, a u 1000, u prvo, da se desi da to nerati. Jedno od anegdote bila za nekod ovih firmi, a imali su neki kod koji je savršilo radi o nekih 15 godina, ono su nabavili boljiz server i izaključilo se da taj program nerati. Zato što su brzine bila takve, a odnosno synchronizacija hardware upozadini je bila takva, da to se lepo radi, ako je tako učešljavanje, a uvek se desilo tako učešljavanje, jer i neko je zgrovaljilo imalo veći prioritet u odnosu na drugo, i to se se se li lepo radi, i onda u nekom trutku samo cestiv sistem prestav da radi, jer su daba bili boržu mašinu, od koja se to više nije primitivaho. Rekli smo, ovo ovde rješeninje neradi, zato što se može desiti da dva procesa uću kritičnu sekciju. Prvi, proveri uslov za ustavi ga scheduler, preligu što postavi in 1, a drugi proces, sad može dodađiti celo poslo, proveri in 1, in 1 ko false, in 2, in 1 ko true, ok, taj je ušu kritičnu sekciju, ovog odblakira scheduler i ono uću kritičnu sekciju. Da, to nije rješenje. E, onda su ljudi reakli slijecu stvar. Hajde da modifikujemo naš program, tako što ćemo por dove promenjive in 1, da je kažemo da smo ušli u kritičnu sekciju i da ubacimo još jednu promenjivu. Ovo ovde promenjiva last, je promenjiva koja kaže, koji je poslednji došao do ispitivanja uslova. Ako ja tu upišem svoje ID, ja sam rekao, ja sam poslednji došao.