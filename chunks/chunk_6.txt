 u okviru hex file. Druga bitna komanda u okviru ljikerske scripte jeste komanda kojem se definišu memorijski regione. Ta komanda se naziva memory i u okviru nije je moguće definisati memorijski regione koja ima onda možemo baratati iz ove komande sections. Syntaksa ove komande krajnje jednostavna. Možemo videti to u okviru dokumentacije. Evo je komanda memory. Dakle neopodnenaivesti ime regiona, zatim atribute njegove. Mesto dakle počinje i koliko je veliki taj region. U sladu sa tim mi ćemo onda ode definisati neka proizvoljana region čisto da bi smo videli kako se to radi. Nekada to bude region prvi. Njegove atributi neka budu read, write i execute. Početak neka bude isti koji je bio do sada za u izlaznu sekciju prva. Možemo ove da iskoristimo i neka dužina bude na primer 32 kilo. Sada ovaj region prvi možemo da iskoristimo da kažemo da neka izlaznu sekcija treba da se smesti. Umešto da ode kažemo eksplicitno odresu, ovo možemo da sklonimo a možemo da iskoristimo ovaj region tako što ćemo reći da čitava ove izlaznu sekcija. Dakle sve ovo što se nalazi levo u odnosu ovaj znak veći treba da se smesti u region prvi. Ovi ćemo dobiti isti izlazni HEX file, jer je ode ista adresa, ali mogu smo i to da promenimo na primer da bude EE00, pa da vidimo onda da se u tom slučiu ako sada prvo pozovemo linker, pa pozovemo obaj koji vide ćemo da se sada ova prva izlazda sekcija nalazi na adresi EE00. Regioni su koristni zbog toga što ako želimo da više stvari ide u neki region jedno za drugom, ne moramo da znamo da se predkona sekcija izlazna završila već će to linker uraditi za nas. Prvo navedemo ide u neka region, to će se prvo smeseti u region neka narana sekcija za koji kažem ide u isti region, ona će ići odma nakon mesta gde se završila predhodna izlazna sekcija koja išla u isti tej memorijski region. Porad ovoga u linkerskoj skripti možemo još neke stvari i raditi. Mi smo odovideli, ne mora jedan tip sekcija da ide u jednu izlaznu, može da bude više njih. Ono što još možemo da radimo, možemo da sami umet ćemo neka ka v sadrže, na primer kažemo da želimo 1 byte čija je na primer vrednost 0xff da se umetne u okviru ove izlazne sekcije prva. Dakle, ove sada je počinje sa 8.0 i tako dalje. Mi smo sad ispred svega toga umetnuli 1 byte čija je vrednost ff 0.0 ako bi smo sad opet izvršili povezivanje i pravljenje objektnog obaj je kopijem pravili izlazni hex file. Vide ćemo da se ove sada nalazi prvo ff. Ovo ovde što je umetnute 0 to je da bi se postihlo poravnanje koje linker sve stan da mora da napravi izbog nastavka stvari koje slede izato je ova tekst sekcija. Ono što možemo da radimo možemo i mi sami da pomeramo prostor ili trenutni location counter u okviru te sekcije. Location counter se inac označava sa tačkom. Tako da ako kažemo trenutna lokacija koje je inac ozala u ovom trenutku jer se nalazimo na početku te sekcije. Možemo da pomerimo naravno 0 u odnosu na adresu da je će čitava sekcija biti smestena. To je u ovom konkretnom slučaju E00. Mi sam možemo kažemo tu adresu 0 plus E00. Čemo da pomerimo za nekih naprimer 5 lokacija. Dakle trenutni location counter je trenutni location counter plus 5. I ono što ćemo sad imati jeste. Čemo prvo imati 5 0. Evo su prva, druga, treća, četrta, peta. Pa on nih naših FF. Pa onda opet do poravnanja odgovarajućeg imamo pomeresovi možemo ove 0. Moguće da mi sami tražimo poravnanje da odi izakražemo da je tekući location counter jednako aline pa na neku vrenosna primjer aline na 16 prosto da dobimo poravnanje na adresu koja je deliva sa 16. Ono što ćemo sad imati jeste prelazak u novi red. Nakon ovog ovdje mesta FF tražili smo da se izvrši poravnanje na adresu delivu sa 16. Onda će čita ove red biti popunjen pa evo ga 80 koj smo preimali na samom početku. Moguće dodavati nekakve druge sadreže, možemo ove da kažemo long što je četiri. Baita na primer 0x01234567 da stajemo i tako nekako u proizvoljnu vrednost. Nakon ove vrednost koji smo tamo tražili samo u little and then format usmještanje. Nakon najnižoj adresi nalazi se byte najmanje težine ove najniža adresa pošto ovaj idena adresu e e 0 0, ovaj idena e e 0 1, e e 0 2 i tako dalje. Ove najniža adresa i to je byte kao što vidimo najmanje težine. Poslenja stvar u ovaj lekciji ali svakako najmanje bitna jeste koncept load memory adrese i virtual memory adrese. Da je ovo virtual nema nikakoveze sa mehanizmom virtualizacije već su ovo koncepti koji važe samo za linker. Dakle, load adresa i virtualna adresa. Ove koncept ćemo najbolje savladati na jednostavnom primjeru pa ćemo zato sami iskucati jedan izvorni assemblerski kod. Ima ćemo jednu sekciju koji ćemo nazvati data.pn. podaci i u ovaj sekcij ćemo imati jedan podatak, jednu reč, četiri byte, čije će vredno zbiti trenutni location counter. Dakle, ova tačka je u suštini location counter, counter ove samo komentar koji govori šta tačka prestalja. Dakle, na početku sekcije koje se naziva tačka data, tačka podaci, naći će se 32 bita čija je vrednost i jednaka adresi na koju se sam taj podatak i nalazi. I ovde ćemo završiti tu sekciju. Dodat ćemo još jednu sekciju koja se tiče nekakog koda, na primjerneh se zove sekcija tačka text tačka kod i u okviru nije ćemo imati instrukciju koja vrši čitanje učitavanje u register r0 i ono što učitava jeste adresa ovog podatka. Dakle, ode se zahtevamo sa ovim jednako, zahtevamo da dobijemo adresu ovog simbola podatak a onda ćemo zatim sa te adrese koje učitana u r0 pročitati sadrže i u r0 onda opet učitati istu vrednost samo sada ono što se zaista nalazi na toj adresi. Ovo ćemo onda nazovemo lmaa.s od loadMemoryAddress i sada ćemo napisati i jednostanulinkersku scriptu za prevođenji ovog lmaa.s filea. Ta scripta neka bude opet, dakle, direktivno, commandat sections u njoj ćemo imati nekakog izlaznu sekciju koja se naziva program i u to izlaznu sekciju neka budu sve sekcije koje počinju sa tekst a u ovaj drugoj izlaznu sekciju u koje su padaci neka...