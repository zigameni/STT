 i kako izgleda komunikacija. Znači to je ovo našem uprošljenjog vida kljencervoj i archipikture potpuno sakriveno od našeg programmera. Programer pojma nema što zove. Programer kada pozoveme todu patch. Programer ne zna, je to lokalno ili je to negde u Kini. Zanima. Isto to je bilo reči kada smo razmatriljili. Programer pozove ne zanima ga gde se to navazi. To radi. A programski jezik odnosto bi bilo teka, će odraditi kreiranje toga. Kako će odraditi neki posao za nastavno. Ako da vidite, nije loše da pospoje te raznorazni oprači, jer mogu dosta da olačaju programirani. Kod ovog najčišćeg načina programiranja to je kljen server archipikt. Onih kompleksnih načina programiranja koji pospoje u sestemu gde treba da se radi neka mnogo kompleksni obada nije pošli. Njego samo na neki mes nije pošli u krijenu. Jer šta je problem ovde sa krijenim servera? Problem je što ono i što je slovo se zablokiralo, on je ni mora da sarči kodgone. Ništa nije mogu drugu da radi u paraleli. Koji poziva ovde sa ol, on je zablokirat do plegodne dobi odgone. Ja simpno na koniciji gde mi možemo da sigram. Ha, sada ću da pošli u tom i tom. Pa ću onda ja doda da prijem pooreku od nekih drugih. Či nije način komunikacije koji smo imali. Kada smo razmatili o ne interagujicetvorove, o neki interagujicet elemente ili kada smo razmatili u kljen prstik. Ovo ovde je nešto što odgovara kljen server archipikt. I ovdje smo mi završili o sestini taj koncert randevula. Sa ćemo napraviti pause. Posto pause ćemo viditi joši jedan koncert, poslini koncert ovde premi. To je koncept koji se naziva randevula. Paoza. Paoza. Paoza. Paoza. Paoza. Paoza. Paoza. Paoza. Paoza. Dobar dan, dobrodošlo i na predavanje na predmetu konkurentno i distribuirano programiranje. Ovo danas je poslini časa u randevoj. Kako, da ješi jedan način od programera sa krijemo, kako izgleda serverska strana naša aplikacije. A želimo da napravimo i dalje isti poziv kao što smo imali i pre. Znači što se naš klienta tice, naš korisnik koji će ovo koristiti, pojima nema. Dali se to izvršava koji njega na računaru ili se izvršava negde drugde. Opet je ideja, hajde mi da sakrijemo, hajde mi da napravimo neku infrastrukturu, ovdje koji to prave, koji će to sve da zamaskira, tako da koristik ima osjećaj da koristi najobičniju funkciju kao i pre što je koristio. Če koćemo da vidimo, da li postoji neka infrastrukturna komponenta koja nam to omogućava i ovo je druga infrastrukturna komponenta, odnosno drugi infrastrukturni način kako to može da se realizujem. Prvi infrastrukturni način je bio koristici rapacar. Konkretni implementaciju rapacar ste videli u programeskom jaziku java. Korisnik dobije objekat, ovdje nema pojma, da li je to pravi objekat ko me pristupa ili je to proksij objekat, preko koga pristupa i preko koga se pozivar nip na srvenskoj strani. Korisnik to ne zna, nekoj odradio povezivanje, nekoj odradio upisivanje u registrar, kako je to napravljeno korisnika u sustinii, to nezanima. I ovde ista stvar, korisnika nezanima kako će se neki deša raditi. Koćemo da naš korisnik, kako to ste koristi, ima potpuno nesvestno ponašanje da to ne znači. Oćemo da vidimo. A gde je to? Ovo ovde slučnji će to biti na srvenskoj strani, opet, da možete što će malo drugačije da se realizujem. Korisnik tiče njemu isto, odnosno proksij objekat. Proksij objekat šaljen. Ja, pa su u štrištini predstavi. Zovem sledću funkciju, pa kaže kako se zove funkcija. Šaljem argumenta. Isto, kao što smo mi realizowali u sustini našu srvensku stranu sa više aplikacije, sa više funkcija, kada smo pravili naš aktivni monitor. I sad koćemo da vidimo, dali postoji i neki drugi način, očin, aktivni monitor koji smo videli. Gde može taj posoda sodati? Posloj, no, ma ovde srvenskom racunaru B koje je pozvani, i racunar moramo oprecedivimo deklaraciju. Isto, ono što smo imali maločas kod rma i, odnosno, rapac, moramo da kažemo šta mi od zahtiva koji dolaze s polja primamo, šta prihvatamo. To moramo da kažemo ostatku sveta i ostatak sveta će to na neki način moći da koristi. A nakon toga, unutar postojećeg procesa, radimo prijem poruke i se što se odnosi na datu poruku. Aha, način, sad sam sada rekao, na srvenskoj strane, unutar main-nit ćemo imati u svestini ovako jednu sekciju in i ni. Ovo ovde ni u svestini kaže kraju onog ugore in block. El mora takvati opisuje, a ne mora to zavisit konkretnog programstvog jezika. Ali ima sad jedna bitnost vara. A ovo ovde je block. Ni primili poruku i tu sad nešto radimo i kad dođemo novo, ni tu vraćemo odgovor ovoj drugoj strani. A, šta je tu problem? A ovo se malo razlikove u odnosu na koncept aktivnih monitora koji smo imali sad. Znači, aktivnih monitori su i nama, išto radili posto koje je ovde. Trebali su da sakriju klient server architekturu. Znači, koćemo da sakrijemo klient server architekturu ako to nekako moguće. A to smo mogli da radimo koristiti čim. Udo što smo videli do sada. A to smo videli do sada su bili aktivnih monitori. Ili, rapaca, ovoj treći način gde imamo in, primim poruku, ali onda imam jedan block, ja samo u ovom dosegu moram da odradim način ne mogu ja sad tu poruku nekako da bufferujem, pa ću za pola sada da odradim nešto s tom porukom, da izvučam iz nekog drugog buffera, pa onda da odgolarim. To ovde u sestini ne radi tako. Šta mi hoćemo da odradimo? Ponovno je še jednom, a što se klient ske strane tiče, treba da se ponaša kao običan poziv procedure. Ali, ta procedura se mozda izvršava na datom računaru, ali se mozda izvršava na nekom dražu. Ozi, s klient ske strane izgleda identično kao kod rapaca, u sestini izgleda, pa da kažemo identično kao kod aktivnog monitora, samo što kod aktivnog monitora, su mi u sestini očekivali da koristnik prepakuje one argumente i da on kaže, ovo ovde je server, ovo ovde je functija, ovo sam ja, da moglo to sve da funkcioni. Ovo je to malo, kažem, saklivenije. Ne pokreće se nova nit. Ono što je bitno, znači niti nova proces, niti nova nit, cel posao na serveriske strane se izvršava unutar jedne nit. Ovo ovde je velika sličnost sa onim, što smo zvali do sada aktivni monitor, ali to što se sličnosti tiče. Ostatak ćemo mi morati malo drugačije sami da realizem. Ovo što mi ovdje imamo, mi ćemo praviti komunikacije i synchronizacije, samostopet i jedno malo napomenam. A postoji jedna nit na serveru. Ako postoji jedna nit na serveru, nema synchronizacije. Na serveriske strane kao malo če što smo imali kod ramija. Rpoca. Tamo smo morali da stavljamo sema kore. Ovde synchronizacije nema. Zašto nema synchronizacije na serveriske strane? A zato što postoji jedna nit, na serveriske strane? Na serveriske strane, ni ćemo morati da synchronizamo zaktive od krivena, tako i dolaze. A to ćemo morati da synchronizamo. Ali, nećemo morati da synchronizujemo u jednu, jedinu nit samu sa sobom, zato što jednanice sa sobom ne synchronizuje. A tačno u kom stanju se nalazi. I radimo na serveriske strane sekvencijno ob...