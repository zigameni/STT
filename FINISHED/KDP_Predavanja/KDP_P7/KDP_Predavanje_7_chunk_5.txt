 To bi mogli da kažemo full.ignal. Šta radi ovaj ovdje get? Verovatno kontra. If. A, ne znam je if ili while. A razmislit ću meš malo kad budem imali kompletan kod. If. Size 1 konula. A to znači prazanje buffer. Moramo da čekamo da se nešto tu pojavi. Full. Wait. Kada se tu nešto pojavilo, mi ćemo u neki rezultat. T, T, jednako data. Od rir. Rir jednako. Rir plus 1. Po modulu n. Size minus minus. I ovde treba da kažemo obavesti u njog drugu stranu. Empty.ignal. To miši koje to to. A sad ovdje sve treba da inicializujemo. Front. I jednako rir i jednako size. I jednako nula. I data je jednako. E od n. Sada još proveramo, dali nam je potrebno wait ili nam je potrebno while ili potrebno if. Ako imamo disciplinu signalem continuum, on ne i što bude. Kajaže signal. On ne i što se bude. Ide u entry queue. Tako da kada se taj bude provudio. To što je ovaj ubacio nešto u buffer. Ne znači da ću u trenutku kada se taj neko bude provudio biti iček u bufferu. Tako da za disciplinu signal end continuum. A ovde mora da stoji while. Sa te strane stoji while i sa ovde ove treba da stoji while. Onaj što čeka će morati ponuo da proviri uslov. Jer od trenutka kada je taj neko bio probuđen. Do trenutka kada je taj neko došao na red. Može proći ne zanimarlivo mnogo vremena. I u to ne zanimarlivo mnogo vremena neko drugi može da uđe i da pristupi datim promenjav. Dobro što smo mi ovde napravili. Napravili smo naše rešenje koje radi za disciplinu signal end continuum. Dali ovo ovde rešenje radi za disciplinu signal end weight. U suštini ovde rešenje radi za disciplinu signal end weight. A ako ima while to što smo mi stavili da se još jednom proviri uslov. Kje malo smo usporili naš program. On će još jednom proviriti uslov. Ali se uslovo trenutka kada nas je neko provudio. Do trenutka kada smo mi probuđeni i nije promenjio. Tako da i u nošto smo maloče simuli napisanu. Gde je stajalo samo F bi radilo za slučaj da imamo disciplinu koja se zove signal end weight. Mi smo na ove način razrešili naš problem proizvođača i potrošača. Vidite ćemo da ovo ovde može malo da se sredi. Dali možemo da primijenimo istu teknika u kojoj maločas. On je pasajnj decondition. I vidite ćemo da možete da se modifikuje. A koristit će neku dodatnu tekniku. Dali možete imati nekih pitanja koji se odnose na ovo što smo do sada radili? Ako ne mati pitanja pao za. Dovardanjuš jednom. Dobro došli na predavanje na predmetu konkurentno i distribuirano programiranje. Na predhodnom času smo razrešili problem proizvođača i potrošača. Koristiti buffer konačnog kapaciteta. A nismo koristili tehniku prostativanja u slova. Jer je kot problema proizvođača i potrošača možda malo teže da se iskoristili data tehnika. Primer kada neku želite da dohvatite podatak iz buffera. Kada neku želite da dohvatite podatak iz buffera. Njemu je potreban sam taj podatak. Ovo je te lokalna promenjiva. Da imamo tu ješ jedan red. Potrebno te lokalna promenjiva tako da ovaj što bude. Kada tu ovaj što bude. Kada tu odradi signalačnijeku bi mogu da pita. If full touch q ako neko postoji pa da proba da reprodu koje ovaj ovde posao. To će viš biti mali problem za reprodukciju. Toko tu jer. Ne možemo da upišem u lokalnu promenju. Možda bi smo mogli da napremu neku listu. Da bi neko pokol Beku stavio odnosno po referenci. Stavio lokalnu promenju u kojoj treba popuniti. Ali to nije ćemo raditi. Ili bi napremljeno dva buffera ili više buffera nego što je tu ima. Što onda nije isprenu rješenje. Nije buffer kapaciteta n. Negobi to posto buffer kapaciteta 2n ili 3n. Ne bih ovšte bio ovaj naš problem koji mi rešavam. Zbog toga. Ovo ovde rješenje se malo teže prebacuje na tehniku prsledjivanja uslova. Teknika prsledjivanja uslova je ona i što bude. I ovdje je rečuna o onom je ko treba da se probuti. Ajde da probamo da napišemo rješenje za problem čitalaca i pisaca. Kuristići, ajde da probamo, napišemo kuristići monitor. Koji imaju disciplinu signal and bait ili signal and continuum. Svaj sem sve jedno. I da vidimo da li može da to može da se razreši. Kuristići onu tehniku koji smo imali prošli put. A to je tehnika prsledjivanja uslova. Prvo ćemo razrešiti problem, kuristići disciplinu koja se naziva signal and continuum. Šta nam treba? Znači imamo četri metode koje potrebno implementirati. To su start read and read, start write i end write. I omora četri. Nemora. Znači može i drugačije to da bude realizovano. Može bude realizovano na primer sa tri metode. Jedan od primera tog se tri metode je bilo metoda prva. Lock shared, lock exclusive, što bi odgovarilo start read i start write. I postoji samo jedna metoda koji se zove unlock. Odključaj ono što sam ja zaključao. Kako znam šta je neko zaključao? Vrlo jednostavno. Ako je broj pisaca koji su pisali već od nule. To znači da je metoda koji mi u svar izželimo da pozovemo end write. Ako je broj čitalaca već od nule, znamo da je metoda koji neko želimo da pozove end read. Tako da mi možemo ovo ovde sve da razrišimo i samo sa tri metode. Lock exclusive, lock shared i unlock. Ako uzmete da gledate te monitore koji rade problem čitalaca i pisaca, oni često imaju još jednu metodu koja se zove upgrade lock. To značimo sam shared, deljeni lock. Značimo sam pravo da radimo operaciju čitanja, ali mi sada iz nekoga razloga padna na pametu, oči da radimo operaciju pisajom. Oči hoću da povećam sebi prioritet ako je to moguće. I to su četiri metode koje možete da možete drugarčije četiri metode, nači kod monitora koji rade ovo ovde sličnu stvar. Pa ona samo treba smistiti, ako to napraviti. Ajde, vidimo, start read. Kada ja imam pravo da čitam. Ja ću sada pisem, rekli smo, signal and continue staviti opet ono while. One uslove, while count double v cio nule. Aha, nači treba će mi ovde promenjive. Int cnr i cnr double v. Možete doda biti potrebno još neka promenjiva, videte ćemo. Ako je broj pisaca već od nule. Čemo. Okej.