 Nije da sam javati što sad i na jedno mesto stavio ili obznanio nekako da svi to mogu da vide... Ne, nego je ovdje naš proces mora od ide od jednog do drugog i da kaže e odrađeno to i to. A ovdje nema nikakve objave, ovdje nema u broadcasting mehanizam. Znači nema u mehanizam za imetujnje poruka postoje neki jezici koji to dozvoljavaju. Na primim, taj nećemo obrađivati na ovom prednetu, ovo se nazivio BSP, gde je dozvoljeno da pošljete poruku pa ko uhvatite i uhvatite poruku. Na primim, radiokumunikacija je takva. One što je dispatcher, na primim, ako se se... Dobro, to je sada će pre nekoliko godine, način ako ste se pre 3 godine vozili taksije. A otacu bili radiotaksi, nisu bilo ove android aplikacije. Po taksima taj li bio radiotaksi. Znači, ono je dispatcher, kaže, vozilo na toj to lokačiju i to objavi preko radija. Pa ko ima uključen radi, ima uključen radi. O koji čuo poruku, čuo poruku? Koja nije čuo poruku, nije čuo poruku. To je odradzeno, ono, brodkast. Svima! E mi ovde ne radimo brodkast. A mi ovde radimo komunikaciju sa svakim pojedinačnim procesom. A viditećemo da se u mi možda moći nekako dodradimo neki brodkast u nekomu djezika, tako što ćemo nekde nešto da objavimo, nekde gde će svi, to možda moći da vidi. Kad budemo došli do, a, jezika koji se zove, odnosno bibliotekje za programski jezik C koji se naziva Linda. To nije delje napromenjiva, ali će se ponašati možda tako što ćemo staviti jedan objekat, ali svi moraju da znaju kako izgleda taj objekat, da vi mogli da ga naću. Dobro, kako izgleda kod za klijenta, za ostale procese nisu klijenti, ovo ovdje nisu nije klijent server, ma da je izgleda kao klijent server arhitektura, izgleda ova isto kao klijent server, a on je mora da prosladi vrednost, zašto je samo vrednost, zašto nije mora da salja, osad i on je ostale argument, zašto nije mora da pošlja identificator i zašto nije mora da salja operaciju. Operacija, pa zadošta ima jedna jedina, ako ima jedna jedina, onda ne mora da se specificiram. A druga stvar zašto nije mora da salja identificator, zato što ona je vratamo kad nađe maksimum, znači kad primi svih n poruka, odnosno 1-1 od svog suseda, a ono i centrali će morati svakom da prosladi odkova. OK, kako izgleda simetrično rješenje, gde svaki čvor ima identičnu strukturu? Če hoćemo da vidimo rješenje, kod koga svaki čvor ima identičnu strukturu? A, što sam rekao, svaki čvor ima identičnu strukturu? Znači svaki čvor mora da raditi isti posao? Dobro, šta će u mi onda da radimo? Svaki od ovih ovde naših čvorova će svakom svom susedu da ode i da pošalje poruku. I da kaže, moja vrednost je tajta, ili barem vrednost je tajta. Ko je sad razlikazm iz ovoj dvere čenice? Kad kažemo, ovo moja vrednost je tajta, moram da pošaljem i svoj identifikator. Kad da kažem, samo vrednost je tajta, nema nešta njem nikom identifikator. Znači velika razlika. Ovo gde šaljimo identifikator, će nam veratno biti potrebno, na primer, kod problema koji se zove stable marriage ili tako nešto, gde će morati da znamo, tačno koje s kim uparen, ili kod problema koji se naziva uparivanje čvorova, tu moramo, tačno, znamo koje s kim uparen. A ovde, pa ne moram, ovde svi moraju da dobiju poruki. Dobro, šta smo onda napravili? Šta sam rekao sad, svi moraju da dobiju poruku. Šta onda radimo? Pa kada smo mi postali svima poruke od svakog. Mi od svih. Treba da dobijemo nazat odgovor. I da osračunamo to što treba da osračunamo. Znači svaku će od ovih čvorova morati lokalno da računa minimumulnalu i maksimum u vrednost. Šta smo radili? Bešli sada slalismo poruki. Znači svaki čvor je slav poruki, jesta. Koliko poruka je svaki čvor slav? Svaki čvore je slav svakom preostalom čvoru poruku, po jednu poruku. Znači imamo n čvorova i svaku treba da pošljede n-1 poruku. I to je ukupan broj poruka koji će ovde kroz ovaj naš sistem biti prosljeđen. n puta n-1 poruka. PUNO poruka! Nalajdamo se da ćemo dobiti neku brzinu sa ovakvim rešenjem. Dobro. A šta radimo dalje? Koliko imamo komunikacijunje kanala i omu enu. Okej. I ajdemo kako izgleda rešenje. Sada su istra. Znači rekli smo simetrično rešenje potno. Rešenje vrlo jednostavno odemo i svim susedima svakom pojedinačnom susedu moramo dodemo i da pošljeme u poruku. For je od jednako 0 do n-1. Rešenjem poruku sam sebi. Ne bi valjelo. Pošljem tu vrednost V i onda treba da odem da primim for je od jednako 0 i od manje od kako su zove n-1. Treba da primim poruku. Ne treba da primim ovo poruku za sve. Onda nisam morali da kažem je od jednako i. To mi ostalo da bi ličilo na one kod koji ćemo posle imati. Uvijek na to da ne više ovo da je minus 2 nego da bi ove for petlje bila identične. Ovo zagleda identične možda i to zatreba posle. I šta radimo onda primim poruku proveri je od me lokalnom minimom ili već od lokalnom maximom ako jeste postavio. I to što ću se srečunom. I to je to. Vrlo jednostavno vidite. I kakvi komplikacija. Prostledali smo svakom susedu i od svih suseda smo dobili odgovor. Faki čvori izgleda potpunosimetečno. Nogo smo poruka više poslali. Ali da smo dobili da naše rešenje radi brže po štodi nismo svako je potrošio isto, noliko vremena kako i one tamo server maloče sradio na računnih minimima i maximima svako je morao to da računa. Ali u paraleli. Odprilike ovo rešenje možda pude ček i spori u odnosunom predkodu da ću njomu previše poruka koja treba proslediti. Da će možda se desi da dođi do zagušenje naše breše. Aha, nekoma možda kaže. Pa dobro zašto onda nismo premenili rešenje kao onom predkodu. Da smo mogli da se dogovorimo da izgleda čvorom sistem onako kao što izgleda na slici 1 i bi se dogovorili. Ali nismo mogli. A to po nekad postoji problem. I to je jedan od poznatih synchronizacijenih problema u distribuiranom programiranju. To je odredljivanje boće. Znači kako odrediti koji od ovih svih naših čvorova je čvor nola. Znači da nekoma možda kaže. Pa vrlo jednostavno oddajmo i uzim ovo poštansko sanduče i o nekojima najmenji broj poštanskoj sandučeta. To baš i nije najbudja rešenja. Znači to smo statički odredili već koje je prvi. Tako da smo mi u suštini već tu natratili i one graf broj 1. Treba da problem je malo komplikovaniji u koliku ima više čvorova. Ne znamo možda koliko ih ima. Negu znamo samo naše suside i onda to dofse sve ispropagira dok mi odredimo. Koliko ima čvorova i koji je tu čvor koji je kako postavljen, potraje. Može. Znači kažem to je jedan od poznatih synchronizacijenih problema koji mi nećemo razraditi duši na ovom predmetu. To je problem odredivanje vođe. Ili problem odredivanje koliko ima sati. Jedna računa da vam kaže sad nje toliko i toliko sati. Druga kaže toliko i toliko sati. A vi treba da napravite neko koordinisano vreme, prema tome koliko su kad su oni postali. Možda koliko je trajalo. Neko kašnije vidi da probate da proračunate koliko ima sati. I to isto jedan od poznatih synchronizacijenih problema. Odredivanja lokalnog vremena. Još ste nam još jedan. Još jedno rješenje. To kroz koji će mi isto samo prooći. A šta koji imamo uprstveno? Znači imamo već i broj čvora. A jedan crat će opet šest kao što je malo často. I svako ima samo po dva susida. Znači nemojmo onako jedan veliki graf. Gde možemo da šaljemo svako svako mjeme. Znači možemo da šaljemo samo levom ilidesnom susidu. A ipak može da se odredi sve ono što treba da se odredi. Rješenje koji ćemo ovde razmatrati je asimetrično rješenje. Kod ovog asimetričnog rješenja otići ćemo i ovde uzretno prema identifikatoru. Vjedećemo da možete postoji simetrično rješenje. Proglasit ćemo ovaj ovde čvora zvoću. Šta ćemo onda raditi? Svaki od ovih ostali čvorova. Treba da pošaljemo poruku. A koji je do tog trenutka određen minimum i koji je do tog trenutka određen maksivim. Znači šta rad ovi čvorovi? Prvoj čvorovi ovde i kaže lokalim maksimum minimum su isti. Znači ono će da pošalje v i ovaj će da pošalje v. A ovaj ovde će da kaže pošalje maks od onog što ja imam maks v i onog što je došlo.