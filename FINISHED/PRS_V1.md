1
Evo prvog snimka iz performansi računarskih sistema. I prva stvar kojom ćemo se baviti su performanse operativne memorije. Kod konkretno za performanse operativne memorije imamo dve stvari. Jedna je iskorišćenje memorije, drugo će biti brzina i širina propusnog opsega. Ovde se bavimo iskorišćenjem. Hajde prvo da vidimo na koji način ćemo opisati operativnu memoriju, koje su pretpostavke koje uvodimo i kako izgleda naš sistem koji posmatramo. Zamišljamo da postoji neki generator poslova, koji u suštini nama generiše jobove koji žele da se učitaju u sistem i da se obrade. I da imamo memoriju. Ovo će biti naša memorija. U samom startu u memoriji moramo da odvojimo jedan deo koji će biti za operativni sistem. Kada pričamo o slobodnom prostoru memorije, ovo je ovo parče dole koje je namenjeno za korisničke programe. A ovaj deo gore gde je operativni sistem, ne možemo ništa da smestimo, to jest ne možemo tu da učitamo program, tako da njega ni ne uzimamo u obzir, kada govorimo o veličini memorije. Druga stvar, taj generator znači nama generiše poslove. I umesto da idu direktno u memoriju, oni će da se baferišu u nekom redu čekanja. To jest imaćemo neki FIFO red. Što znači FIFO? First in, first out. Dakle, po redu kojem dolaze, oni se ubacuju u taj red čekanja. I onda se operativni sistem kada ima vremena, kada ima prostora, on učitava poslove s tog reda čekanja, ubacuje ih unutra u memoriju i onda kada ih učitava, on zauzme za njih neki deo. I tako dalje. I koje su pretpostavke koje ćemo ovde uvoditi? Najvažnije pretpostavke koje ovde uvodimo kada pričamo o iskorišćenju je da smatramo da interesantna nam je slučaj u kojem kada je iskorišćenje zapravo bitno, kada je to kritična stvar. Iskorišćenje je kritična stvar ako imamo mnogo poslova koji dolaze i stalno pokušavaju da se učitaju u memoriju, a u memoriji nemamo dovoljno mesta da ih sve učitamo. A ako imamo dovoljno mesta da ih sve koji dolaze učitamo u memoriji, oni se vrlo brzo obrade, a vrlo sporo dolaze. Mi ćemo imati situaciju da nam uvek ostaje slučaj mesta u memoriji i to nije nešto interesantno za posmatranje. Iskorišćenje će nam uvek biti jako veliko ili blizu 100%. Ono što ćemo ovde posmatrati, to je režim u kojem ovaj generator mnogo brzo generiše poslove u odnosu na to koliko sistem brzo može da ih obradi.

Oni se u memoriji zadržavaju dovoljno dugo da u ovom ovde redu čekanja uvek ima n poslova, već od nula. Čim postoji posao u redu čekanja, odnosno posao se učitava čim se nađe za njega mesta u memoriji, ali to učitavanje i generisanje poslova, odnosno generisanje poslova ide mnogo brže nego što ide obrada poslova, tako da ovaj red čekanja nikad nije prazan. Tako da se nikad neće desiti situacija, imamo mesta da se posao učita, a da nema posla koji bi mogao da se učita. To je jedna pretpostavka. Druga stvar, treba da vidimo kakve su veličine poslova i to će nam uticati na mnoge stvari. Ako sa s označimo veličinu posla, to jest koliko mesta zauzima, postoje različiti modeli. Ima, recimo, model jednakih veličina koji ćemo videti od danas ili sledeće nedelje, u kojem su svi poslovi jednake veličine. Znači svi poslovi su isti. Tu je onda s1, jednako s2, jednako sn. Ako da, svi su jednake veličine. Imamo model u kojem su veličine poslova ravnomerno raspodeljene. Šta to znači? Ako imamo neku minimalnu veličinu posla koja je praktično nula ili malo veća od nule, imamo maksimalnu veličinu posla i imamo neku prosečnu veličinu posla, onda imamo, znači sve veličine jednake verovatnoće, otprilike. Onda u suštini kad bismo uzeli raspodelu verovatnoće, sad ćemo da vidimo šta to znači, onda kad bismo gledali ove na y-osi, stoji koliko je verovatna neka veličina posla, na x-osi stoji veličina posla, na y-osi stoji p od s, na y-osi stoji p od s, verovatnoća da je te veličine, kad bismo imali da su te veličine konkretne brojke, onda bismo dobili ovo ništa. Ovo tako ravna crta, sve su jednake. Ovo ovde je, naravno, minimalna veličina nula, minimalni posao veličine nula, maksimalni posao, o čemu reći da je veličina nekog dva a, odnosno, prosečna veličina je neko a. I ovde uvedemo a kao prosečnu veličinu posla, a je nekada srednje. I ovde ovo tako. Šta onda možemo da kažemo o ovde uniformnoj raspodeli? Da li je ovo uniformna raspodela? Uniformna raspodela. Verovatnoće veličine posla, je l' tako? Pa, pošto je to raspodela verovatnoće, za verovatnoću uvek važi da ukupna verovatnoća svih događaja mora da bude jednaka jedan. Znači, te bacite kod skice, ako su sve strane jednako verovatne, ako nije neka nameštena kod skica nego normalna kod skica, onda vam je verovatnoća da vam padne sada ojka, trojka, četvorka, ili šestica za svaki je tih broj, a evo po jedna šestina. Zbir tih šest vrednosti je jednaka jedan. Isto tako kad bi kod skica imala 700 strana i sve je bila jednako verovatne. Opet bi zbir svaka bio bio po jedan kroz 700, zbir bio jednak jedan.

I sad možete da zamislite da su vam veličine programa 0 adresabilnih jedinica, 1 adresabilnih jedinica do maksimalne veličine programa i da to budu konkretne brojke, da bude diskretna slučajna promenljiva, da ne bude kontinuirana i da ovo da nije neprekidno nego su to tačke odgovarajuće dole na X osi i onda bi opet sve bile jednako verovatne, ali zbir svih tih verovatnoća mora da bude jednako jedan. Ovde radi jednostavnosti, pošto možemo da pretpostavimo da je veličina programa mnogo veća od adresabilnih jedinica, dakle program nije reda veličine jedan bajt nego je, ne znam, kilobajti što je barem hiljadu bajtova, onda kad imamo da je nešto hiljadu ili 10.000 puta veće od bajta, možemo zapravo da kažemo da ovo ovo da ovo uopšte nisu tačka po tačka nego da je to kontinuirana vrednost i da ne razmišljamo na diskretan način jer je jako jednostavnije, možda je za shvatanje, za računanje nije mnogo lakše ako je to kontinuirano nego nam je lakše da radimo integriranje nego neke sume ako nam bude zatrebalo to za bilo šta. Međutim, šta smo se dotakli da kažemo, ukupna suma svih tih verovatnoća mora da bude jednako jedan i onda kad bismo se zapitali šta to znači grafički, pa to bi značilo da je površina ovoga ovoga ovoga ugla mora da bude jednako jedan, što znači da je ovoga visina kolika, ovoga je 1 kroz 2a ovo tako, dakle 1 kroz 2a je verovatnoća svake konkretne vrednosti, odnosno nije verovatnoća svake konkretne vrednosti, ono nije verovatnoća o kontinuiranoj slučajnoj promenljivoj, ovo neće biti verovatnoća već će biti gustina verovatnoće, tako da ovo ovde ne treba da se zove p g g kao gustina, dakle g od svake tačke jednaka iznosi 1 kroz 2a pa je najčešće ovo da je gledati da su svi programi jednako verovatni, već ti može da bude nešto i drugačije, može da se desi da su mali programi mnogo verovatniji.

…veliki program i da veličina programa bude eksponencijalno raspodeljena. Znači, onda biste imali kao Pareto raspodelu da, ne znam, 80% programa su manji od 20%, samo 20% programa su veći od 80%. Dakle, mogli biste da imate da, rekli smo, malih programa ima mnogo više, to jest verovatnoća da je program mali, da bude mnogo veća, da ovako bude eksponencijalno. Kako god da je ta raspodela? U praksi mi to ne pogađamo šta je, nego se uzme smeša programa u sistemu koji se posmatra i broji se koliko ima programa koje veličine i dobije se neka funkcija i se dobije neko parče i odku znam. I onda pokušavate tu funkciju da fitujete čemu ona najbolje odgovara, vidite, aha dobro, ovaj može da eksponencijalno raspodeli ili može da je uniformna ili može da je nešto deseto. Mi ćemo ovde radi izvođenja da većinu stvari radimo samo uniformno, mislim da je najlakša za račun, a koncepti su slični i samo bi se drugačije sprovela račun da je drugačija raspodela. Bitno je onda da razumemo koncepte. Dakle, to je što se tiče veličine samih programa. Druga stvar koja je bitna je šta je sa ovim vremenom zadržavanja. Znači imamo te jake vreme zadržavanja programa u memoriji. I ovo što ovde pričam, to možete da vidite i na predavanjima, ovo su predavanje broj 2. Ali ovako mislim da je više kao deskriptivno na tabli. Da vam pričam i da vam pišem nego da idem po prezentaciji. Dakle, imate vreme zadržavanja programa u memoriji. I neka zdravna logika nama govori da se neće svi programi isto zadržavati u memoriji. Mogli bismo da kažemo svi programi se zadržavaju isto vremena, to bi mogla da bude jedna pretpostavka i vidimo šta bismo onda dobili, ali to prosto znamo da neće biti tako u realnim sistemima. Druga stvar koje bi mogli da postavimo pitanje jeste na koji način je korelisan ta vrednost te-ja sa vrednošću s za isti program. Odnosno, da li programi koji su veći se zadržavaju duže u memoriji ili ne.

U suštini, mogli bismo... Ove bismo mogli da imamo konstantu ili druga bi bila da je t neka funkcija od veličine programa, recimo da je to linearno. Opet, ovo možete da dobijete za konkretan sistem, tako što uzmete smesu programa u tom sistemu, izmerite koliko dugo su bili u memoriji pre nego što su se završili i pokušate da vidite kakva je ta funkcija i da li možete nekako da je definišete, recimo, po pravoj ili na neki drugi način. Vrlo često će zapravo da se pokaže da postoji neka zavisnost. Dalje nam još nešto treba, pa ako nam bude zatrebalo, da vas ne zatrpavam sada sa glupostima, da krenemo s nečim konkretnim, pa ćemo se vratiti na što drugo dalje zatreba. Dakle, za sad imamo s koja je veličina posla i imamo t koja je vreme zadržavanja. I to su dve bitne stvari, ove sam vidim da li, aha, trebamo i ovo, dakle imam s što je veličina posla i t koja je vreme zadržavanja. Imamo sad neki najprostiji mogući sistem, krenemo onako istorijski, prvo smo imali onaj job sistem ili tako koji je mogao da se izvršava samo jedan po jedan posao, nije postojala mogućnost da imate više od jednog programa, odnosno imali ste monoprogramski sistem. Imamo što se dešava u monoprogramskom sistemu, pokušaćemo da vidimo kako je srednje iskorišćenje memorije. Što znači iskorišćenje memorije, to znači koliki deo ove memorije, ovog dela za programe, mi možemo da iskoristimo. Ovo je ovde situacija, ovo ovde gore parče je iskorišćeno, ovo dole je prazno, znači iskorišćenje bi bilo veličina gornjeg parčeta koji je iskorišćeno kroz veličina ukupnog ovog prostora odvojenog za program. E to nas interesuje. Imamo što je monoprogramski sistem. Dakle, u monoprogramskom sistemu smo rekli, nama generator generiše programe, mi vadimo jedan po jedan program od ovde, učitavamo ga i pošto je monoprogramski, to znači da čak i ako ima mesta dole da možemo da smestimo sledeći program iz reda za čekanje, mi nećemo vaditi sledeći program, jer naš sistem ne radi sa više od jednog programa u jednom trenutku. Odnosno, u svakom trenutku nama će zapravo biti učitan samo po jedan program. Što smo dobili? Recimo da na y osu stavim u što će biti usage, u je usage ili iskorišćenje, šta je meni iskorišćenje u ovoj situaciji? Recimo da prvi program koji sam učitao je bio neke veličine s1. S1 vidite, mi možemo da kažemo ili ovo s1 će biti neka vrednost u megabajtima ili u čemu god hoćete, ali nama to nije toliko bitno kada pričamo o iskorišćenju, da je nešto 1 megabajt i 1 gigabajt.

Bitno nam je koliki deo ukupne memorije zauzima proces. Dakle, isto je iskorišćenje ako imam program od 1 gigabajta u memoriji od 2 gigabajta, kao što je iskorišćenje ako imam program od 512 megabajta u memoriji od 1 gigabajta. Dakle, iskorišćenje u obe situacije je 50%. Dakle, ono što mi je ovde mnogo lakše da uradim, ne bih razmišljao o veličini ukupne ove memorije odvojene za korisničke programe, jeste da kažem da ću raditi normalizaciju, odnosno, reći ću da je veličina memorije 1. Dakle, cela memorija veličina 1, čega, nije bitno 1, a s je zapravo, nema jedinicu, nego se samo normalizuje. Otprilike. Recimo da je bilo, da je, da je memorija bila 1 gigabajt, a s je jednako 512 megabajta, kad uraditi normalizaciju, to bi značilo da memorija postane 1 od 1, a s postane 1 od 2. Dakle, podelim veličinu svakog programa s veličinom memorije. I onda meni je, uzir, maksimalno, u nekom 1 od 1, jer najveći program može da bude veličina memorije, ne može da bude veći od veličine cele memorije, a ovo je moj prvi program koji se mučio u memoriji, u nekoj nebitnoj veličini s1. Odlično, stavimo na ovu x osu, da stavimo u vreme. I ta s1 se može da u memoriji zadržava nekih t1 vreme. Ok. Šta ja onda mogu da kažem, dakle, moja iskorišćenja, od trenutka kod trenutka 0 do trenutka t1, je bilo jednako s1. Zašto je bilo jednako s1? Zato što je po definiciji u jednako s kroz m, ovde sam stavio da je jednako 1, znači da je samo s. Otprilike. Znači iskorišćenja u nekom konkretnom trenutku, u mono-programskom sistemu, će biti veličina programa koji je u tom trenutku učitan u memoriju. Dobro, završio se ovaj. Odmah, kada se on završio, rekli smo imamo pretpostavku da je dovoljno brz generator, da mogu da učitana druga. Zato taj drugi, rekli smo imamo veličina s2. Znači, u s2 ovde, i ovde ostavio do nekog trenutka t1 plus t2, odnosno, oni u memoriji, bio ukupno t2 vreme. Otprilike, bilo t1 vreme. I sad bih mogao ovde ovako napisano. I tako dalje. I možda bio negde dalje. I tako dalje. Vidite kako ovaj ide? Pojma. I recimo da smo uzeli da posmatramo neki vremenski interval u koju mi bilo ukupno i poslova. Znači, gledali smo neki veliki vremenski interval koji bio dužine t i u njemu je bilo ukupno i poslova. I to su bili poslovi s1, s2, s2. Šta je meni onda prosečno iskorišćenje memorije u tom vremenskom intervalu? Dakle, kad bih hteo sad da usrednjim koliko je prosečno, čemu bi bilo i jednaka ta vrednost? Pa kao i svaki put kad radite usrednjavanje neke funkcije, jer recimo, uvek imate, ovako neku bezveznu funkciju. Šta znači usredniti tu funkciju? Prvo gledate na kom intervalu to radite. Otprilike, možda neko da vam kaže usredniti od početne vrednosti a do krajnje vrednosti b i to je neka funkcija f u ovde međuova neka x. Kako je usrednjava?


U srednjem tipu, vaš interes je površina ispod ovog grafika. Postavite sebi pitanje: treba da uzmete epsilon i osu x. Kada napravite pravougaonik, površina tog pravougaonika treba da bude ista kao površina ispod cele funkcije. To znači srednja vrednost. Kada bi u svim tačkama vrednost bila jednaka srednjoj vrednosti, kako bi trebalo da izgledao ovde y? To bi bila neka srednja vrednost funkcije, f srednje. Šta je f srednje? F srednje će biti ukupna površina pravougaonika. Treba da važi da je ukupna površina pravougaonika jednaka površini ispod funkcije. Šta je to? To je integral od a do b funkcije f(x) po dx. I tako dalje. 

U šta se ovo pretvara kada imate jednostavnu situaciju, kao što je bio slučaj u monoprogramskom modelu, gde imate više ovih pravougaonika? Ovu funkciju ne morate da integrišete da biste odredili ukupnu površinu. Već će površina biti određena na jednostavan način. Imate... Hajde da pređemo na drugu stranu. Srednja vrednost funkcije na intervalu od a do b će biti 1 podeljeno sa b minus a, što je dužina intervala, pomnoženo sa integralom od a do b funkcije f(x) dx. Ovako. Mislim, ovo ste već videli na matematici, tako da vas neću zamarati. Ovo je srednja vrednost funkcije. Šta je srednja vrednost i kako se koristi ovde? Šta je dužina intervala? Dužina intervala će nam biti t, ovako.

Posmatramo trenutak od 0 do trenutka t. Podelićemo sa t, što je srednje vreme, a funkcija koja se koristi u srednjem vremenu je iskorišćenje u nekom vremenskom trenutku u tom intervalu koji posmatramo. Ovde ćemo samo da saberemo površine ovih malih pravougaonika. Saberemo površine malih pravougaonika: s1t1 plus s2t2, i tako dalje do sntn. Super. Mogu ovo malo preglednije da napišem. Setimo se da je t zapravo t1 plus t2 plus... plus tn. Isto tako, s1t1 plus... do sntn. I to je podeljeno sa t1 plus t2 plus... plus tn. Dobro, nešto sam dobio ovim. Pa, nisam. Sada mogu da se zapitam. U ovim različitim varijantama o kojima smo pričali, u vezi između s i t, šta se dešava u situaciji kada su svi programi jednake veličine? Ako su svi programi jednake veličine, ovde nema ništa posebno da se kaže. Ako su svi programi jednake veličine, ne treba mi ova formula da bih video da će iskorišćenje uvek biti jednako veličini programa. Ako su svi programi veličine pola memorije, bez obzira na učitar, sve vreme će biti iskorišćeno 50%. Vidite da bi se ovde, kada bi se svi zamenili nekim s, skratilo bi se, i ostali bismo samo sa s. 

Šta se dešava ako uzmemo drugu varijantu, što je zapravo u monoprogramskom sistemu verovatnije i logičnije, odnosno uzmemo varijantu da su veličine programa i vreme zadržavanja međusobno linearno zavisne, odnosno da važi da je ti jednako k puta si. Dakle, ako kažemo da je ti jednako k puta si, onda se to pretvara u k puta si na kvadrat plus k puta si na kvadrat plus... do k puta si na kvadrat, a dole imamo k puta si plus k puta si plus... do k puta si. Odnosno, gore i dole se skrate, i ostaje suma si na kvadrat podeljeno sa sumom si. Dobro, je li ovo bolje? Pa, nije, ali može da bude. Kako ovo može da bude bolje? Pomoću jednostavnog trika: pomnožim i podelim i gore i dole sa n. I dobijem n puta (1/n) puta suma si na kvadrat, a dole imam n puta (1/n) puta suma si. Ovako. N i n se skrate, a ove dve stvari će dobiti određeni oblik. Šta su sada ove stvari?


Šta su ove dve vrednosti koje imam, gore i dole u razlomku? To nije ništa drugo do matematičko očekivanje ovih funkcija. Matematičko očekivanje, ili srednja vrednost, je upravo to – srednja vrednost funkcije. Ova vrednost dole će postati srednja vrednost \( s \), a ova gore će postati srednja vrednost \( s^2 \). Interesuje nas srednja vrednost funkcije \( s \), što predstavlja prosečnu veličinu programa, dok gore imamo srednju vrednost kvadrata veličine programa. Sada samo treba da izračunamo srednje vrednosti ovih funkcija.

U čemu se ovo razlikuje od prethodnog usrednjavanja? Tamo smo usrednjavali po vremenu, u slučaju iskorišćenja. A šta imamo ovde? Ove vrednosti \( s \). Za nas, u opštem slučaju, ove vrednosti su nepromenljive. Dakle, program koji nam dolazi možemo posmatrati kao da je njegova veličina nasumično generisana iz nekog opsega vrednosti, od minimalne do maksimalne veličine programa. Stoga su ovde srednje veličine nepromenljive, a ove dve funkcije su takođe nepromenljive. Potrebna nam je prosečna veličina tih funkcija. Naravno, na to utiče raspodela ovih nepromenljivih vrednosti.

Na primer, verovatno je da će program imati veličinu od 512 MB ili 1000 MB. Ako je verovatnoća da program ima veličinu 512 MB dva puta veća od verovatnoće da ima veličinu 1000 MB, onda srednja vrednost neće biti ista za ove dve veličine, čak iako su obe moguće. Dakle, bitna je raspodela ovih nepromenljivih vrednosti. Hajde da to ilustrujemo na primeru.

Jedino što od vas očekujem je da razumete šta se dešava ako imamo uniformnu raspodelu. Drugim rečima, ako su sve veličine programa iz određenog opsega jednako verovatne. Kako se onda računa ova donja vrednost? Jednostavno, šta je prosečna veličina programa? Ako smo rekli da imamo uniformnu raspodelu sa centrom u \( a \), minimumom 0 i maksimumom \( 2a \), onda je srednja vrednost \( \frac{1}{2a} \). Srednja veličina programa će biti \( a \). Dakle, prosečna veličina programa je \( a \).

A šta je sa prosečnom vrednošću kvadrata veličine programa? Onda moramo uzeti u obzir granice integracije. Kako to izračunati? Ovo je sada verovatnoća. Kvadrat \( s \) nema direktan smisao, ali ne moramo ni da crtamo. Šta imamo ovde? Ovo će biti \( \frac{1}{2a} \), jer je to veličina opsega po kojem integralimo. To je opseg vrednosti koje \( s \) može da uzme. Integralimo od 0 do \( 2a \). Koja je funkcija koju integralimo? Integralimo funkciju \( s^2 \). Dakle, \( s^2 \) pomnoženo sa \( ds \). To će biti \( \frac{s^3}{3} \) u opsegu od 0 do \( 2a \). Zatim, \( \frac{1}{2a} \) pomnoženo sa \( \frac{(2a)^3}{3} \), što je \( \frac{8a^3}{3} \), pa dobijamo \( \frac{4a^2}{3} \). Kada se ovo ubaci u formulu, dobijamo \( \frac{4}{3}a \) kao prosečnu vrednost.

Šta ovo konkretno znači za nas? To pokazuje kako se računa prosečna vrednost i kako raspodela utiče na rezultat. Ako imamo uniformnu raspodelu, prosečna vrednost je \( a \), a prosečna vrednost kvadrata je \( \frac{4}{3}a \). Ovo je korisno za razumevanje performansi računarskih sistema, posebno kada se radi sa slučajnim veličinama.










10
Ovo je super. Dobili smo neku formulu. Šta nam ova formula govori? Ovo nam pokazuje iskorišćenje. Ovo nam je iskorišćenje u slučaju kada imamo dve statičke particije, imamo da se programi zadržavaju konstantno vreme u memoriji, imamo da je verovatnoća... raspodela verovatnoće... raspodela veličina programa uniformna, i šta još pretpostavljamo? Da? Da, ovo se... I kada se uspostavi ravnoteža. Da, to je super. To je baš lepo. To je odlično. A... Sada me interesuje koliko iskorišćenje može maksimalno da bude. Dakle, rekli smo... da je od 0 do... 1x, zbog toga što je x manja particija, pa mora biti manja od veće particije koja je 1. I očekivao bih da ako x teži vrednosti nula, možda bih očekivao da to sve postavite kod jedne particije, pa bi to moglo da liči na monoprogramski sistem. Da, imali bismo tako nešto. Ako bih sada uzeo da x teži nuli, ovo bi bilo 0 plus 1 gore, a dole bih imao 2 što množi 0 plus 1, odnosno... kada x teži nuli, pa, da, sve neće pa kod neće... na ružan i nematematički način. Da, stavite. Ovo napišite. Ovo teži jednoj polovini kada... na ružan i nematematički način se napiše. Napišite formulu. Kada x teži nuli plus. Ovo je limes i jednako je jednoj polovini. Da, tako. Odnosno, ovo nije 1. Dve trećine smo dobili za monoprogramski sistem. Kao... maksimum iskorišćenja. Odnosno, mislim, zašto kažem dve trećine. Da, imali smo četiri A. Međutim, koliko je A u ovoj situaciji? Pa ako su programi... ako se programi kreću od 0 do 1, to znači da je A jednako jednoj polovini. Dakle, ako bi programi bili veličine od 0 do 1, kao u ovoj situaciji, A bi bilo jedna polovina... i da je sistem monoprogramski, imali bismo iskorišćenje od dve trećine. Ali, podsećam vas da smo bili u drugačijim pretpostavkama. I to je jedna stvar na koju uvek morate biti pažljivi... u vezi sa onim što vam ovde pričam u ovom primeru. Jedan od najvećih problema... u inženjerstvu, novinarstvu i svemu ostalom je to što... ljudi vole da donose zaključke na osnovu rezultata koje su dobili, a da se ne zapitaju zašto su te rezultate dobili. I onda imamo mnogo lažnih informacija koje kruže svuda. Ljudi se pozivaju na matematiku i statistiku, a zapravo njihove pretpostavke koje su uveli nisu bile iste kao pretpostavke nekog drugog... i potpuno su drugačije. Dakle, ovde bi sada upoređivanjem monoprogramskog sistema koji smo analizirali u prošlom snimku i ovog sistema sa dve statičke particije bilo bukvalno mešanje babe i žabe, zato što su potpuno drugačije početne pretpostavke. Tamo su veličina programa i vreme izvršavanja bili nezavisni, a ovde se svi programi izvršavaju u istom vremenskom periodu u memoriji. Što znači da se rešavaju i analiziraju potpuno dva različita problema, i naravno da će se dobiti različiti rezultati. I ovde ostaje još jedna stvar koju bih želeo da uradim... a to je da vidim koja je maksimalna vrednost iskorišćenja i kako treba da izaberem x da bi mi iskorišćenje bilo maksimalno. Dakle, za koju vrednost x će mi biti maksimalna ova funkcija. Tako bismo mogli da nađemo taj maksimum. Posvetite se matematici 1, 2 ili kada se poveća rad... u suštini, uradićemo izvod. Dakle, treba nam izvod ove funkcije da bismo našli njene lokalne ekstremume. Kao što znate, ekstremume treba tražiti među kandidatima: krajevi intervala, gde izvod nije definisan, i tačke gde je izvod jednak nuli. I onda proverimo da li je to minimum ili maksimum. Dobro, nije možda, ovo je definisano za x od 0 do 1... zato što je u redu, zato što imamo x od 0 do 1. Od 0 do 1, tako. Tako da o tome ne razmišljamo, krajevi intervala su na 0 i 1. U sredini, za 0 smo rekli da je 1,5. U sredini, da je isto, gore će biti 2, dole će biti 2 po 2, što je isto 1,5. Krajevi intervala su po 1,5... ovo su limesi, jel tako? I još ostaje da vidimo šta će biti sa prvim izvodom.


Uzimam, pardon, ovaj stvarno je napisano. Uzimam \( \frac{du}{dx} \). Čemu je jednak prvi izvod? Pa da vas podsetim, možete izračunati kao \( \frac{f'g - fg'}{g^2} \). Dakle, izvod ovog gore je \( 2x \), puta \( 2x^3 + 1 \), minus \( x^2 + 1 \), što množi \( 6x^2 \). I dole ćemo imati \( (2x^3 + 1)^2 \). I samo me interesuje kada je ovaj izvod jednak nuli. U suštini, ovaj dole delitelj nikad nije jednak nuli, to jest, definisanost je ista kao za samu funkciju. Definicija prvog izvoda, to jest, samo u tački \( x = -1 \) nije definisan, tako da nema tačaka u kojima je funkcija definisana, a prvi izvod nije. Tako da samo treba da proverimo kada je ovaj gore jednak nuli. Dakle, treba da nas interesuje \( 2x \cdot (2x^3 + 1) \) da bude jednako \( 6x^2 \cdot (x^2 + 1) \). I sada, pošto je \( x \neq 0 \), možemo da podelimo sa \( x \), jer \( x \) različit od nule. Dakle, za \( x \neq 0 \), pošto smo rekli da \( x \) nije jednako 0, nego je malo veće od nule, nije mala veličina male particije, onda možemo da podelimo sa \( x \), tako da se ovde skrati \( x \), ovo se \( x \) skrati, imamo \( 4x^3 + 4 \), da bude jednako \( 6x^3 + 6x \). Da, tako. Sada da vidimo \( 4x^3 + 4 \), da bude jednako \( 6x^3 + 6x \). Podelimo sa 2, i da prebacujemo polako. Na primer, podelimo sa 2, imamo \( 2x^3 + 2 = 3x^3 + 3x \), odnosno \( x^3 + 3x - 2 = 0 \). Da li sam negde pogrešio? Aha, da, to je dobro. Da nađemo nule ove funkcije. Da vidimo, za \( x = -1 \), dobijamo nešto negativno, za \( x = 1 \) dobijamo nešto pozitivno. U suštini, ova funkcija, hajde da vidimo prvo da li ima nulu. Ovo je na intervalu od 0 do 1. Ovo je neka funkcija \( f(x) \). Za \( f(0) \), \( f(0) = -2 \), a za \( f(1) \), \( f(1) = 1 + 3 - 2 = 2 \). Vidimo da je \( f(0) < 0 \), a \( f(1) > 0 \). Po teoremi o neprekidnosti (Bolzano-Weierstrass), funkcija mora imati nulu ovde. Tako da postoji nula negde u intervalu \( (0, 1) \).

Nulu možemo da dobijemo nekom iterativnom numeričkom metodom, ali to nam nije sada bitno. Za ovakve stvari, na kolokvijumu nećete morati da rešavate polinom trećeg stepena, ali to možete da uradite pomoću kalkulatora. Tako da ovakvo nešto može da se reši iterativno na kalkulatoru, iteriranjem. Ja ću sada samo da uzmem i da ubacim u Wolfram Alpha. Dobro, dobije se da je ova vrednost \( x \) optimalna negde oko 0,596, što je približno 0,6. Tako da je negde za vrednost oko 0,6 se dobije ovo \( x \) optimalno. Sada treba da vidimo koliko je za tu vrednost 0,6 prvo iskorišćenje, da bismo znali da li je ovo maksimum ili minimum, jer nas interesuje kada je maksimum iskorišćenja. Tako treba da napravimo dve particije, tako da nam iskorišćenje bude maksimalno. Hajde da ubacimo ovde 0,6 u jednačinu. Znači, to će biti \( \frac{9}{25} + 1 \) puta \( \frac{27}{125} + 1 \), i to kad se sračuna, iznosi negde oko 0,56. Znači, dobili smo da je maksimalno iskorišćenje oko 56%. Tako da imamo sistem sa dve statičke particije, pod pretpostavkama koje smo uveli, da je maksimalno iskorišćenje, kada se izabere da je manja particija oko 0,6, 56%. Znači, ne možemo teorijski da pređemo preko toga u sistemu sa dve statičke particije. Šta se dešava ako imamo tri statičke particije? Pa, onda se sve još više komplikuje. Sada imate više tipova programa, imaćete više različitih stanja, i graf stanja sistema će postati još složeniji. Za to bi trebalo pisati jednačine ravnoteže stanja, ali to nema potrebe da diskutujemo sada. Ono što treba da znate vezano za ovo jeste da umete da odredite iskorišćenje za svako od stanja, da za konkretne vrednosti \( x \) preračunate iskorišćenje sistema. I tako su uglavnom izvođeni zadaci, i iz ovoga možete videti na kolokvijumu iz prethodne dve godine, i takođe na ispitu, vezano za ovaj prvi deo gradiva. Uglavnom, prvi zadatak bude nešto sa statičkim particijama, pa se samo preračuna. Tu ostaje još samo jedna stvar vezana za sve ovo, a to je da vam objasnim šta su to Markovljevi procesi koje sam spominjao i da vam pokažem još jedan detalj vezan za to. Dakle, ako smo imali da su ove verovatnoće prelaska iz stanja u stanje konstantne, što je situacija koju smo mi ovde imali. Dakle, što su ove verovatnoće prelaska iz stanja u stanje? Imali smo da je uvek verovatnoća prelaska iz stanja \( B \) u stanje \( E \) u sledećem ciklusu \( 1 - x^2 \). To je \( f(x) \) u vremenskom smislu. Promene se dešavaju u diskretnim trenucima, što je to rečeno, koji su unutar \( \Delta t \).


Imamo konačan broj stanja, dakle, ne beskonačno mnogo različitih stanja, već konačan broj stanja, kao što ovde imamo tri stanja. Ovi prelazi se dešavaju trenutno, sa zadržavanjem od Δt vremena, i imaćemo diskretni, homogeni Markovljev lanac. Zašto diskretni? Vreme je diskretno, promene su samo u koracima Δt. Ovo "homogeni" znači da je verovatnoća stanja konstantna u vremenu. I onda možemo da pišemo, ovo je jedan način, i da na ovaj način rešavamo. Tu još ima jedan detalj, recimo, šta još možemo da pitamo i o čemu da razmislimo. Mogli bismo da se pitamo koliko očekujemo da traje, recimo, ciklus, ako smo bili u stanju Bs, dakle, ako smo bili u stanju Bs i pitali se kada ćemo napustiti to stanje. Ajde, recimo, možemo da se pitamo koliko očekujemo da ćemo u uzastopnim ciklusima provesti u stanju Bs. Ili možemo da se pitamo kolika je rekurentnost nekog stanja. Šta je to rekurentno vreme? Vreme. Dakle, rekurentno vreme stanja. Šta je to rekurentno vreme stanja? Možete da zamislite da smo imali, recimo, sistem i da smo beležili u kojem je stanju bio. I on je, recimo, bio u stanju Bs, pa je bio u stanju B, pa je bio u stanju B, pa je bio u Bs. Ono se menja, u Bs ne možemo da pređemo tako. B je prešlo u Bs, pa je onda otišlo u Bs. I tako da imate neku sekvencu stanja koju ste zabeležili. Zamislite da je ta sekvenca baš dugačka, da to dugo radi. I u svakom od ovih stanja je proveo po Δt vremena. Znači, u prvom Δt vremenu je bio u Bs, pa je onda u drugom bio ovde i tako dalje. E dobro. Šta je rekurentno vreme? Pa to je vreme između dve uzastopne pojave istog stanja. Odnosno, ta vrednost može da bude minimalno Δt.

U ovom ovde slučaju, između ove pojave Bs i ove pojave Bs, kaže se da je rekurentno vreme bilo 1 Δt. Između ove pojave Bs i ove pojave Bs, znači rekurentno vreme stanja Bs u ovom slučaju bilo je 3 Δt. I sad biste vi mogli da se pitate, i ko bi očekivao da će biti rekurentno vreme nekog stanja. Ja o tako. Zašto to može da nam bude interesantno i korisno? E pa videćete kasnije, kad budemo radili neki drugi model gde se pojavljuje ova situacija, pa je onda bolje da vam sad ovo odmah ispričam. Kako to možemo da gledamo? Mi sad imamo neko stanje, nebitno koje stanje, neko se zove S, pojma. I recimo da sa nekim P označimo verovatnoću da se u tom stanju ostane, a sa 1-P označimo ukupnu verovatnoću da se iz tog stanja ode. Ok? Recimo da to tako nazovemo. Mislim, možemo da označimo i drugačije, nisam siguran kako je to na predavanjima kod profesorke označeno, ali nije to ključno. Bitno je da razumete poentu. Dakle, posmatramo stanje i posmatramo ukupnu verovatnoću da se iz tog stanja ode. Ne o tako. Šta tu onda možemo da kažemo? Pa koja je verovatnoća? Recimo da sam u tom stanju ostao tačno 1 ciklus. Dakle, ako sam krenuo od toga da sam, ne, ne krećem, koja je verovatnoća, da je k, dobro, neka promenljiva koja će da mi broji koliko sam ciklusa od tog stanja, i recimo k broji uzastopnih ciklusa u stanju. Uzastopnih ciklusa, kako pišem sa k doktor. U S. O tako. Znači, koja je verovatnoća da je k bilo 1? I koja je verovatnoća da je k bilo dva? Da je bilo tri? Da je k koja. Ako smo krenuli od toga da smo na početku već u stanju S, i to je sad bitno, da li krećemo od toga da smo bili u stanju S ili treba prvo da brojimo to prvo, taj prvi?

...ciklus kad smo u stanju S. Mislim, trebalo bi da ga brojimo, ili tako. Dakle, i verovatnoća da smo u tom stanju bili ukupno Δt vremena, to znači da smo bili u njemu i da smo odmah iskočili. Dakle, odmah smo iskočili, iskačemo, i verovatnoća je 1 minus p, ili tako. Šta znači da smo u njemu bili dva ciklusa, k = 2? A to znači da smo prvi put ostali u stanju. Oz tako, znači prvo smo ostali u stanju, a onda smo iskočili. To znači da smo trebali, i verovatnoća p da smo ostali u stanju, puta 1 minus p da smo iskočili. Znači da smo ostali i onda iskočili. Oz tako, znači biće p na kvadrat puta 1 minus p. I vidite kako to ide, u suštini imaćemo da je od k, i p na i minus 1 puta i 1 minus p. Dakle, i minus 1 put smo ostali u stanju i onda smo ga napustili. E sad, kako bih onda mogao da nađem prosečan broj ciklusa koje provodim u nekom stanju? Kako bih to mogao da odredim, koliko prosečno vremena provodim u nekom stanju? Pa ćemo da vidimo kako je to povezano i sa rekurentnim vremenom. Dakle, kako bih mogao da odredim očekivanje, od tako, za k. Matematičko očekivanje za k. Ili k srednje, kako više volite da kažete. U definiciji matematičkog očekivanja neke slučajne promenljive k, pošto ovde, mislim, u nekom slučaju, možete da gledate kao da je random događaj za nas, tako da to je slučajna promenljiva. Koje su sve vremenske vrednosti koje k može da ima? Može da bude od 1 do plus beskonačno. I onda za svako k se pitamo koja je verovatnoća? Koliko događaja? Ajde se samo da mi ne ide, brojač i, ili 1 do beskonačno, verovatnoća da je k vrednost jednog koji i, da smo se baš i ciklusa zadržali puta, koliko smo se ciklusa zadržali, pošto je to ono što usrednjavamo, ili tako, puta i. Odnosno, ovo je kada se raspiše, i 1 do plus beskonačno, i puta 1 i minus 1, puta 1 minus p. 1 minus p mogu da izvučem ispred zagrade. Ovo ovde su umede biti jedna suma sa kojom ćemo se stalno sretati na kursu i to je tako zvani potencijalni red. Tako da trebalo bi da vam pokažem kako da ga sumiramo. Dobro, kako se sad ovo ovde sumira? Šta je ovde zapravo? Sjema ovo liči na neki geometrijski red, samo što se zapravo šeta, šeta vam se i ovo liku uzmete sabira. Ovako je stvari najbolje uzmete da raspišete, da vidite kakav je izgleda prvih nekoliko članova na šta to liči. Pa nemoj kako bi ovo izgledalo. Za i vrednost jednog, jedan ovde će biti 1, a onda za i vrednost dva će biti 2,5 plus 3,5 na kvadrat, plus 4,5 na treći i tako dalje. Znači, ovo je naš potencijalni red. A kako bi ovo ovde mogli drugačije da napišemo? I sad ovo je vrlo neformalno što ću sad uradim, da ne bi se dokazivalo formalno, jer to nikom živom ne treba. U ovom momentu, kako bi smo ovde mogli da drugačije predstavimo? Imate dva načina. Jedan način je da primetite da je ovde 2,5 zapravo, 5 na kvadrat, pa izvod do toga. Ovo je 5 na treći, pa izvod do toga. Ovo je 5 na četvrti, pa izvod do toga. U suštini, to znači, da pošto izvod prolazi kroz zbir, ali opet pošto ima beskonačno sabira, kad u treba je malo formalizma, i onda bi ispalo da je to zapravo 5,5 na kvadrat, plus do 5 na četvrti, pa izvod od sveg toga, a u ovde dole vam ništa drugo, nego 5 puta neki geometrijski red. U spena kvadrat. To jest ovom je p puta 1 kroz 1 usp, pa izvod od svega toga. I u suštini, ovom je celo posav. U svom. I u suštini, ovom je celo posav. I ovom je to. Jer sada znate da se ovde suma, od ovog ovde možda razlikuje za neku konstantu, pošto ta konstanta, samo može da bude puz konstanta, da bi kada se uradi izvod ispala ista stvar, i se samo treba proviriti, čemu je jednaka ta konstanta, i u suštini samo uzmete i ubacite za nekoj konkretno p, i vidite, recimo uzmete da je p jedna polovina, i vidite. Drugi način vam je, i vidite da je ta konstanta jednaka nuli. A drugi način kako možete da uradite, da kažete, ovaj je moj, ovako ja više volim ovde sumiram, ovom možete napisati kao 1 plus 5 plus 5 na kvadrat, plus 5 na treći, pa je. U službom, ovako sam napravite piramidicom u 5 na kvadrat, plus 5 na treći, i tako dalje, plus 5 na kvadrat, plus 5 na treći, i tako dalje. Vidite kako ovo sad već ide. Ovde vam je prvo, ovaj je geometrijska suma g, ovde dole ćete zapravo imati ovaj prvi red samo pomnoženo sa 5, to je 1 pu ta g, pa onda ćete imati 5 na kvadrat, pa g ta g, i tako dalje, i prosumirate u beskonačnost, imaćete g što množi, 1 plus 5, plus 5 na kvadrat, i tako dalje. Odnosno, ono što ste ovde dobili, jeste samo malo, samo malo, samo malo, samo malo. Da, ovde dole isto je još jedno g, dakle dobili ste g na kvadrat, to je ste p, jednako g na kvadrat, tako, dakle potencijalni red je zapravo jednak kvadratu geometrijskog reda. A možete sa dole da uzmete i da preračunate i da vidite čemu je to zapravo, jednako dole uvedite, zapravo isto stvar. No tako, znači samo odradite izvode ovde, ovde, ovde, ovde količnika i dobićete isto. To je potencijalni red, jednako g je jedan kroz 1 minus p, na kvadrat. I ovaj je vrlo logična stvar. Ako vama, ako vi znate, da je verovatnoća, da u nekom stanju ostanete, recimo, da je 2 trećine, to znači da je verovatnoća da ga napustite 1 trećina. I onda, ako se zapitate koji je očekivani broj ciklusa koji ćete ostati u stanju, bi ste onda rekli, pa dobro, ako očekujem da svaki 3, tvojom 3, posto šanse da odem iz stanja, očekujem da ću iz 3. puta da odem. Ali imamo dosta dobi. Pa sada kad uzmem i vratim odegore, i onda imate da je očekivani broj ciklusa jednak 1 minus p, što množi 1 kroz 1 minus p na kvadrat, što je 1 kroz 1 minus p, odnosno u slučaju da smo rekli, da je verovatnoća ostanka u stanju 2 trećine, verovatnoća napuštanja i jedna trećina, dobro li bi ste ovo ako formalno izvedeno da je očekivani broj ciklusa koji se zadržavate u stanju 1 k3, što je baš lepo. Što se dešava sada sa onim rekurentnim vremenom stanja. Znači, ovo ovde je očekivani broj ciklusa koji se zadržavate u nekom stanju i ovo često ide u paketu sa ovde zadacima sa 2 statičke particije ili sa 2 dinamičke particije kao što ćemo videti posle ili bilo koji tipova ih zadataka u kojem imate da crtate neki automat stanja u morašu...

Da se zapitate koliko očekujete da, kad uđete u neko stanje, u njemu provedete vremena. Koliko se očekuje, očekujemo da se zadržavate u nekom stanju. Šta je sad ovde interesantno? Uzmemo i posmatramo sada vreme. I gledamo neko stanje BS. Sistem je bio u stanju BS neki broj ciklusa, bio i Δt, 2Δt i prešao u neko drugo stanje. Onda možemo da kažemo u ovom ovde vremenu bio u stanju BS, onda bio u nekom drugom stanju, onda posle opet negde u nekom stanju BS, određeni broj ciklusa i tako dalje. I to se sad ponavlja. Možemo da kažemo ovako, uvučemo ovde crtu. Ovo ovde bih očekivao da će biti rekurentno vreme stanja. Odnosno, ovo se zove dužina ciklusa, t<sub>c</sub>. To je dužina ciklusa. Od toga on je proveo dva takta u ovom stanju BS, a ostatak vremena nije bio u BS uopšte, nego bio u drugim stanjima, ako se posle toga ponavlja u BS. I ovo tako. To znači da je... Ovo ovde... Kad pustim da se ovde dešava jako dugo vremena, očekujem da se... da je sve podložno zakonu verovatnoće. Dakle, u slučaju da sam dobio da je očekivani broj stanja koje provedem... Očekivani broj ciklusa koje provedem u stanju BS 3, kad bih gledao s mnogo, mnogo dugo vremena, očekivao bih da ovi ovde intervali budu po 3Δt. Neće svi biti po 3Δt, neki će biti 2Δt, neki će biti 4Δt, biće i nekih drugih, ali kad bi se to sad usrednilo u jako dugo vremena, to bi li bismo da su oni u proseku dužina 3Δt. To je jedna stvar. Druga stvar, šta možemo da kažemo dalje? Možemo da kažemo, ako bismo gledali sad ovaj ciklus stanja. Ovo ovo odo ćemo da označimo T kao u stanju I, ovaj ciklus I, a ovde odo ostalo ćemo da stavimo da je 1 stanje. To kao ako i izašao i stanja, koliko vremena očekujemo da je 1 stanje. Znači imamo da je T<sub>SI</sub> plus T ovo i očigledno vreme ciklus stanja. Ovo ovde T<sub>SI</sub> smo odredili i rekli smo da je 1 kroz 1 minus P u Δt, delimo ovoliko ciklusa svaki dužina Δt. Sad bi bilo lepo da nešto kažemo i o ove druge vrednosti. Kako bismo njih mogli da povežemo sa celom ovom pričom? Ovde smo iskoristili informaciju o verovatnoći izlaska iz stanja. Ali nismo ni na koji način uključili celu ovu priču u kojoj smo prenaplinjavali statične verovatnoće različitih stanja. Ovo tako. Dakle, koja je verovatnoća da sam uopšte bio u nekom stanju? To će da mi utiče, recimo ako bih dobio da mi je verovatnoća da sam u stanju PBS 70%. Onda ako posmatram 1000 ciklusa ja bih očekivao do tih hiljadu do ciklusa 700 ciklusa budem u stanju BS. Da bi mi ispalo 70% da sam verovatnoće u tom stanju. Što je taj broj ciklusa koji posmatram veći? To bi trebalo više da ovo bude podložno zakonu verovatnoće da budu manja odstupanja kada ja uzmem i brojim ciklusa u tom stanju od onog što bi mi rekla verovatnoća. Dakle, zakon velikih brojeva. To bi značilo da ako ja imam ciklus neki, ja bih očekivao da nađem gde sam ovde pisao. Gde smo to pisali sad? Eogalt. To bi značilo da bi trebalo da očekujem da mi je T<sub>S</sub> padrem. Da je da nekom drugom brojem do pisa.

To bi značilo da bi trebalo da očekujem da mi je T<sub>si</sub>, koliko sam bio u tom stanju, dužina ciklusa, na neki način približno i jednaka verovatnoći stanja s. Ili verovatnoći da sam u stanju s. Statičkoj verovatnoći tog stanja. I tako. I to je druga stvar koju imam. I treća stvar koju imam. To mi je ovo ovde T<sub>ci</sub> koje bi na neki način trebalo da povežem sa rekurentnim vremenom stanja. Šta je sad to rekurentno vreme stanja? Opet, za to mi treba statička verovatnoća da sam u nekom stanju. Ako mi neko kaže da je verovatnoća da sam u nekom stanju jedna trećina. Pa ja bih onda očekivao da je u proseku svako treće stanje to stanje. I tako. Ako posmatram neku sekvencu, ja bih onda očekivao da je svako treće stanje to stanje. To bi značilo u suštini da je onda meni očekivani razmak između dva takva stanja, 3. Znači, svako treće je to stanje. To jest, očekivao bih da je t<sub>ci</sub> koja zapravo mogu da napišem kao rekurentno vreme stanja. U suštini, jednako, pardon. Mislim, pa hteo. Rekurentno vreme stanja i u suštini, jednako Δt pros, verovatnoće da sam u tom stanju. U tom stanju i. I tako, ako sam rekao da mi je svako treće stanje stanje Bs. To jest, ako sam rekao da je statička verovatnoća stanja Bs i jedna trećina, onda bi bilo logično očekivati da je svako treće takvo stanje u povrci Bs. Odnosno, očekivao bih da je razmak u dva takva stanja u povrci. Jednaka tri, tri Δt. Odelim jedan kroz jedna trećina, dobijem tri i pomnožim sa Δt. Znači, rekurentno rekurentno vreme stanja mi je Δt kroz Bs i. Dobro je, šta je s ovim vremenom ciklusa? Ajde da ga izvučem. Pa sad imam da je vreme ciklusa T<sub>ci</sub>. Evo je psi da poklaćite sam u to stanju. Znači, to će da ide dole. Očekivanje njega prebacim desno. Onda ću imati da je ovo T<sub>si</sub> kao ciklusa koliko sam se zadržao u tom stanju. Očekaj, psi verovatnoća da sam uopšte u tom stanju. I onda bih bilo zamenim, dobijem t<sub>si</sub>, sam rekao da je Δt kroz 1-p i još puta psi. I ovo je sad kao praktično formula za vreme ciklusa nekog stanja. I tako. Vreme ciklusa nekog stanja. Koliko traje ciklus nekog stanja, možete na ovaj način da procenite. I to je u suštini svašta ove da može da se dalje računa. Toliko o sistemima sa 2 statičke particije. Rekao se možete pogledati zadatke na rokove imati prethodnih godina. I ako budete imali nekih pitanja slobodno, idite ili na konsultacije.
