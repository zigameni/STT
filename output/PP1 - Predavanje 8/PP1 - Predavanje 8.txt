 Parceranje od vrha kadnu, odnosno top down parceranje, u lekciji ćemo prvo obraditi osnovne koncepte parcera od vrha kadnu, zatim ćemo videti konkretno kako se konstruišu parceri od vrha kadnu, definisat ćemo odgovarajuću klasu gramatika za koja ta konstrukcija uspeva, to su LL-i od 1 gramatike, vide ćemo i bitan pojem selekcionog skupa smene koja pomaže parceru u svakom koraku rada da odluči koju smenu će sredeću i zabrati, takođe ćemo razmotriti šta ako gramatika nije LL-i, znači moguće equivalente transformacije gramatika da se dobije pogodna gramatika za parsiranje od vrha kadnu i konacno vide ćemo kako se top down prepaznalače proširuju u procesoru da obavljaju syntaxnu upravljanu prevođenju od vrha kadnu na osnovu atributivno translacijeno gramatike, takođe ćemo videti kako se vrši oporava kod greške, kod ovih top down parcera. Koncept parsiranje od vrha kadnu je taj da parser na ulazu ima kompletnu ulaznu sekvencu i da je zatim procesira sa levo na desno znak po znak i pri tome parsere konstruiše celokupno levo izvođenje ulazne sekvence počuva od startnog neterminala, znači ako se posmatra stablo izvođenja odkriva ga od kore na kalistojima. Znači raca obavlja u diskretnim koracima i u svakom koraku rada parser pokušava da uparite kući simbol i sentenselne forme koju trenutno razmatra sa delom preostalo ulaz. Ako je tekući simbol u stanju parsera terminal, znači isti taj terminal mora da bude i tekući ulazni simbol, inače dolazite do greške i prekida parsiranje odbijanje ulazne sekvence. Tada se u tekućem stanju pređe na sledeći gramaticky simbol i takođe na ulazu se konzumira tekući ulazni simbol i pređe na sledeći. Ako je tekući simbol u stanju parsera neterminal, onda je potrebno je zabrati jedno od smena koju se taj neterminal zamenjuje i na taj način dobija nova sentenselna forma u stanju parsera za razmatranje, a tekući gramaticky simbol postan je prvi simbol te izabrane smene. Videćemo da pojam selekcijnom skupa smene nam daje rešenje koju smenu izabrati, jer tekući ulazni simbol mora da se nalazi u selekcijnom skupu izabrane smene. I ova procedura se ponavlja, znači sve dok se rekonstuliša celokupno levo izvođenje, ako je naravno ulaz ispravana. Evo, sad ćemo vidjeti na primeru ove male gramatike od četiri smene, gden još dodatno pomoćimo da svaka smena počinje drugim terminalom, tako da je bilo lako vidjeti na osnovu početka smene, šta se očekuje. Kret ćemo od stanja parsera, to je startni neterminal, a z druge strane na ulazu, na primer imamo ulaznu sekvencu u malo ACDD. Potrebno rekonstruirati korake između u izvođenju iz S do finalnog ulazno gniza. Parser počinje, rad razmatanjan startnog neterminalom, na tom je u stanju tekući neterminalni simbol, i naravno prvi simbol ulazno sekvence malo je tekući ulaz. U obzir dolaze, kad gledamo gramatiku smene za S, to su prva i druga, i na bazi tekućeg ulaza odlučujemo se, to jest parser se odluče za primenu prve smene. Primenom prve smene, u opšteni slučaj, tekući ulazni simbol mora da se nalazi u seleksionom skupu i zabrane smene, a po anseleksionom skupa ćemo malo kasnije definisati. Kada jednom izaberemo smenu, u stanju parsera S se menja, destom stranom izabrane smene, dobijemo malo A, A, B, i to je sad novo stanje parsera, u jedno smo dobili i ova i jedan među korak izvođenja, sada smo mesto polaznog S dobili sentencelnu formu malo A, A, B, to je stanje parsera, i z druge strane na ulazu je nepromenjenu tekući, simbol je prvi simbol malo A. Esad smo rekli da važilo, da se ako je u stanju terminali na ulazu, znači terminali moraju da se poklopi i prosto parser pomera po inter, znači da mu je sad tekući simbol u stanju parsera sledeći, znači ove liko A i za malog A, u stanju parsera, a u tekućem ulazu takođe, znači prelazimo na sledeći ulazni simbol, to je malo C. I sada je potrebno na bazi znači tih informacija da imamo veliko A i malo C i zabrati smenu, jedino smenat za veliko A je treće smena, znači tu čak i nema neku gizbora, i menjamo, znači, A, D, stranom, treće smene, čime to bijamo rekonstruišano sledeći korakovo krainje levoj izvođenja, pošto suvek napada ovej simbolu prvi netermino sleve strane, znači u mesto veliko ga, njega smo zameneli sa malim C, velikim B u ovoj sentensijonnej formi, i to bili smo sad ovako tekuće stanje parsera, gde je, znači, početak treće smene tekući simbolu stanju parsera, a z druge strane tekući ulaz je nepromenjeno ostalo malo C, ne sad, znači, uparujemo, naravno, malo C u stanju i u tekućem ulazu i pomeramo po interese po jedan simbol na desno, znači, sad je tekući simbolu stanju veliko B tekući ulaz malo D, to znači, treba primeniti smenu za B, ja to je četvrta smena, primjenom četvrte smene menjamo, znači, veliko, ovo prvo, veliko B malim D, i posled toga, znači, opet još pomeramo po interese, znači, uparujemo D u stanju i na ulazu, pomeramo po interese na drugo, ovo veliko B u stanju i na poslednje D u ulazu, opet se vrši zame, znači, primjenom četvrte smene veliko B malim D u stanju i, z druge strane, ovo je u tekući ulaz ostalo nepromenjen, i konačno sad kada uparimo terminal u stanju i terminal na ulazu i pomerimo po interese na desno, došli smo do kraja ulazne sekvence i vidimo da smo upravo u tekućem stanju dobili upravo ulazno sekvencu, znači, potpunosmo re-konstruisali izvođenje te ulazne sekve. Celo od startog ne terminala, parser je na uspešan način završio rat. E, sad da vidimo kako praktično konstruisati jedan parser koji radi po ovom konceptu, postoje ražiti metodi konstrukcija tih topdamu parsera, postoje tabelarno vidu potisnog automata kojim se zbog ograničenog fondačasova na kursu nećemo baviti, nego ćemo pokazati metod rekursivnog spusta. To je jedan zanimljiv metod koji samo zahtajeva da parser implementirate u višem programskom jeziku koji ime rekursiju. Kot potisnog automata znamo da imamo stack koji određuju rade automata, a ovde ustvari runtime stack programskog jezika na neke način preuzima tulegu parserskog stack. Metod ćemo objasniti na konkretnom primeru. Ovo je jedna gramatika od 8 smena koja ima malo specifican oblik, ali to narao nije važno za sam metod konstrukcija da kako interpretiramo ovo gramatiku. Ali evo, čisto da napomenem da ova gramatika opisuje aritmetičke izreze koji imaju operacije sabiranja množenja preko ovih uvođenja netrvenog zvištini množenja ima veći priorite tot sabiranja. I obve operacije su levo asociativne, obavljaju se sleva na desno. I z druge strane, znači još dodatno prioritet može da se menja zagradama, znači izreze mogu da se primene zagradu, da je opisu infiks način, od metičke izreze, a operandi su reprezentovanji ovim terminalnim simbolom veliko i. Ova gramatika deluje neupredilog komplikovanji od gramatika koji bi smo mogli da opišamo aritmetički izrez koja bi recimo glasila E je T plus T ili tako nešto. Zašto, ove to sve razdojenu u više smena pa to je upravo posledica transformacija gramatika koji ćemo raznije pričati, znači da smo napisali tako prostiju gramatiku za izrazek kojima smo se sretali kot botom app parsera i koje su često imale i eku direktnu levu rekursiju da na levo i po četvu desne strane imamo isti netemina, znači top down parser ne mogu da obrade takve gramatike izbog njih, toga je potrebno vršiti transformaciju takvi gramatike i kao rezumtrate transformacije mogu da se dobi ove malo manje pregledne gramatike, ali znači koje lepo se ponašaju u top down parsiranju. Bez obzira na to vide ćemo neke formalne uslove koje gramatika mora da zdođevite i da se dovoljevi da mogu da se parsira, ali zaznači se vratimo na primer i zapet postajimo da su ti uslovi za dovoljeni za ovu gramatiku i da vidimo kako se može konstruisati parser na bazile kursimog spusta. Znači program sko rešenje i šini jedan glavni program i nekoliko podprograma metoda, znači funkcija, po jedan podprogram imamo za svaki gramaticky neterminal, na čo ovom konkretnom slučaju poštu u gramatici imamo e, list, t, t, list i pe, toliko treba da imamo tih podprograma i oni će imati samo prefix prot, prot, c, prot, c, list i tako dađe. Podprogram za određeni neterminal ima ulogu da prepozna primenu neke od smena sa datim neterminalu na levoj strani i upari neterminal sa ulazom u skladu sa prepoznatom smena. Recimo za gramaticku smenu ove gramatici 7 i 8 smena sa odnoseno neterminal, te one su jednostavnije pa da vrenemo obješljenje od njih. Zadima da 7 smena ima na desni strani e u zagradama, a 8 smena ima terminal i, znači zagrade su na no terminalni simboli e neterminal. Procedura P treba da pokrije delo procesiranja parsera za prepoznavanje 7 ili 8 smene na osnovu tekućeg ulaza. Mi ćemo uzeti da u programskoj rešenju kosto i globalna promenjiva in koja predstavlja tekući ulazni simbol, znači ulazom u tom trenutku. U smenu bih nam u pravo na osnovu tekućeg ulaznak simbola, videli smo da 8 smena ima samo i na desni strani nače koje i tekućeg ulazni simbol, da prepoznamo smenu 8. Ako je otvorena zagrada tekućeg ulazni simbol, da prepoznamo smenu 7 koji ima otvornu zagradu e zatvorenu zagradu. U svim ostalim slučajima ulaznak simbola na defaultu sušli nigran, ali ovde ekspensitona vedena šta ješ mogu biti ulazni simbol i to su oskali terminali u gramatici plus puta, zatvornu zagrada i end marker. Parser završava rad uzodbijanje ulaza. Také izgrana nam služi da skoćimo na del koda procedure za prepoznavanje određene smene. Ovde eksplicitno datorešenje celosko sa go to da bi se naglasila sa ovim labelama koja smena se prepoznava, ali je to moglo, taj kod može da se ugradi direktona, znači nevora se koristimo u tu nego u direktom svaku grano ovde. I sada vidimo znači kako se pojedine smene prepoznava.
 nam je u ovom primjeru bilo lako da odredimo kad je tek ućivla za određeniju znak koju smenu prepoznamo, pošto tačno svaka smena počnja određeni terminal, međutim u opštenu slučenu smena može da počne na terminalu, ili da bude prazna smena i tada je malo komplikovanja s situacijama, ali mi ćemo nju razrešiti kroz selekcijone skupove smena, o kojima ćemo kasnije pričati. Ovdje je opis dela koda koja je dogovara prepoznavođenju određeni smene, kod treba tako da formiramo što razmatramo desnu stranu smene redom znak po znak slučenu. Slevan na desno je sada ko je određeni znak neterminal, onda treba pozvati odgovarajući pod program. Ako je određeni znak terminal, onda potrebno je ispitati da li je znači tek ući ulaz u tom trenutku jednak terminal, oako jeste, pozvati funkciju koja napredo je ulaz za jedan znak, odnosno prelazi na sledeći znak, na ulaze u nasovimo je next car, a ako ne dođe do poklapanja, ono ga što čekujemo u tom trenutku smeni terminala i tek ućeg ulaznog terminala, onda se reduzima akcija reject kojim se završava radu z odbijanje ulazne sequence. Tako da kad znamo ove opise, sedma smena je znači na desnu stranu imala otvrenu zagradu e, zatvrenu zagradu, prvo je potrebno upariti ovo otvrenu zagradu sa tek ućegu ulaza, međutim, to smo već uradili ovo i case komandi koja nas je dovela do ovog slučenu za sedmu smenu, tako da ne moramo da ponovu ispitujemo, da li je tek ućeg ulaz jednak otvrenu i zagradi, nego samo stavljamo prelaz na ulazu na sledeći ulaz, i to opet a žuriramo na globalnom promenju i koju vidi svi ovi podprogrami i time smo obradili otvrenu zagradu po tom na desnu stranu ide e i tu je potrebno ugraditi, povziv odgovarajućeg metoda funcije procedure e, i zatim potrebno je pariti do zatvrenu zagradu u sedmi smeni, sa tek ućegu ulazom, znači, da li je tek ućeg ulaz u tom trenutku kad se vratimo i znači procedure e, zatvrenu zagrada ako jeste, onda prelazimo na sledeći znak na ulazu i završavamo procesiranje, evraćemo se iz procedure e, jer smo potpunno uparili ovu smenu, u suprotom sluči reject. Vide ćemo kasnije i druge delove programa za druge smene. Šta treba da uradi glavni program? On mora da inicijale za promenju i inda ukaže na prvi znak na ulazu, da pozivao je pod progen za startni neterminal, čim je inicirao, znači, uparivanje celu ulaz na sekvenci, jer u suštini kad pozivamo progen za neki neterminal, on će upariti deo preostalo ulaza sa, da kažem koliko taj neterminal reprezentua, što se tiče startom neterminalom, treba da reprezentuje celu ulazom sekvencija, ako je ne ispravna, tako da znači kad se vratimo i ste procedure za startni neterminal, potrebno je ispitati da li ispacesiran c ulaz, tako što ćemo ispitati da li je tek ući ulazni simbol Marker kraja ulazne sekvence, ako jeste onda znači kraj, uspešan kraj rada parsiranja accept, ako nije neuspešan kraj parsiranja reject, evo ovdje glavni program, ovdje je kompletno rešenje za datu, grammatiku i za sve druge procedure, mi smo razmatrali proceduru P koja imala sedmu i osmustmenu, videli smo za sedmustmenu, za osmustmenu je još jednostavnije, znači, da se ulazimo na ulaz, tako da samo prelazimo na ulaz u nasredneći znaki i vraćamo se iz procedure P, i tako dalje znači, za sve druge procedure po ovom očnih pravilima je napisan kod, vidimo znači da su procedure uzajavno rekordzivne, znači iz jedne procedure se poziva, druga onda se iz druge neke procedure opet poziva, treća ta treća opet može da pozove prv. Sad je došao trenutek da objasnimo pojem selekcioni skupova i da vidimo koje to grammatike što moraju da zadovoljavaju, da bi mogli da se procesiraju ovi metod. Selekcioni skup je skup ulazni simbola koji mogu predstavljati tekući ulaz u trenutku prepoznavanja neke smene koje ima neko x na levoj strani, a neku sekvencu grammaticki simbola alpha na desnoj strani, i znači skup tih terminalnih simbola naziva sa selekcioni skup smene i označrva ovim terminom select. Pridruže nje smene. E sad da bi parse na jedno značin prepoznava u nizu smena za istine terminal x, da bi moglo jedno značno se odruči za jedno od njih, selekcioni skupovi parova smena sa istom levom stranom ne smaju sadržati ni jedan zajedničke element, odnosno njihov presek mora biti pradna skup, odnosno oni su disjunkni. Gramatike kojih je ovo ispunjano, znači kad ispitate bilo koji par smena se istom levom stranom, nazivaju se LL od jedan grammatike, znači to je slična skraćnica, kao što smo upotrebljavali kod botom apparsera, i prvo L znači da parser gleda ulazna sekvenca s leva na desnoj, drugo L znači da se gleda FtMostDrivation, odnosno, levo izvođenju ulazne sekvence i da se pri odlučivanju oslećen koraku gleda jedan simbol sa ulaza. Kako operativno računati selekcijone skupove? Možemo preko veđu definisanih First i Follow skupova, znači za neku smenu selekcijne skup smene je jednak First skupu njene desne strane ako desna strana nije poništiva, odnosno First skupu desne strane unija Follow skupu leve strane ako je desna strana poništiva. Mi smo veđu definisali pojmove First, Follow i Poništivosti i nizova simbola, tako da možemo samo videti kroz jedan primer da izračunamo selekcijone skupove. Evo ga primer, Gramatike od 7 smena, koja ima i ponegde prazne smena, one su uvek problem, kad recimo studenti ne ispitune, čunaju Selective Follow i tako dađe skupove najčešće na prve grešku kot praznih smena. Znači mi treba da odredimo selekcijni skup svake smene i posledo toga da ispitamo da li se radi o L, L od 1, Gramatici. Znači da bi izračunili Select, moramo izračunati poništivost, ne terminala, poništiva skalo što znamo je postojenje prazne smene za A i B, odmah vidimo, a C, pošto nema mogućnost da se 6 i 7 smena desne strane izvede prazna sequensa, znači C nije poništiv, što se tiče Fr skupa, ovdje je olaksano, pošto svaka smena koja nije prazna po činje terminalim simbolom, znači onda odmah vidimo da je 1st od A, na bazi 1. i 2. smene M, B, a 3. smena ništa ne doprinosi ton Fr skupu i tako dalje za B M, A i za C je na bazi 6 i 7. M, B i M, C u Fr skupu. Vešto se tiče follow skupova, prekrij smo da se razmatraju pojave nekoh Gramatickog simbola na desnoj strani smene, znači pošto se A ne pojavljio na desni stranama, pošto u pitanju stakni netem, njemu samo dodemo End Marker. Za B i za C, ovo je primer koji smo mi rani je radi li i mi smo našli za B iz 1. smene, znači treba dobuha ti 1st od C, zatim na bazi 2. smene mora dobuha ti follow od A i kad se to sve napravi unija svega toga dobimo B, C, End Marker, takođe iz 4. smene M, A, B, sledi i za velikog B. Ašto se tiče follow od C, na bazi 1. smene, znači u sebe obuha da follow od A odnosno End Marker, a 6. smena ne doprinosi pošto kaže da follow u C u sebe u buhvata i skupa follow u C, što već znamo. Znači ostaj samo End Marker, tako da smo sve dobili follow u skupove i sad je otrebno odrediti selekcije o ne skupove. Znači select 1. smene vidimo odnosno da je to malo A, select 2. smene malo B, je sad zanimljivi i slučaj je select 3. smene. Tu moramo primeniti ovu drugu variantu formore, znači 1st od prazan sekundce, prazan skupne, da je nam ništa i moramo uzeti follow u skupove znači to je follow od A odnosno End Marker, znači select 3. smene End Marker, što se tiče 4. smene, znači to je malo A, što se tiče 5. smene, isto moramo uzeti follow od B, a follow od B, B, C i End Marker. Što se tiče 6. smene, to je malo B, select 3. smene, i što se tiče 7. smene, to je malo C. I znači dobilismo select 7. skupove svih 7. smena, šta je sad potrebno dodatno ispitati, dali, kad se gleda prva, druga i treća smena, znači select 7. skupove, nesmeju sadržati ni jedan zajednički element, što je ispunjeno, znači kad se gledaju 4. i 5. smena koje imaju B na levoj strane, znači njihovi select 7. skupove nesmeju imati zajedničkih elementa, to je ove A, a ovde su svih drugi, znači simboli 7A, tako da je i tu ispunjeno, i konačno, kojih od 6. i 7. smena nesme bi ti zajedničkih elementa, to je on skupove, ma što isto ispunjeno, znači pošto je sve to ispunjeno, da bi se pošto struisati top down parser na bazi rekurzivnog spusta za ovog grammatiku. P1m case, strukturama kada se odručujemo za neku smenu, uzimamo u obzilove izračunate select 7. skupove. Šta kada grammatika nije LL1, nači kad dobijemo negativane za utrapos izračunavanja select 7. skupove, možemo probati neku od ovih transformacija da bi smo dobili grammatiku koja prepoznaje i ste ulazna sekvence, ali koja jeste LL od 1. Ove transformacije mogu u praksi da pomogno često, međutim teorijski ne garantuju da ćemo dobiti LL1 grammatiku i opšte mogu postojati jezici i grammatike za koje ne postoji uopšta ekvalenta LL od 1 grammatika. Pošto videli smo rani je kad smo pričali o tim determinističkim parserima sa jednim ulaznim simbolom, doprosno oni pokrivojuju samo podskup skupa svi bezkonteksni grammatik. Imamo tri neke transformacije koje ćemo prikazati, jedno je uklanjanje direktne LL2, drugo je dobar služenija transformacije uklanjanje indirect LL2 i treća ova leva faktorizacija, veli očesto se primenuju prva i treća, a ova druga po potrebi, ali ređa postoji potreba za njoj i dostazd komplikuje grammatiku koja se dobio dokove prva i treća su u suštini zgodne za primjenu, zato što nisu pretranokomplikovane. Kod uklanjanje direktne LL2, tipično imamo u grammatici smetni.
 koja ima na levoj strane neki neterminal x i onda desna strana počinja tim istim x, ima neki dalje proizvolj je nastalak, a možem ta isti x imati jedno i lišno smena, da je u čijel desna strane ne počinju veliki mix. Ta prva smena se zove levo rekorzivna smena. Pošto će tako smena imati sigurno u svom selekcijnom skupu i simbole za ove druge smene, ona kvari koncept, znači top top down parsiranja. Kako ćemo transformisati odnosno dredite kvalentu grammatiku koja nema ovo negativno svojstvo, znači direktne levo rekorzije, mi ćemo uskoro vidjeti pravila transformacija, ali da ih ne bi učili na pamet, treba da vidimo u svu štini neku logiku, da zapantimo izatoga pravila logika, je sredneća, znači šta opisuju ove dve smene. Znači najkraća sekvenca koja opisuje x je beta, a duže sekvence se dobije od kraćih, tako što se dodaje alpha nola ili više puta na desnoj strane. Znači u štini to su sekvenca oblika koja počinju sa beta, a izatoga imamo proizvoljom broji alpha. Znači mi moramo isti tako sekvencu da opišemo, a da izbegnemo direktnu levo rekorziju, i, znači, sad pravila koja je generalizala na rupšnje sluče možemo imati za isto ovo x više, radište smena koje su direktno levo rekorziju, i takođe možemo imati više ovih drugih smena, či je desnoj strane nepočinju sa x. I sad znači čita ovoj skup smena za x transformiše se u smene, gde znači imamo niz smena koja či je desnoj strane počinju ovim betama beta1 do betan, a u nastavku je uvedeno novi not neterminal y. Uloga y nada opišao ovaj niz od nula ili više ovih simbola alpha. Tako da imamo znači niz novih smena, znači y mora biti nov uvedeni neterminal koji se do tada nije pojavljiv u grammatici, i, znači, opisujemo y niz alpha, i tako što koristimo desnu rekorziju, znači y alpha 1 y do smene y alpha n y, znači to u suštini niz desak element može biti bilo koji je ovaj alpha 1 ili alpha 2 ili alpha n, i konačno pošto to može biti niz od nula alpha i moramo imati i prazno smenu za y. Znači u mestu ovog skupa smena uvodimo ovaj skup smena i time uklanjamo direktnu levo rekorziju, naravno, ovo transformacije je ponekat potrebno ponoviti nekoliko puta, pošto jedna primena ove ili neke druge transformacije može ponovat uvedi direktnu levo rekorziju, tako da, promenjujemo dovoljom broj puta dok ne lijšemo sve direktno levo rekorzime smene. Što se teče indirectnu levo rekorzije, to je situacija kada recimo neka smena za x počinja neke neterminalne y, onda imamo znači smenu za y koja opet ima ovoj polazni neterminal x, naravno, mogu biti neke smene koje nisu rekorziju, znači u suštini zamenom nekoliko puta da kažem x koristeći nisme no, opet možemo doći do sentensijalne forme koja počinja se x i to je znači indirectnu leva rekorzija. Algoritam za uplenjanje indirectnu levo rekorzije, uvek može da se prijmeni na grammatiku, koj je ne postoje ciklusi, odnosno koj je ne postoji neki neterminal, gde bi mogli izvođenjemu jednom ili više koraka da dođete do istog tog neterminala. Sad ovova i uslob je tako da kažem opasan za grammatike, jer tako grammatika bi bila i dvosmislan, tako da ako je grammatika nije dvosmislan, sigla neće imati ni ove cikuse i u principu kažem ne mora se mnogo pažnja vraćati na tej preduslo, kako uklanjamo indirectnu levo rekorzije iz grammatike, algoritam delo je mnogo složenije nego ova predkodna pravila, ali detaljno ćemo proći kroz algoritam za jedan primer. Kao prvo, potrebno je grammatike neterminale poredjati uki redosle razmatranja, taj redoslet prosto može bito onim redom kako su napisane smene za njih i sad imamo dvostruku petlju, zpogljashnja petlja ide po ovom nizu neterminala redom od prvog k. Posledjem, unutrašnja petlja uvek ide od neterminala koji su pre ovog koji je tekući u spogljašnju, znači recimo ako u spogljašnju A2, u unutrašnji petlji razmatraćemo A1. U unutrašnji petlji, ako dođemo do smene koja ima spogljašnji neterminal na levoj strani, recimo to bi bio u ovom primeroštu se maveo A2, a da desna strana počinje sa ovim A1, onda je potrebno taku smenu eliminisati i prvuzeti sve moguće desna strana smena za ovaj A2 i u mestove origine smene, znači upisati nove smene gde ćemo A2 zameniti, znači redom desnim strana, znači ako A2 ima nekih k smena za A2, onda ćemo u mestove jedne smene dobiti k novih smena, gde će znači redom biti desna strana prve smene za A2, pa onda ovog gama, pa desna strana druge smene za A2, pa gama i tako dalje. Znači prosto smo na te načine eliminisali za ove smene A2. Kada se znači izadji istem u nutrašnje petlje, odnosno razmotre redom sviti parovi mogućih ovih neterminava, onda je još potrebno u spoljašnje petlje, prenego što pređa u nasrednji teraciju spoljašnje petlje, razmotreti, dali postoji direkt na leva rekursija po ovom neterminalu spoljašnje petlje i ako postoji, treba prema onom predkodom pravilom eliminisati i onda se pređa na srednji netermino spoljašnje petlje. To je u suštini algoritm, treba još dodati jedan detaj, a to je da pri naravno eliminaciji direkt leva rekursije moguće prema onom predkodom pravilu da se u gramatici pojave i novi neterminali, ovače koji nisu se pojavljivali u ovih inicinalisti, tako je nove neterminale treba dodati na kraju ove liste i mora se iterirati po njima. Znači ova lista nije fiksna samo na početku algoritme, nego može dinamicu i utok algoritme se prošire, o tome treba vodi treću. I avo sad jedan konkretan primer gramatike koja posleduje indirektnu levu rekursiju, zato što vidimo da, načine i posledu i direknu levu rekursiju ovdje recimo, spok druge smene, ali ime indirektnu, recimo, s je menja sa t, a t je onda menja sa e. Da ilustrem ovaj algoritm na ove gramatici, poredjamo neterminale u redom s e t i sad razmatramo, idemo u onu duplu petlju. Znači u prve iteraciji, spoljašnji neterminal je s. Unutrašnjeg neterminala nema, pošto nema ničeg levog od s, u potrebno razmotriti da li imamo direktnu levu rekursiju po s, nema, tako da smo završili sa, prvom iteracijom spoljašnje petlje i sa s. U drugu iteraciji spoljašnje petlje, e je spoljašnji neterminal i u utrašnjem petlju i u utrašnjem petlje s je neterminal. Znači razmatramo, da li posloje smene u gramatici koji imaju na levoj strani e, a da desna strana počinje sa s nema. Ima da je leva strana s, a da desna počinje sa s nema treba obrnom se. Znači u utrašnjem petlji nema transformaci i zljazi se iz u utrašnja petlje i onda je dodatno, treba proviriti da li postoji direktna rekursija po ovom neterminalu spoljašnja petlje e, to postoji to je ovo druga smena i primjenom ono pravira za uklanjanje direktna leva rekursija, zna, alpha je plus t, a beta je t, piszemo e je beta e primje nogu uvedeni neterminal i onda piszemo za nogu uvedeni neterminal e primje alpha, ovo puste e prim i e prim je e psilno. Znači dve nove smene za novi neterminal i taj novi neterminal stavljamo na krajove iteracionaliste. I tim smo završili sa e u spoljašnje petlji i prelazimo na treću iteraciju spoljašnje petlje gde je t te kući neterminal spoljašnje petlje, a, znači redom prvo razmatramo s pa onda e u utrašnje petlje. Znači ako gledamo da li imamo t na levoj strani, s na desnoj strani to nema, znači u utrašnje petlje nema promene, znači ako u spoljašnje na levoj strani imamo t, a u početku desnoj strane e, znači tu situaciju imamo situaciju da treba u smenu transformisati, znači zbacite u smenu i zameniti e svim njegovim smenama. Sva sreća za e imamo samo jednu smenu, tako da u mestove izbačene dodajemo samo jednu novu i u toj novoj smo ovo e zamenili sa t e prim. Znači to je bilo u utrašnje petlji i sad još dodatno liše nema šta da razmatram u utrašnje petlji, nego još samo treba u spoljašnje petlji razbotiti da li ima direktne leve rekursije po t. Znači ima zbog ove preposlenje smene i potrebno znači limini sa ti direktnu levu rekursiju. Ovo je beta, znači t e beta t prim novu uvedeni neterminal i dve smene za t prim znači alpha, to je s tovoj primanja t, t prim i t prim je epsilon i dodajemo i t prim na krajone uređene liste neterminala. I ti me smo završili s trećom iteracijom i sa t u spoljašnjjjjjjjjjjjjjjjjjjjjjjjjjjjj視. Šta je još ostrodo za spoljašnje petlju? Pa ono je novu uvedeni neterminal e prim A u nutrašnji petlji redom idemo s e t Gledamo da li imamo t prim na ove strani a neki od ovih pomenuti s e i t na desnoj strani Nemamo pošto ovo je prim to nisam pomenuto još dalje to nije nema promenu u nutrašnji petlji tako da završavamo potpuno obradu pošto nema ni direktne levu rekursije po e prim završavamo obradu za e prim i onda uzimamo t prim u spoljašnji petlji kao ove te gući i sad moramo redom da gledamo s e t i e prim u nutrašnji petlji ZA s e i t nema promene međutim za t prim u spoljašnji petlji a za e prim u nutrašnji petlji ima otrebe da se transformiš ova smena i da se izbacimo ovo e prim u mesto e prim imamo dve smene moramo napraviti dve nove smene jednom ćemo e prim zameniti sa plus t e prim drugi put ćemo e prim prosto samo izbaciti primeno ove prazne smene tako da u mesto ove jedne smene dobijemo ove dve smene i sad pošto izlazimo iz nutrašnje petlje i nema u nutrašnje petlji šta da razmatram još razmatramo da li postoji direktna leva rekursija po t prim pošto t direkne leve rekursije nema zaključujemo da je ovo finalna grammatik time smo završilo ovo komplicno opravilo uklanjenje indirektne rekursije a sad opet jedno jednostavno pravilo vezano za levu factorizacijom ovo pravilo primenjuje se ako u grammatici imamo nismena za neki neterminal ovde napisan es ove pte smene mogu imati ražite desna strana međutim te desna strana mogu imati neki zajednički prefix alpha
 pa onda je neki radit nastavak. I znači, ovo alfa smeta u nekim selekcijnim skupovima, znači uzrokovac će da isti terminali ući u selekcijnim skupovima i ove smene, i da bi to je li mi nisali, mi u suštini opjedinjavamo, znači uvodimo novi neterminal S-prim koji će opisati ove različite nastavke beta 1 do beta n i u mestu ovih originele smena ostavljamo znači smenu za S koja počinja sa alfa i za, znači, stoj i taj novu uvedeni neterminal, a novo uvedeni neterminal opisuje ove različite nastavke. Rekao sam nije garantolano da ćemo ovako gramatiku dovesti u l-1 oblikali, uvek je olaksana situacija kod ovih programskih jezika, što te gramatike relativno lako uvek mogu da se transformišu u malo praktičnog iskust. Evo, jedan čisto teorijski primari, jedan informativni slajda, postoji, recimo, jezik koji nije uopšto opisiv l-1 gramatikom, to je jezik koji se sastoji od dve vrste sekvenci, znači ulazni simboli su malo a, nula, jedan i malo b. I onda ako imamo sekvenci koja počinja sa jednim ili više malih a, onda ide nula i onda ide onoliko b, koliko je bilo ovih a, to je jedna vrsta sekvenci, a druga vrsta sekvenci je, znači, da počinju sa malima jedno ili više, zatim da ide jedinica, a da pose toga ide recimo b, duplo imamo b, ovako je bilo a, ovva na početku. Ako je jezik definisana ovaj način, mi možemo napisati neku bezkonteksnu gramatiku za ovaj skup sekvenci, sekvenca ovog tipa ćemo opisati sa ovim esprim, sekvenca ovog drugog oblika ćemo opisati sa esekundom i onda ćemo ih, na rovom podvesti pod zajedničke ovaj neterminal s, kako opisujemo recimo sekvence ovog oblika, pa najkraća takva sekvence a0b, a duža sekvenca se dobija od kraća, tako što napred dodamo a, a nazad b. Za ovaj drugi oblik sekvence isto najkraća sekvence a1bb, a duža sekvenca se dobija tako što nakraću, napred dodamo jedno a, a nazad 2b. I kao što vidimo, nije nikakaprolet da se ovo opiša bezkonteksnom gramatikom, međutim, ova gramatika nije l1, zato što recimo selekcijuni skupovi, ove prve dve smene imaće zajedničko a. I naravno, bez nekog satformalog dokazivanja, na ulazom mora da se prođe svih ovih n, h da bi se došlo doove n ljedi nice, da bi se ko se moglo videti, da kad je da je oblikowa ili oblikowa onaj, a 0 i 1 ne mogu biti u istoj smeni, tako da kad se to razdvej na dve smene, ne možemo gledajući samo jedan simbol na ulaza uvek, će znači negde biti konflikto, to je priješljenje zašto ne može da se nađe za ovoj jezik l1, l1 gramatika. Sintaksnog pravano prevođenje od vrha kad nu, kako proširiti parcer koji je prepoznavač, koji samo određuje da li je sequence ispravno ili ne, da obavlja atributino translaciju, specificirano u nekom atributino translacijanom gramatikom, evo koncept jedan koji pomaže da se na neki logične način zapamte pravila koje ćemo formalno posled definisati, znači ako imamo neku smenu koja ima na levoj strani neki neterminal a, a desna strana na primer ima neke gramatike simbola odde su zadati b i c, onda treba u suštini zapamtiti pravilo da nasleđeni atributi neku gramaticku simbola u stvari određuju u proceduli rekorzivnog spusta ulazne parametre, asintetizovanje atributi su izlazni parametri procedure, nači ako se ta logika zapamte, onda su je drugo logičko proizilazi iz toga, jer mi znamo da način onaj rekorzivni parcer kad obrađe ovako jednu smenu, prvo u runtime ulazi u proceduru a, da bi prepoznavo njenu desnu stranu, a to znači pošto su nasleđeni atributi a, ulazni parametri oni su već poznati, njih je definisano naiko poziva a, zatim da bi se pri prepoznavanju, znači isprocesiralo b, mi ćemo zvati proceduru b, ali znači pre tog poziva moramo izračunati nasleđene atribute b ka ulazne parametre, znači za proceduru b, znači to je sreća što se računa, zatim dolazi do tog poziva procedure b, u notar toga se računa ju naravno izlazni parametri b, to je simtetizovanje atributi b, znači to je sreća što se računa, zatim kada se vratimo opet iz poziva b, moramo izračunati ulazne parametre za c, to je nasleđene atribute za c, i posled toga znači ide taj poziv c, gde se računa ju simtetizovanje atributi o c, i konačno kad se vratimo iz c šta je poslednje što se računa, izlazni parametri od a, i posled toga se dešava povratak i iz procedure a, znači redosled je upravo ovoj pojedini kategori atributa pojedini simbolo ovaj koji smo naveli. Znamo čak i od kojih atributa koji mogu da zavisili, recimo, ovi simtetizovanje atributi a, pošto se računa ju poslednje, oni mogu da zavisili od bilo kojih od ovih, redkodno, pomenuti atributa nasleđenih od a, nasleđenih od b, simtetizovanji od b, nasleđenih od c, simtetizovanje od c. Dokrecimo, ne znam, nasleđeni atributi od b, pošto se oni računa ju odnopri pozivu a, oni mogu da zavize samo od nasleđenih od a. Znači u glavnom, od ovih svih koji su, od njih u smene. I znači, ova pravila koja sam ja ovde neformalno objasnio, kao način, kao neku logiku, kako zapamtiti, se formalizuju kroz pojem l atributivnih gramatika. Znači, formalno, u slavi koja mora gramatika da zadovojava da bi bila l atributivna, je da nasleđene atributi simbola sa desne strane smene mogu da zavisili od nasleđeni atributa sa leve strane i od bilo koog atributa bilo koog simbola koji je na desne strane ispred posmatranog simbola, zatim, sintetizon je atribut simbola sa leve strane, smene može da zavisili od nasleđenih atributa tog simbola i od bilo koog atributa bilo koog simbola sa desne strane smene i konacno, sintetizon je atribut akcijonog simbola, smen je da zavisili sklučivu od nasleđenog atributa istog akcijonog simbola. To ću prva dva pravila sam opisao o ovom u ovnom pretvunom primjeru, jedinu znači, još treba dodatno zapamtiti ovom pravila, da još to su tiče znači, njegovo sintetizone atributi je da zavisili sklučivu od njegovoj nasleđenog atributa znači to je najlakša možda zapamtiti po tome da akcijne simbola može tisto implementaciji sklatiti kao posebom podprogram za sve sebe pa znači njegovo nasleđene atributi je njegovo ulazni simbol, a njegovo sintetizone atributi je njegovi izlazni neki parametar, tako da logične da izlazni parametar zavisili sklučivu od ulaznih. Zmotrimo sad kratak primer što se tiče tih pravila, čega koji atribut može da zavisi da bi bili za dovolje i uslovi l-atributivnosti, znači kaže sveće smene su dajoneke atributine grammatike, znači posebom se razmatraju tačke a, b, c, u svako od njih p, q i r su nasleđeni atributi, a s i t sintetizovanji. Zna svako od smena pronat će od koji sve atributa mogu da zavisati atributi p i r, da bi smena bila l-atributiva. Ako razmatrimo znači, ovo prvo pravilo za a, šta možemo reći? Znači atribut p je nasleđeni atribut, znači ono se računa naravno kad je na desnoj strane smene to je u redu i rekli smo da ovo može da zavisati od nasleđenog atributa simbola na levoj strane, a to je samo q, i od atributa simbola na desnoj strane koji je levo od p i njegovog simbolat, a to je a i njegovatribut u. Znači p je samo može biti funcij od q i u. Što se triča atributa r? Znači to isto nasleđeni atribut na desnoj strane i može da zavisi nači nasleđeno na levoj strane q i od ovih atributa ovih simbola koji su na desnoj strane ispred a, a to su ispred veliko gato su, znači u i t i p. I konačno nije se tražilo li možemo reći da i odetra definicati sintetizavni atribut simbola na levoj strane s, a on može da zavisati prakšno svih drugih atributer, samo poslednji računa. Slično to mi je u tački b, znači vidimo da p može da zavisati samo nasleđeno q na levoj strane, r može zavisiti o to u i od ovih koji su, znači, levo od veliko gato na desnoj strane p i u i tako da li u tački c nasliča način. Kako proširiti naš prepoznavač da obavlja ovo sintetismo upravljano prevojđenju, u slučaju znači da su zadovoljeni uslovi el atributivnosti i da sama grammatika, znači stičanih njenih selekcijnih skupova zadovoljava najlalijadan uslo, nači ako je sve to zadovoljeno, onda je moguće konstruisati procesom za taku grammatiku i osnovna ideja je znači da nasleđeno atribute prenosimo po vrednosti kao ulazne parametru pod programa, sintetizovane atribute po adresi kao izlazne parametre, jer njih može poseb poziv vlad za koristite njihove promenjene vrednosti. Svi atributi koji su sa desne strane koji se pominju, znači nekog sve njih na njeni desne strane, dođe biti postat će lokalne promenjive, nači svi atributi istog simbola sa leve strane mora imati isto i mer, to su sad postoju formalni parametri. Misli sa kog ima više smena za tajih simbol, onda ih moramo dovesti na isto ime i poslednje tačka je jedna mala optimizacija koja može da se sprovede, ali ako se ne sprovede nije strašno, a to je da neko pravilo prosto kopiranja vrednosti da izdobije vrednost od ipsalon, može su potpunosti, ali mi nisati preimenovanjem iksu ipsalon ili obrnuto. Pričemo se samo ne smeljume menjati imena atributa sa leve strane koje smo ovim predhodnim pravilom doveli na ist. Evo, znači jedan preneg da ćemo ilustrovat i sve to i kako izgleda odgovarajući procesor, vidimo da gramatike ime neke četri smene, zve za veliko sdve, za veliko a, i ima i neke akcijone simbole, i ima znači neka atributivna pravila, naravno bilo bi potrebno proveriti, da li je u pitanju l-1 gramatika, to nije teško, znači vidimo da prva i druga smena ime vražitice elektrensku upvena počin smalima, druga malim b, isto važi za treći četrtu smenu, jestli su se tiče u slova l-atributivnosti, trebalo bi naravno sad videti koje su vrste atributa, i naravno proveriti, da li je zadovoljeno evo mi možemo za prvu smenu pogledati, znači vidimo da d-v se računa, to je znači nasleđena atributakcijnog simbola i on u principu, znači može da zavisi od bilo kojih ovih atributa, znači kuh je sintetizovan i na levoj strane, znači kuh ne smedazavisi, ali smedazavisi od ovih atributa koji su na desne strane levo od akcije b, znači to su svi oviti druge.
 atributi na desnoj strani i on zavisita od njih i zavisi. Onda x je očigledo nasleđen je atribut ovog velikog a na desnoj strani prve smene i on zavis je od x1 na x1 je atribut terminal uksminivog roza koji znamo da je u tom trenutku prepoznavanja testmene dati, njega da je leksički analizator, tako da je to sve u redu. Zavis je od simbola levo od sebe, kao nasleđen i to je u redu i konačno kuj je sintetizovan je atribut, prvi se ovom posljednje računo on može znači da zavisi bez problemot bilo kogod ovih atributa. Znači recimo za pravu smenu zadovoljeno je pravilo je atribut, tismo tako može da se proveri za sve ove druge smene. I sad kako konstruišamo procesom, pa prvo ćemo uraditi vreimenovanje atributa, ono što svakako moramo da uradimo to je da dovedemo atributa u tovi simbola na levinj stranama smene, znači recimo za s mora ovde biti isto imeni atributi, to je uradjeno tako što je r1 preimenovan na q, takođe u ovde moraju biti isti atributi, vidimo da je su preuzeta ove imena iz 3 smene i za 4 smene. Dodatno možemo ili mi nisati ova pravila prosto kopiranja vrednosti, vidimo da su ta pravila recimo u prvi smeni, imamo 2x dobija vrednosti od x1 i q od q1 i preimenovanjem x1 u x, če ovdje bi u x1 sad piše x, a q1 je bilo ovde sad piše q prosto su ta pravila uplonjeno i ostalo je samo jedno pravilo koje nije prosto kopiranja. Znači to je jedna mala optimizacija da prosto u kodu nemoramo, imamo eksplizet. U delu ali naravno to je toliko mala optimizacija da nemorada se sprovodila, ali u svom znači sve optimizacije su uredjeno u sve 4 smene i sad imamo ovu variantu gramatike na bazi koje direktno pišemo parser na bazi u urzivnjovog supusta. Ovde je ona promenjiva koja predstavlja tekućivlja zimbol nije ina nego u i ona sad nije recimo prosto ceo broj nego prošto ulazni token ima i klasu i vrednost, to je jedan zapis, znači u nam paskalskom stilu. Znači jedna komponenta zapisa je klasnji deo ime, a druga komponenta je njegovog tribut neka ceva brojna vrednost i znači postoji procedura advanced koja mora da znači svaki but kad se pozove sredneći ulazni simbol zapiše njegovog klasu i da odredi vrednost njegovog tribut. Takođutred je da imamo procedura accepti reject. I sad glavni deo ovog rekordzivnog parsera moram imati proceduru s proceduru a i glavni program, možemo krenati u glavnu programu, da ću imamo programu, moramo inicializovati promenjivu u pozivom advanced procedure, pozvati proceduru za startni neterminal koji je izlazni parametr. Znači njega poseb možemo koristiti naprimela ispisati vrednost ili bilošta. On je na nivou glavnog programa kao globama promenjiva definisan i znači poslo ovog poziva možemo da ga koristimo. Potrebno kada se vratimo iz Q ispitati da je ulazlo što do endmarkera, onda je accept i nače je reject. Što se tiče procedura, decimo s, ona znači treba da iskodiraju tako prepoznavanje ove prve dvesmene. Q ima sintetizonetribut koji predstavlja izlazni parametr, to je sprenos po vrednosti upaskalo je to parametr za koji piše var u nekim drugim programima koristili biste nešto drugu, ja bi biste koristili one tipove veliko integer ili reference za izlazne u ceu, biste koristili pokazivače i tako dalje. I rekli smo, znači, Q je izlazni parametr, a ovi ostali atributi koji se pojavljaju na desnoj strani prve i druge smene, to su neznam x, y, zet, duplo, v, r. U moraju postati lokalne promenjive u procedurie s i konačno procedura je sima oblik znači da ima case na baziji tekućeg ulaznog simbola, ako je a prepoznaje se prva smena, ako je b prepoznaje se druga smene, a znači, pošto ovdje već smo uparili a, u case ne moramo, možemo svati samo advance i posle poziv procedura a i poziv procedura s, naravno, potrebno izračunati atribute ako je bilo šta potrebno predkodno izračunati, znači imamo taj advance, međutim pošto smo ovdje izvašili preimenovanja, znači ne imamo nikakva računanja da upacujemo, nego direktno zovemo a, zovemo s. E sada treba izračunati du proverion, se koristi u akciji, be akcija, be ovdje implementirana kao pozivneke procedure out koja kao stvane parametri ima, nači goji akcija i simbol se izdajne izlazi, vrednost njegovog atribut, nači, uslovi je al atributivnosti će vam garantovati da uvek imate mesto gde će tu ubaciti kod za računanje vrednosti atributa, naravno, najkastnije mesto za računanje vrednosti je nepotredno prenego što se da vrednosti upotrebi pošto ovdje, to bio ili tako naj nasređeni atributa. Ustvari, ulazni parametro daud, nači, ovo je bilo posrednje mesto gde to mora da se računa, a u jednoj i najranije mesto pošto on koriste ovku koja se vraće iz s. Neka, znači, postoji veći, da kažem, prostor, nači, više meste gde se može staviti, ali kažem, nači, sama je al atributivnost garantuje da ćete uvek imati nači mesto gde da upacite kod za računanje atributa. Aksepti reject u realnoj implementaciji, nači, šta bi aksept bio kraj rada s prikrotanjem ulaza, to je nek povratak iz parsera, a reject bi možda bio prijavanjeke greške i, isto da kažem, kraj rada parsera. To u principu nemogu biti samo prosti podprogrami, zašto, recimo, ako bi reček bio prost podprogram, nama se može desiti ta greška ulezu u bilo kontrenutku rada parsera, kada je, recimo, parser otišao duboku u rekurzi i jedna procedura je pozala drugu, druga, treću i tako da je način napunjenje onaj runtime stack. I onda se pozave reject i sad reject prijavi grešku i u rade return. Taj return bi se samo vratio u tu proceduru koja je nastala greška, ali par serbi onda nastavio što u principu ne želimo, ako nije ugradjeno pravak od greške, mi želimo da potpunot završimo rad, a parser bi pogrešno nastavio da dalje procesila sekvencu, kada nije bilo greška. Mora se obezbediti mehanizam, tako zvanog odmotavanja stacka, odnosno da u suštini ove rejecto odmah iskoči na nivo glavnog programa. Procedure main pripojavi grešk, ako se reject pozave iz ovih rekurzivnih podprograma. Kako se taj mehanizam obezbedjuje, pa zavisi od jezika do jezika, značo, ovi jezici koji imaju upacanje izuzetka, ideja je da u suštini reject poprijavi greške baci izuzetak i da se taj izuzetak ustvari hvata u ovde u glavnom programa. Za jezike koji ne imaju bacenje izuzetka kao što je C, C ima neki drugi mehanizam koji je adekvatan za u situaciju, to je onaj setJump i longJump. SetJump je postavlja kao nekolabelu odredište skoka i on bi bio pozva negde u glavnom programu pre cele obrade, a longJump je nešto što bi bilo pozvano na kraju reject koji bi uzrokavao da kažem odmotavanje steka i dolazak opet u glavni program na mesto odredjeno sa timsetJump. Tako da o tom detalju treba oditi računa. Dodatan praktičan detalj je oporavak od grešaka, način realan parser mora da uznog obzir da ulaz može da bude pogrešan, ali želimo da parser ne prekine rad na prvoj i syntaxnoj grešci, nego da pokuša posljev, naravno, detekciji prijave greške da se pokuša oporavak. Parsera, odnosno da parser nastavi rad da isprocesira celu ulaznu sekvencu kao da nije bilo greške i ova vrsta parsera, ako sve se na nove način zadovoljav pravilo da u trenutku detekciji greške ne moramo da se vraćemo nazad na ulazu, nego u nastavku rada modifikacijom preostalo ulaza i da kaže modifikacijom stanja parsera možemo se izvući i nastaviti rad. Evo kako izgleda implementacija ovoj ostavnog aliviricno panićnog oporavka u varianti ovih top-down parsera. Dodat ćemo svakoj od ovnih rekordinog procedura za neterminalne dodatni parametra, koji je ustvari neka kao skup terminalnih simboola i koji u normalnom radu parsera taj parametra se ne uzimo u obzirna igranika gulogu, međutim u slučaju pojave greške koristimo taj tako zvanik termset skup. U termsetu će se naći z terminalnjenost tekući ulaz i simboli koji bi mogli biti ispravan tekući ulaz posle povratka znači iz odgovarajuće procedure. E, ako se uloz na procedure detektuje greška, ide je u stvari da na ulazu gutamo simbole sve dok ne nađe neki simboli termset. E, kad nađe neki termset, onda prosto izvašemo ulaz ulaz u ulaz i ulaz u ulaz u simboli termset, onda prosto izvašemo povratak iz procedure A. Naravno, to je sve posle poziva one prijave greške. Evo, kako, na konkretnom primjeru bi onda izgledao jedan rekursivni proces. Uze ćemo uloz u jednostavnu gramatiku koja ima znači dve smene za S i jednu smenu za E. I, rećimo, ako razmatramo proceduru E, ona će prepoznavateljano u treću smenu i njen ko će biti mnogo jednostavan, a njen termset, taj ulazni parametar koji je skup terminalni simboli. Ako zovemo proceduru E iz koda procedure S pri prepoznavanju, prve smene, u termset ćemo ubaciti zatvoren ovu uglastu za agradu, a ako zovemo proceduru E iz konteksta prepoznavanja druge smene, u termset ćemo ubaciti ovu običnu zagradu. I dodatno potrebno je ubaciti i ono što sledi S, pošto je S statni simbol, znači njega sledi u svakom kontekstu EndMarker. Tako da ćemo u ovaj termset ovaj znači, znači, ako kontekst u prve smene termset će biti zatvoren ovu uglasta za agrada i EndMarker, ako kontekst u druge smene biti će zatvoren ovu običnu zagradu i EndMarker. Zašto ubacimo EndMarker pa da koristnik oga greška da je izostavio, da njega ne li više ili sve zatvorene zagrade, mi ćemo na kraju naletati na EndMarker i na taj način će biti izvašen povratak i svih procedura. Evo kompletan primer za ovu malu grammatiku, ovdje je dobro glavni program i iz njega se poziva procedura E u njenom termset.
 tu je naravno sa simbolom dolar je reprezentovan marker kraja ulaza, znači to je term set za ovaj poziv procedure S i imamo proceduru znači oporavka od greške koja prijima dva parametra jedno je parametra koji određuje poruku o grešce a drugo je term set koji je prosređeno odgovarajući proceduri jer obrad od greške procedura telegira ovaj procedur i recovery začineno je da prijavi grešku, tako što ispisuje da je bilo očekivano ovo što je prosređeno kao prvi parametar, ali je nađeno ono što je trenuto tekući ulazni simbol i onda ovde je realizovan ono gutanje ulaza do dok se nepojavi neki istrpset, znači vajelin not in term set, do in i odako nekskar i onda se vraćamo iz recovery. I sa taj recovery ustvari ugređena svakod mesta gde bi inacim zvali reject, znači sad zovemo recovery. Kad u kontekstu prve smene zovemo proceduru E onda na ovaj term set od procedura S koji inac je dolar dodajemo još ovo je unija, znači pošto je to skup dodajemo zatvoren uglasno zagradu, tako da je pozivamo sa tim term setom dolar i uglasno zagrad. I sad ako pripovratku iz E znači to bi bila sad greška u S, ne bi bila zatvoren za zagradu i bi smo zvalili kavlje, ali samo sa ovim term setom odesto odnosno očekivali, bi smo sve bismo pojali do kraja ulaza sekvenci. Međutim u procedur je, znači ne bi bilo A na ulazu u trenutku, kad je pozivamo proceduru E onda bi smo zvalili kavlje sa njenim term setom koji bi bio kao što smo rekli, ako je to iz konteksta prve smene sadržav bi uglasno zagradu i marker kraja, tako da bilo šta da najđe na ulazu, znači ulaz bi se jeo do ili zatvoren uglasno zagradu ili marker kraja.
