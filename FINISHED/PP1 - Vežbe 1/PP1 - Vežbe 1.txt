 Dobrodošli na kurs programski prevodioc i 1. Ove semistr ćemo započeti jednom kratkom uvodnom lekcijom, gdje trebao da vidimo, dakle kako funkcionišu programski prevodioc i šta uopšte predstavlja pojem programsko prevodioca, kako izgleda konstrukcija i koja im je osnovna namin. Programski prevodioci predstavlja u programe koji prevode il tako neki ulazni program, koji je napisano od strane programera u nekom jeziku i to je neki source programski jezik, izvorniji jezik u ekvivalentni program koji je napisano u nekom drugom target programskom jeziku, odnosno ciljnom jeziku. Ukoliko bi smo posmatrali, compiler kao odnosno prevodilac, kao neku običnu crnu kutiv, dakle bez ulaska u konkretne detalje implementacije, mogli bi smo ga predstaviti ovako kao naslici. Dakle, imamo ulazni programski kod koji je napisano u nekom izvornom programskom jeziku i on se na neki način prevodi u neki ekvivalentni programski kod koji je napisano u nekom drugom programskom jeziku. U najčasim smislu, kada govorimo o prevodiocima, onda smatremo da će program biti prevedani iz nekog višak programskog jezika koji je, dakle, ima neki određeni nivo abstrakcije, to ipak nešto do danas se najčešće piše, u neki skup instrukcija koji odgovara nekom procesu i to bi bio neki naš zapravo target jezik. U tom smislu, prevodioci prevode programe, kako bih pripremili za izvršavanje? Naravno, međutom takođe postoje i prevodioci koji radi drugi vid translacije, odnosno radi prevođenje iz jednog višak programskog jezika u neki drugi viši programski jezik i oni se nazivaju source to source prevodioci. On imaju posebnu naminu i jedan od primera ovakve translacije predstavlja prevodioci koji služe za transformaciju programskih koda koji je u ekvivalenta programa koji su napisani u Python 2, koji su napisani u Python 3, kako bi se prosto izbegla manualno prepisivanje programa prilikom migracije na Python 3. Naravno, u slučaju također prevodioca da bi program na kraju naravno mogao da se izvrši što je naravno cijn bilo kog programa verovatno koji je napisan, on također, naravno, posebno mora biti prevedan u neku formu koja će omogućiti njegovo ispravno izvršavanje. Da bi previlo neki program odnosno tekst iz jednog jezika u drugi, prevodioc mora razumeti njegovu formu odnosno sintaksu i također mora razumeti i sadrežu, jednosno semantiku jezika na kome program napise. On također mora poznavati i pravjela ciljnog jezika, a na kraju mora znati kakod urodima piranje izsorci jezika u ciljni jezika. To praviće nje mogu raditi interpreteri ili kompajleri. Oni su s jedna strana slični, naravno, zato što imaju identična zadata, ka to je da prevedu neki ulezni program, da ga analiziraju i verificuju, međutim opet drugačija funkcioniša i za razlik kodi interpretera, kompajleri posmateraju cel kod, transformišu ga u neki među kod i na kraju emituju mašinski kodu u svoj klasičnoj nameni. Da li će se koristiti interpreteri ili kompajleri za prevoženje zavisi od konkretno programskog jezika i neki primari jezika koji su interpretirani, su recimo Python, Java, Script i Ruby, dok su primari kompajleranih jezika c i c++. Dakle, kod kompajliranja naravno cilj je da na kraju dobijemo jezik, koji će se brže izvršavati na ciljnoj mašini, međutim kompajliranje ima svoje režijske troškove, pa prosto naravno u tom nekom smislu i interpretiranje ima svojih benefit. Ose mojih jezika koji su tipično klasifikovan i na interpretirani ili kompajljera na jezike, postoje jezici koji koriste oba procesa u svojom prevoženju i tako je naprimer programski jezik Java. Programski kod koji je napisano u javi prevodi se u neku kompaktnu reprezentaciju koda koja se naziva bytecode, a zatim su on izvršava na odgovaraćo javino-virtualno mašini, jednostno jvm, i jvm je praktično interpreter bytecode. U zavisom studi implementacije jvm, većina takođe uključuje i tako zvoni jit compiler, odnosno just-in-time compiler, koji kao što moj samo ime kaže kompilaciju radi u toku izvršavanja samo programa odnosno u rantaimo i njegova uloga je da često izvršavan i kod compiler odnosno prevedega u native kod za datu mašina. Dakle, kod se na početku interpretira, međutim, ono je koji bude češće izvršavan se compiler kako bi bio naravno brš. Compilere jasno imaju značen ulogu, izuzetno značen ulogu. Posredno imaju vidiđu da većina sotvira koja se piše se i prevodi i da je, naravno, absolutni imperativ i zadatak svaku compilera da obezbedi uspešno, odnosno, izvršavanje napisanih programa, a takođe njegov cilji da obezbedi da se ti programi izvršavaju što je moguće fikasnije. Prema nekoj jednostavnoj podeli funkcija compilera, najadnostavnije je on ima neka dva osnovna dela, to su frontend i backend. Frontend procesira i razume source jezik, a backend je zadožen za target jezik, kao što možemo videti na ovaj slici. Kako bi se povezalo frontend i backend, compiler uvodi takođe i neku među strukturu, odnosno, reprezentaciju programa koji procesira i to je neka intermediet reprezentacije, odnosno, IR što se može videti ovde između frontend da i backend. U principu, među forma je zgodna zbog toga što je nezavisna od source i target jezik. Najvešće osim faza procesiranja koje postoje u oku u frontend i backend, postoje takođe i neke optimizacije. Ukoliko posmatramo, sada compiler, malo posmatramo širi pojem, ugodimo i treći deo, i to je optimizacijon ideo compilera koje radi isključivo nad baš tomi intermediet reprezentacijom, odnosno, među reprezentacijom kota. Ubađenja mova intermediet struktura postoje prilično jednostavno dodavati faza koja je rada nad njom i koja je će biti u ovom konkretnom slučaju okviru optimizacijonog dela zbog toga što nema potrebe za poznavanjem detalja samih jezika, niti source, niti target jezika. I kao što reko ga dakla, ova struktura odgovara optimizacijom i compilerima, same optimizacije prestavljaju najkomplexne ideo compilera, isprostu grazoga što ne postoji jedno rešenje koje će odgovarati svim programskim kodovima i testovima, već su u glavnom u pitanju nekakaj juristička rešenja optimizacije i one dosta zavise među osobno jedni u drugih, a naravno zavisi i od samih programa kako ćemo odći da budu primenjivani. Na ovu kursu se mi ne bovimo optimizacijama, o zato što to naravno prevazila zi osobne koncepte compilera, pa prosto neamo dovoljno vremena a naravno, prilično je široka priča, ali je to ako nekog zanimo, dakle posobno interesantan del compilera za obradživanje. Okej, kao što je već rečeno, uloga front-end je da razume source jezi, kodnostu njegovu formu, syntaxu i znacenje, kao i da verificuje naravno ulazni program. Ukoliko je taj program isprvan, on će se prevesti u među formu, a ukoliko nije isprvan, potrebno da se naravno prijevi greška na odgovarićem nivou procesiraju. Da bi proverio syntaxu ulaznog programa, compiler naravno mora da uporidi struktur u koda sa specifikacijom jezika. To znači da mora postojeti neka formalna specifikacija samog jezika i definicija tog jezika, a prema definiciji jezika je formiram prema nekom skupu pravila i to se sve naziva, odnosno, ta specifikacija se naziva grammatika. U okvorm front-endu, u prve 3 faze procesiranja kojima ćemo se mi baviti u okvorm ovo kursa, scanner i parser otvrđaju validnost ulaznog programskog segmenta. Što se tiče naša projekta, gde ćemo mi, dakle, u okvorm ovo kursa u samo i u nekom teorijskom delu, kroz predavanja i vežbe, dakle, dobiti neku podlogu kako funkcioniš u nekej osnovni segmenti kompajlera kroz ove neke četiri faze. Z druge strane, također, to ćemo vidjeti u praksi kroz sam projekt, i projekt kad se bazira na nekom programskom jeziku mikrojava koji predstavlja jednu manju specifikaciju programskog jezika jada. Dakle, kao što reku, imacemo neke faze tog projekta i to su četiri osnovne faze. Prva faza je leksička analiza ulaznog programa, i ova faza podrozumeva prepoznavanje i klasifikaciju pojedinočnih reći programa. Dakle, skjener na početku vidi ulazni program kao neki niz karaktera i onga konvertuje u neki niz klasifikovanjih reći. Te reći su prepoznate tako što su u izvornom kodu o ivičene belinama. Svaka od ovih reći mora biti ili ključna reć do programskog jezika ili nekako mora biti specificire na pravilima jezika kao neka promenjiva ili numerečka konstanta ili neka čar konstanta ili tako daljem. Ukoliko leksičko analiza ne uspede identifiku i odgovarejću reć, onda treba da bude prijevdila
 na greška i to je praktično sugestije programeru da je pogrešio u toko pisanja koda, znači u pitanju neka slovna greška u ključnoj reči ili neko neizpoštovano pravilo, kao recimo da variable počinju nekom cifrom ili tako da. Nako što su prepozlate pojedinačne reči, sledi će koran ki složiti te reči u rečenicu i to je uloga parsera, odnosno syntax na analizašto je druga faza našeg projekta, koji na osnovu, one formalne specifikacije, odnosno grammatike, treba da identifikuje, kojim grammatickim konstrukcijama pripada i odgovarajuće naredbe programa. Na osnovu toga on će odrejiti, da li postoje eventualne odstupanje od pravila, u koliko bi smo chcieli da je uzmo neki primer za to, recimo mogli bi smo da uzmamo deklaraciju promenljive i sada ako recimo u okviru te deklaracije promenljive u specifikaciji našeg jezika stoji da ona izgleda tako što se prvo navodi tip, pa imete promenljive, pa recimo tačka zaraz, u koliku zaboravimo da naglasimo koji je tip, to treba da bude prijavljeno kao neka greška na nivou syntaxne progre. Treća faza će predsedati semantičku analizu ili proveru, da li su ove rečenice koje smo formirali u predhodnoj fazi sa nekim smislom, da li imaju dakle nekog smisla ili one prosto zadovdavaju to formu grammatike i nemaju dakle neko posebno značini. Primero ovakva jedna provere je recimo pri dodali vrednosti, nekoj promenljive, provera vas da li ta vrednost koja se dodeljuje odgovara po tipu promenljivoj koja se dodeljuje. Nakle ne možemo mešati babe i žada. I na kraju kada smo završili sve ove provere, ostala mi još četvrta faza i to je generisanje kod. Nakon što smo to uravili, naravno dalje program se može izvršiti i onda vidimo, da li zapravo je se izvršava na način koji smo očekivali time što smo napisali odnosno dalje neki uvazni program koji je obrađeno kroz ove četiri faze. Ok, to značno što zdiče naše projekta, vide ćemo ove četiri faze, kao što reku za koji god nivo se odlučili, prozimo obavezno kroz sve četiri faze kako bi smo dobro savladali njihovo funkcionisanje, ali naravno što si tiče kompailera u praksi, nismo reklji šta se sve deša u ovom zadnjem delu kompailera odnosno u beckendu i u principu ovde se na osnovu ove intermediete prezentacije emituje kod za target mašin. Da bi moglo da se emituje taj kod za target mašin u koju prestilio neki skup instrukcija, ali naravno moraju se izabrati operacije ciljne mašine. Takođe, zprovo da se različiti algoritmi za efikasnu avokaciju, registra, mapiranje tih registra i naravno potrebno je odna odgovarit će i način rasporediti, odnosno napraviti redusled operacija koje su izabrene kako bi su one izvršile što je efikasnije moguć. Takođe, ove skup faze koje se nalazi u beckendu neće biti tema naše kursa, zato što ponovopravazila zepetakle neke te osnovne faze koje su nama potrebe za osnovno razumevanje koncepata compilera, ali je dobro da poznajemo šta sve tu postoji, naravno u koliko nekog zanima može se više posvetiti ove oblasti, pa je to čisto da tu postoji neki uvid u to šta sve dostopno. Kao što je veći rečena u vodu, prve tema kojom se bavimo uokuru ovog kursa je prva faza u konstrukciji compilera koji ćemo obređivati i to je leksička analiza. Šta sve podrozumava leksička analiza? Dakle, leksička analiza se bavi procesiranjem ulaznog koda, koda koji je napisao programmer u nekom programskom jeziku i prepoznavanjem pojedinočnih karaktera to koda i njihovim grupisanjem u neke ključne reči ili u neke druge tokene na tog programu. Dakle, cilj leksička analize je da pojedinočne karaktera spoji u reči i da tako odkrije, dali su dobijeni tokeni, ono što je označeno pod ključnim rečima, skupom ključnih reči tog programskog jezika, dali su u pitanju neke variable, numerečke konstante, neke druge konstante koje su specificirane samim ili tako programskim jezikom, odnosno njegovim specifikacijom, ili se možda radi o neku i greški koja je napravljena u okviru programskog kota. Kako se radi u pravo ovo prepoznavanje? Možemo vidjeti na jednom jednostavnom primjero, gde je ideja da vidimo prepoznavanje jedno od ključnih reči, to je ključna reč nju. Ovo je dakle reč koja se sustoji od neka tri slova, tako da sve što je potrebno uraditi u okviru prepoznavanje je upravo na ići na sekvencu od ova tri karaktera, koji su spojeni baš na ovaj precizirani način i u koliko je dakle pronođena takva jedna sekvenca karaktera, to treba prepoznati kao odgovarajuću ključnu reč koja se dalje koristi na odgovarajući načinu skladu sa specifikacijom jezika. Ovo je prepoznavanje celo, prestađa jedan veoma brz i efikasam proces i kao takovi je naravno automatizovan, a upravo je automatizovan korišnjem ovakvih diagrama nekih stanja i prelaza, gde zapravo ovi diagrami predstavljaju nešto što zovemo konačnim automatima. Prnego što pređemo na zadatke, hajde prvo da vidimo što su to konačni automati i kakvi sve konačni automati postojem. Osim, dakle, za samo ovo prepoznavanje pojedinočnih simbola, odnosno grupisanje, u odgovarajuće reče, naravno konačni automati imaju i neke druge svoje razne primene, o čemu ćemo nešto kasnije pričati. Svaki konačni automat ima odgovarajući konačni skup stanja. Stanje su ovde prikazana kao ovih krugovil, tako koji su nazvani na odgovarajući način, zato što je bitno, dakle, da svakostanje bude jedinstveno i kao takvo da može da se prosto identifikuje. Osim toga je naravno, postoje prelaz između stanja, koji prosto govora, dakle, kako izgleda sam diagram toka, odnosno kako izgleda kontrola toka nekog izvršavanja ili prepoznavanja. Osim toga je naravno, imamo pojedinačne simbole koji se mogu pojavljivati i to su dakle simbole koji su dozvoljeni naravno specifikacija. Ovde konkretno interesovate su na samo ove tri simbola, odnosno, karaktera, ali u opštavim slučaju naravno tu mogu biti najrazličitije vrednosti, znači karakteri, cifre i tako dalje, sve ono što predvidimo da može biti standardno pronađeno u uloznoj sekvenci. Samo stanja, takođe mogu biti označena kao stanja prihvatanja ili stanja odbijenja. Kako bi smo znali, kada smo neku sekvencu prihvatili, odnosno nismo je prihvatili. Iniče, dakle, ovu prepoznavanje sekvence treba da zapravo prepoznaje neki niz karakter koji je o ivičan belinama. Dakle, znamo da, u koliko želim da prepoznamo ključnu reć nju, ono je odvojena od osatka tog koda belinama. I onda, u koliko je ta ključna reć nju pronađena upravo kao takva, od ova tri karaktera, mi treba da je prepoznamo uspešno. I to prepoznavanje ovdje u okviru ovog konkretnog automata, vidimo tako što smo krenuli od neku inicijalnoj startnog stanja, to je ovo stanje S0. Nakon što smo prepoznali symbol n, prelazimo u stanje S1, nakon što smo prepoznali symbol e, prelazimo u stanje S2 i nakon prepoznavanja poslanje karaktera duplove, prelazimo u stanje S3 koje vidimo da je označeno duplom zatvarnom kružnom linijom i time je označeno da je to u prvo stanje prihvatanja. Predhodne tri stanja nisu stanja prihvatanja, ono su stanja odbijenja, označena su u ovoj predstavi, dakle samo jednom ovom kružnom linijom. I naravno razlog je, zato što ne žalimo da prihvatimo ključne reći n i ne, dakle te kada isrpimo celu segvencu, mi ćemo je prihvatiti, zato što smo prepoznali da je to nekad ključne reć u odgovarajicjem rečniku. Također razlog zašto ovde imamo vaš ovaj broj stanja je zato što ponovno želimo da, dakle uslovimo određeni redosled tih odgovarajicih simbola i upravo to radimo na ovaj način. Kako budemo prozili, kasnije kroz zadatke, procesirećemo, dakle funkcionisanje samo galgoritma prepoznavanja i vidjet ćemo naravno na primerima, kako se kroz struišu automati i također, kako se radi prepoznavanje odgovarajuće segvence. U sklopu konačnih automata postoje determinističke konačne automati i nedeterminističke konačne automati. Determinističke konačne automati se definišu tako što imamo neki konačnog skup stanja i konačnog skup simbola, međudim također imamo veoma jasno defini se na relacije. To znači da ukoliko se trenutno izvršavanje, odnosno prepoznavanje, dakle meču je odnosno nalazi u nekom određenom stanju i pojavi se odgovarajući simbol na ulazu, neki karakter u toj ulazoj sekvencii koji je sledači, tačno na osnovu trenutnog stanja i tog simbola na ulazu, mi možemo odrediti u koje sledače stanje se prelazio.
 I to je uvek, dakle potpuno nedvosimisleno i zato kažemo da ovaj konačne automat ima determinizm pa izbog toga determinističke. U principu za konačne automate pustoje dve neke osnovne predstave koje se koristite i koje ćemo mi koristiti u okviro ovog kursa. Jedno smo videli malo pre i to je grafovska predstava, dakle predstava pomoću grafa prelaza, a druga je ova neka tabelarna predstava kao što je možemo videti u okviro prvog zadatka u okviru same postavki. U principu dahle oni imaju potpuno identično značenje i jedino što malo drugačije izgledaju. Pa hajde da vidimo na ovom konkretnom primjero, dakle šta sve to čini ovaj konačne automat i da konkretno vidimo s vama ukratko prođemo kroz ovu tabelarno neku formu. Vidimo dakle da postoje jedan konačni skup stanja i stanje su oznočena sa leve strane, o ovom slučaju A, B, C, D, E i F. Takođu postoje i simboli koji mogu činiti ulaznu sekvencu i vidimo da su ovde dozoljeni simboli, isključivo 0 i 1 i to je naznačeno ovde gore iznad same tabele. Tako da praktično ovde vidimo da za ovaj konačni automat koji predstavljenu ovom ovde zadatku prosto ne prihvatao bilo o kakve sekvence koje se drže neke drugje ulazne simbole. Tako da to nije razmatra. Osim toga, kao što reko, za svaku kombinaciju stanje i ulazni simbol imamo definisano kako se naša automat ponaša potpuno nedvo smislanu. Zbog toga u svakom od ovih ulaza možemo naći najviše jedno stanje koje nam dakle kaže, evo na par primera, u koliko se trenutno nalazimo u stanju a, a dođe na ulazu simbol 0, prelazimo u stanje d. Ako se nalazimo u stanju a, a dođe simbol 1, prelazimo u stanje a, odnosno ostajemo u stanju a, i otak. Ukoliko bi smo probili da isprotimo neku sekvencu, precimo, koćemo da vidimo šta se dešava sa ovim automatom ukoliko dođe sekvence 0 i 1, moramo za početak da znamo odakle krećemo uopšte, odnosno odakle pratimo kako se ponaša naša automat za tu ulaznu sekvencu. To je naznačeno startnim stanjem, a oznaka za startnu stanje predstavlja ovu srelicu koji možete videti za strane pored stanja, a i ona kaže da je baš stanje a to početno stanje od koga i kreće prepoznavenje. To bi na onom našem malopredjošnjem primjeru bilo stanje s0, dakle jasno je oznaceno odakle počinje prepoznavanje neke sekvence. Ovdje konkretno, u koliku bi smo žalili, recimo, da vidimo kako se zapravo propoznaje sekvence 0 i 1, vidimo da krećemo od stanja a, ako dođe symbol 0 na ulazu, prelazimo u stanje d i tada posmatramo u pravo ovdje ulaz, pardon, označen vrstom d. Ako nakon toga dođe jedinica, dakle vidimo da prelazimo u stanje c, to je ovo ovde stanje, i nakon doka još to što steva da proverimo je, da li je to stanje prihvatanja ili odbijenja, ono što smo pominjali malo pre, kod prepoznavenje ključne rečinju, pa ono što ćemo uraditi je pogledati koji je od ovih vrednosti koje možemo viditi sa desne strane, stoji uz odgovarajuće stanje. Ako smo sada prepoznavenje ove početne sekvence 0 i 1, završili u stanju c, pogledamo i vidimo da sa desne strane stoji 0, to znači da je u pitanju stanje odbijenja. Stanje prihvatanja so označena jedinicama i nulama, i to su u ovom slučaju isključivo stanja E i F. I ovo bi bila dakle reprezentacija pomoću tabela, kao što rekok, one potpuno imaju identičnu semantiku, identično znacenje, objete reprezentacije. Tako da pa naš prvi zadatak ovde je da predstavimo kako izgleda baš ove konečne automatu, alternativnoj formi, pomoću grafa prelaza. Sušnjenski sama konverzija nije uopšte komplikova, na videlismu kako izgledaju ove dve forme, tako da ću ja pokazati sada kako izgleda ta grafovskja reprezentacija. Vrlo jednostavno se dobija jedna iz druge, potrebno je znati obeza što se nekad traži u vidu jedne reprezentacije, nekad u vidu druge, a ako ništa nije specificirano, naravno možete koristiti koju god reprezentaciju želite i koje vam više odgovara. Ova grafovskja reprezentacija se formira tako, što je naravno potrebno da predstavimo sva stanja koje smo imali i u tabelarno i reprezentaciju u vidu čvorova, a one prelaze koji su tamo postojeli u vidu polja u samoj tabeli, sada su označeni granama koje posloje između čvorova i ova je naravno jedan usmereni graf. Startno stanje je bilo stanje, a tako da vidimo da imamo ovu ulaznu vstrelicu koja jasno značova da je to startno stanje, inoče još glasno da je napomenem, eventualno u slučaju da ne postoji vstrelice koja se nalazi pored nekog od ulaza u tabelarno i formi, smatra se da je startno stanje, onda prvo stanje koja je naznačeno u toj tabeli, dakle implicito, je tako u koliko ne postoji eksplicitno označavanje ulazno, odnosno početnog stanja. Nadanje kako formiramo, odnosno kako povezavamo stanja u ovom našem automatu, pa tako što kažemo, ako smo u stanju a, a tamo smo videli iz tabele, dođe nam nula na ulazu, beše prelazimo u stanje d, ako dođe jedinica, beše ostajemo u stanju a. Tako da u principu sve što trebao da uratimo, da bi smo uradili, da bi smo sprovele ovo preslikavanje, je da 1 na 1 ubacimo granu između ona dva stanja gde smo malo prevideli da postoje ti prelaz i korišćanjem tabela. Ponavo, dakle moramo nekago naznačiti šta su stanja prikvatanja, a šta su stanja odbijenja, i kao što smo videli u onom ulaznom primero za krjučnu rečinju, stanja odbijenja so označavaju samo kao jedan krugil. Tako dok se stanja prikvatanja označavaju još jednom dodatnom krugnicom, pardon, oko inicijomog stanja, čim je kažemo da je to stanje prikvatanja i da praktično bilo koje sekvence koje završi u tom stanju prikvatanja, predstavlja sekvencu koju ovoj naš automat prepoznaje. Sve one sekvence koje završi s prepoznavanjem u ostalim stanjima, nisu prepoznate od strane ovog automata. Cja ovoj algoritm rada automata postoji i u vidu ovako, dakle, nekog pseudokoda, gde je prosto u ceo taj proces na odgovareći način formalizovan, tako da možemo proći i kroz to. Kao što reko, dakle, imamo neki skup stanja, gde postoji neku tekuće stanje, stanje u koje je trenutno i inicijalno je to, naravno, startno stanje, a postoji i simbol koji se nalazi prvi ulazno i sekvenci. I dok nismo došli do kraja te ulazne sekvence, dakle, dogod imamo simbole koje prepoznajemo, tekuće stanje dobijemo, tako što pogledamo u našu tabelu ili u naš graf, dakle, na osnovu naša konačnog automata, gde su parametri neke funkcije al tako koje nam je tekuće stanje i šta je simbol koji se nalazi na ulazu, pročitamo praktično iz našega automata šta se nalazi u nekom polju koje je u preseku trenutnog stanja i simbola koja je na ulazu i to postaje naše tekuće stanje. A naš sledeće simbol postaje sledeći znak iz ulazne sekvence. I tako radimo svedok nismo došli do kraja sekvence, kada smo završili, sada je potrebno jedino da odredimo, dali smo tu sekvencu prepoznali ovi automatom ili je to nešto što nije bilo očekivano u skladu su specifikacijom i treba prijaviti kao greškom. To ćemo proveriti, tako što smo rekli da ono poslednje stanje u kome smo završili mora biti stanje prihvatanja ako želimo da naše sekvenca bude prepoznata. Tako da ćemo samo ispitati, da li je tekuće stanje, ono poslednje u kome smo završili, pripada ovom skupu stanja prihvatanja i ako jeste tako ulazna sekvenca se prihveta, a u suprotnom se ta ulazna sekvenca ne prihveta i prijavljuje se neka greška. Često u okoru ovih automata moguće i označavati stanje greške kada prostu ne postoji neka kombinacija trenutnog stanja i ulazniju simbola, jer naravno moguće da u određenim stanjima prosto nije dozvoljeno imati neki, da se u sekvenci pojavi neki od simbola koji su inače dozvoljeni, ali otom potom nekad kasnije ćemo videti i takav neki primer. Trebulo bi da sada imamo dovoljno jasno, da nam bude dovoljno jasno kako funkcioniša ovih automati i da možemo da pređemo na zadatak pod b. Kaže izložiti nekoliko sekvenci koje ovaj automat prepozna i navesti nekoliko sekvenci koje ovaj automat odbija. U principu kako ćemo to uraditi, pa tako što, dakle bilo koja sekvenca koja završi sa prepoznavinjem u stanju koje stanja odbijenja, je sekvenca koja će da se odbija, a bilo koja koja završi u stanju prihvatanja je sekvenca koja će biti prihvatjena. I sada stanjimo odbijenja, videli smo malo prejednu sekvencu, dakle probali smo da prepoznamo sekvencu čini mi se 0,1, ali tako i videli smo da je to sekvenca koja nas vodi u stanje d.
 izda klinicijalnog stanja u stanje D i nakon toga jedan u stanje C, C je stanja odbijenja, tako da ova sekvenca neće biti prepoznat. U principu, sekvenca prihvatanja mora da završi sa prepoznavanjem ili u stanju E ili u stanju F. Da smo, recimo, ovoj sekvenci 0 i 1 dodali još jednu jedinicu, vidimo da bi smo iz stanja C prešli u stanje F i time bi smo imali, to je bilo stanje prihvatanja, tako time bi smo imali neku sekvencu koja se prihvata. Tako da u principu, naravno, imamo proizvoljom broj različetih sekvenci koja se prihvata ili odbijaju, ovdje imamo i neke rekursije, tako da možemo napraviti i bez konacom broj takvih. U svakom slučaju, ovde se tražilo da umemo da prepoznamo bar neku takvu sekvencu i da napišemo da bi smo čisto videli da razumemo šta zapravo predstavlja sekvencu koja se prepoznaje, a šta predstavlja sekvencu koju automat odbija. Ok, i posljednji našte data kojog okviru, odnosno posljednja stavka u okviru ovog prvog sedatka je pronalaženje najkreće sekvence koju ovaj automat prepoznaje. E sada, da u principu videli smo da nije neki posebno problem pronači sekvence prepoznavanje ili sekvenca odbijanja, me izđutim postavljamo se pitanje kako ćemo odrediti baš najkraću sekvencu koju ovaj automat prepoznaje. Ovde ideja za tako nešto, videli smo kao i malo preka da smo probali dopronađemo sekvence koje se prepoznaju, najlikša je krenuti od posljednjeg stanja, odnosno, ovak stanja gde znamo da takva sekvenca mora zavrašiti. Sada, naravno, ako nama nije bitno, o to bude najkraće sekvenca i onda možemo krenuti od ulaznog startnog stanja, međutim, pošto želimo da postignemo da to bude u najmanjem broju koraka, onda je ovdakvo je najbolje da krenemo od posljednjeg stanja, za koje znamo da mora biti stanje prihvatanja i da probamo nekako da dođemo do startnog stanja. I sada mićemo da napišemo takve neke sekvence, pa ćemo prosto dovidimo kako ćemo da dođemo do nekoje najkraće. Dakle, videli smo malo pre, imamo neka dva stanja prihvatanja u kojima treba da završi svakak o ta sekvenca u jednom ili drugom, tako da je to jedno je stanje E, a drugo je stanje F. I sada ono što nam izlevići korak je o tako, je da vidimo kako mi da dođemo do stanja E ili F. Na osnovu ove ovde tabelice, što možemo zaključiti? U kako možemo dođi do stanja E? Da bi smo videli kako dolazimo do stanja E, potrebno je da pogledamo naš automat i da vidimo ili tako koji ulazi, odnosno koje kombinacije nas vode upravo do tog nekog stanja. I sada ono što možemo primetiti je da ove tabeli imamo tačno jedno E i jedno F, tako da ono što nosvodi do stanja E je zapravo stanje F, u koliko dođe simbol 0. Tako da vidimo da bi smo stigli do stanja E, potrebno je da pre toga prođemo kroz stanje F a da bi smo stigli do stanja F, potrebno je al tako da pre toga prođemo kroz stanje C. Međutim u ovom ovde trenutku što možemo mi da zaključimo. Tako, obete naše sequenci ili možda ih kasnije i bude više, svaka koji imaju nešto još ispre cebe i to nešto treba da vidimo al tako koji je to skup stanja kroz koji se prolazi da bi sova najkraća sequenza prepoznala. Međutim, ono što možemo zaključiti na osnovu ove prve sequence je da ona svaka ko naravno, ili tako mora kao i ova druga krenuti iz A. Međutim, ono momenta kada ova sequenza završi u stanju F, to stanje F je već stanje prihvatanja. Tako da se sequenza će već biti sequenza koja se prihvata. Tako da sequenza sledeća koja završava u stanju E, samo može biti duža od sequence koja je pronađena sa završetkom u stanju F. Izbog toga je nama praktično ovo prvo prepoznavenje, odnosno bilo koja je sequenza prepoznata na ovakav način nikada ne može biti najkraća. Pošto ne može biti najkraća, onda to nije ono što se tražilo u okviru ovog zadatka i mi možemo slobodno da napustimo prosto ove načine ispitivanja sequence i da kažemo dobro. Tako da ovo ovde nije naš put, naš najkraće sequence sigurno neće završiti u stanju E, već je završiti u stanju prihvatanja F i od atla je došlo iz, prepoznavenje je došlo iz stanja C, tako da je to prosto neki put kojim treba da nastavimo. Ok, samo algoritm dalje ide potpuno identično kao i do sada, dakle gledamo kako smo mogli da dođemo u stanje C. I sad vidimo da smo u stanje C mogli da dođemo ili iz stanja B, ili iz stanja D, ili iz stanja E. Dakle B, D i E, to su praktično naše putanje. Sad možemo da kopiramo ovo još dva puta i da prosto zabelazimo mi sve putanje koje smo imali. Dakle prva ovde koji smo pronašli al tako je bila preko B, druga je bila preko D, a treća je B što je bila preko E al tako. Se vratimo mi to da proverimo, tako je. Dobro, što sad zaključujeme? Ponovobrovatno možemo nešto da zaključimo al tako. I to što možemo da zaključimo u principu je ponovog za ovu treću sekvencu. Tako je sekvenca pre C i F, već završava u E. A to znači da bi ovo ovde bilo veći stanje prihvatanje. I pošto smo videli malo pre da al tako bi onda najvrvatnije, odnozu sa si sigurno ovde bilo i ono F, mi možemo slobodno da odbacimo ovu sekvencu, zato što ona ponovog sigurno neće biti najkreća. Tako da nas ova sekvenca zapravo nije nezanima toliku, dakle neće presadljati najkreću sekvencu, možemo da je odbacimo kao i ovu malo pre, i možemo da se fokusiramo prostu na ove dve sekvence i da vidimo šta nam te dve sekvence daju. Ok. Što se tiče sekvence sa B? Šta možemo da primetimo? Do B možemo da dođemo ili iz stanja D ili iz stanja E. Tako, jedini način da dođemo do B, su stanja D i stanja E. A to smo već videli da nije naša najkreća sekvenca. Dakle, ova sekvenca koja je ide preko E, videli smo već dva puta da bi ovo svakako bilo stanji prihvatanja, tako da nemam smisla uzeti tu sekvencu kao najdužu, zbog toga nju možemo da odbacimo. Ali, ono što takođe vidimo da bi smo stigli do stanja B, moramo ići preko stanja D, a tonom takođe neće biti najkreća sekvenca, imajući u vidu da u ovoj donju sekvenci idemo direktno iz stanja D u stanje C. Tako da sloveno u ovom trenutku možemo odbaciti ove sekvence, zato što sigurno neće biti najkreća. Ostanom još samo da vidimo kako možemo doći u stanja D, isto kao što smo radili malo pre, i u principu, ono što vidimo na osnovu ovde tabele, je da u stanje D možemo doći sklučivo i startnog stanja A, tako da će zapravo ovo biti naša kompletna sekvenca, koja se pokazala i kao najkreća sekvenca, prepoznavanja kroz stanja, a da bi smo videli koja je to konkretna sekvenca, nam zapravo treba da isprtimo simbole koji su se pojevljivali na ulasu. I ti simboli, dakle nas vode kroz stanja A, D, C i na kraju do stanja F. Iz A dolazimo u stanje D, ako je na ulazu se pojevi nola. Iz D dolazimo u C, al tako, ako je na ulazu bila jedinica, i iz C dolazimo u F, ako je na ulazu bila jedinica. Kad smo u stanju F, to je stanje prikvetanja, tako da se 0,1,1 čini mi se, stižemo u stanje prikvetanja i ti smo pronašli našu najkraću sekvencu. Naravno, videli smo, postoji značeno veći broj sekvenci, i kao što reko, ako pogledate, samo gomilanjem ovoj A možemo formirati slično u sekvencu koji će biti sekvenca prikvetanja, tako da tako i sekvenci, u tom zločinu, beskonačno, ali ono što nam je ovde bio cilje da pronađemo upravo najkraću sekvencu koji u tomat prepozne i to smo uradili upravo na ovaj način. Tako što smo dakle kretali od poslednjih stanja, jer smo znali koje stanje moraju biti stanja prikvetanja, tako da smo znali gde želimo da stignemo. I onda smo razmotavali taj put da dođemo do startnog, odnosno, inicijalnog stanja. Svaki put, kad dobijemo veći broj različeti putanja, mi smo razmatrali, dali takva putanja će biti najkraća ili neće biti najkraća, prema tome, dali jedan i en del već sačinjava sekvencu koja se...
 prihveta u tom slučaju znamo da nije najkreća ili možemo nekom drugom putanjem doći brže do željenog rezultata. I na taj način smo detektowali koja bito bila najkreća putanja. Sveđa sve zadaata koji imamo je da praktično konstruišamo neke automate či je specifikacije su nam date u okviru zadatka pod različitim stakama. Pa kaže ovako, projektovati je u tomce konečnim brojem stanja či je ulaz na zboku skup nula i jedinica, dakle imamo sekvence koji isključivo čine nula i jedinice i koji prepoznaju tačno sledeće sekvence simbolu. Pod a kaže prepoznaju sve ulazne sekvence. Hleda vidimo kako bih skomisla konstruilisali automat koji prepoznaje sve ulazne sekvence, se stoji se isključivo od simbola 0 i 1, gde je naravno moglimo da prestavimo tabelerno, možemo da prestavimo i grafički, možemo da mi je za početak lakše u gratuoskoj reprezentaciji. Najanostavni algoritm, verovatno, koji možemo da smislimo, je automat koji možemo da smislimo, je automat koji se se stoji iz isključivo jednog stanja, gde je dakle tonamin start na stanja, i mogu nam dolaziti 0 ili 1. Ovo ćemo malo dopovećemo. Mogu nam dolaziti 0 i 1 i ono što nam je cijeljno da to bude naše stanje prihvatanje. Tako da ćemo prestaviti to ještje kruvom, malo ćemo da se stavimo. Ovo ćemo da se stavimo. Rekljamo, dakle, ovo je neki minimalni automat koji smo mogli da napruvimo, gde imamo jedno startno stanje s0 i ukoliko dođe ili 0 ili 1 ostajemo u istom stanju, a ovo je takođe između ostolog i stanje prihvatanje. Tako da na taj način smo bezbedili da prihvatamo sve sekvence. Ovo je automat smo nama mogli da napruvimo i drugačije, dakle nije ovo jedno rješenje koje smo mi ovde mogli da smislimo. Šta smo drugačije mogli durati? Po možemo da imamo dva stanja u okviru našega automata. I racimo, kažemo, ovo prvo stanje ćemo da koristimo isključivo za prepoznavanje 0, a ovo drugo ćemo da koristimo isključivo za prepoznavanje 1. I ovdje ćemo da imamo sve sekvence. I ovdje ćemo da zovemo stanje s1. Međutim, naravno, takođe moramo imati transicije između ovih stanja. Tako da ćemo reći, neka nam startnostanje bude stanje s0. Dokram dolazio 0, vrtimo se u okviru istog stanja, a onda kada nam tu, recimo, dođe jedinica, prelazimo u stanje s1. S1, znači, kad smo u stanju s1 dolazio nam jedinica, ostajemo istom stanju. Međutim, recimo, kada dođe 0, možemo da pređemo u stanje s0. Kao što vidimo, oba su stanja prihvatanja, tako da se te strane koja god do ovih sekvenci da se pojavi, mi svaka ko ćemo prihvatiti tu sekvencu. I evo ga naš finalni automat. Dakle, ovaj dve automata na kraju prihvataju potpuno isti skup sekvenci. Tako da je bilo sve jedno da ćemo konstruisati prvi automat ili drugi automat. A u tomat možemo, naravno, čak širiti odgovarajući skup stanja. I to je samo pokazatelj da je zaista jako rjetko kada su automati jedinstveni. Čak vidjet ćemo kasnije kada uvedemo i pojem nedostižnih stanja, uveki moguće konstruisati dakle različite automate koji prihvata i odgovarajući skup sekvenci. Ok, dakle, to je jedan primjer. Na primjer, takođe, ono što bi ih dobala ovde još. Pošto vidimo da i u ovaj osnovnih varianti ovog jedna jednostavnjeg automata koji ima, dakle, samo jedno stanje koje stanje prihvatanje i u ovaj kasnije varianti, inicijelno odnosno početno startno stanje, takođe stanje prihvatanje. To će praktično značiti da ovaj automac takođe prihvata i prazno sekvencu. Prazno sekvenca je ona koja, dakle, očigledno, nema ni jedan simbol, odnosno, ni jedan karakter u toj sekvenci. Tako da oni bi, naravno, prihvatali i takvu neku sekvencu. Ukoliko bi smo, recimo, želili da konstruišemo automat koji ne bi prihvata o praznu sekvencu, tada bi bilo potrebno da imamo još jedno dodatno stanje koje ćemo ubaciti kao startno i gde će praktično ovo stanje biti stanje odbijenja, a gde ćemo reći, ako nam bilo šta dođe na ulazu, pređi u ovo stanje sledaće, tako, i to ne bude neko stanje prihvatanja i na taj način smo mi obezbedili da prazna sekvenca ne može nikada biti prihvatana. Tako, naravno, moramo označiti ovo startno stanje i tima bi smo praktično napravili jedan automat stanja, gde, dakle, se prazna sekvenca ne prihvatanja i tako prosto razlikujemo tako šta želim da postignemo. Ok, šta nam je bilo sledići zadatak? Sledići zadatak nam je bilo da ne prihvatimo ni jednu ulaznu sekvencu. Kada videli smo na početku kako prihvatamo sve ulazne sekvence, sad je pitanje, kako ne prihvatamo ni jednu ulaznu sekvencu. Pa, opet, trebalo bi da ovo bude dosta jednostavno, ili tako. Počemo ću se razlikovati takovo automato dono koji je inicijalno bio napravljen. Pa, po tome, je otakušta, ovo ovde neće biti stanje prihvatanja, nego će biti stanje odbijenje. Na taj navčin imamo početno startno stanje, gde prihvatamo sve sekvence, kde je, koji procesira sve sekvence koje se zastoja od simbolenu ulaj i jedan, znači učin, nije jedna takva sekvenca ne može biti prihvatjena. Tako da je ovo stanje, stanje odbijenja uvek i naš automat praktično ne prihvata ni jednu sekvencu. Naravno potpuno je kvivalenteno bi bilo i kada bi smo u ovom donima automatu, takođe, ili minisela je stanje prihvatanja, i oba stanje zapravo bila stanje odbijenja, postigljubi smo praktično istu stvar. Danje treba da prihvatimo neku konkretnu sekvencu, to je sekvenca 101, kako sad ne bih morala ovada crtem. To je u suštini nešto smo već videli u uvodu, kada smo obješnjavali generalno pojem konočnih automata. Dakle, kada prihvatimo bilo koju neku konkretnu sekvencu, gde želimo da njeni pojedinočni simboli idu odgovarajuće poretku, onda naravno uvek to možemo uraditi ovaku, gde bi smo samo u mestu, naravno, konkretnih simbola N, E i W. Stavili u ovom slučaju 1, 0 i 1. Takođe, naravno, ono što možemo dozatno uraditi, je uvesti još jedno stanje koje bi bilo neko stanje greške, kao peto stanje, recimo, ovde, gde bi smo ga prosto povezali sa svim prostalim stanjima i rekli, ako je došlo nešto bilo šta drugo na ulazu, možemo čisto to prebaciti u stanje greške i time bi smo značili da ne dozvoljavamo prihvatanje nije jedne druge sequence u odnosu na baš ovu koje specificirana. I pod D zahtovi bio da prepoznamo isključivo praznu sequencu. Ako želimo da prepoznamo isključivo praznu sequencu, a ja sad obrisala sam malo pre sličicom, šta bi zapravo ovde modifikovali? Pa, ono što želimo je da nam inicijelno stanje bude stanje prihvatanja, time ćemo reći da je prazna sequenca, al tako sequence prihvatanja, a ono što ne želimo je da bilo koje druga sequenca bude prihvačena, tako da ćemo ovde morati da uklunimo oznaku da je to stanje prihvatanja, odnosno da napravimo da je ovo drugo stanje, stanje S1, stanje odbijenje. I na taj navčin smo mogućili prihvatanje isključivo prazne sequence, a sve druge sequence će biti odbijene u ovom automatu. To su dakle bili neke primeri konkretno u ovom ovde zadatku, a što reko, mogući...
 uvek konstruizati i neke malo drugačije automate, gde prosto ćemo ubaciti još neka stanja i u principu, ono što se može, naprimer, uveku raditi u koliko ne žalimo da napravimo minimalni automat, je da prosto dodamo još neko stanje do koga ne postoji put, odnosno do koga se ne može stići iz ovih drugih stanja. I sad, naprimer, u koliko bi smo mi prosto uzeli, da je plicirali neko od ovih stanja, recimo, evo ga stanje. Ovo samo, naravno ga moramo nazvati drugačije da bi bilo jedinstveno i to stanje takođe, naravno, može biti stanji prihvatanja, međutim, nije nina koji način povezano sa preostalim stanjima u automatu, nek budo da je ovog, dakle, ovog ovdje automata. Onda, naravno, takve stanje uvek moguće dodavati, međutim, one ne utiču na ovaj automat. Utiču zato što su, do njih ne može doći i takve stanje se nazivaju nedostižna stanja, što je i dober uva za naš sledeći zadatak. Naravno, kao što reko koje takve stanja, sudat mogu dodavati u automat, al se poslice pitanje, čemu to je odako, zato što u principu ovi automati služaju za implementaciju neke logike prepoznavenje, gde se naravno mogu se dodavati i neke funkcije u te automata, u koliku želimo da još našto dodatno implementiramo, te jestim ovi stanja koja prostu ne vrša nikakog funkciju, samo optereću implementaciju, isbok toga nemoju neku posebnu svrku, tako da najčešće nećemo želiti tako našto da radimo, većemo želiti prosto da formiramo minimalne automate, kako bi smo što više pojednostavili samologiku prepoznavenje. Ok, tim je smo završeli drugi zadatak, ovdje su dati neki primeri u tabelernoj formi, tako da je to i to naravno se može pobijatati. Ok, treći zadatak kaže, pronaći sva suvišna stanja u automatu prikazanom na slici. Dobro, dakle ponevojujemo neki automat, datu odgovarajuće tabelernoj formi i ovom što treba da pronođemo sva suvišna stanja u ovom automatu i videli smo malo prešta, znači imati suvišna stanja, stanje koja ne vrši nikakvu funkciju i to je u principu suvišno, odnosno, nedostižno stanje, dakle stanje do koga se ne može doći, od procesiranjem bilo koje regularne sekvence krenuši od početnog odnosno inicijalnog stanja, ako rifćenjemo ovo konkretnog automata. I sad kako ćemo mi da pronođemo koje su to suvišna, odnosno, nedostižno stanja? Pa ideje je zapravo da pronođemo koje su to stanja koje su dostižna, odnosno, figurašu u ovom ovde automatu i da na osnovu toga prosto sistemu eliminacije dođemo da toga koje su stanje nedostižna, odnosno, ne učestuvaju u funkciju oni su ni automata. To ćemo uraditi tako što ćemo, dakle, krenuti od stanja koje je sasvim sigurno dostižno, a to je prosto naše inicijalno, naše inicijalno stanje i to je startno stanje A, zato ćemo dodavati u ovaj skup dostižnih stanja sve ono dokle možemo da dođemo al tako procesiranjem ulaznih sekvenci, a prosto ono što nam preostane, a što nismo pokupili tim samim algoritmom, proglazit ćemo kao nedostižno stanje. Dobro, iz stanja A, u koliko se na ulazu pojevi 0 dolazimo do stanja C, u koliko se pojevi 1 dolazimo do stanja E i u koliko se pojevi dvojka prelazimo u stanje G. Tako da sva ta stanja, pošto tranato nisu oznočena kao dostižna, možemo ubaciti u ovaj skup dostižnih stanja i prosto nastaviti dalje. Nakon što znamo da možemo doći do tih stanja, onda praktično i sva dostižna stanja iz ovih koje su sada ukličeno u spisak, takođe postaju dostižna. Pracesiracimo jedno po jedno tako stanje, pošto smo prvo najvešli na C, pogledat ćemo dakle gde se sve može stići iz stanja C. I to su stanja J, A i H. I kada njih sad dodamo ovdje skup redom, dakle A je već ukličeno, pa naravno nećemo duplicirati ulaze, sada u time dobijemo nikad u novo informaciju, ovo održavamo kao skup stanja, tako da su sva jedinstvena, ali ćemo dodati stanje J i H i pređi ćemo na procesiranje sledaček stanja koja nije obraćeno, a to je stanje E. I sa stanja E može se preće u stanja E, dakle ostati u stanju E, ili preće u stanje J ili H. I kao što možemo primetiti, sva ta stanje se već nalazali u skupu, tako da procesiranjem ovog stanja nismo došli do novih zaključaka, tako da ćemo preći na sledače, to je stanje G. Vidimo da možemo preći ovdje stani H, A i J, koja bi takođe trebalo da su sva oklučeno u ovaj skup, tako da samo idemo dalje. Zatim stanje J, dolazimo odnosno dostižno na su nam stanja BH i G. Ako pogledamo ovoj skup, vidimo da stanje B nemo, ono nije oklučeno, tako da ćemo ga dodati. Sledaće je stanje H, dakle pogledamo, imamo G, J i B, vidimo da su to sva stanje koje su već uklučena. I preostalo nam još stanje B i ponovol tako vidimo da su iz njega dostižna samo ona stanja koja su već uklučena u ovaj skupi, označena kao dostižna. E, u topnoj trotku mi, dakle, ne umo ni jednu nova stanje koje smo uklučili u skupi, time smo završili sa skupom dostižnih stanj. Ono što nam osta je da odredimo koje su to nedostižne stanje i njih ćemo dobiti, tako što ćemo od svih oveh stanja, ali mini sationa koje su označena kao dostižne. Sato trenemo redom, tako imamo ABCD, kada pogledamo u ovaj ovde inicijelni skup, vidimo da su ABC uklučeni, međutim D nije uklučeno kao dostižno, tako da ćemo ga označiti kao nedostižno. E f g h, vidimo da je e tu, f nije, al tako, g h i s, i preostali su nam i i jot, a stanje jot se nalazi u skupu, međutim i ne, tako da su ove tri stanje prosto označena kao nedostižno. Nakon što smo značili, je govarajuće stanje kao nedostižno, ono što nam preostane je da uklonimo sve ulaze koje sadrže takva stanja, zato što prosto time ne dobijemo nikakvu informaciju, ili tako, takva stanja videli smo malo pre nefigurišu prosto u funkcionisonju ovog automata, tako slobo da ih možemo ukloniti, i to znači da ćemo ukloniti vrste, ili tako koje se odnose na stanje i, na stanje d i na stanje f, i ono što znamo naravno da prosto uklanjenjem tih odgovarajućih vrsta smo eliminisali sve što je bilo suvišno, odnosno nepotrebno u ovom našem automatu i da smo dobili ono što će stvarno biti korešćeno ufigurisonju toga automata. E sad, ono tako, i hto smo sigurni i što znamo, je da nakon uklanjenje tih vrsta iz ove tabele nikde u samoj tabeli nećemo imati ni jedno od ovih stanja, a upravo smo sigurni, jer da se oni tu nalaze, ono bi zapravo bila dostižno. I kao što vidimo trenutno, jedina mesta gde možemo primjetiti posujanje dakle takvih stanja su ona do kojih se dolazi upravo iz samih nedostižnih stanja, tako da recimo do d i i se dolazi iz stanja f, ali kad pogledamo i stanje f je označeno kao nedostižno, tako da samim tim to prosto da je neku drugu grupaciju u delu automata do koji se cele ne može doći, pa nije ni toliko bitno što su oni medjusobno povezani. Dakle, uklonit ćemo ih i tim ćemo imati automat koji više nema suvišna stanja. Pradazimo na sljaveći zadatak. Date primer 2 ekvivalentno nakonačno na automata gde jednom stanju automat m i n, gde jednom stanju automata n odgovara više ekvivalentni stanja automata m i dokazati da primrza dovoljava uslova zadatka, a nakon tog je takođe naprimjur odvaj ekvivalentna konačna automata m i n, gde automat m ima stanje koje nije ekvivalentno nisa jednim stanjem automata n, takođe dakle dokazati da primrza dovoljava uslova zadatka. Dakle, vada uvodimo neki pojem ekvivalentnih konačnih automata, tako da bi smo mogli u obšto da prvo analiziramo neki primer, a potom i sami kustrujšemo primer, prvo dakle trebu da vidimo što u obšto podrazumeva ekvivalentne automate. Da bi neka dva automata bila ekvivalentna, podrazumeva se da praktično pošavši od njihovih startnih stanja da se oni ponašali na potpno identično način. To znači da prihvataju potpno identično skup sekvenci počuši od svojih startnih stanja, al dakle. U tom smislu dakle, naravno oba automata moraju prvo obradivati sekvenci koje imaju i identično skup pojedinočnih simbola, a nakon toga moraju da važne dva uslova u uslov kompatibilnosti i uslov propagacije. Uslov kompatibilnosti znači da su njihova startna stanja, oba ili stanja prihvatanja ili stanja odbijenja i da počuši od tih startnih stanja važi uslov propagacije, a to znači da istih startnih stanja se dalje prelazi u odgovarajuće stanja za svaki ulazni simbol i da svaka je taka par.
 stanja mora takođe biti ekvivalentan. U slavom propagacije se podrazumeva da će na dalje bilo koji takav par stanja iz jednog automata i druga automata takođe morati da budu ekvivalentani. Ukoliko se to pokaže kao tačno kažemo da su automati ekvivalentani, u koliku bilo kom trenutku zakličimo da jedno dova uslova dva ne važi, naravno zaključujemo da automati nisu ekvivalentani. E sad, na prvom primjelu da prosto analiziramo kako izgledaju dva ekvivalenta na konočna automata i podanam je traženo da jednom stanju automata n odgovera više ekvivalentnik stanja automata n. Takle treba da dokažemo na primjelu da tako primjer zadovoljeva uslova zadatka, pa, ajde, mi prvo da pogledamo, tako je jedan takav primjer da ga analiziramo i onda nakon toga možemo i da konstruišemo svoj primjer za pod b. Dakle, oddaj su nam data neka dva automata, automata m i automata n, i treba da pokažemo da su ta dva automata ekvivalentana, odnosno da važi uslov kompatibilnosti i da važi uslov propagacije. Za uslov kompatibilnosti startnih stanja je dosta jednostavno pokazati startno stanje automata m je a1, a startno stanje automata n je a2 i kao što možemo primjetiti, oba ova stanje su stanja odbijenja. Dakle, retni smo da uslov kompatibilnosti važi, ako su oba stanja ili stanja prihvatanja ili stanja odbijenja, dakle, porašaju se identično, ono što vidimo je da je taj uslov zadovaljeno. Međutim, nadalje moramo da vidimo da važi uslov propagacije, odnosno da li polaskom od ovih startnih stanja preostali parovi stanja koji su dobije iz oba automaca, takođe se porašaju na identična način. Ok, a to možemo uraditi, tako što ćemo ponovu formirati, dakle, neku tabelu, gde ćemo vidjeti, al tako kako se ponašaju, kako se ponašaju ove parovi, tako da ako je prvi par koji smo izdvojili, bio par a1, a2, a neki ulazni simboli koje nam s ovdje pojavljuju su x, y, s ilu odstrebno da imamo kako su oni praktično ponašaju. Je sad a1 ako dođe x na ulas, prelazi u stanje b1, dok a2 ako dođe x na ulas, prelazi u stanje c2. Tako da suštelski sledeće par koji ćemo identifikovati je par b1, c2. Ok, što se tiče, šta se toga šta se dešava ako na ulas dođe simbolipsilom, tako da i stanje a1 su prelazi u stanje c1, a i stanje a2 u stanje c2, tako da sledeće par koji identifikujemo je par c1, c2. I to su parovi, za koje to koje će treba provoriti da li važi uslov ekvivalencijem, odnosno kompotibilnosti. Znani, za a1 i a2 smo vidjeli da su oba stanja odbijenja, tako da su oni kompotibilne. Za b1 i c2 možemo videti da su oba stanja prihvatanja, tako da su oni kompotibilni i za c1 i c2 takođe možemo videti da su oba stanja prihvatanja, tako da su kompotibilni i za c1 i c2 tako da su kompotibilni, kompatibilni, tako da što se tiče dakle toga, možemo zaključiti da je za sad sve urep. Ukoliko bi smo u ovom trenutku, na primver, zaključili da postoji nekompatibilnost između članova nekog od ovih parova, nibismo odmah zaključili da ovih automati nisu je kovalenta i ne bi bilo potrebevo ovo što da proveravamo do kraja. Zada sve dalo je ok, tako da ono što nam je preostalo je da vidimo da li sad dobiti novih parova koje smo uključili propagacijom, zapravo koje parove dobijemo, da li dobijemo neke nove parove i da proverimo identično kao da sad da dali za njih važi uslov kompatibilnosti i uslov propagacije. Dobro, iz stanja B1 za prvi automata kod ođe X ostaje sa u istom stanju, a iz stanja C2 ako dođe X, takođe za ostaje u istom stanju, tako da zaključujemo da ovih par je tako već imamo izbog toga ništa novo tu ne saznajemo, tako da ne uključujemo ovih par u našu tabelu, ne dobijemo nikakvu novu informaciju. Što se tiče toga, a što se dešava kada dođe Y na ulas, iz B1 se prelazio A1, a iz C2 se prelazio A2, tako da praktično imamo par A1, A2 i takođe kada pogledamo, to je nešto što već imamo ove našu tabeli, tako da ponovno ne dodajemo ni jedan ovih ulaz, i nismo proširili skup koji treba proveravati. Što se tiče C1 i C2, ako dođe X, prelazimo u par stanja B1 i C2 i kada pogledamo, to takođe imamo ovde, a što se dešava kada dođe Y u par A1, A2, to ponovno takođe imamo, tako da ni tu ne imamo tako nikakve promene, pošto nismo dobili ni jedan ovi par stanja, time smo mi zapravo konvergirali i završili smo prover u slova za ova dva stanja, zaključili smo da su stanja ekvivalentna i da su samim tim, ja tako, automati ekvivalentni. U principu, na ovakav način uvek možemo raditi proveru ekvivalentnosti dva automata stanja, tako je što jednom, tako što ćemo počavši od parova njihovih startnih stanja proveravati uslov kompotibilnosti i uslov propagacijem. Videli smo da je to ovde zadovoljeno, tako da smo samim tim proverili da taj uslov zapravo i važe sa doma zadatku, pod A je bilo traženo da se formiraju takvi automati, da jednom stanje automata N odgovara više ekvivalentnih stanja, automata M i to smo zapravo i pokazali, praktično da se može preslikati na više stanje iz ovoga automata M. Pod B nam je bilo traženo da takođe imamo dva ekvivalenta na konačno automata M i N, ali automata M ima stanje koje nije ekvivalentno ni sa jednim stanjem automata N. Praktično, nalačin način da to uradimo je tako što ćemo uzeti opret ova dva automata, ali ovom automatu M dodati, recimo, neko nedostižno stanje. I kada to uradimo, dakle, dodamo neko nedostižno stanje ova automatu, recimo, ovako, dakle, to je stanje koje, kao što smo videli malo pre nije povezano, nisačim drugim, onda da bi smo dokazali da važi, uzeli smo da je to stanje stanje odbijenje, da bi smo dokazali da važi da prosto ovo stanje nije kompatibilno ni sa jednim drugim, ponovit ćemo postupak, tako što treba da pokažemo, dakle, dali je stanje D1 kompatibilno sa stanjem A2 ili je kompatibilno sa stanjem C2 ili možda oba ili nije jednim. Pa ono što odmok možemo zaključiti je da stanje D1 ne može nikako biti kompatibilno stanjem, sa stanjem C2, zato što je jedno stanje prihvatanja, a drugo je stanje odbijenja, tako da ono što još eventualno ostaje da se proveri je, da je dan je stanje D1 ekvivalentno sa stanjem A2, pošto vidimo da su kompatibilne, atakove su stanja odbijenja, ono što nam još ostaje da proverimo usov propagacija i da je na taj način prosto proverimo, da li smo stvarno formirali o nakavu automat, kakav smo želili prema specifikaciji. I ono što bi smo ponovu uradili je da krenemo od para D1 A2 i da vidimo šta se da je. Ako dođe x i šta se da je, ako dođe y. Dakle, ukoliko dođe x, d1 ostaje u d1, A2 prelazi u C2, Ako dođe y, op, pardon. Ako dođe y, d1 ostaje u d1, A2 prelazi u C2, tako ponovu praktično imamo identičan par. I sve što nam je ostalo, da proverimo šta se dešava sa parom d1 i c2. E sad da d1 i c2 smo veza ključili da ne važi uslov kompatibilnosti, te samim tim ne važeni uslov propagacije za ova dva stanja, izbog toga dobijemo da takođe d1 i A2 nisu kompatibilna stanja, nisu ekvivalentna stanja i samim tim proverom smo utvrdili da smo zapravu i konstruisili ono što smo želili u skladu sa postavkom. Dakle, u okuru ovog zadatka videli smo šta zapravo predstavlja ekvivalentnost automata, kako se proverava i kako možemo provoriti ekvivalenciju po jedinočnih stanja.
 Sledaći zadatak nam kaže da treba da pronadžemo minimalnu ekvivalentun tabelu prelaza za zadati automat. Da bi smo mohli da pronadžemo ekvivalentun tabelu, nam je naravno treba ekvivalentni automat i to znači da prihveta potpuno istu skupu sekvencije koje polazni automat što smo videli iz predhunog zadatka. Međutim, pošto treba također do to bude minimalna ekvivalenta na tabela, to znači da moramo sprovesti postupak minimizacije na zadati ima automatu. Taj postupak minimizacije podrazumeva da prvo otklanimo sva nedostižna stanja u koliko ih ima i postupak za uklanjanje nedostižnih stanja smo videli u nekom od predhodnih zadataka, a nakon što smo to uradili također da pronadžemo, da li postoje neka međusobno ekvivalenta na stanja? Jer dakle, u koliko ima ekvivalentnih stanja njih također treba ukloniti, zato što nije potrebno imeti duplikate stanja koji se ponaša i na identiča nače. Tako da naš postupak ovde minimizacije kaže podbroj jedan ukloni nedostižna, odnosno suvišan stanja i podbroj jedan detektu, podbroj dva detektu i dalipostoje međusobne ekvivalentna stanja i u koliko postoje zameniti skupove sa po jednim predstavnikom od svakog tog skupa. Ok, što s ličom uklonitvaju nedostižnih stanja, videli smo već kako to funkcioniše, trebalo bi da bude prvično jednostavno, tako da možemo još jednom, da prvo formiramo skup dostižnih stanja, da vidimo od čega krećemo, krećemo od stanja S1 koja je startno stanje i iz S1 nam je dostižno i S3 stanje. Iz S3 su nam dostižnih S5 i S6. Iz S5 imamo još i S4 koja nismo uključili, a iz S6 takođe i S7. Iz S4 nemamo ni jedno novo stanje, a iz S7 imamo S3. Iz S3, S6 i S5 dakle ništa novo i praktično time smo završili određivanje dostižnih stanja na osnovu ove tabele. Sada kada pogledamo, sistemu me eliminacije kao i malo tpre, hodjemo da identifikujemo što je to nedostižno u ovom automatu i vidimo da praktično nam se nigde napojavio stanje S2, tako da je S2 nedostižno stanje i kao tako ga možemo ukloniti. To kao je malo preznači da ćemo ukloniti ove ove jedan D odnosno vrstu iz naša tabele i time smo smanjili automat za jedno stanje. Dobro, taj dao poslabio lakši. Nakon što smo to uradili treba da odredimo među s obne kvivalentno stanje i da i zamenimo sa predstavnikom. Zavči, celu tu grupu zamenimo sa pojednim predstavnikom, kako bi smo smanjili u kupom broj stanje, minimizavali automat. Međutim, dakle, kako ćemo to uraditi? Pa videli smo malo prei jednu strategiju za detekciju ekvivalentnih stanja. Ta strategija znači da uzmamo svaki par stanja da provirimo, da li su ona među s obne kvivalentna, provirom uslova kompatibilnosti i uslova propagacije. To znači, recimo da sada pošto eliminisamo stanje S2, radimo provoru za stanje S1, S3. Nakon toga, S1, S4. Nakon toga, S1, S5. I tako danje. Sve sve smo, delo je kao mnogo provera. Nek je od ovih provera su i relativno trivialne. Na primer, kada poradimo stanje S1 i S4, vidimo da tu veći ne važi uslov kompatibilnosti, jer je stanje S1 stanje odbijenja, dok je stanje S4 stanje prihvatanja. Tako da bi smo takve parove mogli relativno jednostavno da odbijemo, odnosno odbacimo. Međutim, za ove druge koji ne padajujenu, to je prvoj provori. Morali bi smo doodradimo provoru uslova propagacije samim tim dosta koraka. A opet kad pogledamo z druge strane, ove sam automati nije toliko veliki. Tako da smo klonili ovo jedno suvišno stanje, imamo 6 prostali stanje, što opet nije nešto izuzetno velike automatu. U opštom slučaju, naravno, može imati mnogo veći broj stanja. Međutim, veći vidimo da i s ovim brojem stanja takav neke postupak je prilično zahtevan dosta vremena uzima i nije ideja da zadatke rešavamo na taj navčin u koliku se drže neki veći broj stanje i to će nam uzeti dosta vremena za provoru uslova ekvivalencija. Drugi, možda jednostavni način, a svakako brže da se ovo postigne, je podela skupa stanja u neke dve grup. Odnosno, umesto da proverovamo 2x2 stanja i da od pojedinačnih stanja dolazimo do nakraju skupa ekvivalentnih stanja, mi hoćemo da krenemo uprvo o tih skupova i da onda delimo skupove sve dok nadođemo nakraju do finalnog seta skupova, gde svaki skup zapravo može da se zameni jednim ekvivalentnim stanjem, odnosno nekim predstavnikom tog skupa, zato što se sva stanja u okviru finalnih skupova ponašaju na identične načine, jer su oni među sob nekvi valentine. Kada krenemo od jednog inicijelnog skupa, naravno tu pripadaju sva ova stanja koja su inicijalno dostažna i nisu suvišna. Tako da to bi naš bio jedan inicijelnih skup koji krećemo da razgrađujemo premo prvom uslovu, a to je uslov kompatibilnosti. Znamo je odako da nikada jedno stanje, gde je jedno stanje stanje prihvatanje, ne može biti ekvivalentno za stanjem odbijenja. Tako da inicijelno možemo ovej startni skup podeliti u neka dva, gde će prvi skup biti skup stanja koja su stanja prihvatanja, a drugi skup biti skup stanja koja su stanja odbijenja. Ajde, vidimo koje je to stanja prihvatanja, koja je stanja odbijenja. Stanja prihvatanja će nam biti s4 i s6, a stanje odbijenja će nam biti s1, s3, s5 i s7. Tako stanje odbijenja s1, s3, s5 i s7, a stanja prihvatanja s4 i s6, kao što sam već napomenulo, ne računamo stanje dva, koje prosto nedostižno, izbog toga izbrčeno, tako da ga nema potreba ni posmatrati u ovom skupu, kada određujemo ekvivalenciju. Kada smo podelili naša stanja u dva osnovna skupa, ono što sigurno znamo, je da stanja koja pripadaju jednom skupu nema gubiti ekvivalentna stanjima koja pripadaju drugom skupu. I nikada se ponobot u ti skupovi neće spojiti, tako da će do kraja našega određivanja ova stanja ostati nekompatibilna, odnosno nekvivalentna. Ono što mi hoćemo da vidimo, dalje so finala na dva skupa ili ćemo možda i ove skupove pojedinočno takođe razložiti ponovom i samim tim ili tako nećemo na kraju imati dva stanja, nego ćemo imati ipak malo veći broj stanja. Kako ćemo sada dalje da radimo proveru? Ono što zapravo znači da su stanje ekvivalenta, to znači da se ponašaju potpuno identično za ove sekvence koje postoje. Tako da ono što treba da proverimo na njivo u svaku ovog pojedinočnog skupa je dalje se stanje koje se nalaze u tom skupu, ponašaju međa subno da identična način. To znači da za početak, za sva stanja koje se nalaze u ovom ovdaj prvom skupu, treba da proverimo kako će se ona ponašati ako na ulazu dolađe simbol 0, odnosno dolađe simbol 1. Hajde da vidimo šta se dešava kada na ulazu se pojavljuje 0. Zatim, stanje s1 ako dođe 0 i stanje s1 ostajemo u istom stanju. Dobro, dakle ostajemo u istom stanju. Zatim, zleće stanje s3 ako dođe 0, prelazimo u stanje s6. S6 ne pripada ovom skupu. Samim tim se s1 i s3 ne ponašaju na isti način ako na ulaz dođe 0. I za s3 stanja se prelazio u stanje s6, zbog toga s3 ne može biti kompatibilno sa stanjem s1, s5 i s7 trenutno. I ako stanje s5 i s7 je šuvak nismo obradili. Tezbog toga, poštu s3 ponaša drugačije, izvojit ćemo ga u posebno stanje, a vidat ćemo da ćemo mu priključiti još neko od prostalih stanja koje nismo obradili. Naravno, ještje treba i s6, ostaju izvojeni kao i do sata. Zadim da vidimo za s5 i s7 šta se dešava. S5 ako dođe 0 prelazio u stanji s1, s1 se nalazi u istom stanju u kom se nalazi s5. Tako da za sada s5 se ponaša na identična način kao i s1 izbog toga mogu ostati u istom skupu. A što se tiče s7, takođe ako dođe 0, ostaju u stanju s7 koje pripada istom skupu. Tako da nakon provere šta se dešava sa ovim stanjima u slučaju da se na ulazu pojavio simbol 0, vidimo da se oni ponaša identično, da se stanje s3 ponaša drugačije izbog toga smo njega izdvojili u poseban skup. Što se tiče stanja s4 i s6, nismo ih ispitivali, tako da oni i dalje ostaju izvojeni u svom zasobnom stanju. A ono što radimo kao sledeći korake, proveramamo, da li se s1, s5 i s7...
 i ako na ulas dođe jedinica. S1 ako na ulas dođe 1, prelazi u S3. Dakle, prelazi u S3. Sada, da li će S1 ostati u istom skupu kao stanja S5 i S7? Zavisi od toga. Dali se iz S5 i S7 prelazi u S3 ili se neponašaju kao stanje S1? Tako da S1 ćemo sad ostaviti u tom skupu, međutim, da li će ostati zajedno sa S5 i S7? Zavisi će od toga, kako se automat ponaša kada je u stanjima S5 i S7, a dođe na ulaz jedinica. Kad smo u stanju S5, a dođe na ulazu jedinica, prelazimo u stanje S4. S4 i S3 se ne nalaze u istom skupu. Istoga zaključujemo da se S5 neponašana identiča način kao S1, ako se na ulazu pojevi jedinica. S7, ako se na ulazu pojevi jedinica, iz stanja S7 se prelazi u stanje S3, što je identično ono me što se dešava iz stanja S1. I na taj način zaključujemo da se stanja S1 i S7 ponašaju na identiča način, dok se stanje S5 ponaša drugačije i stanje S3 se takođe ponaša drugačije. I njih njih nećemo spajati, zato što jednom kada utvrdimo da se ne ponašaju identično, prosto više nikada ne spajemo te skupove. U ovom trenutku imamo četiri različite skupa i nakon toga proveravamo skup S4 i S6. Hajde, zavidimo šta se dešava. Sa stanjima S4 i S6 ako na ulazu dođe 0. I stanja S4 prelazi se u stanje S1, a i stanja S6 u stanje S7. Ono što znam u ovom trenutku i da se S1 i S7 ponašaju isto, pripadaju istom ovom skupu. Tako da, iz te perspektive posmatrno, S4 i S6 takođe ponašaju isto i zadržat ćemo ih u istom skupu. Ako se pojevi jedinica na ulazu, kako se onda ponašaju? Iz S4 se prelazi u S4, odnosno ostaje se u S4, a i iz S6 takođe se ostaje u S6. Ponovodakle, i S4 i S6 u istom skupu, destinacije tih prelaza je otako. Izbog toga zaključujemo da se S4 i S6 ponašaju na identično način, odnosno zaključujemo da su oni medživ. S3 možemo je kompatibilni. Pošto nije bilo nikakvih promena, kompatibilni ekivalentni, ona što zaključujemo, jedanakvo nove proveri. Vi zapravo imamo četiri stanja, videli smo da su stanja S1 i S7 ekщоvalentna. Tako da S1 i S7 možemo markirati kao neku stanje a, dobro, neku stanje a, dobro, neku stanje b. S5 ćemo markirati kao neku stanje c, a, S4 i S6 kao neku stanje d. Naravno mogli smo ih i drugačije nekako nomerisati, i njih ćemo povezati, i od njih ćemo napraviti rezultojići graf. Stademo u očnem slučaju, ovo i danje ne bi bilo kraj algoritma, zato što je mogla da se desi na specificna situacija. U slučaju da recimo se pokazalo da S4 i S6 nisu među sobno ekvivalentni, moglo se desiti da neki od preostalih ovih stanja koje su do sada tretira na kao ekvivalentna i pak nisu ekvivalenta. U slučaju recima da smo u nekom trutku zatručili, da se i stanja S1 prelazi u stanji S4, a i stanja S7 da se prelazi u stanje S6, koji su u to momentu pripadali jednom identičnom skupu, na osnovu toga smo zaključili da su S1 i S7 ekvivalentna stanja, međutim nakon toga se ispostavi da S4 i S6 i pak nisu i da samim tim ne pripada i u istom skupostanja. To bi značilo da S1 i S7 se ne ponašaju identično i da bi ih trebalo razdvojiti u zasebne skupove i onda oni ne bi bilo ekvivalentna stanja. Ova se može praciti na više načina. Ili tako što ćemo naravno pamiti u šta se radilo, da je postoje taj prelas i onda nakon što vidimo da se recimo desilo ovo nakradno odvajanje praktično to povežemo, ali tako i razvojimo stanja koja se tako različito preslikavala, ili tako što ćemo spraviti prosto še jednu iteraciju dok se na uverimo da nema promena i da smo zaista završili sa našim algoritm. U svakom slučaju u ovom konkretnom primvru naš algoritm je završen, imamo neka četiri stanja i pošto se takle ove S1 i S7 ponašaju potpuno identično kao S4 i S6 međusobno uzelismo da je to kao jedan predstavnik, povezat ćemo ove graf i formirat ćemo naše minimalne ekvivalentno tabelo prelaza i to je u suštini ono što se od nas tražilo u ovom zadatku. U principu, oba ove naravno načina za detekciju međusobneguvalentnih stanja su legitimna i u najvećem broju slučajeva nije zadat o koji se algoritm koristi. Međutim, jasno je da ovaj drugi algoritm znatno može da uštedi vreme na ročitom situacijama kada prosto postoji veći broj različetih stanja, zato što prosto, kao što smo rekli na početku, ta dva algoritma različeta funkcionišu. Prvi polazi od pojedinočnih stanja i proba da ih spoji, tako što će otkriti međusobno da su ove nekvivalentno, dok od ovog drugog kreće se od jednog skupa, on se razvaja na temelju kompatibilnosti stanja i razvaja se, kao da ide od korena, ka listovima nekog stabla. Svedok ne pronođemo zaista minimalni set, minimalni set skupova, gde svaki skupo buhvata sva međusob nekvivalenta nastanja. Nakon deterministričkih konečnih automata dolazimo i do druge grupe konečnih automata, a to su logično nedeterministričke. Razlika u odnosu na prvu vrstu automata, koji smo prošli malo pre, je u tome što, kao što i samo ime kaže, postoji određen izvor nedeterminisma, koji se ogleda time da prosto na osnovu trenutnog stanja i simbole koji dolazi na ulazu, ne možemo jednostno na jedinstven način praktično odrediti, koja će biti to sledat će stanje, po kome će se nastaviti prepoznavanje konkretne segvence. Taj nedeterminizem se ogleda u nekoliko stvari i to možemo primetiti na ovom primeru jednog nedeterministričnog automata, koji vidimo u okviru prvog zadatka, a to je za početak da imamo više startnih stanja. Tako sam, automat naravno ima potpuno identične gradivne elementa, što znači ponovno ima neki ogranični skup stanja, takođe ikonočni skup simbole koji se mogu nalaziti na ulazu, kao i stanje prihvjetanje i stanje odbijenja, međutim imate neke izvara nedeterminisma, i to je prvi koji primećujemo, je da ima više startnih stanja. I to vidimo tako što imamo više strelica sa leve strane uz stanje. To znači da nismo sigurni dalih prepoznavanje naše segvence kreće iz stanja a, b ili c. Osim toga, nedeterminism se ogleda i u tome, što ono što primećujemo, u koliko se, recimo, trenutno nalazimo u stanju a, a na ulazu se pojavi simbol a, mi nismo sigurni dalih prelazimo u stanje a, b ili c. I to vidimo se pojavljio u opštom slučaju više strelko u samom automatu. Na taj način dakle prosto nemamo jedinstveno određeno kako se automat ponaš. Traće izvorni, nedeterminisma nije direktno prikazan u ovom automatu, međutim on prestavlja ostojanje nečegu što se zove epsilom prelaz, ili epsilom sekvencem. I ona podrazumeva da se u samom automatu dešava prelaz u novostanje, čak je u koliko ne postoji konkretan simbol sa ulaz. To znači da se prosto neke prelaz može, a i nemora deseti, bez potrebe da postoji konkretan simbol na ulazu. Nešto ćemo o tome više kasnije pričiti, kada budemo videli na konkretnom primjer. Ono što je posledica kod ovakvih automate, nešto se može očiti na jednom primjeru automata, gde se identično sekvence može, a i nemora prihvatiti. To je sekvence 0,1,1 koja u koliku primjećujemo, ako njeno prepoznavenje ide kroz stanja S0, S1, S2 i završavu stanju S3 koja je stanji prihvatanja, ova sekvenca će naravno biti prihvaćena, međutim, u koliko ide od startog stanja koja je stanja S0, preko stanja S1, pa se vrti u tom stanju S1 i završi u njemu, ovo neće biti sekvenca prihvatanja, kao takođe i u koliko završi u stanju S2, dakle biće sekvenca odbijena. Tako da ono što možemo primjetiti da prepoznavenje i identične sekvence može rezultovati, dakle potpuno različitim rezultatima.
 Ukoliko hoćemo malo da formalizuemo kako izgleda ovo prepoznavanje sekvence, ponovno imamo algoritm za prepoznavanje, možemo proći kroz njega. I u principu počemu se razdakuju ove algoritme u odnosu na prepoznavanje sekvence kod deterministično-konačnog automata, što sada umesto jedno konkretnog tekućeg stanja u kome se nalazimo, zapravo imamo tekućeg skup stanja. Inicijomno tekućeg skup stanja se određuje kao unija svih startnog stanja. Tako da početno stanje ovde jasno ne može se jednoznočno odrediti već je to skup stanja A, B i C, dok je tekućeg ulaz prvi simbol ulazne sekvence. Sekvence se prepoznaje svedao k se ne dođe do njenog kraja, a na koji način se radi prepoznavanje korak po korak, pa u principu za svako od stanje koje se nalaze u tekućem skupu stanja, formiramo, dakle, jedan, novi skup stanja i njega dobijemo tako što uniramo praktično prelaze iz svakog stanja koje se nalazi u tom tekućem skupu za odgovarići simbol koji se našla ona ulazu. Tako da gledamo gretno, ukoliko bi smo to sad posmatrali na ovom primoru inicijalnog skupa stanja, što je A, B i C, ukoliko se pojavi A na ulazu, stanja u koje se prelazi, odnosno skup novi stanja u koje se prelazi, je unija svata tri ulaza, tako da bi to bilo A, B, C i E kao naradno, dakle, novi skup stanja koji bi onda postao tekući u naradnoj iteraciji. I tako, idemo sve do kraja ove sequence kojio prepoznamo i na kraju takođu, kao i malo pretreba da odretimo, da je konkretna sequenza, sequenza prihvatanja ili odbijenja i to radimo tako što pogledamo ponovno finalno stanje u kojom smo završeli. Međutim, kao što smo videli, dakle, mi suštavski ne završavamo u jednom stanju, već je to neki skup stanja koji je krajnji i ono što je potrebno da vidimo, da li postoji makar jedno stanje koje bilo označeno kao stanje prihvatanja, ako je će se naći u tom finalnom tekućem skupu stanja, u koliko se nalazi makar jedno tako stanje, označavamo da je sequenza-sequenza prihvatanja, a u suprutnom ako su sva stanja odbijenja, označi ćemo da se sequenza odbije. Dobro, sada smo malo i formalizuvali ovo prepoznavanje i procesiranje same sequence, međutim, kada malo zdravorazmski promislimo prosto, nedeterministički automat nije toliko, da nekažem, nije uopšte primenljiv implementacional praksi, u koliko je prakciču ima toliki izbor, nedeterminismo, da mi nismo sigurni uopšte kako će se dati automat ponašati. Tako da zbog toga potpuno ima smisla ovaj nedeterministički automat nekako konvertovati u nešto što će za nas imati smisla i što ćemo zapravo moći da implementiramo. Izbog toga postoji algoritm za konverziju iz nedeterminističku u deterministički automat, koji funkcioniše zapravo identično kao algoritm zaprepoznavanje sequence, uz par dopun. Sad ćemo konkretno na ovom primeru viditi kako izgleda taj automat za konverziju i nalačno će nam biti da ponovno zapišemo nekako taj primer. Znači, reprezmo, krenućemo od neku ulaznog seta stanja i uzrećemo ga kao uniju inicijelnih stanja, što je bilo A, B i C, čim njim i se. Tako je A ulazni simboli koji postoje u ovom konkretnom automatu koji se prihvataju Su A, B i C. Ok, dobro, videli smo pri prepoznavanju. Za svaki stanji koje se nalazi u nekom tekućem skupostanja, za odgovareći simbol pravimo uniju ovih ulaza, izbog toga, isto tako ćemo raditi i konverziju, ćemo reći da za ove inicijelni set stanja koja je A, B, C, ako se pojevi A, uzrećemo uniju ova tri ulaza, što znači stanja A, B, C i E. Ok, ukoliko se pojevi B, uvezit ćemo ponovu uniju ova tri ulaza i to će biti stanja A, B i C i ponovu za simbol C, uzrećemo uniju ova tri stanja i to će biti E i D. I što radimo u sljedećem koraku, dopuđujemo naš početni skup ovih setova stanja trenutnih, o nim setovima koje nemao do sada, tako da će to za nas biti A, B, C i E i u sljedećem koraku D i E, ovaj set od A, B i C već imamo iz prvo koraka, tako da tu praktično nemo nikakve nove informacije. Što zdiče ABC i E seta stanja, ponovu da bi smo videli u koje stanja sve može da se pređe ukoliko dođe simbol A na ulazu, napravimo uniju ova četiri ulaza i imaćemo al tako ABC, E, ovdje imamo CA i ovdje E, dakle ponovu će biti u pitanju jedno isto stanje, pa ćemo ga samo prekopirati, tu se ništa neće promeniti. Što se diče toga šta se dešava, ako dođe B, imaćemo ABC i E, tako će to biti ponovu identično stanje, al tako, i u slučaj da dođe C, imaćemo ponovu al tako uniju ova tri ulaza i ovaj, što znači E i D, a to je isto ono što smo imali malo pre, tako da nemamo ni tu nikakve, pardon, nove informacije. Dobro, za skupko i čine stanja D je, ukoliko dođe A na ulazu, ponovu al tako imamo uniju ova dva ulaza, to su ponovu D je, ako dođe B, imamo takođe D je, tako da tu nemamo ništa nova, međutim ako dođe C, imamo AB i E, a to je set koji nismo videli do sada, tako da ćemo govrstiti u naš inicijelni skup stanja i videti šta se dalje dešava. Za uniju AB i E ponovu imamo ABC i E, možemo to kopirati, dakle tu nemamo ništa nova. Ukoliko dođe B, imamo AC i E, je l tako, dakle to nam je unija ulaza AB, CA i E, a to je nešto što nismo videli do sada, tako da ćemo time proširiti naš skup. I ukoliko dođe C, imaćemo samo E, što takođe nismo imali do sada, tako da je to u ovom koraku proširujemo naš skup za dva nova seta stanja. AC, E i samo E. OK, što se teče skupa stanja AC i E, da vidimo šta se dešava kada nam se na ulazu pojavi symbol A, ponovu uzimamo uniju, il tako i to će biti ABC, E. Što već imamo, ilte, dakle tu ništa neće promeniti. Ako dođe B, dakle posmetram ulaza AC i E, Ako dođe B, imamo BC i E, i ako dođe C, imamo ulaze, imamo stanja E i D i to je nešto smo već imali, tako da tu nemo ništa nema. Međutim u ovoj iteraciji smo pronašli novih set BC, E, tako da ćemo njega ubaciti u ovu našu tabelu. Što se teče E, stanja i skupa koji se stoji sklučivo, tih stanja tu samo možemo prepisati ono što se nalazi ovde, tako da tu nemo ništa novom. A što se tiče skupa BC i E, ako dođe A na ulazu, imamo AC i E, ako dođe B na ulazu, ABC, E i ako dođe C na ulazu, ovo je što kombinacija BC, E, ako dođe C na ulazu, imamo DE i E i takle u ovoj iteraciji ne dobijemo jedan u novi skup stanja i tima smo konvergirali u algoritmu, odnosno, završili smo transformaciju. E sad ako uhoćemo da od ovoga zaista napravimo determinističke konečne vtome, to, na što nam je ostalo, je da svakamo ovom set u stanja, dodelimo neki jedinstveni naziv i to, dakle, možemo u ovom slučaju jednostavno uvraditi, tako što ćemo reći, ovo je...
 S0, ovu će nam biti S1, ovu će nam biti S2, sledeće stanje će nam biti S3, sledeće S4, nakon toga ide S5 i stanje S6. I sada kada ovu povežemo, zamenimo jel tako ove ulaze sa novim nazivima stanja kako smo ih upravo dodelili, mi ćemo dobiti jedan običan deterministički konečni tomet, da ćemo za svaku kombinaciju trenutno stanje i simbol koji se nalazi na ulazu, imeti jedinstveni prelaz u naradno stanje datog determinističu konečnog automata. To nije konkretno bilo odraženo u ovom zadatku, međutim je to hteli smo da vidimo kako se radi tako u enverzije, to je nešto će nam svakako biti potrebno u naradnim zadacima. I već je temo sledećeg zadatka koji kaže o dreidi deterministički konečni automat koji je kvi valentan datom nedeterminističom, da je dakle treba primeniti potporo identičnu proceduru kao što smo to uradili sada. Jednostavar smo zaborvili, to je da odradimo koje su dovi stanje stanje prihvatanja, a koje su stanje odbijanja. I kao što reko, kad smo precisnije definisali procesiranje samih sekvenci i prepoznaveni ovim nedeterminističkim automatom, to ćemo odrejiti tako što prvo vidimo koje su inicijalno stanje prihvatanja i to je stanje C. Bilo koji skup finalnih stanje koji u sebi ima stanje C je stanje prihvatanja, odnosno skup prihvatanja je alzako, a one koji nema je odbijanja. Tako da ovde dakle S0, S1, S4 i S6 bi bila stanje prihvatanja dog bi sva ostala stanja bila stanja odbijanja. Da se vratimo za datku 2, dakle za datak 2 kaže o dreidi deterministični konečni automat koji je equivalentan datom nedeterminističom. Da smo mi, dakle, videli kako izgleda taj algoritm i kao što reko, algoritm je veoma sličeno ono me koji služi za prepoznaveni sekvenci, jedino što dodatno imamo na kraju ovom piranje u nova stanja. I to je opisano ovim ovde postupkom. Kao što vidimo, ono što nismo na primer malo preimali u prvom zadatku, to je da određeni ulazni takođe mogu biti prazni i to zapravo označava da je u pitanju neka greška. Što znači da ukoliko se nalazimo u stanju b, a na ulazu dođe y, to je neregularna situacija, dakle tako nešto ne bih smelo da se desi i ako se desi, onda dolazi do greške. U principu, takva greška se može modalovati ili ovako praznim ulazom ili se može označiti nekim petim stanjem u ovom slučaju, najčešći su označava zapravo stanjem e. Što možemo primjetiti da smo najverovatni imali u okviru ovog prvog zadatka, samo to nismo dodatno razmatjali, gde stanje e bi onda bila označeno kao neka greška, a to najčešći vidimo po tome što se iz stanja e nikada ne vraćemo u neko regularno stanje, zato što prostu jednom kad imamo grešku, imamo grešku do kraja i to je na arno stanje odbijenja. U principu, kao što reko, možete modalovati ili praznim ulazima ili alaciranjem novog nekog stanja, koja će onda ove biti označeno prosto kao stanje greške i iz koga kasnije nema pogratka u regularno stanje. Ok, hajde da vidimo kako ćemo ove da konvertujemo u jedan determinističke konačne utomet, pošto smo sad da upoznati sa procedurom, možemo i samo proći kroz rešenja ovde. Dakle, inicijalno biramo start na stanja i kažemo da oni pripadaju skupu startnih stanja, tako da će to biti a i c i onda za svaki od ovih prelaze radimo uniju odgovarajućih ulaz. Tako da ako izbieramo a i c kao startno stanje, odnosno startnih skup stanja, u slučaju da dođe x, prelazi se u skup ad, u slučaju da dođe y, prelazi se u skup cd i u slučaju da dođe cd, prelazi se u skup koji ima samo stanje a. I to je ono što vidimo, dakle na osnovu ovog ovde ulaza. Nakon to prvo koraka, vidimo da smo uvrstili još neke nove parole, odnosno nove skupove ad, cd i a. I njih sve dodajemo u ove naše ovde skupove koje do sada nismo videli, nakon toga na potpuno identično način radimo uniju. Za ad unija je al tako ad, c i a, to dodajemo ad, c i a, do sada nismo videli skup c, tako da ćemo njega ovde uvrstiti. Za c i d unija je d, c d a, tako da to takođe dodajemo, d, c d i a, tako je. I nadalje nastavljamo prosto naš aloritom do kraje. E sad, ono što primećujemo ovde, cd je da smo ovde eksplicitno stavljali prazen skup za stanje greške, dakle nismo ostavljali ovdje u nako samo prazno polje, već smo ubacili to neko stanje greške. Kao što rekok, ono je jedino što je bitno, koje god notacija da se usvoji, jedno što se jedno muži u to stanje greške, bilo koji simbol da nam se pojevi na ulazu, ostaje se u stanju greške i to je obovezno stanje odbijenje. I na kraju kada smo konvergirali sa algoritmom, ono što nam ješo ostaje da provarimo, takle koje su to bila stanja prihvatanja, inicijelno su to bila stanja c i d, tako da svi naši skupovi koji budu ovde sadržali stanje c i d su stanja prihvatanja i vidimo da je to ovdje stanje, stanje ad, stanje cd, stanje c i stanje d. Možemo ostaviti ovakvog algoritm, automot pardon, možemo premapirati ove setove, odnosno skupove stanja u nove nazive i formirati graf ili prikazati u to objelvarno stanju, potpuno je sve jedno. I ostavno mi je još jedan zadatak u sklopu ove lekcije, a to je zadatak koji kaže, konstruisati minimalni deterministički konačniju automot, koji prihveta sve i samo one sekvence oblika s1 s2, gde je s1 sekvenca koju prihveta automaca slike a, a s2 sekvenca koju prihveta automaca slike b. Ok, u ovu zadatku imamo neka dva automata. Prvi automat prihveta sekvenca oblika s1, drugi automat prihveta sekvenca oblika s2, a uno što mi treba da uratimo je da konstruisamo neki treći automat, koji će da prihveta sekvenca oblika s3, gde je to s3 zapravo, kada je nacija sekvenci s1 jezva. I naravno treba da bude deterministični konačniju automot i to da bude minimalni. Tipočno, s vremnina na vrijeme se prosto daju ovakvi zadaci, gde je onda to bude neka kombinacija problema, tako da se obje sekvence prihvata je od strane automata, moguće je naravno da bude dato i da se obje sekvenca odbijaju, ili da se neka odbijaju, ili tako razvečete neke varijante. Mi ćemo sad da vidjeti u ovaj varijantija, naravno dalje prosto nije njišta specijalno teško kombinovat u ovaj varijante i malo modifikovati problem i onda naravno samim tim rešenjem. Šta je namaj cilj? Namaj je cilj da formiramo neke rezultujiči automot, koji će dakle prihvatati sekvence oblik s3, koje predstavljuju konkatenaciju sekvencije oblik s1, s2, d s1 sekvence koje prihvata prvi automot, s2 sekvence koje prihvata drugi automot. Znači, ono što nam treba je da formiramo te rezultujiči automot i onda što nam je jasno, je da ta rezultujiči automot kako praktično mora izgledati u odnosu nova početna dva automata. Znači, ono mora sadržati sve informacije koje se drža ova dva automata. Pošto se u sekvencije s1 nalaze simboli a i b, u sekvencij s2 u nekoj kombinaciji simboli b i c, onda jasno dove rezultujiči automot mora sadržati mogućnost da ima bilo koji od ovih simbola, tako da simbole a, b i c i da su u druge strane narbno bukvata sve ove informacije koje bukvata u ovih automata, što znači kompletna stanja koji ovo ne o bukvata je kao i prelaze koji se tu nalaze, pa ćemo onda vidati čime još možemo da dopunimo ove naš rezultujiči automot. Dakle, za početak ovdje imamo šest nekih stanja za sadam. I imamo na ulazu i ataku a, b i c. I dobro, sad trebao da vidimo kako ćemo doformiramo rezultujiči automot. Bošto mora se prepozneni sekvenca s1 i sekvenca s2, a to jako dobro rade oba automata pojedinočno, onda ono što nam je ostalo je da prosto prekopiramo ono što imamo u okviru da dva automata, što će nam obezbediti pojedinočno prepoznavanje sekvenci s1 i s2. I z prvog automata, dakle, ono što vidimo je da tako startno stanje nam je stanje nula.
 I izostanja nula ako na ulazu dođe malo a, prelazimo u stanje 1. I izostanje 1 ako dođe malo a, prelazimo u stanje 2. Ako dođe malo b, ostajemo u stanju 1. A i izostanja 2 ako dođe malo b, prelazimo u stanje 0. U principu to je to što stiče prepoznavanje konkretna sekvenca S1. Što se stiče prepoznavanje sekvence S2, onaj deo drugog automata. Startno stanje u tom drugom automatu je stanje a. I u kolikom dođe malo b, prelazimo u stanje... Prelazimo u stanje b. Ako dođe malo c, prelazimo u stanje c. Što se tiče stanje b, ako dođe malo b, prelazimo u stanje c. Ako dođe malo c, prelazimo u stanje a. I to bi trebalo da je kompletna informacija koji smo mogli da prepišamo prosto iz ova dva automata. A ono što je naš sledaći cilje da nekako povežemo prepoznavanje ove dve sekvence i da dobijemo neku rezultujiću sekvencu koji treba da prepoznaja tako ovaj rezultujići automat. Ok, hajde vidimo kako ćemo to dograti. Prvo ako malo analiziramo ove ovde sekvence, onda ova što možemo da primjetimo je da prvi automat koji prepoznaje sekvencu u 1 prihvata kakve sekvence. Pošto vidimo da je start na stanji, stanji prihvatanja, to znači dove je automat prihvatel tako sve sekvence koje se završavaju u početnom stanju, stanju nule i sekvence koje se završavaju u stanju dva. Ako automat prihvata odmah početno, očnog startno stanje, to smo ću videli u onom nekom od početnih primjera, to znači da ćemo zapravo prihvatati i praznu sekvencu. To znači da s1 može biti prazna sekvenca, što znači da automatski prepoznavanje s3 rezultujiće sekvence može krenuti od prepoznavanja s2 sekvence. Zbog toga, osim što je nul to stanje startno, takođe će i početno stanje drugog automata biti startno i to je stanje a. Tako da ove našne nedeterminističke automate koji ćemo prvo da krejramo, može imati dva startna stanja, to su stanja nula i a. Kao što je reko, kova stanja nula, automatski se vidi zbog čeve startno stanje, a startno stanje je takođe i a zbog toga što ove prvi automat prihveta i praznu sekvencu za sekvencu i je. Ok, sledeća stavka koju možemo da primetimo, 1. Automatski, čim se prepozna sekvenca s1, treba skočiti na prepoznavanje sekvence s2. Što znači da u ovom našem rezultujićem automatu nekako moramo obezbediti da čim je prepoznat prvi del sekvenca s3, znači del koji se odnosi na s1, mora da se skoči na drugi del automata koji radi prepoznavanje sekvence s2. Kako ćemo to da uratimo? Pa u principu, ako pogledamo ovde, dakle, bilo kada kada je prepoznata prva sekvenca, odnosno prvi del sekvence, treba skočiti na prepoznavanje drugog dela sekvenca. Šta to znači? To znači da ako u ovom prvom automatu, prelazimo u stanje dva. Stanje dva je stanje prihvatanja. To znači da nakon toga automacki možemo preći na drugi del automata koji radi prepoznavanje drug dela sekvenca. Isto se odnosi takođe i na stanje nula koja je stanje prihvatanje. Znači automacki ako prelazimo na stanje nula koja je stanje prihvatanja, mi možemo nastaviti i na drugi devo automata i time omogućiti prepoznavanje drug dela sekvenca. Tako da u ovom našem rezultućem automatu treba da kažemo da kada god završimo u stanju prvog dela automata, možemo preći i na drugi devo automata koji treba da nam prepozna sekvencu s2 koja je sada pripadal tako ovoj sekvenci s3. Naravno pogledamo takođe kako je sekvenca s2 i dalje ovo je automat prihvata praznu sekvencu i vidimo da to nije sluči, zato što startno stanje nije stanje prihvatanje. Zbog toga s2 mora biti sekvenca od bar jednog karaktera, možemo da analiziramo da vidimo koje, ali u svakom slučaju to će za posledicu imeti da mi jedno stanje prvog automata ne može biti stanje prihvatanja. Tako, sigurno se mora procesirati bar jedan karakter drugi sekvence kako bi to bila usvojeno da je sekvenca prihvatanja. Ok, šta smo do sada postigli? Do sada smo postigli prepoznavanje s1 iskakanje na drugi devo automata u pravo ovakvim prelazima, na drugi devo automata, tako da taj drugi devo automata treba da prepozna sekvencu s2. Kada smo skočili al tako na drugi devo automata, to znači šta smo mi ovde sad rekli? Rekli smo, aha dobro, krenemo od startnog stanja nola, ako dođe malo a, prebacimo se u stanje 1. Ako dođe malo b, idemo ostavimo u stanju 1, ali ako dođe malo a, možemo da se prebacimo u stanje 2, pa tamo da nastavimo procesiranje, ali takođu poštoće naša sekvenca ovde s1 biti sekvenca prihvatanja, možemo iskočiti na prepoznavanje drugog dela sekvenca. Isto to važi praktično i za ovaj ovde prelaz. Znači ako smo u stanju 2, a dođe malo b, možemo preći u stanje 0 nastaviti sa prepoznavanjem prve sekvence, ali takođe možemo skočiti i na stanje a, i time prepoznavati drugu sekvencu. Kad smo prešli na prepoznavanju drugog dela sekvenca, odnosno sekvence s2, sve što praktično treba da uradimo, je da prepišemo koja je su stanja prihvatanja, odnosno stanja dbijenje iz onog drugog automata, razlog za to je, zato što je sada prosto potrebno prepoznati sekvencu u 2, a to je onaj drugi automat znao kako se radi. Znači on kaže stanja je stanje odbijenja, stanje b je stanje prihvatanja i stanje c je stanje odbijenja. Što znači da nakon ovoga mi možemo da kažemo da je zapravo samo stanje b je stanje prihvatanja, a da su sva druga stanja u ovom rezultojićem automatu zapravo stanja odbijenja. I mi smo formirali naš rezultojići automat koji prepoznaje sekvence ovakog obrata. I sada, naravno, ovaj automat je nedeterministički automat, tako da ukoliko želimo da formiramo automat koji je bivu i ciljog zadatka, to je deterministički automat, ono što moramo da uradimo je da uradimo transformaciju i da ovakav nedeterministički automat prevedemo u jedan deterministički konačni automat. Kada pogledamo kako izgleda ovo rešenje, njega ćemo samo ukratko objasniti zbog to, ako što ono izgleda malo drugači. U ovim ovom rešenju, osim ovog standardnog dela koji se odnosi na one prvi kora koji smo napravili, da to je da smo samo kopirali prvi i drugi automati na dovezali ih jedan na drugi, imamo i nešto se zove jedna kolona za onej epsilom prelaž, što sam pominjala u uvodu o nedeterminističkimi automatima, a to je da se tu praktično radi o nekoj praznoj sekvenci, gde može postojati prelaz, a ne mora da postoji u tom slučaju. I to je upravo ono što sam malo preirekla, kad se jednom nađemo u stanju prihvatanja prvoga automata. Bilo da je to stanje nula ili stanje dva, od atle se može preći na drugi deva automata. I to je označeno ovim prelazom po epsilon sekvenciju, odnosno epsilon prelaz, koji će dakle reći, u ovom trnutku se može preći na drugi automat, ali ne mora. Već, pošto će sigurno se pojaviti nešto od ovih simbola, može se naravno i ostati u ovom prvom automatu, osim, naravno, u slučaju da se pojavi simbol C, što ne postoji ka obrada u prvom automatu. Međutim razlog zašto smo mi malo prej, baš onako napisali nedeterministički automat, a ne ovako, je što u principu epsilon ne predstavlja terminal. Zmog toga njega ne treba pisati ovako u obliku ovom koji je predstavlja ovdog rešenju. Već bi rešenje trebalo predstaviti baš ovako, kako smo i videli malo prej da se predstavlja i nedeterministički kornčne automati. Ove ovde stadiju, u međutaku kažemo o stanje,
 automata u rešenju je predstavljeno tako, zato što je moš da jednostavnije malo za razumevanje. Prosto svatite ti da jednom kad smo došli u stanje prihvatanja kao što sam rekla, možemo preći na drugi deo automata, a ne moramo. I to je simulirano ovim epsilom prelazom, međutim formalno nije isprvno i zato da tle nemojte ostavljati takva rešenja na kolokvijomu odnosno ispitu, već rešenje prikažite na ovakav način. I sad naravno ovde je nakon toga trebalo prikazati konverziju u determinističke koračne u tom, tako da bi smo to uradili identično kao što smo do sada radili, pokupili start na stanja što su stanja nula i jedan je o tako, to stavili u jedan inicijelni skup i nakon toga ponovlo kao i do sada prosto radili unije odgovarajućih uleza i formirali determinističke ekvivalenta ovog nedeterminističvog konočnog automata i tobe praktično bio ovde rezultujiči automata. Kao što je reku, postoje različete kombinacije ovog ovde problema, treba prostupo razmisleti kako bi se formiralo rešenje, u koliko bi se jedan prihvatao, drugi ne prihvatao, jedan bio u izvornoj sekvencii, drugi tražio recimo do prihvata potpuno obrnute sekvence i tako dalje. U principu svi problemi se rašavaju na veoma sličanacin, samo je potrebno malo modifikovati problem i malo modifikovati rešenje. Dobro, to bi bilo to što se tiče determinističkih i nedeterminističkih automata. Slediće lekcije će nam biti regularni izrazi, gdenam je cilj da prosto razmotavamo malo ovo klubko, da vidimo kako pomoću regularnih izraza i zapravo prepoznajemo u lekcijkoj analiziji određene nizove karaktera koje želimo nekako da spakujemo i kako onda od prosto toga što smo radili i što smo prepoznali formiramo ove automate koje sada znamo prosto kako koristimo i kako procesiramo pojede inočne sekvence. Slediću lekciju u okviru lekcijke analize predstavljuju regularni izrazi i kao što smo već pominuli, regularni izrazi će biti delo i naše projekta i jedno od naših tema. Gde će nam datlio biti cilj da zapravo definišemo neka pravila prepoznavanja pojedinih sekvenci koje se pojavljuju na ulazu, prepoznamo ih kao regularne izraze, dakle na osnovu nekog pravila i kasnijih transformišemo u konočne automate a potom i koristimo na opisani način. U okviru samoj projekta mi ćemo definisati neka pravila, recimo da ukoliko prepoznamo nijegih cifara na ulazu, to interpretiramo kao neku celobrojnu vrednost. S druge strane, dakle kako prepoznamo pojedinočne karakteri, dakle šta su za nas karakteri, šta su nizovevi karaktera, recimo kako definišemo variable, tako da prosto imaćemo neke neka pravila na osnovu koji ćemo te sekvence prepoznavat i da će koristiti na odgova reći način kroz fase izraze compiler. Što se tiče samih regularnih izraza, u suštini oni opisuju na neki formalni način različite skupove ulaznih sekvenci i sada ćemo vidati kako to prosto formalizuamo kroz neka pravila, zatim nam je cilj da vidimo neke osnovne operacije koje postoji koja ćemo definisati i nakon toga da prođemo kroz dva algoritma zakon verziu iz regularnih izraza u nedeterministice konočne automate i naravno potom nam je cilj da na osnovu toga formiramo deterministice konočne automate i da je naravno znamo kako ih koristimo. Ok, u principu ono što nam je cilj je da na ulazu dobijemo neki regularni izraz i da procesiramo određenu sekvencu korišnjem tog regularnog izraza odnosno da je prepozna. Na neki formalni način ćemo opisati nekoliko razvečitih operacija koja ćemo koristiti i osnovne operacije koja ćemo koristiti su operacije unije, gde operacija unije zapravo podrazumeva da postoji ili jedan deo sekvence ili drugi deo sekvence. Naprimer, ukoliko formalno koćemo to nekako da predstavimo, onda u ovakvim nekim oznakama unija a ili b se definiše kao skup nekih sekvenci, to ćemo oznacovati s ovim l, kao skup nekih sekvenci a ili b, gde znači biće pronadžena ili sekvenca a ili sekvence b i to je predstavljeno na ovakvi jedan način. Zatim operacije konkatenacije ili operacije na dovezivanja gde formalizovanop predstavljeno zapravo se pojavljuju sekvence koje predstavljuju konkatenacije u neke dve sekvence a i b u ovom slučaju. Osim toga imamo dve operacije ponavljanja, prvoje operacije zvezdasto zatvaranje koja zapravo predstavlja ponavljanje od nola do bezkonačno puta, što znači neka sekvenca se ponavlja maksimalno tako neograniceno, međutim minimalno može da se ne pojavljuje uopšte i to nam zapravo simbolizuje ono neku epsilon, epsilonane prelaz, odnosno praktično nepostojanje do gdje se druge strane imamo i pozitivno zatvaranje, odnosno plus zatvaranje koje podrazumeva ponavljanje te sekvence barem jednom, a naravno maksimalno neograniceno puta. I u principu ove operacije ćemo mi koristiti da bi smo opisali sekvence gde ovdje imamo u nastavku neke primere odveđenih regularnih izraza i njihovi definicija, gde kažemo da recimo koje je to skup sekvenci koji zapravo predstavlja konkatenacije u nekih simbola A, B, C, pa kao što vidimo u tom skupu nalazi se samo sekvenca A, B, C. Dakle to je neki terminalni simbol A na koji se nadovezuje simbol B i na koji se nadovezuje simbol C, tako da je to sekvenca koju mi ovdje prihvatalo. Sa druge strane ako hoćemo da opišemo koje se to sve sekvence prihvataju u koliko imamo uniju simbola A, B i C, vidimo dakle da su to sekvence koje se zastoje od jednog karaktera A ili B ili C. Ukoliko recimo hoćemo da opišemo sve sekvence koje je odgovare ovakom nekom pravilo, a to znači da predstavljuju konkatenaciju unije simbola A i B i simbolas C i D. To znači praktično da će to biti konkatenacija po jednog elementa iz prve unije i jednog elementa iz druge unije, što znači da imamo mogućnost sekvenci AC, AD, B, C i B, D. Po jednoj od tako element iz ove unije. Ukoliko recimo koćemo da predstavimo koje to sve sekvenci zadovoljavaju zvezdasto zatvarnje. Kao što reko, minimalno je da nemao ni jedan karakter i to bi su mogli nazviti nekom epsilon sekvencom, to je praktično nepostojanjem ni jednog karaktera u okviru te sekvence. Zatim jedno pojevlivenje tog simbola u ovom slučaju A, dva pojevlivenja, tri pojevljivanja i tako dobeskonačno. U principu skup sekvenci koji bi opisivao pozitivno zatvarnje bio identičan, osim što ne bi imao na arno ove epsilon, jer smo već videli da pozitivno, odnosno, plus za zatvarnje podrazume o ponavljenje od makar je dan put datokaraktera u neku i sekvenci. Slednjići naš primer, kako izgledaju sekvence koje predstavaju pozitivno zatvarnje unije A i B, to će značiti da praktično imamo ponavljenje od bar i jedan dobeskonačno, nekoj simbola iz A ili B, ali u svako iteraciji tog ponavlja naravno možemo uzeti ili A ili B, dakle ne moramo od početka do kraja uzimati tačno taj jedan simbol koji smo izberali na početku. Tako do skup sekvenci koji opisuju ovakvi jedan regularni izraz, su recimo A, B, AB, AAB, ABA, ABB i tako daje. Dakle, maksimalno naravno potpuno neodređeni, odnosno neogranicem broje pojedinočnih ponavljenja ovih simbola. Takođe, kada opisujemo neke regularne izraze, odnosno koćemo da definišemo neku prepoznavenju od guvaraće sekvence, najčešće takođe nam je od interesa da znamo i koji sve simboli mogu biti u toj sekvenci. I onda često rodi nekih praktičnih primena, kao što sam već navila neke primera, to je prepoznavenje neko gni za karaktera ili niza cifara, gde ili nekih identifikatora koji su definisani na ugovarajući način, gde recimo slova ili ti karakteri mogu biti iz nekog određanog obsega. Tada često uzimamo kao neke smene, odnosno zame, nekde prosto ukoliko želimo da ugovarajućemo obsegu, imamo neke karakteri, da ih ponavljamo veći broj puta, mi naravno ne moramo navoditi svaki karakter pojedinačno ugvjero tog nekoh regularnu izreza, već ovo što možemo uraditi prosto
 Prosto uvesti neku smenu, odnosno zamenu, uvesti neki naziv za odgovarejući skup simbola, prosto dodeliti neku simboličko ime tom skupu i nadaljiga tako koristiti u okveru regularno gistrse. Na primru, slobodno možemo reći slovo je neki karakter od a do c, malo ili veliko ili oba takva, isto tako za cifru možemo reći od 0 do 9 ili ako želimo pozitivnu od 1 do 9 i tako dah. I onda na primer ako hoćemo da kažemo da neki identifikator predstavlja nijiz karaktera koji obavizno mora počanjati slovan, a nakon toga može imati od 0 do bezkonečno slova ili cifara, onda bi smo to pokazali pravilima baš ovako. Dakle, na početku je neku slovo koje smo već predhodno definisali da može biti bilo koje slovo od a do c, veliko ili malo, a nakon toga se može pojaviti neko drugo slovo ili neka cifra i to veći broj puta maksimalno bezkonečno, ali takođe i ne moraju da se pojavaju i time definisamo da identifikator niz karaktera od barem jednog slova koja mora počanjati slovom, a nakon toga se mogu pojavivati i cifra i slova u nekom proizvojnom poradku. Dakle, regulorne izreze ćemo baš tako i koristiti, kako bi smo definisali ovo pravila, i sad smo videli koje su konvencije za zapisa, odnosno korišćenje i videli smo nekoliko primera i kao što sam rekla da bi smo mogli neka koji da koristimo ovo prepoznavenje, a to je navoće biti c if da transformišemo regulorne izreze, sekvence koje prepoznajemo tim regulornim izrazima u automate i da na taj način, dakle formalizujemo prepoznavenje samih sekvenci, a nakon toga, naravno, automate ćemo koristiti na odgovarajući način i kasnije od okusemestra ćemo i više pričati o tome. Prvi algoritm koji koristimo za konstrukciju nedeterminisečku konočnog automata iz regularnog izraza naziva se Thompsonovo algoritm i prođućemo prvo kroz nekoliko pravi, laj koje nam kažu, kako pojedinačne operacije koje smo sada videli transformišemo, tačno, u automata, odnosno, u neka stanja automata i odgovarajuće, naravno, prelas. Inoče, karakteristicno je da se ovdje uvek konstruiše nedeterministike konočne automata, a da, ukoliko nakon doga, želimo da dobijemo deterministike, što uglavnimi jeste cilj, da videli smo prošli put, kako bi smo realno u praksi nekako mogli da skoristimo taj automat, da je skoristimo, naravno, algoritm za konverziju iz nedeterministice automata u deterministice konočni automat. Dobro, sada ćemo vidjeti, dakle, kako se definišu operacija, odnosno, kako se radi konverzija za pojedinačna operacija koje smo već videli da postoje, a nakon toga ćemo na nekom primeru izkonstrujiti nedeterministike konočni automata baš na osnovu podinačnog regularnog izraza. Ok, u principu, naravno, cilj nam je da od odkuvarajućeg dela regularnog izraza dobijemo neki skup stanji i odkuvarajuće prelazi i tako u koliko imamo neki terminal, odnosno, simbol konkretan u tom regularnom izrazu, njega ćemo prikazati upravo ovako, kao jedan, zapravo, simbol koji se pojavlja na prelazu između dva odkuvarajuća stanja u automatu. Ukoliko je to konkretan simbol, kao recimo ovde a, onda ćemo ga prosto staviti na tom prelazu baš kao takav simbol, što znači, u koliko se nalazimo u nekom stanji i, a nakon toga dođe simbol a, prelazimo u stanje jot. Ukoliko naravno imamo samo ta jedan simbol, onda je ovo stanje prihvatanja, a u opštem slučaju takavde automata se može naći bilo gde naravno u samom rezultujićem automatu. Sa druge strane, naravno, pošto konstruišemo nedeterministički konočni automat, moguće i da nemamo odkuvarajući simbol na ulazu, i zbog toga je moguće da na odkuvarajućim prelazima takođe postoji i epsilon prelaz, što znači, nema konkretnih simbola, već jednostavno se prelazi i u stanje jot bez konkretnog ulaza, odnosno konkretnog simbolasa ulaza. Što se tiče samih operacija, videli smo operaciju unije. Ta operacija unije, kao što je po definiciji, znači da unija neke sekvence a i sekvence b, podrazumeva, da će je činiti atako ili a ili b. I kada to želimo da predstavimo u autobus, mi ćemo zapravo uniju predstaviti kao neka dva alternativna puta, odnosno dve alternativne putanje, gdje u saunu automatu može biti izbrana jedna ili druga putanja, što, dakle, skroz ima smisla prema definiciji same unije. Kako to prikazano? Pa, u koliko je rečeno da će se pojaviti neki simbol a ili simbol b, onda bi smo to prekazano, da se je u ulaza, kada je ulaza sve ništa, i se je ulaza sve b. Onda bi smo to predstavili kao putanju između neka dva stanja, gdje u koliko se sad nalazimo u stanju i, dakle, sledaće nam može doći ili a ili b na ulazu, je to ćemo predstaviti ovako, kao neki skup stanja, gdje će istog našeg trenutnog stanja u kojem se nalazimo, postoje ti, naravno, u slučaju da je ili između neka dva simbole. Gdje je ulaza sve gdje je ulaza sve gdje, na kojima se nalaze simboli epsilon, što prosto označava da se može izabrati jedna ili druga putanja, ne deterministički, a nakon toga, postoje dve alternativne grane, jedna ovde u okviru ovog gornjeg, skupa koji ovako predstavim prosto kao neka komponenta, jedna u okviru ovog donjeg, gdje između ova dva stanja u nekom stavljenu, na kojima se nalaze simboli epsilon, u ovom slučaju to bi bilo na gornju grani a, a na donju grani bi to bilo b. Nakon toga, te dve rastavljane putanje treba ponovno da se spoje i da se nastavi dalje procesiranje u samom automatu, tako da ponovno postoje ovako dve grane koji imaju na sebi epsilon prelaza, što znači ne reaguju pod pojevom nekom kokretnog simbola, na ciljnom stanju n i na dalje, kao što rekoh, cjela ova konstrukcija može biti deo ostatka automata. Ovdje je epsilon predstavljeno malo kao e, malo kao epsilon, to je čisto stvar zapisa, u oba slučaja ovo e i epsilon, naravno nisu terminali, već predstavljuju neku praznu sekvencu, odnosno predstavljuju ovdje nedeterminizam u samom automatu, što znači može biti izabrena gornje putanja, gdje će postojeti neki konkretan prelas podgovarjećem simbolom, ili neku i sekvenci, ili će biti izabrena ova donja putanja, gdje će takođe postojeti ovdje neki prelas pod konkretnom simbolu ili neku i sekvenci koja je opisana tim dela. Ovdje je takođe konvencija da se ove grane predstavljuju epsilonom i dobro je da se tako predstavljuju, u koliko postoji više izlazni grane, ili više ulazni grane u neku stanju, da one prosto budu predstavljene s ovim epsilonom, što znači uprvo značova da može biti izabrana jedna ili druga putanja. Što se tiče konkatenacije? Konkatenacije sada predstavljuju vezivanje ove dve neke komponente i to vezivanje se realizuje tako što prosto se povežu ova stanja. U okviru svaki ove komponente postoji po jedna grana koja se je između stanja i i joti, između stanja i jotika i na njima mogu postojeti neke konkretne simboli, odnosno konkretne sekvence. Tako da to znači da će biti izvršam prelaz i po jednom, i po drugom simbolu, odnosno i po jednoj, i po drugoj sekvenci, i za koju postoji konkatenacija u tom nekom opisu. Još to nam ostala ponavdanja, odnosno zatvaraća. Zvezdasto zatvaraće kaže znači da se neka sekvenca može ponoviti nula jednom, dva put ili beskonačno, nogo puta, naravno i sve u medjju vremen. I one se predstavlja delom automata, tako što se krjene iz nekog stanja ovdje opet nazvanu i. Nakon toga, ulazi se u ovaj ovde del koji ponov o predstavlja i na to, ako je nam je zadožno za to ponavljanje odkuvarevček simbola. Međutim, takođe, pošto može da se ne pojevi o tako taj simbol ili neke sekvence nijednom, onda zbog toga postoji ova alternativna putanja, koja nas odmah vodi na ovo ciljno stanje, što znači da ćemo preskočiti cija ovaj srednih delom i ako se desi baš takav prelaz, to znači da se određena sekvenca, odnosno simboli koji se ponavlja, o tako nisu desili nijednom. To je baš one sluče, kada imamo praznu sekvencu koje se prihvata ovim delom automata. S druge strane, ako se pojevi konkretan simbol bar i jednom, to znači da prolazimo u prepoznavanju u pravu ovim ovde delom automata. Ubanavog, ako je malo prepodrazumeva, da ovde zapravo imamo neki preles po konkretno i odkuvarećim simbolu ili sekvenci. A to ponavljenje se upravo realizuje, tako što se iz ovogo ovde stanja može vratiti u predhodno stanje i zatim se ponovno ponavljati taj simbol ili konkretna sekvenca koja se ovde dešava. Navrno, ovdje del nije predstavljen do mnog grana.
 zbog toga što nemora biti jedan simbol, već tu može biti čitava konstrukcija koja se dešava u koliko je u pitanju neki kompleksni i regularni izraz. I nešto u tome ćemo naravno vidati i kasnije, naprim. Kale se završava prepoznavanje ponavljanja, izlazi se iz ovog ovte stanja i stiže se u stanje gde više prosto nemam ponavljanja u okviru ovog dela automata. Time smo obezpedili za svaki broje ponavljanja koji može biti obuhvaćen u to seqvencum da ona može biti prepoznata i da nakon doga postoji ove izlaz. Isto kao i malo prepo konvenciji, ovde postoji epsilom prelazi. Kada postoji više izlazni grane z nekog stanja i takođu postoja epsilom prelazi kada postoji više ulazni grana u odgovarajuće stanje. To je prosto dakle radi zapise, vidat ćemo kasnije kako obrađujemo te grane koje imaju prosto epsilom prelaza i kako zapravo konvertujemo taj nedeterminizam u deterministići konočni automat. I ostala mi još pozitivno zatvarnje. Pozitivno zatvarnje zapravo predstavlja podskup ovog zvezda stuk zatvarnja i taj podskup se ogleda u tome što prosto nemojmo tu praznu seqvencu, nemojmo mogućenost da presklučimo ova ideja automata koji je obrađuje ponavljanje konkretnog seqvence, odnosno simbola. Izbog toga ove je ovde ideja automata zapravo je identića, osim što nema ovo jednu granu koja preskaceta ideja ponavljanja zato što se nina koji način ne može zaobići to prepoznavanje, jer se kaže da se određe na seqvenca, odnosno neke simbolu, prepoznaje barem jedno. Zabog toga nema preskakanja, već se obovezno mora proći kroz ta ideja prepoznavanja, a nakon toga se možemo vrtati tu nekoj petlji u koliko se prepoznaje više puta takva seqvenca ili se izlazi iz ovog stanja kada je sve prepoznato i prelazima na prepoznavanje nekog drugog dela seqvenca. To bi je zvištini bilo to kako prevodimo konkretne ove operacije u delove automata na nekom teorijskom njewovou, međutim kada imamo neki konkretan problem, onda sada ako li hoćemo da vidimo kako ćemo naravno to primeniti u praksi, ono što nas zanima na početku, kako možemo za neki konkretan problem, da vopšte formiramo regularni izraz i kako ćemo takav regularni izraz prevesti u konačni automat korišćenjem uprovo ovih pravjela, koja smo ovde i videli. OK, šta nam veš je za datak? Dokladili smo sad krenali prosto od nekoj teorijske podloge, međutim naravno, one bila vezana za neki za datak i te za data kažem, napisati regularni izraz koji opisuje označene decimalne konstanta. Primer i dozvoljenih konstanti su, recimo, 1.257 plus 0.0392 minus 12.035.362.0, a recimo, neki od primerenih dozvoljenih su tačka 123 ili minus 23 tačka ili samo plus ili samo tačka. I nakon toga stoje i napomena i kaže u regularnu izrazu koristiti simbole plus, minus, tačka i d, gde simbol d predstavlja proizvojnu cifru? OK, u okvjerozodatka ovdje videli smo prosto šta možemo koristiti u okvjerozodatku regularnu izraza, čak i da to nije dato, ono što bi smo uradili je da bi smo pogledali šta je to naš problem, na koj način ćemo opisati taj problem, odnosno šta nam je potrebno od simbole koji se mogu pojaviti na ulasu. Onda pošto se radi u označenim konstantama, onda znamo da nam treba znak, što znači plus ili minus ili možemo da ne umo ništa, al tako, pošto su pri pitanju decimalne konstante, to znači da mormo nećemo dvojiti i ovdje je prosto taj delimiter tačka. I naravno osim toga tu su cifre, gde nama je ovdje i eksplicitno račeno, da prosto u te cifre možemo zameniti nekim simbolom, i to je upravo ono što sam i ispričala u okviru ovog uvoda, da prosto ne moramo eksplicitno pisati sve pojedinačne simbole, pa onda recimo, ako trebao da presavljamo njihovo konkatenaciju ili uniju ili bilo koje dovih operacija, ako svaki pot navodimo sve te pojedinačne simbole, prosto naša izrašća biti dosta dugačak, izbog toga pokušavamo da zamenimo, kad godi je to moguće nekim ojim simboličkim konstantama, kao što je sada, naprimer, upravo ovoj simbol d. Ok. Hajde, da prvo da vidimo, da gledaćemo da definišamo problem, i inoče, ovo je jedan tipski zadata koji se može pojaviti na kolokvijomu, gde prosto je predstavio neki problem, gde treba modelovati regularni izraz i gde na kraju, naravno, posledan isledeći neki koracij. Pošto ovdje trebao da vidimo, kako ćemo opisati označene decimole konstante, ono što vam je dato u zadatku, dati su nam primiri koji su dozvjeni, koji su nedozvjeni, i to može malo da nam olaksa. A recimo, u situacijima kada nam to nije dato, ono što je svakako potrebno, kako bi smo bili sigurni, da smo dobro formirali naš izraz, je da upravo sami formiramo te izraze, odnosno, primere, i da naravno budemo pri tam potpano objektivni i da pravimo dobra testprimere, koji će zaista da testiraju naše rešenja, a također i da nas usmere ka rešenja. Dobro. Od čega bi smo ovdje krenuli? Pa krenuli bi smo verovatno od togo čime može da počinje jedna označena decimolna konstanta. I ono što vidimo na početku kod ovih regularnih, odnosno, dozvojenih konstanti, je da jedna dobra numerečka decimolna konstanta može početi, recimo, plusom, može početi minusom, a može takođe biti bezikakvog znaka napred, što smo videli na osnovu ovih primera, tako da znamo da na početku se može naći nešto od tatri, plus, minus ili ništa. Tim smo rekli, dakle šta je, šta se navazi na početku, sada moh se oni središnji djavel, tako da vidimo šta može biti u sredini. Ineče bilo bi dobro da nekako to opišemo, tako da u suštini ono što ćemo reći, je da na početku možemo imati plus, ili minus ili možemo da nemo ništa odnosno da se nepojavio nijednog simbolu na ulazu. Čim, dakle, postoji opcija da vam se nepojavio nijednog simbolu na ulazu, to nas treba odmada nas usocire na epsilon smenu, ja ću ovdje to napisati kao e, ali u principu je to naravno epsilon smena, što znači prosto ništa se konkretno nije pojavilo, međutim mi definišemo to na ovakam način, zato što prosto želimo da ostavimo mogućnost da ne moramo na ulazu imeti ni plus ni minus, već do to prosto može biti epsilon. Nakon toga nam doleze neke cifre. I sad tu imamo te neki središnji deo, gde očigledno treba da imamo neke cifre pretačke, možemo imeti tačku i treba da imamo onda nešto nakon te tačke i ono što vidimo ovdje kod nedozvoljanih primera, takođe jako korisno, a to znači da naša, naš ovaj deo koji ide i za tog početka koje može biti plus, minus ili ništa, ne smet počinjeti tačku. Dakle, obaviozno moramo imeti nešto pretačke, takođe ne smet biti ni samo plus ni samo minus i u tom smislu to znači da moramo imeti bar jednu cifru koja će se naći pretačke. Ako smo naše cifre, mi definisali ovim nekim d, gde možemo reći da je to d bilo koja cifra uopsego od 0 do 9, dakle, rekli smo mora se pojevljivati barem jedna pretačke i to znači da ćemo označiti to prosto ovim zvez, ovim pozitivnim zatvaracem, odnosno plus ponadenim. Ja ću ovdje predstaviti ovako, inječe se ovaj plus stavlju SuperScript. Izna da li mi, da koj znamo ovdje u čemu se tu radi? Tako da moramo imeti barem jednu cifru koja će se naći nakon ovdje početka, ako želimo da definišamo numerečku konstantu. I kao što rekla u ovim primeri, nam ovdje pomažu da upravo to schvatimo, da ne možemo počinjeti sa tačkom, da ne možemo imeti isključivo plus u tom smislu prostu vodimo sa ovim konkretnim primerima. Kao što rekla, da ne postoja ovih primeri, bilo bi dobro napisati baš tako par nekih dozvoljenih konstantijun usnono što bi bilo dobro rešenje i par nekih nedozvoljenih odnosno što ne treba da bude prihvaćeno procesiranje. I upravo smo za sada obezbedili, da na početku imamo ili oznaku ili ništa i da nakon toga imamo jednu ili više cifare. To bi bilo ovaj del ispred same tačke. Sve se tiče ovog drugog djela. Pa, ako pogledamo šta su naši dozvoljenih primeri, mi vidimo da imamo 1.257, što znači da je namo dozvoljeno da vopšte nemo decimalni ideal, da nemo tačku i da nemo...
 ovaj decimalne ideo i za tačke. To znači da bi nam ovako prepozneto konstanta, takođe bila sasvim uspešno rešenje. Međutim, hoćemo da obezbedimo da nakon toga možemo imati i tačku i decimalne ideo, tako da ono što možemo reći iz ovoga, jedan nakon ovoga može ne doći i ništa, tako što bi je opet bilo neka epsilun sekvenca, što znači ovaj ovde ideo nam je takođe uspešno prepoznat, ne treba nam ništa izatoga, ali hoćemo da obezbedimo da takođe i može doći tačka i neki decimalne ideo, izbog toga ćemo reći dobro u koliko dođe tačka, nakon toga mora doći nešto. E sad opet ono što smo videli ovde je da isto nije dozvodeno da bude samo minus 23 tačka, što znači da u koliko postoji tačka mi ponovom moramo imeti barem jednu cifru. I zbog toga ćemo ponovostaviti ako dođe tačka, sigurno imamo neko ponavenje ovih cifarog, da je to ponavenje podrozumeva barem jednom da se desi, tako da ne možemo imeti zvezda sto ponavljenje. I na taj način mi smo obezbedili tri neka djela ovog našeg reguljervno gizreza, koji treba da prepozna decimalne numerečke konstante koje će imati biti označene i kako smo to uradili, još jednom samo kratak rezime. Prvi del koji se odnosi na samo oznaku, da li će biti plus, da li će biti minus ili možemo da nejamo prosto bilo kakav znak. Nakon toga sigurno se mora pojaviti barem jedna cifara, da bi ove naš izraz bio uspašan, a nakon toga može prosto da to bude del koji nema ona decimalni del, nema tačku ni ti iz bilošta, i u tom slučaju bi za toga nema ničega, zato smo stavili ovaj epsilon, ali može postojeti i tačka, ako postoji tačka i za nje obovezno mora stajati barem jedna cifara, a može i biti veći broj tih cifara, izbog toga smo stavili ovo ovdje ponavno. Tako da, ovo što smo zmizkombinovali u ovakvju rovog izraza je unija, koja ne me koristila ovdje na početku, zatim konkatenacija. Inat će konkatenacija ne mora eksplicitno da se piše u samom izrazu, a može da se piše, ako se piše ona prestavija neku tačku, mi ću ti da bi to bio neka srednja tačka koja sad ovdje ne mogu boš tek tako da prestaviti, međutim konkatenacija nema potrebe da se predstavio samom izrazu, tako da ako ne postoji eksplicitno kao simbol, implicitno se podrazume ove da je u pitađu konkatenacija. Positivno zatvarnje, odnosno ponavljenje odbarem jednog puta određene cifre i nakon doga ponovu imamo neku uniju, uniju ili epsilon ili konkatenaciju tačke, koja predstavlja ovdje simbol koji se može pojaviti na ulazu, i pozitivno ponavljenje, odnosno pozitivno zatvarnje, odnosno ponavljenje neke cifre barem jedan put. Timo smo defensili naše pravilo i sada ako pogledamo sve ove primere, mogli bi smo prosto da provjerimo, da li svi oni zadovoljavaju ovo naše pravilo od ovih primera koje treba da zadovoljavaju, a prosto od ovih koja ne treba, da li zaista ne zadovoljavaju ta pravila i videli bi smo da je baš tako. E sada, naravno, ovim izrazom koji smo mi ovde napisali, moguće je prepoznati i možda neke vrednosti koje mi možda u realno nekoj primeni ne želimo, ukoliko bi smo imali nula tačka 0, 0, 0, 0, 0, to bi takođe bilo jasno prepoznato ovim ovde izrazom, ukoliko to ne bi smo želili, morali bi smo nekako da modifikujamo izraz. I sad nećemo mi ovdje ulaziti u takve neke detaljer, ciljna mi je da vidimo kako se radi konverzija u nedeterministice otomate, međutim je realno neko odrešenje koje može biti sprovedeno, je da se recimo razlikuje skup cifara sa 0 i bez 0, tako da se prosto napravi neko razlikovanje i da se definiše da negde mora postojati neka cifra koja nije jednaka nula, jednostno veća je od 0. Tako da, naravno, ovaj moguće modifikovati i dobro je da se igrate svakako sa tim, da probate da azmišljete odome kako se može modifikovati problem, kako se može modifikovati rešenje, da li se recimo može limitirati koliko cifara hoćemo nakon tačke, dakle sve su to neke primeri kako možemo prosto promeniti ono što se traži od nas i takođe promeniti samo rešenje. Kada smo to uradili, odnosno definisali smo praktično kako će izgledati naš regularni izraz, sljedeća stavka koji želimo je da konstruišemo nedeterministrički konačni automat na osnovu tok. I to ćemo uraditi, tako što na osnovu ovog našeg izraza mi ćemo zapravo ići korak po korak, sa onim praviljima gde smo videli kako se eksplicitno pojedinačne deosekvence konvertoje u samo automat, tako da ćemo korak po korak ići ispajati ove delove našeg izraza u neko celinu, koja će na kraju biti zapravo naš rezultujiči automat. Hayde da vidimo kako to izgleda. Prvi korak će nam biti ova unija, ona 3-2 simbola zapravo koje se mogu konkretno pojaviti na ulezu, to su plus i minus za označene konstante i epsilon u koliko prosto narano ništa nije prikazano. I ta ideo se prevodi u ovako nešto, ovo što smo videli odmah na početku. Kako izgleda unija? Unija omogućava alternativne putanje u samom automatu, pošto ovdje imamo 3 alternativi al tako u okveru unije, to znači da moramo imati naravno i 3 putanje koje mogu biti izabrene, gde u koliko je izabrna bilo koja od ovih putanja za procesiranje, automatski, ove druge dve moraju biti odbačene zakomkretno prepoznavanje neke sekvence. E sad, u koliko idemo strifno premonom algoritmu, on je izgleda joj tako da imamo tomstvom normom algoritmu, da imamo jedno početno stanje i da pošto imamo više alternativnih pravaca, automatski imamo ove neke 3 grane koje u nesebi imaju epsilon prelas, što znači da za ekspolisitne pojeve nečega na ulazu, može se preći u neko od ova 3 stanja, gde dalje narano zavisi šta se konkretno pojavilo na ulazu. Pa ako se pojavi plus ili tako da imamo označenu konstantu koja ima plus na početku, prosto će biti izvršen prelaz iz stanja S1, S4, ako se pojavio minus iz stanja S2, S5, dok u koliko nema ništa, iz stanja S3 u S6. Gde je na kraju cilj, da se ponovno te sve putanje sjedine, ide se na dalje nastavio procesiranje u samom automatu, tako da ove ideo sekvenci bi bio prepoznat upravo ovako. I ovde ponovno imamo to spajenje putanja korišće mojih epsilon prelaza. Ono što je naravno još dodatno potrebno, kao bilo oko o mojem automatu, da svako stanje definisano jedinstveno, tako da imena koja smo im dodeljeli, nije bitan sam poreda, kredo sa stvornije bitno, međutim ono što je bitno je da taj mena budu na jedinstven način odvećena. I ono što vidimo, to je baš i situacija ovdje. E sad, što se tiče same definicije, kada su nam zaista potrebni ovi epsilon prelaz, i kao što regoh nekaj konvencije, da oni var postoje u situacijama, kada postoji više izlaznih ili ulaznih grana u neko stanje. Međutim, ukoliko je, na primer, situacija baš kao ovada ovde, da postoji ovaj dodatni epsilon prelaz, da mi time definisamo neke tri grane na toj putanji, nije neophodno uvoditi ova stanja, moguće i samo uvesti jednu grano koje će da poveže ovo početno i zaavršno stanje. I da mi nećemo insistirati na tome u okviru naše izadataka, naravno i na ispitnom delu, da se do kraja ispošto ove algoritmo u smislu preslikavanja pravila 1 na 1 sa tim brojem stanja, brojem putanja, na konkretne rešenje. Već prosto da ispoštojemo ten do neku, neki osnovni smisl, je tu da ispoštojemo, da kretopravilo, da ukoliko postoji više izlaznih ili ulaznih grana, tada ćemo staviti epsilon prelaz, a u suštini ovde smo mogli imati samo jednu granu i izbaciti stanje s3, s6 rešenje bih dalje bilo korrekt. Ove pa videa odakle predstavljamo ovako. Sledajosnjih ideo dodajemo ili tako ponavljenje od bari jednom cifre, koje dolazi izatoga. I to radimo tako što, kong teneeramo na ove prvi ideo ili tako, ovo i drugi ideo, koji ponovno, ako idemo strictno prema algoritmu, se definiše tako što imamo neku početno stanje. Nakon toga imamo jedan del koji ovdje mogućeva nam ponavljenje ove ovde cifre, međutim i na kraju izlazimo iz toga, kada više prosto ne prepoznajemo, ili tako ponavljenje neke cifre. Međutim, kao što vidimo, po što imamo pozitivni zatvarač, onda se ovdje ovde del prepoznavanje jednostavno ne može preskočiti i procesiranje mora proći kroz ta stanja. I ovdje smo isto, koji malo pre mogli izbaciti jedno ovo stanje, ona bi bilo praktočno identečno bilo rješenje bez toga, tako da mogli smo naravno i tako nešto da uradimo, nećemo strictno insistirati na tome da se ispoštuve identečno vaš broj stanje. I trači del.
 gde smo dodali al tako ovaj deo da imamo ili epsilom prelas, pa u tom smislu uopšte nemo prepoznavanje ovog dela sa tačkom i onim decimalnim delom, ili imamo celo taj deo. Kongateniramo al tako na avo predhodno što smo prepoznali, pa u koliko imamo epsilom, ovdje smo uštedali, samo smo ponove al tako imamo uniju, rekli dobro, tako ovom ovde putanjem i preskačemo celo taj deo i odmah idemo na završno stanje, a ovom ovde gornjem putanjem uprvo bezbeđujemo konkatenaciju tačke i nakon toga ovo ponavljanje odbar jednom ove cifre koji zapravo predstavlja identičnu ideo kao što smo imali i gore. Kada smo sastavili ove ote delove dobeli smo naš optomat, kao što rekli, ono što je bitno da nam sva stanja budu jedinstveno numeriseno, odnosno jedinstveno nazveno, kako bi smo naravno dalje mogli da ih koristimo i u principu na nekom grafoskom onom nivou mi smo sad o konstruisali nedeterministički automat. Nakon što smo konstruisali ove nedeterminističke automat, ciljne mi je da vidimo kako njega dalje koristimo, odnosno kako ga prevodimo u deterministički konačni automat. U principu bi trebalo da obude jasno, dakle samo smo koristili pravila, jedan na jedan smo ih preslekavali, kao što rekok negde možemo malo i da uštinemo na ovim viška stanjima i prelazima epsilon, to ne bi nikako smelo da promeni naše finalno rešenje, pretvaj svega mislim na to da dobijeni deterministički konačni automat koji ćemo videti sada kako se formira, naravno ne bi smeo da se promeni uz avisnosti doga, da li imamo više epsilon prelaza ili manje, a samim tim naravno i broj stanja. Ono što ne smemo duredimo je da ispustimo neki del koji konkretno sadržio ove simbole, a rekli smo, predržavaćemo se i ono pravila za veći broj izvaznih odnosno uvaznih grana. Dobro. Evo, napr. akubi smo sada i pogledali ovo rešenje koje stojimo materialim, vidimo da ovdje imamo nešto veći broj stanja i to je uprvo zbog toga što je ovdje ispustovano jedan i jedan isovim kongatenacijama. U sve u svemu oba takva rešenja moraju dati isti deterministički automat i samim tim ćemo i verifikovati naše rešenje. Kako se sada formira deterministički automat na osnovu ovakvog jednog nedeterminističkog automata koji videli smo na koje način je formiran, a to je praktično strikturnom primjanom ovih pravila i konverzijom delova izraza u same delove automata. Krećemo od startnog stanja i nama praktično startno stanje predstavlja baš ovo ovde početru. Međutim u startno stanje moramo uključiti sva ona stanja do kojih možemo doći počevši iz ovog ovde označenog sajedinica koja je baš baš startno, do koji možemo doći samo epsilom prelazima. Znašto je to baš tako? Zato što epsilom prelaz potrozumeva da mi zapravo i nemamo neke konkretan simbol koji se dašova na ulazu i uprvo je u tome nedeterminizamo ovog automata. Takle možemo preći i u stanje 2, i u stanje 4, i u stanje 6, i u stanje 7, i u stanje 8, i u stanje 9. Bez pojeve konkretnog simbola sa ulaz. To će značiti da zapravo mi možemo doći u bilo koji je od ovih stanja kao početno i zbog toga sve njih moramo uvrstiti u toj neke inicijelni skup stanja. I to je uprvo ono što smo uradili ovde, postavili smo to startno stanje koje se stoji uprvo i svih tih stanja koje su dohvatljiva samo epsilom prelazima iz ovo početnog stanja označenog sajeta. To je neke epsilom plouže, odnosno predstavlja skup svih stanja koje su dohvatljivi putem epsilona i to ćemo nazvati naravno kao neko o stanja, ovove sad veći konkretno kao del transformacije iznete terministicku ude, terministicki automat. Kako znamo kao da stanemo sa tim uključivanjem stanja u skup? Pa onda kada prosto više napostojim jedno stanje koje dohvatljivo samo putem epsilona, odnosno kada s svim tim stanjima je otaku do koji smo došli gde smo završili, zapravo je potreba neki konkretna simbol da bi se prašlo dalje. Kao što vidimo, stajemo u stanju 2 zato što nam tu treba plus, stajemo u stanju 4 jer nam tu treba minus i stajemo u stanju 9 jer nam tu treba d, tako da ne možemo uključiti više ovih stanja u taj neki inicijelni skup. Tima smo definisali šta je naše startno stanje, ovve naše automata naravno videli smo morat takođe imeti i simbole ovdak u kao kolone i to je ono što smo videli proše puta kada tu nemo ništa specijalno nova i ono kako papunjavamo ovaj automat i da prosto kažemo ako se nalazimo u ovom stanju a dođe nešto od ovoga na ulezu gde dalje prelazimo. U principu kad kažemo nađemo se u ovom stanju a vidimo da je to jedno kompozitno stanje koje se sastoji od većeg broja stanja, to znači ukliko se naš nedeterministrički automat nađe ubila okomo do ovih stanja šta se dešava. Dakle tako to procesiramo. Znači kad se nazimo u ovom ovde inicijelnom nekom skupu tih stanja a pojevi se plus na ulezu, ono što mi gledamo je koje stanja od ovih uopšte reaguju na taj plus i kada pogledamo to je samo stanje 2. Zato što si i stanje 4 ono čekuje minus tako da ništa a stanje 9 očekuje d, a sva ostala stanje zapravo su samo epsilom prelazi tako da isključivo sa plus se reaguje iz stanja 2 i tada se prelazi u stanje 3. Međutim, dakle ovdje bi smo dodali stanje 3, međutim ponovog kao i do sada. Svaki put kada uključimo neko stanje gledamo gde se sve može stići odnosno s koji skup stanje se sve može stići iz dok stanja, putem samo epsilom prelaz. Tako da ćemo to uraziti i sato što znači čim smo u stanju d3 mi možemo biti u stanju 8, odnosno možemo biti u stanju 9 jer su oni dohvatljivi samo epsilom. I to ćemo zapravo upisati u ovaj plus i to je ono što je definisano ovdje kao stanje b, dakle jedno kompozitno stanje od stanja 3, 8 i 9. Ok, ako dođe minus, ili tako ponovu iz ovog ovdje startnog stanja, mi vidimo da jedino stanje 4 reaguje zapravo na taj minus. Gde ste prelazili iz tog stanja 4, pa prelazili su u stanje 5, međutim ponovu, kao i da sada, gde sve možemo da stignemo iz stanja 5, pa u stanja 8 i u stanja 9, zato što postoje epsilom prelaz i koji nas vode tam. Tako da stanje u koja se prelazi iz stanja a, ako dođe minus, jedno kompozitno stanje koje se zastoji od stanja 5, 8 i 9 i ovde smo ga predstavili kao stanje neko C. Ovo ovde nije zvezdica, ovo ovde je tačka, pošto se me rekli da se ovde predstavio i sklučivo simboli koji se mogu način na ulazo, tako da to obavazno tačka nije zvezdica. E sad šta se dešava kada dođe tačka na ulazu? Prvo treba da vidimo gde uopšte može ovde da nam dođe tačka. I ako pogledamo, jedno od ovih ovde stanja je nereagoje na tačku, tako da zapravo ovde ne može da se desi, već je tu biti neki prazan skup. Dale će to ostaviti to samo kao što smo pričuli prošli put, kao prazan skup, kao prazan ulaz nikakog ne definisavši, ovde je to označeno baš eksplicitno praznim skupom koji je nazvan kao D, ali u principu to ne mora, dakle možemo samo ostaviti prazan ulaz, jednostavno za ovaj ovde skup stanja nije moguće uopšte da se desi takva kombinacija, da se naše prepoznavanje trenutno nalazi u nekom od stih stanja, a da se pojavi tačka na ulazu. To nije moguće, izbog toga se ovaj ovde sluče nikad neće desiti, to je prazan skup. Ako dođe D na ulazu, jedino stanje koje se nalazi ovda koje to prihvata je upravo stanje 9. E sad gde se sve može stići? Prelazimo u stanje 10. Mi ću ti da ima iz stanje 10. Putem epsijona se možemo vratiti u 9, možemo preći u 11, preći u 12, možemo preći u 17, 18 i 19. I sve to predstavlja naš skup dostižnih stanja u koliko se pojavi D. I načicimo ta skup sa e i kao što vidimo, on je jedno kompozitno stanje od svih ovih stanja koja sam naglasila. Tako da u principu ništa ovde nije specijavno teško, ono što detektujemo za svaki od ovih simbola, dali neko od stanja koje su uključene u taj skup, reaguje na odgovarajći simbol, što znači desit će se konkretan prelaz ako se tako našto pojavi na ulazu. I nakon toga u svaki od tih skupova uključujemo i sve ona stanja koje su dostižna samo epsilom sekvencom, odnosno bez konkretne pojeve terminala na ulazu. Ove je ovdje del, bez toga epsilom dela i je identično ono, mežem da smo prošli put pričali. Međutim, e to, sad uključujem...
 i taj dodatno del, je prosto prošljiput nismo gledali dakle tu grafičku predstavu. Ok, naravno svako od ovih stanja koje smo nova uveli, kao i do sada, tako dodajemo ovde i gledamo kako se dalje u tom od ponasa kada se nalazi u tom stanja. Sada ako smo u stanju B, odnosno u kompozitnom stanju stanja 3, 8 i 9, a dođe plus, kako reaguje ovve otome, popolivamo da li u opšta u stanjima 3, 8 i 9 može da dođe plus, vidimo da ne je otako. Isključivi simbol koji se može pojaviti u nekom od tih stanja je simbol D za stanje 9. 3 i 8 vidimo, rade samo epsilom prelaze, tako da to ništa. Znači plus, minus i tačka se ni nemogu pojaviti u okviru ovog stanja i mi ćemo ovde ostaviti ili prazne ulaze ili ćemo kao i ovde označiti sa D, što je eksplicitno i otako naglašeno stanje koje zapravo se ne sastoji ni od jednog od ovih počadnih stanja. Emeđutima, ako dođe D, znači iz stanja 9 prelazimo u stanje 10, ali se epsilonu možemo vratiti u 9, možemo otiću 11, 17, 18, 19 i 12. I to je zapravo stanje koje smo već do sada videli, a to je stanje E. I u principu ovakve automate i relativno brzut konvergiraju, zbog toga što imamo ovde već delove koji se ponavljaju, tako da u principu ćemo to se pto će se naravno manifestovati i u okviru ovog tabelernog prikaza. OK, što zadeče skupat C koja je obukvata stanje 5, 8 i 9, ponovno ne postoji mogućnost prelaza nipo plus, nipo tački, nipo minus. Već i skluču, ako se pojevi symbol D, a pošto ponovno otako ovog ključu je stanje 9, znači ponovno ćemo imati stanje 10, 9, 11, 17, 18, 19 i 12, odnosno stanje E. Naravno za D nema potrebe bilo što reći, al tako pošto u principu iz praznog stanja ne ide se nigde, tako da ov ove ovde je čisto prazen ulas, kao što reko, u slučaju da odlučimo da nije ne prikazujemo ovog kova zasebno stanje, već prosto ostavimo prazna ulazu, onda naravno nije ovde red ne bi bio potreba. Što zdiše stanje E, sada je ono malo kompleksne i se drži veći broj stanja. I u principu kada pogledamo, ovde se sada može 10 i prelas po D ili po tački, ako malo bolje analiziramo ovaj ovde ovdje otomat, jasno nam je da se nikada više u samo moment otomato, odnosno ovom 10-om delu, nećemo imeti prepoznavanje terminala plus i minus, to je ostalo vezano za ovaj ovdje početak. Tako da samo D i tačka. I zbog toga u ovo provodva ulaza imamo D, odnosno prazna skup, a u principu ako dođe tačka, mi pogledamo al tako, ove otomat reaguje na tačku u stanju 12, stanja 12 je uključeno u ovaj ovdje naš skup i pogledamo gde prelazimo. Prelazimo u stanje 13, a od atle je epsilom prelazom dohvatljivo samo stanje 14, tako da će to biti ove naš F skup 13 i 14 koji ćemo uključiti u sam otomat. Ako dođe malo D, malo D može dođi iz stanja 10 u okveru ovog e o tako, izbog toga ponovog će to biti isti skup stanja koji je označen sa ovim e. Što se tiče našeg skupa stanja označen sa F 13 i 14, ponovog ovde se ne mogu desiti ni tačka, ni plus ni minus već izključivo samo D, ako dođe D i stanja 14 prelaza i sa stanje 15, epsilo nam se možemo vratiti u stanje 14 ili preći u stanje 16 i stanje 19. I to je upravo ono što predstavlja ovaj naš skup označen sa g. I kada pogledamo ješ jedno to stanje, odnosno skup označen kao stanje g, čine ga stanja 14, 15, 16 i 19 ovde se jedino može pojaviti malo D na ulazu i u tom slučaju se vraćemo u isto stanje, zato što se i stanja 14 prelaza u stanje 15, a od atle se ako prosto ne dođe ništa na ulazu već samo do hvatljivost epsilo nam može stići do stanja 14, 16 i 19. Opet imamo stanje g. Ono što im je još ostalo je da odredimo koje je za stanje prihvatanje, koje je za stanje odbijenja i stanje prihvatanje je bilo koje je kompozitno stanje koje se drži ovo finalno stanje ovde. Odnosno stanje 19 to su stanja e i g sva ostala su stanja odbijenja. Ono što smo ovde formirali je jedan deterministički vtomat, njega znamo kako možemo da koristima. Tipično poslednja stavka koju imamo i ono što je nam je i cilj, a što smo videli prošlo puta, je da takav dobijeni deterministički vtomat prevedemo u minimalni deterministički vtomat, što znači da ćemo poveći standardnoj proceduri ukvoniti nedostižno, odnosno suvišna stanja i nakon toga ćemo videti nekim od onih metoda kako da vidimo da ali prosto postoje ekvivalenta na stanje. S uzetiča dostižnih stanja ovde ponovobismo krenuli od početka, tako, anem je kao startno dostižno, zatem uključujemo BCD i E u naš skup, iz njih su nam dodatno dostižno F stanje, a iz F stanja G i time smo otkli da su sva stanja dostižna, te sa te stranje nemo suvišnih, odnosno nedostižnih stanja. E sad sredeća je minimizacija na osnovu toga, da ali postoje ekvivalenta na stanja, videli smo prošli put dva načina kako to možemo da uradimo ili tako što ćemo provaravati svaka dva stanja međusobno, ili tako što ćemo koristiti ove particijoniji algoritm, pa ćemo odvajati prosto skupove stanja, al tako iz jednog zajednečkog skupa ćemo ih sve nadeliti dok ne dođemo do kraja do toga da li imamo ekvivalentni stanja ili ne. Inicijelni način kako podelimo praktično ta jedan ogroman skup koji se ne ogromavi, veliki skup svih stanja ABCDFK, dakle ta jedan na dva dela je tako što ih podelimo prema stanjima prihvatanja i odbijenja. I u jednom skupu su nam stanja odbijenja, to su ABCDF, a u drugom su nam stanja odbijenja E i G. Naravno, ovo D stanje možemo odmah izostaviti, to je ovo što sam rekla, to je stanje koje suštenski i nije del ovoga automata, ovo je stanje greške, tako da slobodno njega možemo dokronimo. I onda primatom, osnovno i to je podelimo četri stanja u jednom stanju, tako kažemo, nasmo jednom skupu i dva stanja u drugom skupu i treba da vidimo, da li se oni ponašo identišno. I sad ponovom, taj algoritm bi smo sprovodili, tako što, i svakog tog skupa, a ako se ponašaju konkretna stanja za neki simbol koji se pojavlja jedna ulazu, tako da recimo ako dođe plus, kako se ponaša a. Iz a se prelazi u b, to znači da ostajemo u istom tom inicijalnom skupu. Što se tiče b, ako dođe plus, prelazi se u stanje greške, ne postoji, tako da već vidimo da se a i b ne ponašaju isto. Što se tiče c i ono isto prelazi u stanje greške, i što se tiče f i ono isto prelazi u stanje greške. Tako da zaključemo da se a ponaša različit u odnisu na sva druga stanja koja pripada u ovom skupu, izbog toga ćemo a odvojiti u odnusu na b, c i f u zasebni skupa. E i g ćemo nam za sada ostatisti, pošto to ne razmatram. Što se tiče minusa, tako sad više nema potreba da posmatramo a, kao što smo zaključili prošli put, ono prosto nikad više ne može biti spojeno s nekim drugim skupom, tako da ono što možemo dovradi, ima je prosto da provjerimo za b, c i f, da li se oni nekako razdekujemo. b za minus prelazi u d, c prelazi takođe u d i f prelazi u d, da se za sada se ponašaju potpuno identično. Isto to ćemo uraditi i za tačku, i za malo d, i za tačku zaključujemo da prelaze svi u d, tako da se takođe punašaju isto. Dogo za malo d, zaključujemo da se b i c ponašaju isto, odnosno prelazav stanje e, ali da se f ponašaju drugačije prelazaju stanje g, izbog toga ćemo podeliti ovaj ovde skup na 3 skupa, a b i c koje za sada deluju ekvivalentno, i f koje očigledno ne ponašaju se identično kao ova dva. Možemo takođe onda uzatim posmatrati i e i g. E i g, dalje se ponašaju isto ili različitom, ako dođe plus, ponašaju se isto prelaze u d za minus takođe. Međutim za tačku, jedan prelazi u f, a drugi prelaze u d, i to nam predstavlja različito ponašanje, pošto f i d ne nalaze sa u istim skupovima, da su u stavljima d se suštenski nikt ne nalazi, ali izbog toga predstavlja jedno stanje koje je s ovdje ne modulo, tako vidimo da su oni ponašaju različito, zbog toga ćemo razbiti e i g. Tako da, u suštini, ono što smo zaključili, i ako provarimo, to nije uticalo na b i c, zaključili smo da su b i c.
 među sub nekvi valenta na stanja, što možemo i vidati ovde i same naše tabele, punašaju se identično i sami timi ih možemo zamjeniti jednim stanjem i timi ćemo minimizovati naš automat. Tako da kad pogledamo kako sad izgleda naš rezultojići automat, on je manje za jedno stanje, ovdje smo takođe oklonili ideje pa suštinski izgleda kod je manje za dva stanja i ovako izgleda dakle naš rezultojići automat. Minimalni deterministički automat koji opisuje celobrejne konstante koje mogu biti označene i decimalne i koji je dakle dobijen tako što smo prvo, primjernom Thompsonovog algoritma, konvertovali regularni izraz u nedeterministički konečni automat, njega dalje konvertovali u deterministički konečni automat i kao finalni korak minimizovali tako automat. Videli smo jedan algoritm za konverziju i pretvarenje regularnih izraza u nedeterminističke automate, sad ćemo vidjeti i drugi. To je pozitio nji algoritm, odnosno algoritm na osnovu stabla pozicije i vidićemo i uporidićemo nekako ta dva algoritma. U principu, kod Thompsonog algoritma dobra strana je to što je prilično jednostavan i što je dostavstvim stavljavom i onda praktično jedan na jedan samo pri slika vam o pravilu nekonkretan primer i uvek nedvosmisleno možemo formirati automat. Ono što smo videli je da je taj broj stanje može varirati, broj gradna sa epsilom prelazima može varirati, međutim ono što je bitno da dobijeni konačni automat ne može se nikako razlikovati deterministički konačni automat. Naravno, sad to nisam broj komentari, sad međutim jasno je da će to biti slučaj, zato što videli smo da u okviru onih pojedinočnih stanja koje formiramo kao skup dostižnih stanja na osnovu epsilom prelaza, ukuliko smo imali još dodatnih stanja koji su bih li među smo povezani epsilom prelazima sve ćemo ih uključiti u isto stanje, tako da upravo zbog toga se finalni, odnosno ekvevalentni deterministički konačni automat ne može razlikovati. Tako da, tomsenom algoritm je pravoliniški, pravoliniški jednostavan, međutim realno rečeno može biti dosta kompleksan, imeću vidu koliko imamo takojih epsilom prelaza u nekom opštenu slučaju, gde za veći regularni izraz taj automat može dosta da narasta. S te strane, ovaj metod pozicija je na neki način kompaktni, pa prosto vidjet ćemo sada kako on funkcioniše, što se tiče primene jednog ili drugog u zadacima gde je eksplicitno rečeno koji se mora koristiti, naravno da nema nekog izbora, međutim ukuliko to nije rečeno, onda naravno uvek se možete odlučiti za nej koji je prosto vama jednostavni. Ok, prvi primjer koji ćemo raditi je kako ćemo praktičnu metodom pozicije od ovakvog jednog regularnog izraza dobiti neki konačni automat. U principu, ovdje imamo neke konkretne simbole koji se pojavljuju na ulazu, gde, dakle, sad vidimo neki drugi tip problema gde nam nije dat, dakle, opis problema pa da mi pravimo regularni izraz već nam je već dat. Gotov regularni izraz koji treba pretvoriti samo u automat. U principu možete dobiti jedno od te dve stvari. Ovdje, regularni izraz izgleda tako da imamo neki simbol A pa U nija odnosno ili neko ponavljanje sekvence B, C gde možemo i preskočiti celo tu sekvencu, u ponavljivti je jednom ili više puta i nakon toga se nadovezuje neko D. Ovdje simbol koji se pojavljuju na kraju prescuze simbol kraja sekvence. U principu, u samom zadatku to ne mora biti dato. Dakle, u kolikova mi je data, recimo, u kolikova mi je data regularni izraz isti ovakav samo bez to kraja sekvence, to je dalje isti problem i u principu, našto ispravno rješenje je upravo doplniti takav izraz ovim znakom za kraj sekvence. Tako da, još jednom, u koliko ne bude eksplizidno datu za datku, obavvezno ga treba doplniti. E sad, kad bi smo, recimo, chceli da vidimo nekih od primera sekvenci koje treba da budu prepoznat ovim regularnim izrazom, to bi moglo biti A, D, recimo, ili B, C, D, ili samo D, ili B, C, B, C, B, C, D. Dakle, ono što predlažem da svaki put se prosto napiše nekoliko sekvenci koje mogu zadovoljavati takav regularni izraz, jer će to takođe kasnije značiti, kada budemo konstruisali automat, da prosto proverimo da li taj naš automat paš da dovoljeva one sekvence koje mi vidimo u samom regularnom izrazom. E dobra, srednjih će stavka koji žalimo da vidimo je kak uopšte, šta uopšte predstavlja ovaj metod i šta mi to zapravo konstruiša. Mi konstruišamo nešto što se zove stablo pozicije. I to stablo se formira kao binarno stablo i to procesiranjem ovog regularnog izraza zdesna u lev. Pokoracimo, to bi izgledalo nekako ovako. Na početku podelimo ovaj naš startnim izraz u dva dela. Prvi je znak za kraj sekvence, to je kraj njedesni, a drugo je ovaj ostatak. Bitno je da uveku vedemo znak za kraj sekvence, zato što nam ono zapravo znači, odnosno pomoći će nam da odlučimo kada je naša sekvenca prihvaćena, kada znamo da se ništa drugo neće naći na ulazu i da prosto ili prihvadamo ili odbijamo sekvencu. Slednji korek je ponevo podelimo ovaj ovdje ostatak koji imamo na poslednji simbul i preostali idea. Kao što vidimo, ovdje smo u korn smestili konkatenaciju. To je baš ono što sam rekl al okviru prošlog dela ovog časa, a to je da se konkatenacija nemora eksplicitno pisati, međutim podrozume vas. Pošto ovaj ovdje del opisuje neku sekvencu koji zastoji iz prvog dela i nakon toga D, to znači eksplicitno konkatenacija simbola D i ovog prvog dela sekvence. Nakon toga pogledamo sad ovaj ovdje del sekvence i vidimo da je to neko A ili ponavljenje ovog BC. Tako da ćemo mi iznameniti celu ovu konstrukciju sa ili A ili ponavljenje BC. Ovo ponavljenje je zvezda stoponavljenje, inoče predstavlja unarno operaciju i menje se u našem stablu ovako. Dok ovo BC na kraju predstavlja konkatenaciju simbola B i C i to ćemo predstaviti ovako. I sad da dapljamo što naše rezultojiće stablo je jedno binerno stablo koje smo dobiljili procesiranjem ZDESNA u levo i tako što smo radili grupisanje u okviru pojedinočnih idejlova T sekvence. Još jednom tamo gde ne jeme prosto simbola koje značavaju operaciju izmijegi podrozumuje vasse konkatenacija. Ovo je naše rezultojiće stablo. Sada vreć smo stablo se uzove stablo pozicija, a nam je sad falete pozicija. Šta zapravo predstavlja pozicija? To smo neke numeričke vrednosti koje za početak dodeljujemo ovim terminalima, odnosno simbolima koji mogu činiti našu sekvencu i redom krenemo slejevanu desno i numerišemo te simbole počev od nekoj vrednosti, o tipučnoj jedinice. Tako da u sljedećem koroku ćemo svaki ove simbolu koji se može pojaviti na ulozno, numerisati po jednom vrednošću otako, a je dodeljenu 1, zatim b u 2, c3, d4 i simbol za znak sekvenci, za kraj sekvence 5. I tim smo odredili njihove pozicije. Ove pozicije će nam koristiti da praktično za svaki del podstabla, koji zapravo pisuje neki del sekvence, odredimo kojem poziciju može da započne ta del sekvence, a kojem poziciju može da se zavši. I u sljedećem koristiti, to ćemo raditi za svaku del sekvence koji je predstavlja nekim delom stabla. Tako da hajde da vidimo kako bi to funkcionisano. Ova ope konkatenacija b i c predstavlja upravo del sekvence koji opisuje oto ovaj ovde del. Tako da spajenje b i c. Kako određujemo sada čime može da počinja neki del sekvence, čime može da se zavši? Tako što, imamo skupove koji će za svaki del stabla da odredi šta koji je pozicije čine početak, koja je pozicije čine kraj tog dela sekvence. I na početku, osim toga, takođe još jedna stavka, označavamo nešto su se zau puništivi čvoravi. A to znači koji deo stabla ne mora da postoji. U ovom našim konkretnom stablu mi smo značili dva čvoraka u puništiva i ajde da vidimo iskog razloga. Ovo zvezde su zatvarenje.
 u principu uvek poništivom, zbog toga što ono zapravo podrazumeva da neki del sekvenca opšte ne mora da postoji. Kao što smo videli iz primera koje smo usvojili za ovaj ovde regularni izraz, reklet smo da klova objevca je opšte ne mora da se nađe u tom našem izrazu i to je dobaš slučaj kada ova zvezda stuponavljenja je s odnusi na ponavljenji od nola puta, kad je tu zapravo epsilan sekvenca. Ondo svoj noj ideo da mi preskočimo, ali tako taj ideo uopšte u samom automatu. Tako da ste strane zvetlice je uvek poništiv čvor i time smo videli o tako da ovo je ovde del stabla ne mora da postoji, odnosno da taj del sekvencije ne mora da postoji. Kada određemo šta je još poništiva, ovo ovde ili je takođe poništivo zato što opisuje del stabla koji predstavlja sekvencu gde može biti izobrno a ili može biti izobrno ovove ponavljenje. Međudimo, ovo ponavljenje može da se desi nola puta i u koliko je izobrno ova putanja, odnosno ova grana, ovo podstavlja, a ne ovo levo, onda je u tako c ovoj del sekvencije neće postojeti i to je baš bio ove slučaj kad smo rekli da imamo samo d u našoj sekvenciji. Dakle a ili ovo ovde ponavljenje e pa nije a nego je baš do ponavljenje, a ponavljenje njeg nola puta i tada je ovaj c ovo sekvence preskočen, zbog toga je takođe ove je ovde čvor poništiva. Nijetan drugi čvor u našem stablu nije poništiv jer ovakom katenacija sigurno ima ovaj ovde simbol D, vidimo da D nikako nemo preskočite, izbog toga nije poništivo i sam tim nije ovog ore nije poništivo, a taj rud da je ov nika nije poništiv, izbog toga što sigurno imamo znaga za kraj sekvence. I ato, tim smo to odredili. E sada kada određujemo one skupove, krećemo od upravo ovih simbola koji se mogu pojaviti i to je trivialna operacija odrediti čime može da počne taj daj sekuvence, čime može da se završi i to značemo mu ovako skupovi ima tih pozicija. Uvek naravno za terminalne simbole to je baš ta pozicija, zato što prosto i to je da pletrivio na ideo, ali čisto koćemo da ispuštujemo sam algoritm, tako da uvek stavimo jedna skup sleve strane koji označova početek, određeno gdela sekvence i jedna z desna strane koji označova kraj i oni su uvek ovako inicijalizovan i baš tom pozicijom, jer je to praktično nedvosmisleno Ono što je namo od interesa je da vidimo upravo za ove operacije, odnosno za interne čvorove a pošlo oni reprezentuju neke netrivijalne delove sekvence, čime ti delovi sekvence mogu da poču, čime mogu da se završe i ideja nam je da idemo od najdopitek delo u stablu i da propagiramo ka vrhu i da dođemo do samog korana i ti mi ćemo zapravo zatjučiti čime sve ove cele sekvence može da počne a čime se završane U prvom koraku, kao što reko, krećemo od ovog najdubljeg dela tako da treba da određemo za ovu prvu konkatenaciju i to je potpuno jasno jer kad pogledamo nemažemo mi odrediti za neki od čvorove koji su na višim nivojima ako nevamo informaciju šta nam dolazi Tako da, prvo je al tako određemo za ove i ovdje i sad ove konkatenacije naša pošto, u koliko postoji ta ideja sekvence on sigurno izgleda baš tako, bc tako konkatenacije znači niz od dva karaktera bc tako da ona obvezna počinje se b odnosno obvezna počinje pozicijom dva a obvezno završava se c odnosno obvezno završava pozicijom tri Time smo odredili čime počinje ovej del i čime završava idemo na više i određujemo isto to za ovo zvezda su zatvare i sad, znači ako imamo uopšte ovaj ovdje del sekvence u našoj sekvenci koja se prepoznaje sa ulazom Znamo da, bez obzira da je to bc ili bc, bc, ili bc, bc, bc ili tako dajem Sigur uvek počinje se b i sigur nosu uvek završava se c Ovakom katenacija nam to obezbeđuje koliko goca ona puta pojenovila uvek ćemo početi sa ovom pozicijom a završiti sa ovom pozicijom tako da će naš početni skup takođe biti dva a z krajnji skup takođe biti i sljučivo pozicija tri sad imamo dovoljne informacije da određemo za sledaći interni čvorku i ovo naše ili i sad kad pogledamo to ili zapravo reprezentuje ovaj ovde del sekvence i sve ovo zapravo podrozumevo upravo taj del i sad vidimo šta taj del podrozumeva pa ovaj del sekvence počinje ili sa a ili počinje sa ovim ovde del tako da u kodiku počinje sa a onda je to pozicija jedan ali ne mora počinjeti sa a tako može biti izbrana ovaj ovde del sekvence odnosno ovo ovde grana i tata gledamo čime počinje taj tu del drugi del a on počinje sa dvojku zbog toga naš startni skup ovde je upravo skup pozicija jedan dva dok je naš krajni skup određen tim je čime može da se završava ovde sekveca a to je ili a u koliko je izbrana bašta putanja ili kraj ovog dela sekvence a to nam je određeno ovom završanom pozicijom znači tri naš početni skup je jedan dva a naš krajni skup je jedan tri i kad promislimo to je upravo ono što smo i videli od ako ili je ovaj del sekvence a ili ovaj del sekvence bc bc bc i tako daje u tom slučaju tako počinje sa a ili b a završava sa a ili c i tim smo odredili ovaj oddada vidimo da u svakom koraku kad idemo kakorano stable koristimo informacije koje imamo od ozdoj stable izbog toga ne možemo proizvoljno da izbeberemo čvor od koga ćemo da krenemo ažuriranje već moramo krenuti od najdublijeg dela ustabla i propagirati do korana tako sad smo spremni da odredimo naš početni skup početnih simbola za ovaj ovde del sekvenca koji zapravo prezdede sve ovo ovde i naš krajnji skup simbola i onda kažem gledaj ću ovu ovde granu ostabla naš del ovaj može da počne s jedinicom i dvojkom to vidimo od afte tako da ćemo u statni skup da uključimo jedan i dva mećutim onda vidimo da nam je ovo takođe po ništiv čvor to znači da ceo ovaj del uopšte nemora da postoji i to je uprvo ona sekvenca kada smo videli o tako da izbra na ovva putanja bc al da su ona ponavlja nula puta izbog toga sve ovo može da ne postoji i tada nam ceo ovaj del sekvence zapravo počne sa d tako da naš startni skup stanje je tu 1,2 i 4 a šta ne mi je završnja skup pozicija pa ovaj ovde del naša sekvence se srčingot počinjalo sigurno završava 4 odnosno pozicijom 4 odnosno da je ovu ne poništivo i u praktično u toj kunkatenaci taj drugi del je siguran tako da ovaj ceo del ove može početi 1,2 ali mora se završiti pozicijom 4 i posljednja stavka koja nam je ostala a to je da u našem korinu ovog stabla sad vidimo čime može počinjeti sve ovo praktično i čime završava i pošto u pitanju u kunkatenacija ne poništiva onda znamo da sigurno počinja ovo čime ovo počinje a da sigurno završava o nim čime završava drugi del tako da počinje skupom pozicija 1,2 i 4 a završava pozicijom 5 i time smo formirali naša stavlo pozicija nadam se da je ovaj dovoljno jasno vidi u tim, sljedeći korak je naravno da vidimo kako da iskoristimo mi uopšta ovo stavlo pozicija kako nam ono zapravo služi da bi smo informirali naš automat i ono što je pokazano višto će biti u stvari prikazano na primjeru je da je ovaj zapravo najteži ideo ovoz metoda, formirate samo stavlo a pročitimo kroz nekoliko primjera pa će biti jasno ako nekom slučaju nije sada jasno dok i drugi ideo prilično jednostavnije sljedeći korak, nakon što smo formirali stavlo pozicija, ovde dato finalno rješenje je da odredimo za svak od tih pozicija koji je skup sljedećih pozicija što znači skup sljedećih pozicija to znači u našoj konkretnoj sekvenci koja sljedeća pozicija se može pojaviti odnosno koji sljedeći simbol odnosno karakter se može pojaviti ali u ovom momentu na nivou pozicija tako da, ona što treba da uredimo i možemo da gledamo na nivou sekvencija ali je boje da gledamo na nivou stablja kad naučimo malo kad uđemo u što se samim metodom prilično jednostav pozmetramo za svaku poziciju pojedinočno tako da imamo 5 ulaz ove našoj tabelici i za svaku poziciju pozmetramo koji je to sljedeći simbol odnosno sljedeća pozicija koja može postojati u toj našoj sekvencij i kada pogledamo uvek gledamo od konkretno te pozicije pa desno u samom staplom međutim, kada se krećemo desno u odnosno poziciju 1 sljedeća ova grana koja podrozum uva grana koja podrozum
 ovo podstablo nije zapravo sledeća u sekvenciju odnosuna a. A razlog zašto nije jer ovdje postoji ili. Tako da su ove dve grane alternativne. Ova dva podstablo su alternativno. Zbog toga ovo ovdje podstablo nikada ne može biti u samoj sekvencij iza ovog a. Taj tako ni pozicije dva i tri ne mogu biti sledeće poziciju odnosuna poziciju jeda. Tako da u koliko postoji pozicija jedan, odnosno karakter a u sekvenci, ono što ide iza je prva sledeća stvar koja sigurno postoji al tako ovoj sekvencija, to je naša pozicija četri. I pošto pozicija četri je neponištiva, dakle nema načina da se zaobiđe taj deo sekvence, onda je to jedina sledeća pozicija za poziciju jeda. Inače, napominjam da s ovim poništevi čvorvi moraju, napominuti u stablo, odnosno ukviriti ovako na neki način, u suštiniju oni su jako korisni, zato što ako dobro označite šta je to poništiva, to ovo može pomoći da jednostavnije rešite problemi da se ne prevarite pri ršave. Da videmo sledeću poziciju za poziciju dva. Do ovog konkatenacija nečega što je neponištivo, što je sasvim izvesno, znači izvesno da će se c pojaviti u sekvenci I za B ako imamo B, tako da nakon B sigurno dolazi C, izbog toga je pozicija ovde tri. Šta nalaj dolazi nakon C? Na nakon C, ukuliko ovdje imamo ponavljanje, odako dolazi dvojk, to je ona varianta kada imamo BC, BC, BC, BC i tako da. Dolazi pozicija dva. Međutim kada izlađemo i stok ponavljanja, onda se krećemo dalje po našem stabilu odnosno po sekvenci i prvi sledeći simbol koji se pojavljuje d, odnosno pozicija četri. Međutim, kaj vi do sada što smo videli odako, ta četvorka se mora pojaviti, ne može se preskočiti, tako da će naš skup sledećih pozicija za trojku odnosno za C ostati dva i četiri, odnosno nakon C se može pojaviti B, a može se pojaviti d. Nakon pozicija četri, odnosno ovog d, sigurno ide znak za kraj sekvenca, odnosno pozicija 5 ili je to obično, akon kvete nacije, ništa nije tuplo ništivo, tako da je to samo 5, a nakon pozicija 5 nemoj njišta i time smo formirali zapravo ovo tabelu narjednih pozicija. Čemu to služi? Pa, sad hvačemo na kraju da formiramo naš automata. I automata se formira, tako što naravno kao i da sada, koloni će nam biti simboli, koji zapravo se mogu naći na ulazu, a ove ovde ulazi bi trebalo da nam budu stanja. Zatak šta je naše startno stanja ovdje? Pa naše startno stanja predstavlja skup svih pozicija, kojima naša ova sekvenca može početi. I to je zašto smo imo ovo što formirali ovo stavlo pozicija, da bi smo ispropagirali taj skup do vrha. Taj skup ovde je nam skup 1, 2 i 4 pozicija. I sad je pitanje kako mi dalje popunjavamo ovoj naš automata. Za svaku poziciju koja se nalazi u tom skupu pozicija, mečujemo, odnosno mapiramo, na odgovarajući simbol tu poziciju, i popunimo odgovarajuće ulaze o nim prelazima koji smo malo predefini sali u okviru tabela. Hajde da vidimo naprima. Naš startni skup pozicija 1, 2 i 4. Znači krećemo od pozicije 1. Pozicije 1, opamala smo im brzala, pozicije 1 odgovara simbolu a. Odgovara simbolu a. Što znači, mi ćemo popuniti ovaj odgovarajući ulas o nim što predstavlja sledeću poziciju za simbol a. I kada pogledamo ovu naš ovde tabelicu, to je praktično četvorka. Tako da mi ćemo popuniti ovaj ovde ulez pozicijom 4. I naravno uvrstit ćemo tu poziciju kao nov i praktično skup. Kao što radimo koji automata inoče pojebilim se nov i skup. Mi ubacimo ovde kao stanje sa strane koje ćemo posle kasnije ponovu posmatrate. Dakle, kako se ponoša. Nakon toga ubrađemo sledeću poziciju. U sledeće pozicije pozicija 2 i tonem odgovara simbolu b. Zatim pogledamo šta je sledeće. Tako u odnosu na b to vidimo odavde i vidimo da je to pozicija 3. Tako da ćemo odgovaraćemo ulaz u popuniti 3 i dodati to u naš automat. Sledaće u ovom ovde skupu nam je ostalaš samo pozicija 4. Pozicija 4 odgovara simbolu d. Kada pogledamo u naš ovde tabelicu za sledeće pozicije. Dakle, sledeća pozicija 5. Tako da ćemo ulaz u d. U sledeću tabelicu, u popuniti poziciju 5 i dodati odgovaraće ulaz u našom tabelu. Nakon toga, prelazimo na obradu sledeće gred i to je naše stanje koje se sastoje isključivo od pozicije 4. Što znači ponovno ćemo upisati samo u ovaj ovde ulas koji se odnosi na poziciju 4 odnosno na simbol d. I to će ponovno biti odgovaraći prelaz odnosno 5. Sledaće stavka, naravno sledeći ulaz ili tako to je trojka. Trojku još da sada nismo imali odgovara simbolu c. I kao što vidimo u ovoj tabelici za sledeće pozicije, sledeće pozicije trojke su pozicije 2 i 4. I to smo dodali kao ovde stanje i naravno dodali smo kao ulaz. Za 5, pošto je to znak, zakraj naše sjegvenca, onda pravdicu, naravno, nema ništa i za toga što ide, tako da to neoznačavano. A za 2 i 4 potrebno da popunimo ulaze koje tko gvaraju pozicijama 2 i 4, a to su ulazice simbole b i d. I mi ih naravno popunjavamo njihovim sledećim pozicijama, što su pozicije 3 i b, i time smo konvergirali i završili smo obred. Inače, jasno je da ćemo ovde naravno konvergirati. I to u relativnom malom broju koraka, naravno, odnosno u kompome broje stanja, normalno, i pozicija. Zbog toga što broje ovih različetih stanja je definisan upravo time koliko različitih simbola ima, zato što za te simbole mi svaki put definišamo identične sledeće pozicije, koje nam zapravo jih slavdjavaju, zatim šta će biti stanja koje će mogli učiveti u sledećem koraku, izbog toga relativno brzo konvergiramo. Kada smo dobili ovo, sve što treba dobredimo je da prevedemo sada skupove ovih pozicija u stanje koje ćemo donumerišemo s0s1s2s3s4 i prosto ćemo formirati deterministički konočni automat. Za njegu bi smo to koji mogli da ispitamo, da li je minimalni ili nije. Postoji pravilo za automace dobijene metodom pozicija, meću ti, tako, ja to porazmislite, da kakvi su ti automati koji se dobiju i dalito nekako možemo pokazati. Ovom bi trebalo da bude jasno kakvo funkcioniše metod pozicija, ono što nam je još naravno ostale doderimo šta su stanja prihvatanja, šta su stanja odbijenja i u principu, kao i do sada, stanja prihvatanja su sva one koje sadrže neku poziciju, odnosno stanje, alo uopštom slučaju, koje veza vršno i pošto ovdje zato smo boši uveli ovo stanje, odnosno, ove simbol kraje sekvence, da bi smo mogli da razlikujemo tako kada prihvatamo zapravo neku sekvencu, izbog toga je ovo i slučivo stanje koje stanje prihvatanje, sve ostalo su stanja do odbijenja, jer mi jedno drugo stanje ne sadrži simbol za kraje sekvence. Tima smo prošli kojc prvi primer i u principu, to je to što se tiče, primera koji se nalaze ovde u materijali. I sad mi ćemo u okviru ovog časa proći kroz još nekoliko primera, kako bi smo su upoznali sa nekim još dodatnim poljiljnostima i nekim stvarima za razmišlenje, a jedna od tih ideja zapravo je kako ćemo modelovati pojavu više istog praktično simbola više puta. I, a to, to man, idemo malo provažbamo, treba formirati odnosno konstruisati stavlu na osnovu ovog ovde. Ovog ovde je regularnog izraza. Takle, kao i do sada krenemo opresiranje tog izraza s desna u levo, što znači prvo napravimo kunkatenaciju ovog kraja sekvence i ostatka. Nakon toga, za ovaj ostatak, ponovno s desna na levo. Idemo kunkatenaciju zatvarača, odnosno, plus ponavljanja ovog CA i ovog ovde ostatka. Hajde da vidimo. Dobro, kaj ovde nije de ovdje C. Izvinjom se, ali u principu je toto. Drugi deo ponovno imamo kunkatenaciju A ili tako nula ponavljanja neke sekvence, a ta sekvenca je unija, odnosno, A ili B. E dobro. Prebalo bi do sada već da smo tako svesni kako ide o formiranje, da hluvak zdesna u levo i prosto razložemo delove sekvence. Sada kada krenemo da dodaljevo pozice simbolima, mi krenemo od prvog simbola, naravno, dodalimo moj diničom. Međutim, kada dodaljem od drugog A, tu se sada postavlja pitanji, dali mi ovom simbolima...
 koji se zove isto kao prvi simbol, dodeljujemo i isto poziciju ili dodeljujemo različitu poziciju. Naravno možno zašenja odnosno odgovor varirati u odnosno na konkretnu situaciju, meću tajom kva ćemo da utvrdimo neku opšta mesto za to i da bi smo to utvrdili, uzet ćemo jedan primjern koga uvijek možete da se setite ako zaborivite koja je pravila, da je prosto isprobate na nekom osnovnom primjero i pokažete šta je neko opšte pravilo koji će sigurnu uvek te raći. I na jednostanji primjer da to pokažemo je obječna konkatenacija neka dva karaktera, ne budu a i an. I naravno kako bi smo formirali naše stable za početa, pa kao konkatenaciju znaka za kraj sekvence, redbe smo čekli da ne postoji taj znak za kraj sekvence eksplicitno u izrazu, vikat odajte. A zatim ovoj prvi ideo je prosta konkatenacija dva simbola A. Ako da dva simbola A označimo istim pozicijama, onda naravno i kada označavamo ili tako propagiramo zapravo skupove pozicija u savom stavu, mi ćemo reći da ove ideo konkatenacije uvek počinje sa pozicijom 1 i završava sa pozicijom 1. I da cjela ta sekvenca uvek počinje sa pozicijom 1, a uvek završava sa znakom za kraj sekvence, odnosno sa pozicijom 2. I kada bi smo sada želi da formiramo automoto dologa, mi bismo al tako prvo formirali tabelu prelaza i reći da bismo da nakon pozicija 1 može dodođe ponovu pozicija 1 i to je naravno slučaju paš ovog prvog A i za kogada odmog dolazi A. A izna takođe može dodođe iznak za kraj sekvenca, odnosno pozicija 2, i to je u prvo slučaj ovog drugog aja. Dok naravno i za znaka za kraj sekvence, nema ništa, to je već standardna stvar. I kada na usnovu toga hoćemo da formiramo automot, krenemo u startnog stanja i to je zapravo našu pozicija 1. A zatim kažemo, ako nam A dođe na ulaz, je v tako prelazimo u neko stanje koje se stoje pozicija 1 i 2. To uključujemo, ali tako kao našu nova stanja koje smo detektowali. Značim, vrlo brzokonvergiramo, zato što je pozicija 1 i 2 o buhvato i zapravo A, tako da ovaj ovdo ulaz će ostati identičan. Na taj način mi smo završili. Jedno je stanje prihvatanje, drugo je stanje odbijanje. Inače, ono što nisam napomenalo do sadar, prosto nismo nibili u tako situaciji, je da ukoliko imamo više simbolan, oni se u ove finalnoj tabeli naravno objedinjuju pod istim, dakle simboličkim imenom bez obzira, kako označili njihove pozicije. Kaznećemo malo više prodiskutovat i o ton. I sad, ako bi smo čisto radi naše lakše grezumevanje i interpretiranje dobijenih rezultata, koji bih povoljiova je u tomet u recimo, grafovsku reprezentaciju. Ono što bi smo dobili je jedan ovakav ovutomet. I stada kao što vidimo, naša sequenci A-A je nešta se absolutno prepozne. Tako je krenemo i stanja je s nulom, dobijemo prvo A-a pređemo u stanja s 1, pojevi se još jedno A i to je stanji prihvatanje, tako da naše sequenci se prepozne. Međutim, ono što smo napravili i ovom prijelikom, i da se osim A-A, prepozne i samo pojeva jednog A. Da se takođe prepozne i pojeva 3A, 4A, 5A i tako danje. Dakle, konstruizali smo rezultujići automet, koji prihvata mnogo više u odnisu na ono što smo mi inicijalno želili da prihvati. A naš cilje je ove da konstruišamo vaš automet, koji će odkovarati tom regularnom izrozu koji smo napisali. Samim tim ovo nije validno rešen. Za neke situacije će biti ok, ali u opštom slučaju neopohodno je svaku dobitu ponavljanja odvojiti zasebnom pozicijom i tako ovdje numerisati prvo A-pozicijom 1, a drugu A-pozicijom 2. Na dalje praktično sve ostale simbole numerišamo odvojenim pozicijom 3, 4 i 5. Ponavljav ovo c je ovde zapravo d. Kada smo uspali to da uradimo, to je bitno da ne zaborvimo, sada i propagiramo isto kao i malo pre pozicij skupove kojima mogu počinjati odričeni delovi sekvenci i završavati do našeg ruta. U principu takođe odredili smo i poništiv čvor i torim je ovo zvezde so zatvarenje. Kao što smo zaključali, zvezde so zatvarenje uvek poništivo, a za ostale čvoru da treba otvrditi dali su ili nisu i u suštini ovo ili naravno nije, zato što je u pitanju ili A ili B, oba su konkretne simbole tako da su ne poništivi. Ova konkatenacija takođe nije će biti poništiva, zato što sigurno ima ovo A, ako i ovog dela nema. Plus ponavljanje nije poništivo, osim ukoliko se ne ponavlja nešto što po samo sebi može biti prazna sekvenca i pošto smo onda već dobili neka dva postavljka koja nisu poništiva, onda i ova konkatenacija nije poništiva i naravno korino ne može biti poništiva, zato što uvek uvodimo znak za kraj sekvenca. Kako sad da propagiramo ove skupove početnih i završenih pozicija? Dakle, ovo ovde ili označava deo sekvence koji počini ili se A ili se B, te naš početnih skupu čini pozicije dvaj i tri, a takođe i zvršava ili se A ili se B pa i naš kraj nji skup oba. Takođe, dvaj i tri. Dobro je parkora, ka je žemapra. Takođe, ovo ponavljenje predstavlja obovozno ponavljenje sekvence A ili B, što znači? Možemo imeti A, A, B ili samo B, B, B ili samo B, ili kakogod. Tako da, bez neke pravilnosti, može početi bilo kojemu dova dva simbola i može završiti bilo kojemu dova dva simbola, zbog toga smestamo pozicije dvaj i tri i u početnih i u krajnih skup. Nakon toga, ponoviramo tako na gore, određujemo skup za ovaj ovde čvor, koji predstavlja konkatenaciju. Pošto bo i neponištivu, to znači da ovaj ovde, ovde, ovde celo po sequenca, sigurno počinje sa A. I dobro što možemo da vidimo i samo ovde, samo ovdi sequenci ponavljam, dobra je praksa uzeti neke konkrentine sequence i sad naprem'o reći, tako da recimo to je A, C, odnosno A, D, kako gote, ili to je A, A, C, recimo. Dakle, dobro je uzeti konkretne primere. Kao što vidimo, u svakom slučaju počinje sa A, tako da početni skup mora imati A, dok završmi skup, takle, ova cela del sequence, s čime se može završavati. Može se završavati sa A ili B odavde, tako to su pozicije 2 ili 3, što je vidimo odavde, uvekljedamo završno poziciju, ovog sadesna strana. Vi ću ti pošto ovde poništivo, može sve da ne postoji, onda je potrebno uzeti i završno poziciju ovoga sa lejve strane, te ćemo zbog toga imati Uniju 1, 2 i 3 kao završnje pozicija. Sledaća konkatenacija ponovu, pošto ovaj del ne poništi, sigurno počinje sa onim čime počinje ta ideo sequence i to je A, a pošto i ovaj del ne poništi v takođe, onda sigurno završava sa onim, sa čime završava i ovaj del sequence i to je 4. Inače, a dakle, ovaj ovde del, ovaj ostalo od predhodnog, ne može da završava sa jedinicom, zbog toga što ovo ovde nije poništivo, tako da u tom slučaju, dakle, ovo završava isključivo pozicijom 4, zato što ovde imamo prosto našto što je ne poništivo, tako sigurno se završava sa 4. Ostalo je od nekog drugog primjera, koji ću posao samo dati kao primjera za samostalni rat. I na kraju, kada propagiramo ovod do korena, dakle, pošto je ovaj del ne poništiv, dakle, sve počinje, ja dakle, o nim čim je počinja ovaj levi del, a pošto i desni del ne poništiv, završava se s ovim se čim je počinja ovaj desni del, i time znamo da cjela naša ova sekundza zapravo počinje se jedin, a završava se sa 5. I time smo formirali naše stablo. Dakle, kada bi smo sada uopštili nekako ova algoritma, ono što bi smo zaključili, je da, krenemo od datanam, i onda svakom narodnom koraku posmetramu koja je u pitanju operacija. Ako je u pitanju u konkatenacija, možemo reći da je skup sekvenci, skup pozicija koja je počinja, odgovarajuća sekvenca koja je predstavljena, dakle, tim poc sablon, sigurno, ono čim je počinje, ono što se nalazi, ili tako u levom poc sablon, a ukoliko je to poništivo, onda se gleda i čime počinje, ono što se nalazi u desnom podstapla. Ekivalenzima je i za kraje praktično. Ako je ovde našto što je neponištivo, onda se uzima samo taj simbol, kao što bio slučaju ovde, dakle, uzima se...
 i sklučuvo četri zbog toga što je ovo neponištivo, sigurno se završava sa tim. Pečetom, u koliko je poništivo, onda se mora uzeti ono čime se završava levo podstablo, što je baš ovdje ovdje primjer kada smo osim 23 uključili i jedinicu. Zbog toga nam treba da prosto označimo me ove stvari i da budemo dovoljno pažljivi. Sa ili, znamo da imamo alternativne putanje, tako da je moguće uzeti početak oba, odnosno kraj oba i sa ponavljenim, naravno, znamo da se ono što se nalazi dole o podstablo samo vrtio, tako određeni broj puta, tako da u skladu sa tim ažuriramo startni i krajnji skup pozicija. I ovdje smo formirali naše stavo pozicija i trebalo bi da prosto razumemo kako funkcioniše za provova konstrukcija. Slediči korak, naravno, kao i da sadam, nam je, i ovdje ću isto ovdje doprezretam, nam je da zisvako od ovih pozicija odredimo skup sledačih pozicija. Za jedinicu, tako na koni jedinice pošto ovdje imamo konkatenaciju, može nam doći ili dvojka, ili trojka, ili tako, tako da uključi ćemo i 23, meću ti, pošto je ovdje poništiv čvor, to znači da ceo ovdje delu nema rovo što postoje ti u onoj našoj sekvencii, onda praktično tu može se nalaziti nešto što je iza i to je pozicija 4. Zabuk toga ćemo uključiti i poziciju 4 ovdje. Pozicija 5 ne može biti sledeća za poziciju 1, zato što ovak četvorka neće biti poništiva, ne može biti preskočena i za te strane ovdje ne možemo uključiti poziciju 5. Dobro, slediče pozicija 2. Dakle, zbog ovog ponavljanja nakon pozicija 2 može doći ponovog pozicija 2, može doći pozicija 3. Međutim, ukoliko završimo al tako tu ponavljanje, onda znamo da nakon toga dolazi pozicija 4. Tako da, za našu sledeću poziciju odnosno poziciju 2, to je skup od pozicija 2, 3 i 4. Zdlječe pozicija 3 potpuno identično stvar, zbog ovog ponavljanja može doći pozicija 3, može doći pozicija 2, a može doći pozicija 4, kada se to ponavljanje završi. Za poziciju 4, može doći ponovog pozicija 4, pošto ovdje imamo plus za dvaracal, tako da se ponavlja ta idealna sekvence, a nakon što je završeno ponavljanje, može doći pozicija 5 i time je to skup. Nakon pozicija 5, naravno nema niček. Sledaća stavka je odrediti finalni automat i s finalnim automatom uprvo krećemo, tako što znamo šta je naše startno stanje, šta nam ulezi u startni skup pozicija i to je uprvo pozicija i nače. Ono što sam malo prenapljenovala, ali prosto kada smo diskutuvali, onaj primjerv sa 2 simbola a, možete možda nismo dolinu vratili pažnja u tom momentu i još nismo imali neke ovako veći primjer sa identičnim pozicijama, je da, ovom, na primjervo, ove predstavi automata koji ostavljamo na kraju. Možemo koristiti pozicije kao konkretne neke simbole, ali tako ovako u kolonama, možete možda način u raditi i sprovesti uniju svih pozicija koja odgovaraju istom simbolu. Pobivom našem konkretnom primjervu presljavjeli pozicije 1 i 2 koji odgovaraju simbolu a, a razlag za to je što prosto na kraju moramo formivati 1 automat, gde se potpuno nedovosmislano zna da na osnovu konkretnog stanje i baš simbola koji se pojavi na ulazu, mi znamo kako se dalje ponašamo. Nemožemo to raditi na osnovu pozicije, zato što iz pozicije parsera, koji prolazi kroz sam kod, dakle kada najđa neki karakter, on ne zna kojojto poziciji, nam odgovara da je to pozicija 1 i 2. On zna samo da se nalazi trenutno u tom odgovarajućem stanju i da se pojavi o odgovarajuće konkretnom simbolu na ulazu i samim tim mi ćemo to kasnije vratiti. Ako njih je lakše, možemo sprovistio ovaka v medju korak koji će odvojiti stvari po pozicijima, a tako da se nakon toga radimo mreć, i to ćemo upravu uvrdu u ovom konkretnom primar. Dakle, startno stanje nam se sastoje od pozicije 1 i tako ćemo za poziciju 1 napisati skup ovdje tako narednih sledećih pozicija. Zatim ćemo taj skup uključiti u našu tabelu i za svako dove 3 pozicije 2, 3 i 4 i pretstaviti skupove koji se sastoje od sledećih pozicija za svakodnjih. Tako da smo poponili ova tri ulas. Tu imamo novo stanje stanju 4p i dodat ćemo gelta po i nakon ovog smo potpuno konvergirali i ne imamo novih stanja. One što je sledaće neophodno uvraditi je baš ovo što se malo prerekla, a to je napraviti uniju stanja 1 i 2 i prosto ih objediniti pod prelaz a. I to je ono što ćemo joj uvraditi. I u principu to je naravno nije ništa kompleksno, prosto ćemo objediniti ova dva ulaza i evo ga ovde. I imamo naravno ovo da je odgovara simbolima b, c i d, tu smo imali praktično medvosimislenom. Sledaći korak je da nekako numerišemo ova stanja, možemo to uvraditi kao je smo lese 1 i s2, gdje je poslednji stanje, stanje prihvatanja zbog toga što obuhvata ona iz naga za kraj seknice i u tome smo već diskutovali u sklopu pretodnog zadatka. I to je to. Imoj još jedan primerčić koji nećemo gurati do kraja. Već prosto želimo da vidimo još jedan segment, vi naravno odradite do kraja, formirajte deterministički konačni automata koji ima naravno nekih nepoznanice, možemo odavatno prodiskutavati. Među tim, ono što je interesantno u ovom primjero kada formiramo stablo pozicija je pojava epsila. I u principu šta odrazumeva konkretno ova izraz. Ova izraz opisuje neke skup sekvenci, koji može biti a, može biti b, može biti bb, može biti bbb, može biti a, b, b, b, i tako dalje. A u principu može biti i prazna sekvenca. Izbog togo imamo ovo epsilom koja nam uprvo modelo je takva neke kombinacije, tako, kombinaciju prazna sekvenca ili, recimo, isključivo ponavljenja simbola b. E, pošto, moramo da modelamo alternativnu putanju između a epsilom. Naravno podrozumimo da sad već namo doformiramo ovo stablo pozicija, pa neću ulaziti ponovu u detalje formiranja ako bude bilo potrebe prodiskutovaći motona konsultacijama. U svakom slučaju, ono što je dobro primetiti ovde je da se simbol e ne numeriše. Ne odvoje se specificna, odnosno, specijalna, odnosno posebna pozicija za epsila. Razljub za to i što se pozicije odvaju isključivo za simbole koji se mogu pojaviti na ulazu. A to je nekako i prirodno, zato što za te konkretne simbole mi odvojamo pozicije kako bi smo mogli da definišimo u koje pozicije slede neku i kako bi smo mogli da dođemo do startnog stanja, kako bi smo formirali autonet. Pošto epsilo ne može konkretno da se pojavi kao simbol na ulazu, ne može biti ona kolona u okviru naše tabele koje vam predstavljamo konačni autonet. Nema naravno mi smistvo u ovo što je numerišati, razljub za što postoji ustavile, naravno da bi mogli da se definišu alternativne putanje, ali nam suštenski nesluži za određivanje konkretnih pozicija. Kada koćemo da dođemo naravno do startne pozicije, ono što ćemo mi je reći, je da ceo ovaj ovde deo može počinja ti jedinicom i završavati i jedinicom isključivati. I sad, i ako tu imamo alternativne putanje, ta alternativna putanja zepravit će na predstavljaj izbor između neka dva konkretna simbola, već predstavljaj izbor između jednog simbola ili ničega drugog. U tom slučaju, dakle, u koliko postoji, ovaj deo sigurno počinja i jedinicom i završava jedinicom, zbog toga smo tako predstavili. Međutim, to zapravo značovo da je ovo ili poništiva. S druge strane, ovo zvezda stoponavljenje B.A. je naravno poništiva, kao je bilo koja drugo zvezda stoponavljenje. I samim tim sad da vidimo da imamo ikon katenaciju koja je takođe poništiva, zato što predstavio gov' katenaciju dva dela tog izraza, koji oba mogu da ne postoje, i zbog toga je ovakom katenacija poništiva. To znači da ona može počinjeti sa jedinicom i dvojkom i završavati sa jedinicom i dvojkom. Što to znači za cijel naš ovaj kompletni izraz? To znači da cijel naš izraz može počinjeti jedinicom i dvojkom, što je odab, da je o tako došlo, pa dogrom što došlo, dakle. A sam druge strane, ovaj deo može i lopšta da ne postoji. I onda samim tim cijel izraz može počinjeti odmah i drojkom i to je baš situacija kada praktično ne postoji ni jedan simbol, već prihvatamo pravzno sekvencu. I naravno, završava se znakom za kraj sekvence i naravno, sljedeći koraci bi nam bili da ponovno od ovoga formiramo sam deterministički konočnog. Poma tali to smo da sada veca vladali kako se ranti. U okveru ova tri primera, videlić smo pojem metoda poziciji, kako formiramo stavlu pozicije, kako dolazimo do startnog stanja, kako formiramo tabelu sledećih pozicija i kako popunjavamo konkreten automat.
 Osem toga videli smo i neke konkretne situacije i to je situacija kada nam sapojavljuju više puta simboli. Videli smo da u opštom slučaju je dobro da ih numerešamo odvori pozicijemo, kao i situaciju u kojem se pojavlju je epsilon, a to znači da nevom u konkretan simbol već on nekako predstavlja praznu sekvencu i prosto ne treba mu dodalivati poziciju. Eto, što se diče ova dva metoda, dakle, naravno, na vama je koji će vam biti jednostavni, koji ćete više želiti da koristite. U principu kao što sam reklav, u koliko je eksplicit na datu u sedatku, onda naravno tu mogucnost izbora ne imate. Međutim, u principu trebalo bi da oba metoda budu dovoljno jasna i da nije problem rešiti odgovariti problem jedno i drugom metodom. Ono što je naravno možda karakterističnije u slučaju metoda pozicije je da prosto morate biti malo ipak pažljivi, zato što je jednostavnije napraviti grešku ipak nego kojto vam se naovo algoritmo koji je dosta onako pravoliniski i dosta je jednostavn, ali u svakom slučaju metod pozicije je novo kompaktani i brže se i lakše dolazi do rešenja. Ove nadilje nam je ostalo da završimo sa leksičkom analizom, tako da ćemo na početku videti šta zapravo preslide pojem transliteratora kao jedne karike u lancu koji do sada nismo obradili u okviru leksičke analize. I nakon toga nam je ostalo da pogledamo još kako funkcioniše alat koji ćemo koristiti za izradu prve faze projekta, odnosno za leksičku analizu nekog programskog segmenta napisanog u mikrojavi. Što stiče samog transliteratora njega obradujemo u okviru ovog leksičke analize, odnosno dodatka i susećemo se s ovim pojemom u okviru prvog zadatka. Haj prvo da pročitemo prvi zadatak da vidimo o čemu se tu uradi pa ćemo onda videti šta uopšte predstavlja sam pojem transliteratora. Zadata kaža ovako. U programskom jaziku ispit postoje dve vrste iskaza. Promenljiva jednako izraz, if promenljiva, den iskaz, and if. Identifikatori promenljivih su jednostvoni. Izrazi sa sastoji od promenljivih i celobranih pozitivnih konstanti povezanih operatorima plus i minus. If iskazi se mogu ugnježdavati, iskaz i za den se izvršava ako je vrednost promenljive i za if različita od nola. Sve leksičke jedinice moraju međusubno biti razdojeni prazninama u vidu razmaka ili novog reda. Po dakon, strujsati deterministički konačni procesor koji služi do prepozna jednu leksičku jedinicu odnosno leksemu i pretvori u interni leksički kod. Kodovi su dativ sve desčo i tabeli. Nakon toga trebao da vidimo kada utvrdimo kako su formiraju kodovi i kako radimo ovo prepoznavanje da konstruišemo nijas kodova koji odgovara nekom konkretnom ulaznom prokremu i da objesnimo koja je funkcija transliteratora. Ok, hajde, da krenemo u prvo od pojima transliteratora da bi smo videli šta zapravo radimo u okveru ovog zadatka. Ukoliko, recimo, prepoznamo sa ulaza u okveru leksička analiza, isključivo reči koje su na neki način izvinjavom se sastoje od slova i u druge strane od nekih celobronih konstanti. To znači da mi konkretno sa ulaze dobijemo karaktere koji su dakle neka slova je odakvo od A do C, mogu biti mala, mogu biti velika i se druge strane takođe neke cifre koje dobijemo kao pojedinočne ponovu simbole i od kojih treba da formiramo neke jedinice. Ono što želimo recimo da formiramo u takom nekom slučaju je sa jedne strane neki identifikator, odnosno token koji će biti sastanjeni isključivo od slova a sa druge strane neka celobrona konstanta koje će biti sastanjeni isključivo od cifara. I kada bi smo kustrujseli naš konečni automat koji treba tako našto da prepoznam, im bi smo rekli, a dobro krećemo od startnog stanja, stanja S0 i akunom dođe prvo je al tako neko slovo, recimo malo A ili malo B ili naravno malo C i tako dalje tako sve ono što želimo da obuhvatimo praktično tom nekom reči i mi prelazimo u stanje S1 u okuru koga ponovom mogu dolaziti ista takva slova, al tako dakle A, B, C, D i tako dalje. Ovde naravno dakle nisu predstavljeni svi pojedinočni simbol i odostno karakteri, ali podrozumeva se da ako recimo kažemo da je to reč koje se zastoji od isključivo slova, malih ili veliki ili oba engleskog alfaveta, dakle naravno imelibismo prelaza u okuru ovog našega automata za svaki takav simbol. I onda ukoliko prihvatamo takvu jednu reču, ovob je naravno bilo stanje prihvatani. Sa druge strane, ako nam u startu dođe neka cifra, mi onda znamo da treba da prepoznamo ov tako numeričku konstantu. Izbog toga prihvatamo na ulazu, ja tako bilo koji cifru od 0 do 9, zatim prelazimo u stanje S2 i tu također dok nam dolaza cifre pojedinočni simbol i od 0 do 9, mi se vrtimo i ostajemo u ovom istim stanju. I na kraju kada smo završili došli do neke beline ili do sledećeg reda, mi kažemo da smo praktično prepoznali takvu jednu celinu, odnosno token i onda bi i S2 bilo stanje prihvatani. Ja sad naravno ako su bilo u kom trenutku desi, da smo recimo pomješali slova i cifre, u ovom slučaju bi smo prijavili grešku, zbog toga što je recimo naš cilj bio da isključivo prepoznajemo numerečke konstante ili da isključivo prepoznajemo reči, odnosno tokene koji se sastoje isključivo od slova. E sad, ono što možete primjetiti u okviru ovoga automata. I ako dakle je u tomat opet nekada pojednostavljen time što eksplicitno nismo crtali prelaze za svaki konkretan simbol koji može doći na ulezu, kada bi smo to uradili, ove i o tomat bio bio značeno kompleksni, jer bi smo mi eksplicitno predstavljali grane za svaki pojedinečni simbol koji se ove može naći. Ako pomislite da ovde gore možemo imeti sva mala slova, sva velika slova, takođe i u okviru stanja S1, što se tičaci para takođe, naravno to bi bio značeno veliki broj prelaza. U opštim slučaju, dakle nevezano sada za istručivo reči koje se sastoje od slova ili konstanti ovakvih numeričkih, kada bi smo to oradili u svakom slučaju, imali bi smo naravno izuzetno kompleksne automate gde bi trebalo specificirate stavno sve ove simbole. A sa druge strane, ako razmislimo, odali nam je to zapravo i potrebno, pa čak i kada mi konceptuvolno pričamo o tome, kako zapravo funkcioniše konstrukcija oga automata, odnosno kako on treba da se ponaša, mi nećemo reći, ako u startnom stanju pojavi nam se malo A, mi prelazimo S1, ako nam se pojavi malo B, prelazimo S1, ako nam se pojavi malo C, mi prelazimo S1. Ne, mi ćemo reći, ako nam dođu slovo, mi prelazimo S1 i dogodnom tamo dolazio slova, mi ostajemo u tom stanji. Kada nam dođe znak, tako, Belina ili prelazak u novi red, dakle kada smo oivićili nečim tajniz simbola, mi kažemo, ha, dobro, ako smo i dalje vas jazem stanji prihvatanja i prosto to identifikujamo kao neku reć, koja se stoji u slučivo slova, to je ono što smo mi hteli i recimo, tonom je neki identifikato. S druge strane, ako smo počali sa cifrem, prelazimo u stanji 2 i sve da go dolaza cifrem, mi o toga formiramo neku numeričku konstantu, zaključujemo dakle istu kao i u prvom slučaju. Tako da, čak i kada razmišlamo na nekom algoritm skom njubou, mi nećemo ulaziti u specifikaciju pojedinačnih simbola koji se javljili na ulazu, većimo probati nekako to da klasifikujemo i da predstavimo na neki ovakav način. E upravo to je uloga transliteratora, a to znači da radi klasifikacija u pojedinačnih simbola na ulazu i zapravo da ih klasifikuje u neke jasno-na tako klase tih pojedinačnih simbola. Ukoliko prosto nadalje se procesiranje tih simbola odvija na potpano identično način i funkcionisanje samog automata ne zavisi nikako od vrednosti pojedinačnog simbola, već samo od toga koja klasi pripadat. Na primver ovdje se naša u tomat potpano identično ponašlo bilo da na ulazu dođi nola ili jedinica, uopšta nije bitno, ili tako ne postoji neke pojedine akcije koje se razlikuju, već jedno što je odznača i je da je u pitanju neka cifra. A te samim tim ako iskoristimo ovaj proces prevođenja, odnosno klasifikacije određeno gulaznog simbola, mi ćemo nadaljemoći dosta da pojednostavimo cijel proces zapravo analize i pojednostavićemo dosta i al tako pa samo parsiranje, odnosno nećemo imeti neku nepotrebnu kompleksnost u našem automatu. One što nam je cilj da kleje da od neku izvornog programa u procesu transliteracije dobijemo je tako neke klase i na osnovu toga da na kraju formiramo neki interni leksički kot koji će dalje biti prostlađen na semantečku analizu. Zbog toga jako često ovaj transliterator je se efid...
 implimentiraju u vidu nekog vektora, gde zapravo za svaki pojedinačni simbol koji se može pojaviti, postoji njegov o jasnom aprinje na odgovarajuću klasu koje pripada i onda na daljo u skladu sa tom klasom naravno se prepoznaju čita verečenice i već kako smo dalje pričali da funkcioniše syntaxna analiza bar ovako u grubo rečeno, a sljedeće naše velika tema će biti upravo to pa ćemo onda i detaljnije pričati o tone. I sada kada pogledamo dakle šta ovde imamo, upravo nam je ciljda kada parsiramo, u smislu parsiramo, procesiramo je ovdak u neki ulazni program, odnosno neki njegov segment koji ovde datu za datku, da ga klasifikujemo na odgovarajući način i za svaku daklu klasu vratimo neki niz internih kodova u formi klasa i vrednost ukoliko tako nešto postoji. Kada sada procesiramo ovaj ovde program, dakle prvo našta na ilazimo je jedan token il tako koji je token a. Ono što bi smo pogledali je da li zapravo naravno pripada nekoj ključnoj reči ili sa čim možemo da ga uklupimo i kada prosto pogledamo ovom ovdje vektoru pa a nam odgovara slovo, tako da ćemo ga mapirati il tako, da slovo, kao slovo, odnosno znamo da to odgovara našim promenljivama, to je ono što smo videli u okviru, u okviru ove postavke odnosno tabele, kada smo rekli da se izredi se stoje od promenljivih i celobrni konstanti, a da su zapravo promenljive odnosno identifikatori zapravo jednostlovni. Tako da mi bi smo naravno na osnovu samo ga utvrdili da je to slovo, pošto ovde nevamo ono ponavljaje koje smo imali malo pre u okviru našega automata, time smo došli do kraja, zapravo smo dobili jedan tokenio, tako došli smo do neke beline i onda smo pogledali, hej, al to neka ključna reć, ovdje smo od ključnih reći samo imali if, then, and if, tako da vidimo da nije i samim tim to prosto mora biti jedna promenljiva, zato što odgovara tom nekom pravilu koje smo mi naznačili, a sliču nešto smo videli i u onom samom konečnom automatu koje smo nešto ramije povedali. Tako da bi smo kljasifikovali kao promenljiva, ovdje smo dodelili ovo P, kao klasna oznaka prosto to što vidimo iz ove tabela. Ono što odgovara v rednostnom delu je redni broj ulaza u tabeli simbola i to je zapravo sada ovde prosto plastično predstavljeno kao jedna neka tabela koja se drži simboli, koja se drži broj ulaza, naravno kada budemo pričeli nešto kasne u tog okursa o tabeli simbola, nogo pširlije ćemo pričeti u njenoj funkciji i načinimo implementacije, ali u ovom druh otku nam je prosto potrebna neka vrednost koji ćemo dodeliti u ovoj klasi, kako bi smo jedinstveno mogli da identifikujemo o koji su promenljivo i rati. Tako da ono čemu nama svoži ovde klasifikovanje da kažemo, aha dobro, na ovom mesu sada mi zapravo očekujemo neku promenljivu, kao što vidimo, dakle to će odgovarati ovom iskazu ovdegu i kaže promenljiva jedmako i izraz. Tako da mi očekujemo tu promenljivo, kakva god to bila promenljiva, bila ona ABC ili kakog god se zvala, baš zbog toga radimo ovu klasifikaciju, međutim naravno u neku momentu će nam trebati i da znamo koja je to eksplicitno bila promenljiva, izbog toga ćemo je upravo i dodeliti u ovu vrednost kako bi smo je jedinstveno identifikovali. Tako da je to P1 i to je neki naši internikot. Nakon toga u ovom procesiranju dolazimo do jednakosti. Kada pogledamo jednakosti, od tako dakle to je u ovu našu tabela, bi bila dakle neki specialan karakter i kada pogledamo i kako zapravo izgleda ova naša tabela koja je data u samom zadatku, vidimo jednakosti, ovako je klasni ideo, tako da je to klasa zasebna za sebe. Z druge strane nema vrednostni ideo, zato što naravno sa jednako je prilično jasno definisano o čemu se radi i kao što vidite to je predstavljio konkretan terminalni simbol, odnosno simbol, koji postoji u ovom ovde iskazu da jasno možemo da uklupimo to u sam konkretan izraz koji ovde imamo. Jednako dakle zbog toga nema svoj vrednostni ideo, nakon toga dolazi nam x, ponavo x je tako slovo, i kao dakle slovo odgovara nam u ovom slučaju to je neko je promenjivo, što znači klasifiku većemo ponovog kao p, a vrednostni ideo koji će biti, će biti al tako ulaz u samoj tabeli simbola, druga po redu, tako da će to biti dvojka. Nakon toga imamo plus, ponovog plus al tako ima svoju klasu, te ćemo reći, a ha ok, klasa je plus, a vrednostni ideo nema, je ponovog jedinstvano je određeno. Nakon toga, sljedeći token koji nam dolazi je if, evo klasni ideo je takođe if, nema, pošto je to ključan reć, nema svoj vrednostni ideo i upisan je od. Nakon toga a, ili tako to je ponovog promenljiva i njen vrednostni ideo je 1, i tako ćemo prosto klasifikovati svaki u ovu pojedinočnu reć koja je s ovdje nalazi i zapravo ćemo imeti 1 niz ovako internih hodova koje dalje možemo da procesiramo. Tako da praktično na ove način mi zapravo odgovaramo na opitanje pod b, odnosno klasifikovamo pojedinačne reći i na dalje naravno takve reći koristimo. I sad, ono što se tražalo pod a je da konstruišemo deterministički konačni procesor koji će prepoznati jednu leksičku jedinicu, to znači, dakle, jednu ovu reć i pretvoriće u interni leksički kod, odnosno u ono što smo videli ovde kao jedan kod, znači klasni i vrednostni ideo. I naravno koristit ćemo ovde tabelu. Sad, kako ćemo to u radici, pa tako što ćemo zapravo dodati neku akciju, odnosno proširićemo ono što znamo da je automat, nekom akcijem koja će zapravo da vrši ovu funkciju, odnosno da realizuje ovo što nama treba. E sad, kako ćemo to da urodimo? Pa u principu, vrste nam ovde predstavljaju stanja i ono što bi smo mogli ovdje da posmatramo, dakle, imamo jednu startnu stanje i onda imamo prepoznavanje ključnih reću, prepoznavanje konstanti ili nekih specijalnih znakova. Dakle, vrlo, svično u nama što smo malo prevideli, jedno što s ovdje svarim malo modifikuju, pošto prosto imamo neki drugi skup uleznih simbola koji se mogu pojaviti, i te tako možemo iskonstrujzati više različetih stvari, odnosno imamo i ove neke ključne reći, a takođe imamo i specijalne znakove. I onda u principu, naravno, se ulaza može da nam dođe slova, može da nam dođe cifre i specijalne znake, i naravno da smo završili prepoznavanje ove naše jedne reći, odnosno, tako jedno velek semo. E dobro, šta bi bila ovde akcije? Akcije su ove nekako simbolički oznočene, kao B1, B2, C1, C2 i tako dalje, nakon toga su predstavljene prosto izvojene ovde sa strane, kako gozato specificirali OK, samo je neopohodno da se jednostavno, odnosno, jasno vidi, dakle koja se akcije izvršava u kombinaciji nekog stanja i određenog simbola sa ulaz. U principu, u startom stanju, i slično kao što smo videli i malo pre, realizujemo, odnosno, razlikujemo šta smo prvo dobili na ulaz. Da smo dobili slovo, cifru ili neki specijalni znak. U principu, ako dobijemo slovo, inicijalizujemo neki buffer, u kome treba da akumuliram o to sve što nam dolazi sa ulaza, inicijalizujemo dakle buffer sa tim vrednostim delom leksičko kod. Ako nam je došla cifra, ponovu inicijalizujemo dakle neku vrednost sa ulazam, međutim, u koliku se radi o cifri, dakle, naravno, moramo usput da konvertujemo u cifru, kako bi smo na kraju sve to mogli da konvertujemo i u broj. I u koliko je u pitanju neki specijalni znak, odredićemo klasu tekućeg znaka sa ulaz. I na kraju, naravno, kad akumuliram ova ako dolaze nam sledeće slova, naravno, kad su u pitanju slova, sve što je potrebno je da samo pamitimo te karaktere. Z druge strane, kad nam dolaze cifre, je ovo što je potrebno naravno je da u toga pravimo neku celobronu numerečku konstantu, tako da ćemo ovo predhodnu zakomćenu vrednost celobronom nožiti sa 10 i plus dodavati cifru, ali baš dakle u formi cifre, al tako kao brojne konstante i to smo uradili naravno transformacijom iz karaktera koji smo je efektivno pročitali sa ulaz. I na kraju, kada je došla znak za kraj, al tako, mislim, naravno, time smo oivićili, al tako nekim Belinama ili znakom za naredni red, mislim, u principu, sada pronašljeno se pročitali celu tu reč, ukoliko je bilo reč o celobronu konstantu i naravno usputi i komertovali, i sada o našto treba da urodimo i da prepoznamo o čemu se tu radi. Tako da zbog toga imamo na kraju ovu akciju 1, 2 ili 3. Gde je dakle zapravo ideja da recimo, ako imamo neki niz karakter, neki niz slova, treba da vidimo, da li se radi o nekoj ključnoj reči. Ako se vratio o ključnoj reči, znači vrati ćemo neki internikod ključnoj reč, bez naravno vrednosti zbog toga što je to neka eksplicitna veće reč, dakle, nešto što znamo šta je neko...
 nema potreba niza kakvom vrednošću, kao što su malo prejmali situaciju kod recimo ključne reči if. Z druge strane, ako nije to slučaj, dakle, prepoznavači vratio error u smislu, ne postoji takva definisana ključne reč, to znači da pošto smo prepoznavali slovo po slovo, a odredili smo da je to legitimno za prepoznavanje nekih promenljivih. Tako, imamo odgovareći buffer i vraćamo internikot koji se stoji od, dakle, klase koje ovom slučaju promenljiva i plus određeni simbol u tabeli simbola u koliko postoji, u koliko ne postoji, dakle, prijavljio se neka greška. Z druge strane, ako se radilo o akumuliranju cifara, sada ćemo tako vratiti internikot koji će u ovom slučaju biti c, što nismo se susreli, ja sam zustavila rani ovo prepoznavanje, ali kao klasa posebna za numeričke konstante i koja, naravno, ima upravo ono vrednost koje smo uspodčitelji i konvrtovali u neku, al tako, neku vrednostu tog broja, nakraju, u tu stvarno konstantu. I treću, u koliko bio neki specialni znak, dakle, vratit ćemo internikot koje značava specialni znak i to bi bilo to. I praktično videli smo kako, dakle, funkcionišu u okviru ovog primera, videli smo kako funkcionišu u transliteratori, videli smo na jednom konkretnom primeru sekvenci, dakle, kako formiramo ove internekodove, zašto nam je to bitno. Juš jednom, dakle, da napomenem, upravo, zbog toga da ne bi smo komplikuvali implementaciju kasnije posebno parsiranja po jedinačnim simbolima, jer nema razloga, pošto, dakle, nikako se ponašenje samih automata u ovom slučaju na razliku odnosu na to, da li dolazi cifra 2, ili dolazi 25 ili 27 ili šta god, veći ovom pitanjem bitno samo da je to neka numerička konstanta. Te samim tim, prirodno dolazi u dove klasifikacije, je ovde smo videli juš jednu svar, dakle, kako od ovog jednog onočnog automata, gde smo videli, prepoznamo nizove. Slova ili cifara ili imamo neki specialni znak, mi zapravo proširujemo taj automat, pretvaramo ga u procesor, timi što zapravo dodeljujemo ulazu neku akciju. Tako, na osnovu ovih konkretnih akcija, mi smo zapravo imali ili akumuliranje slova, ili smo imali konvertovanje cifara u neku numeričku konstantu, ili smo imali, dakle, neki specialne simbole u ovom slučaju i na kraju, kada smo završili, odnosno, ivičili tu našu reč, još smo, dakle, radili konvertovanje upravo ove interni kod, koji nam kaže, ha, dobro, dakle, koja je klasa i koja njena vrednost ukoliko je bilo potrebna i samim timu, odnosno, ove neke tri, odnosno, ove klasi koja smo imali otakom, mi smo razlikovali, da li se radio nekoj tjučne reči ili se radio nekoj promenjevoj, da li je potrebno dodeliti u tom slučaju određeno vrednost, da li se radio numeričkoj konstanti ili o nekom specialnom simbolom.
