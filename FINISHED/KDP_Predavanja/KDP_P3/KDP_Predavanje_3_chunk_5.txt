 Ko će se onda proboditi? Ko bi trebao se proboditi? Svi procesi treba da se probode i da vidi, e to za mene E da zakhličene nije, samo će je jedan proći dalje a svi ostali će se zablokirati. Tako da ovaj ovde je naš ticket algoritm koji smo mi razmatili, je prvi pošteni algoritm ali ima malih nedostataka Prvi nedostatak je taj što zahteva je da kažem specialna istrukcija da bi mogu da se realizuje Drugi nedostatak je taj što ako želimo ovde da implementiramo svaki put kada se promeni data promeniva, svi moraju da provere, uslo, dalisam ja sledeći? Nemo neki način da kažemo da samo nekima o njih kažemo ajde, proveri i ja si ti sledeći nemojte svi da proveravate, potrošićete silno vreme na proveru a samo jedan može ići danje ako pravimo kritičnu sekciju samo jedan može danje tako da ovo je jedan od nedostataka već ili nedostatak tika i algoritma to je da na red dolazi a da bi smo zakliučili koji je sledeći moramo save da probudimo da bi oni mogli da nastave danje i mi ćemo ovdje algoritm sada razmatrati na narodnom času sa 2 aspekta prvi aspekt je, jer moramo specijalne instrukcije da koristimo to će biti bekeri algoritm druga varijanta koji ćemo razmatrati će biti Andersenovicel ha algoritm koji će posmatrati ovu drugu varijantu a to je ili moraju baš svi da se probude doli možete imati nekih pitanja koje se odnose na ova dva algoritma koje smo razmatrali sada na času prvi je bio petersenova algoritm za n-procesa koj toga algoritma smo rekli da se blokira poslednji ako nije jedini u svakoj fazi iteracije samo poslednji prolazi dalje, jedan jedini koji će doći u tu poslju fazu zato što smo rekli u n iteracije izbacujemo po jednu, dok ne ostane samo jedan u svakoj fazi i drugi algoritm je bio tiketa algoritm a koji kaže a ja čekam dok legoce na nekom displeju ne pojavi moj broj da limate nekih pitanja? ako ne imate pitanja ovdje ćemo napraviti dobar dan dobro došli na predavanje na predmetu konkurentno i distribuirano programiranje na naših časa su naredni synchronizacijoni algoritmi želimo da vidimo da li možemo malo da poboljšamo naš tiket algoritm tiketa algoritm je veoma pošten algoritm koji treba da obezbedi proces koji je prvi došao prvi uđi u kritičnu sekciju tiketa algoritm onakav kako smo ga razmatrali ima nekih nedostataka prvi nedostatak se ogleda u tome što zahteva korišćenje specijalnih instrukcija zahteva instrukciju dohvatio operant i uveće operant to nije bilo baš neku uvećanje preveliko za neku nerealnu vrijednost koji smo mi koristili bilo je uvećavanje za jedan tako da ovoj instrukciju smo mi u suštini već imali na predmetu koji se zove architektura koristitivna informara to je bilo instrukcija increment dovuci vrijednost uveće za jedan i vrati nazad nedeljivo jedna instrukcija jedina razlika u odnosu na toj instrukcije je ta da je nama ovde u akumulaturu ostala stara vrijednost da te promenjive ovako nešto postoj i možete naći kod progrmskog jezika java kad budete gledali u vrednosti koji su dozvoljene tamo, jedna od tih je fetch.net gdje možete da uvećate vrednost i da dohlatite star u vrednosti, vidite ćete da imate set i get, način postavi dohlati get.net, način možete da dohlatite ili da dohlatite, da uvećate... Sa njih pite samo, dobijate postavnju vrednost, ono koji ste uvećali ili dobijate vrednost koje je bilo pre. Neki programski jezic i odnosno neki architekture će vam dozvoliti da ne dobijete ovako instrukciju kao što smo malo čas imali, gde ćete dobiti star u vrednost, negde možete dobiti tu novu vrednost. Ovdje je fetch and add, a postoji onda add and get. To je dodaj i vrati mi tu uvećanu vrednost. A kuzmeti da gledate assembler, vidite ćete da svako njih može da napraviti različitu versiju tok. Dobro, način sada se naši algoritmi koji treba nekako malo da promene tiki algoritm, kreću na dve strane. Prva strana je ta da ne koristimo specijalne instrukcije. Druga strana je da ne moramo da budimo baš svakog, jer koji tika algoritma, voša strana ako bi smo želi to da implementiramo u nekom drugačije možda malo jeziku, je moramo da obavestimo sve i svi moraju da ododu do provere, i ja sam jasne ledeći. To je spor. I mi želimo da vidimo, da li možda u mestu tog spor ogrešenja možemo napraviti neko malo brže resenje. I prvi od ovih algoritma je Bakerie algoritm. Bakerie algoritm je algoritm koji treba da liči na ovaj naš predhodnji algoritm, samo što nećemo imati onu promenivu next. Molim? Kako nećemo imati promenivu koja kaže koja sledeći? Jednostavno. Uzrećemo najveći broj od svih onih koji čekaju trenutno u redu i taj broj ćemo uvećeti za jedan. Algoritm bi treba da opisuje kako se čeka ispred Bakerie ili negde, gde ne imate masinu kao što ima tubancik, gde dođete udariti izadživam broj. Nego pitate ovde koje poslednji, vidite od tih kojoj odnosno odete svakom gvernete na broj koji ima i uvećete taj broj za jedan. Taj maksimalni broj koji vidite uvećete za jedan i na taj način čekate. Znači, da sam sad rekal, kada se pojevi nova osoba koja hoći da čeka red, šta ta osoba radi, pa pogleda ko to do sada čeka red. I pogleda svakoj toj osobi koji broj ima. Ovo osoba odeg vrne tu, nađe šta je maksijum i kaže moji broj je i dobije za jedan veći broj od svih oni koji se terremotno nalaze tu da čekaju. I na ovaj način smo mi eliminisali jednu od promenjivih koje nam omugućava da napravimo synchronizaciju. I sada je pitanje, možda ovo ovde možemo da realizujemo na relativno jednostavan način. A opet ćemo kao kod našeg Petrsenovog algoritma, da krenemo od algoritma za dva procesa, posložnjavati ovaj ovde algoritm za n procesa. Posložniti to, a šta ako želimo da bude n. Da li to možemo na vrlo jednostavan način da uvećamo, da skaliramo ili možda moramo da napremo neko filtriranje kao kod Petrsenog algoritma. Tike algoritm koji smo videli, onakav kakavi radi i za dva, i za deset procesa. Nemam absolutno nikakve razliklije. On je uvek isti. Ovoj ostali algoritmi se možda malo razlikujem. Ajde da imamo kako bi smo mi to mogli da napišemo. Ajde da ispišem još jednom, šta sam ja rekao? Maločas dođem i gvirnem dokleje svako od oni koji čeka red došao. Kako to radim? Ode sam to zapisano na ove način. Entri protokol kaže turn od i doklet sam ja došao je jednako max od svih ovih ostalih plus jedan. Uvećaj i maksimum onih koji čekaju za jedan i to je tvoje broje. Nakon toga šta radim? Moram da sačekam da dođem na red. Kako to radim? Ode sam i uporedim se sa svim procesima koji postoje. Ne poredim se sam sa sobom. Kada mogu preskočiti nekog, ako je turn od i od jednako nula, to znači ja taj nekog svkem se poredim. Ne želim da čeka red. Radi nešto drugo.