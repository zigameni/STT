 Svima. OK, čao svima, nadim se da se čujemo. Dobrodošli na još jedan čas zaštete padataka i kao i svaki nedelje, kolega Adrijov i Asko tu sam vama i danas nastavljamo temu koji smo zapučali na prošom času, a to je PGP. Čao, Akim. Čao, čao. Čao, svak. Prošle nedelje smo obradili nekoliko funkcionalnosti u opiru PGP. I dakle, to su bila funkcionalnosti, ilosno servisji obezbeživanja tajnosti i autentikacije. Dakle, svaki smo videli pojedinačno, o kako funkcionišu, na koji način se obezbeđuju i u čemu se zapravo zasljiva pouzdanost algoritama, koji se koriste, prilikom obezbeživanja ovi funkcionalnosti i zašto otvrdimo, dakle, da su one sigurno pouzdane i da ove generalno šeima dakle radi dobra. Tako da, ovo što možete videti na ovom slajdu je zapravo onog, gde smo se zaustavili prošle nedelje, a to je jedna kompleksna šeima koja objedinjenu prikazuje obezbeđivanja autentikacije, obezbeđivanje tajnosti i dakle ima nekoliko ovih različitih seljmenata. Pa prenevu što prećemo na slediću funkcionalnostu, o koji ćemo pričati, a to je upravo funkcionalnost kompresije. Hajde samo ukretku da ponovimo ove segmente, prosto da bi smo se nadovjezali onda na tu priču kako funkcioniše kompresije i dakle, kako su među se vno zapravo porađane ove funkcionalnosti, zašto baš tim redosledom, tako da je to možemo to prodiskutovati. Ok, dakle, prvo ukretko pošto ispretili ste to prošle, put pa nije potrebno da pričemo sve deteno iz početka. Dakle, rekli smo da na početku obezbeđujemo autentikaciju podpisivanjem same korike, a to podpisivanja realizujemo tako što crejeremo neki hash u potrebom određene hash funkcije i data nakon toga taj hash podpisuje. To radimo dakle tako što ga zapravo kriptuvemo našim privatnim ključom, odnosno privatnim ključom pošiljavca, jer je upravo taj privatni ključ da klaj jedinog posledu sam pošiljavac, nije jedna druga strana ne može da ga posledu i na taj način možemo jedinstveno da uspostavimo korelaciju između ključa i identiteta njega u blastika. Zatim tako kriptovanji hash konkateniramo u samu poruku i kasnijećemo naravno koristiti za proveru pravotog podpisu. Nakon dolazi dolazi ove servis zipovanja, odnosno kompresija, u kome ćemo pričati već u okviru sledećeg slajda i nakon toga dolazi ideo o bezbeđivanja tajnosti i odnosno šifrovanja same poruke. I rekli smo da za šifrovanje poruke koristimo nekih osimetričnih algoritama za šifrovanje, sami tim da moramo izginerisati neki sesijski ključ koji će s ovdje koristiti. Mošto ne žalimo da ni uzuvimo ključeve, odnosno da ih koristimo više puta, to znači da ćemo svaki put da generisimo novi ključ za šifrovanje poruke, a to znači dakle da nekako moramo da i distribujeramo samu poruku, pa ćemo nakon šifrovanja same poruke, dakle naravno i nju taj ključ takođe nekako moći, morati da pošaljemo, a to radimo tako što dakle ključ zapakujemo zajedno sa porukom, međutim, naravno ne u video playing teksta, ja čemu šifrovanje onda, već nečim šifrojemo i taj ključ. E, dakle šifrojemo javnim ključem prima oca ove poruke, zato što je to praktično vrednost koju mi možemo da dobijemo, a opet znamo da tako poruku nećemo će da dešifluje niko, osim ono ko me poruka namenjena, odnosno ko zapravo ima odgovareći privatni ključ. Dobro, kad smo šifrovali ključ, javnim ključem prima oca, dakle spojimo naravno ključ sa tom šifrovanom porukom, sve to zajedno spakujemo, šaljemo do prijemnet strane. Na strani prijema, naravno, dakle potrebno je poruku raspakovati, dešifrovati i nakon doga proveriti, da li je to zaista od onoga od koga smatram o da poruka jeste. I naravno svaki dovi korak koji smo preduzali tokom procesa svanja, sada moramo ponoviti u obrnutom porke. Što znači, prvo radimo dešifrovanje poruke, istim onim simetračnim algoritm koji smo koristili za šifrovanje, a da bi smo mogli da dešifromu poruku jasno trebanom ključ. Tako da ćemo prvo da dešifromu ključ, odgovarajući privatnim ključom koristika. Kad smo dobili ključ, dešifromu samo poruku i dalje nastavljamo sa svedaćom funkcionalu, a to je sada dekompresija, pošto smo prilikom pakovanja i slanja same poruke, radili kompresije u obrnutom. Svedaći korak, naravno, još provera potpisa da vidimo, da možemo da autentikuemo tu poruku, jer na kraju, naravno, osim što nam je bitno šta je sam sadržaj poruke, poruku nećemo da prihvatimo, ako ne potvrdimo njenu ispravnost. Izbog toga moramo nekako da verifikuemo sam potpisa. Potpis ćemo da verifikuemo, pošto nam je poslat dakle tanko što je kriptovan privatim ključom pošiljovac, prvo moramo da ga dekriptuemo i doćemo raditi, naravno, sada odgovarajućim javnim ključom pošiljovac, koji je nama dostupan kao neko koje u okviru dakle ove neke grupa. Dešifruamo dakle taj potpis, međutim pošto pe u pitanju hash i to je one-way funkcija, mi ne možemo da uradimo inversno keširanje, već ćemo dakle da primenimo identično hash funkciju na caum porukom, da dobijemo neku vrednost, koju ćemo zatim doprovarimo sa onom dešifrovanov i ako sa one poklope dakle mi smo uspeli da verifikuemo datu poruku i onda već dalje možemo da je koristima. Ok, mala rekapitulacija. Osim doda prošli put smo rekli zašto nam je značeno da prvoradimo potpisivanje pre samog procesu inkripsije i razlog za to i još jednom, a što će nam takođe pomoći i da onda zakličimo izbog čega baš i kompresi usmeštamo u ovaj poredak ako možete vidati na ove šemi. Dakle jedan od razloga zašto baš na taj način prvoradimo potpisivanje pa onda samo inkripsiju je zbog toga što često nakleželimo da čuvamo samu poruku u plain textu. Dakle i da nekako možemo da verifikujemo potpis poruke i nekad kasnije. I sada u koliko bi smo na privar prvoradili proces inkripsije pa onda potpisivanje, ono što bi smo mi zapravo radili je potpisivanje inkriptovanje porake. Dakle, u koliku u tom slučaju takođe odlučimo da čuvamo poruku u plain textu da bi smo kasnije mogli da verifikujemo njen potpis, mi bi smo naravno morali da šiprojamo na identično način kao što je to bio slučaj, prilikom samo potpisivanje da bi smo mogli da verifikujemo taj potpis. A to bi značilo da moramo da čugamo identifikator algoritma za šiprovanje, da moramo da čuvamo i sam pljučku je koriščen za simetrično šiprovanje, što je veća policina podata koji se moraju čuvati zbog neke kasnije verifikacije. U tom smislu uvek nam je najbolje da radimo odpisivanje na cavom porukom, dakle nemodifikovanom porukom nad kojem nije primenje ni jedan od ovih drugih servisa, da bi smo prost uvek mogli da kada čuvamo tu poruku odmah direktno da prenad njom možemo da sprovedamo verifikaciju bilo kontranutkom. Ok, to je bio mali pocitnik, sad možemo da pređemo na sledeću funcionalis, što kao što sam rekao prekstavlja service kompresije. Dakle kompresije znate šta prekstavlja i ona ima generalno više namenu od kojih, dakle neke dve ostavne namine, su sa jedne strane naravno smanjenje u kupnog memorijskog za uzjeća takve poruke koje komprimovana. I su drugi strani, takođe, unošlenje neke, odnosno praktično, unošlenje određenog nivola tajnosti, što zapravo omogućevo da poruka nije više u nekom svom izbornom obliku, tako da se te strane, dakle, nema više svoju izbornu formu. I to su neka dva svojstva operacije kompresije koje stvarnam odnačuje, dakle, okviru ovog servicea. Što sviče same kompresije, dakle, algoritm koji se koristi je zip-algoritm. Videli ste okviru šema, da odde smo imali ono z, dakle, to nam je oznacavalo generalno algoritm kompresije, a sa druge strane smo imali naravno je equivalentan algoritm za dekompresiju. I u okviru prošloh časa je i bilo jedno pitanje koje se odnosilo baš na samu poziciju algoritma za kompresiju, odnosno zašto baš radimo kompresiju na tom specificno meskom. I odgovor ponovno dakle može da se poveže sa pozicijom algoritma za kompresiju u odnosu na podpisivanje. I sa druge strane sa pozicijom algoritma za kompresiju u odnosu na šitro. Što sviče, pozicije u odnosu na podpisivanje, dakle, ponovno možemo povlući na lelu sa onim što smo malo prereklja, što je opet svezano za sam algoritm šitrovanja. A to je da je nam vrlo često odznačuje da upravo čuvamo samu poroku, dakle, poroku u plain textu koji ćemo nekad kasnije moći da veritikuvamo zajedno sa nekim podpisom koji čuvam. I sa druge strane, okoliko, potpisujemo direktnu, dakle, nekomprimovanu poroku, isto to možemo naravno i da radimo. Sa druge strane, okoliko, prvo, primenjujemo samo funcionalnost, tudistno operaciju kompresije, pa tek nakon toga operaciju podpisivanja, jasno je dakle da za prover u samu verifikaciju podpisa, namo kasnije treba upravo tapo komprimovanu poroku. Okoliko, dakle, želimo iz praktičnih razvogu je da čuvamo poroku u plain textu i kasnije za verifikacije, onda naravno moramo raditi dinamicke rekombresovanje poroke.
 komprimovati svaki put kad oželimo da izvršimo verifikaciju na isti način kao što sam to malo preopisala za proces inkripti. Dakle, pokonom identično svar bio. Međutim, ono što može biti problem je što prosto algoritmi za komprimovanje nekada ne radu u potponosti deterministički odnosno mogu varirati u odnosu na konkretno implementaciju, odnosno verzi u algoritma. To naravno ne znači da vi upotrevom razvečetih verzija nekog algoritma nećete da je kompresijom doći do istih podataka. Koćete, dakle, inače, ja svo ne bi ste njih mogli da koristite na ovaj način algoritme za kompresiju. Međutim, može se desnit da sam komprimovanji podatak ne bude potpuno identičan u koliko se gobija kompresijom neki drugi verzije algoritma za kompresiju. To je nama naravno problem, u koliku radimo verifikaciju na takim podacima, zato što prosto ako očekljamo da imamo identičnj podpis, odnosno identični proizvod hash funkcije, onda jasno da moramo biti i imati identične podatke koji su na ulazu prosto u tu hash funkciju. Zbog toga se može desiti da mi oče ne možemo na ovaj način korektno da izvršimo verifikaciju takve borke. Sa druge strane, ako gledamo, odnosno poslutram opoziciju samu algoritma za kompresiju u odnosu na šifrovanje. Kao što sam rekla, druga namena algoritma za kompresiju je upravo umošlanje nekog nedeterminismo u samu poroku u smislu nečicivosti, poroka se ne nalazi u noj svoj inicijalnoj, osnovnoj form. Izbog toga na taj način se može i povećati kriptografska sigurnost, ako upravo ka ulaz neku algoritma za inkripsiju nema to ne plain text na početku, koji ste imali, već prosto imate na neki način obrađen taj plain text, recimo kompresiju. Zadošto, dakle kompresije će na taj način figuristati i kao sam neki algoritm šifrovanja, uslovno rečeno da tako kažem, gde prosto od neko količine podataka koji ste imali na ulazu, ako evo mi gleda plain text, prosto dobijete nešto drugo na izlazu, dakle kao neki blog podatak koji je zaminja nekim drugim blogom podatak. I onda jasno, ako mi je sada takva vrednost na ulazu neku algoritma za šifrovanje, onda ti ime prosto postižete bolju sigurnost samog algoritma. Dakle to je osnovna ideja, kako algoritm kompresije može uklicati na celu ovo šemu i zbog čega smo se prilikom desajna same šeme odlučili za poziciju kompresije, odnosno, da je kompresije u specificom delu ševe. Sleća funkcionalnost je email kompatibilnost. Dakle email kompatibilnost nam služi da prosto bilo kakva, dakle, poruka, odnosno poruka koja potiča iz bilo kakvog sistema elektronske pošte, da se može da se interpretira na potpuno identičan način. Što znači da je u principu, u koliko vi šajete, dakle, neku poruku, u koje ste između ostalo mogli da obezbedite i šifrovanj prenos, što, dakle, nije obavezna funkcionalisti, što ćemo videti na nekom osledaćih slajdova. Tako poruku se sastoji prosto od neke grupe baitova, koji, dakle, mogu biti, nekako, odnosno, mogu imeti nekakve vrednosti i baitova, u suštini, ne moraju se sastojiti i sklučivo danski tekst. Međutim, dakle, postoje neki sistem i elektronski pošte, koji dozvoljavaju i sklučivo formu aski tekst. I u smislu tom, dakle, da bi se prosto takvi poruke mogli prepoznati, interpretirati i dalje poristiti, onda prosto mora da postoji neki način konverzije u taj neki sistem, koji prosto može biti prepoznat od strane bilo kakvog sistema za elektronsku pošte. Za to koristimo neki algoritm konverzije koji se naziva Radix64 konverzija, a koji prosto, dakle, u te ulezne podatke, odnosno, podatke koji dobija posmatra kao neki tok baitova, odnosno, ovdje kaže, dakle, tri octeta binarnih podataka, ali octet kao grupa od osam bita, dakle, prestađu suštiti ki jedan bait, konvertuje u neka četiri jazki karakter. Odnosno, od neke grupe od tri octeta dobijemo zapravo neku grupu od četiri puta, takođe, osam bita i na taj način radimo prosto konverziju, nešto što može svuda da se interpretija. Datlove se konverzije se radima specifiča način i ono što se usput dodaje i neki kod za detekciju greša kao premisu, koji se zove cerce i koji prosto predstavlja, dakle, neki dodatno, neku dodatno, redudantno vrednost koje se dodaje samo od poruci, tako da na stanjih prijama može da se provori, i da li je možda došlo prosto do neke greške tokom premasa. Zad jasno da, ukoliko smo od neka tri octeta podataka dobili na kraju neka četiri jazki karaktera, mi smo povećali veličinu, dakle, same poruke i to jasno, za trećinu, ono inicijalne poruke, odnosno, za 33%. I ukoliko koćemo da procenimo sada koliko je upravo obezbeđivanje ovakve kompatibilnosti, naškodilo, dakle, samo i veličini poruke, možemo naravno doda posmatramo na samom porukom, pošto ve dodatne vrednosti koje se lepe na poruku koje se šalje, a to zapravo predstavlja, dakle, sesijski ključ koji smo videli šipro se lepe sa na samom poruku i dodatno potpis koji takođe predstavlja neku dodatno informaciju koji nije vezana zato mislim, dakle, nije sastelni ideo, one inicijalne poruke, odnosno, inicijalno plain texta koji se obrađuje. Za njih se može smatrati da su prosto u ovom turnutku namazane marljive veličine da bi smo diskutovali u smislu povećanjem veličine samog poruke, odnosno, promene veličine same poruke usled obezbeđivanja i mail kompatibilnosti. Tako da ćemo prosto videti kakavi je impact obezbeđivanja ove funkcionalisti nad samom poruku. Ukoliko smo rekli da se poruka dakle povećava za 33%, dakle onda jasno imaćemo 133 postpela, tako u kupne veličine same poruke. Međutim sva sreća imamo algoritm kompresije koji smo takođe predkod da implementirali kao service uokferu PGA. I koji nam dakle ovde u ove proceni kažemo da nam da skračuje veličinu naše poruke za 50%, i na ta način vidimo da na krajn korupku je smo povećali veličinu poruke uokferu obezbeđivanja ove kompatibilnosti, ipak i dalje imamo neku smanjenje poruke, odnosno neku kompresiju od otprilike 1-3. Što zdiča samog algoritma, odnosno na koji način on dadi, dakle nepostoji nikakavi vidi predprosesire. U smislu dakle da ukoliko prostu se već poruka se stoji od aski karaktera, odnosno aski teksta, onda nema potrebe raditi bilo kakvo kompatibilnost. Sveć prosto, dakle sve što se dobija na ulazu, kakogod tipa dakle bili sami podaci u okeru poruke, prevode se na osnovu radik spormata. I u tom slučaju naravno u pravo vršanjem ove konverzije. Ukoliko dakle je konverzija izvršena na celim blokom, odnosno i na samom porukom. U tom smislu dakle izloz neće biti čitljim nekom običnom posmatraču koji nema prosto PGP implementija. Sa druge strane, u koliku na primar se konverzija izvrši samo nad nekim hederom, recimo samo nad nekim potpisom poruke koji je pridružali podatak, onda dakle naravno poruka nije će moći da se verifi koja bez PGP-a, ali će moći da se čita i bez PGP-a pošto prosto dakle potreban PGP-protokol da bi se obezbedilo tako ovakom potibilnost, ako se ova transformacija nije izvršilo na celom porukom, onda jasno dakle može biti čitljiva u koliko naravno ove i takođe nije šikrovalno ili primenja na neka druga transformacija na celom poruku. Evo dakle, na ovdje imamo neki tok kontrole, što sviče obezbezivanje svih ovih functionalisti, gdje kao što možete videti, neke functionalisti su opciju, ne neke su obvezne i za početak dakle imamo u sa leve strane, dakle šemu koja opisuje diagrama na toka kontrole za slanje same poruke. Tako da na početku imamo poruku i u koliko dakle želimo da obezbedimo potpise za samo poruku, dakle to ono što radimo prvo i što ste već videli u samo i šemi. Generišemo neki potpis, što znači generišemo keškoj potpisujemo, odnosno šifrujemo i vezujemo ga za samo poruku. Nakon toga, dakle dolazi kompresija, videli smo kako izgleda obezbezivanje kompresije u potrebom zip algoritma. Nakon toga, u koliko je potrebno obezbedjeti tajnost poruke, to znači da radimo šifrovanje same poruke, što znači generišemo ključ, šifrujemo poruku, potom šifrujemo i samo ključ i tako kog kateljera, ono su spojene podatke, šaljemo dalje. Međutim, pre, naravno, slanja, dakle radimo konverziju poruke iz neku izbornog formata, premah radišu da se čatiri algoritmu za konverziju i takve poruka je na dalje spremna za slanje. Sa druge strane, na strani prijema, dakle potrebno je prosto da skinamo tu konverziju, odnosno da restauriramo poruku premah sistemu prijema same poruke. Zatim, naravno, ukoliko je bila obezbedjena tajnost poruke, odnosno, primenjeni algoritm za šifrovanje, jasno je da sada moramo uraditi i proces deshifrovanja, što znači...
 nače prvod doči do samog ključa, a nakon toga je dešli proveti poruku prema sistemu koji smo već opisali imitar. Nakon toga je naravno, kao što vidite, radimo sve ove koraki u potkuno obrnutom procesu, što je prirodno. Tako je tako da radimo dekom prešiju kao sledeći naš korak. I na kraju još ukoliko je bilo bezbeđeno potisivanje, sada proveravam odnosno verifico moj našu poruku, tako što dešli provemo sam hješ i poredimo dakle sa hješom primljenje poroke. I na kraju kada smo dobili našu poruku, naravno ukoliko je zadovoljila odgovarajuće proveri, tako poruku koristimo na već predvijen i način. Dobro, ono što je ostalo ko o poslednjoj funkcionalnost, koji je negde opisa na kao servis, negde ne u literaturi, zavisno toga našta nađete, je proces segmentacije. I proces segmentacije zapravo se na kraju sprovodi i prilikom slajnja, nakon što su sprovedeni svi prethodnih servisti koji smo opisali, zbog naravno prosto limita maksimalne dužine same poruke koje se može poslati od jedna. Tako da ukoliko je poruka naravno u svoje ukupnoj veličini prevazila zi tu neku maksimalnu dužinu, onda se ona mora podeliti i svaki taj segment se prosto nezavisno šaje. Ono što je jasno je da naravno na stanih prijeva takođe mora biti ovezbeđeno restauriranje poruke u nekom početunom poretku, kako je ta poruka naravno bila formirana, sprovedena kroz sve one servise, odnosno funkcionalnosti i tek nakon toga podeljena, znači mi naravno na stanih prijeva moramo restaurirati odgovarajući poredak samih delova poroke. Pošto poruka je dakle u potpunosti prošla kroz sve one funkcionalnosti, to znači da ukoliko je bilo ovezbeđeno potvisivanje poruke, ukoliko je bilo ovezbeđeno tajnost i u okviru tih funkcionalnosti bili dodati otakoni neki podaci, poput potpisa poruke i poput sezljiskog ključa. Javstvo da će su oni nalaziti samo jednom i da će to biti u okviru prvog segmenta, onda prosto preostali segmenti sadaržat će ostatak poruke. Na prijemnoj strani, naravno, prvo moraju da se skino sva zaglavlja elektronike pošte, kako bi se restauriralo dakle početni redos na samih segmenta, pošto tamo možemo imati dakle neke identificatore blokova i tek nakon toga, dakle je naravno moguće dohvatiti odgovarajuće podatke, primeniti one service u obrnotom poredku, već kao što smo videli malo pre, na ostavu onog diagrama toka kontrole koji se odnosi na prijem samih poruke i naravno na krajnji cilje. Tako da nakon svih funkcijonalisti prijenjanih, mi zapravo dođemo do same poruke na strani prijem. Ok. Dakle, videli smo kako izgledaju ostav de funkcijonalisti PGP-a, na kojim servicima se baziraju. I još jednom, dakle, videli smo da, akon svih tih servise mi se oslanjamo na neke algoritme, koji su, dakle, već poznati algoritme koji su nezavisno ispitani i koji su samo integrisani u ovaj protokol. Na dalje nastavljamo sa nekim detaljom i implementacije. Kao što videli ste, dakle, imamo prosto više nekih varianti ključeva, koje koristimo, tako da jasno, dakle da moramo imati neki način da koristimo sve te ključeve i da imo organizano. I u ovom turnutku ja ću propustiti reč Adrianu, koji će nastaviti da vam priča o različitim vrstama PGB ključeva i njihovo i upotrebi u okveru same še meme. Alamajo. Se čujem. A, čujem. Alam. Da, dakle, kašto je maja i rekla, sad prelazimo na ovaj neki drugi deo PGB-a, koji se tiče ključeva. Odnosno, sad ćemo rednom objasniti i odnosno ponoviti koje to sve ključevi za početek postoje u PGB-u. Zašto oni postoje i kako se generalno koriste i kako se nekako čuvaju u okviru PGB, odnosno, imamo razne neke zahteve koje treba da formulišujemo, dakle, kada pričemo ovim ključajima, pa prosto naradnih nekoliko slajdova, odnosno praktično, cijela vao prezentacija dokraće se baviti ovim ključima. Tako da za početak da se pocetimo koje smo to sve ključeve spominjali u okviru PGB, a čuli smo ih danas ponovno još jedno, kad je maja na početku, da kažemo, dradila nekora kapitulacija, ugradila od predhodne nedelje i videli smo da tu imamo nekoliko varijanti o njih ključeva koji se koriste. S jedne strane imamo ona i jedan one time ključ sesije, koji se koristi za simetrične algoritme, koji se koristi prilikom bezbezivanja tajnosti. Sa druge strane, prilikom i o bezbezivanja tajnosti, da bi smo kryptovali sam ključ sesijala, opet i za obezbezivanja autentikacija, imamo korišćenje parovo javnih i privatnih ključeve. To su ta tri ključa koja smo spominjali, koja smo videli da negde postoje. Postoje i četvrta vrsta ključa koja se koristi u PGB, u vidićemo malo kasnije gde se ona tačno koriste i kako funkcioniše, a to u suštini jedan ključ baziran na samoj lozinci koju koristnik unosi, koji služi za prosto manipulaciju nad nekim strukturama podata, kada ćemo čuvati te neki ključeve, tako da prosto vidjet ćemo kada stihnimo do tog dela kako se i gde se on koristi. Ono što moramo da obezbedimo kada pričamo ovim ključajima, je su ta neka tri sledeća zahteva. Prvo kada pričamo simetričnim ključajima, odnosno ovom one time ključu, moramo sigurno da obezbedimo da se ona nekako generiše na strani slanja poruk, jer tako je prosto svaki ključ za šifrovanje koji koristimo za tajnost, koristimo samo jednom što smo pričali prethodne nedelje, prosto je potrebno na neki načno bezbediti, da se ti ključevi generišu prosto na jedne predvijediv, a o petefika sa način, odnosno da tim generatorom i generišemo neki mis ključeva sesije i svaki ključ sesije koristimo vrlijekom jednog šifrovanja te neke poruke. To je prva neka tema koji ćemo pričati danas. Z druge strane kada pričamo o javnim i privatnim ključajima, ono što se sad tu postavlja kao pitanje, jeste šta se dešava u koliko neki koristnik ili niz koristnika želi da koristi više svojih parova javnih i privatnih ključeva. I razlozi za to mogu da budu razni. Dakle, sa jedne strane koristnik možda smatra da je neki njegov par privatnih i javnih ključeva kompromitevan, pa želi taj par da zameni. Ili, z druge strane, prosto želi da doprinese sigurnosti svega ovog, tako što će redom, dakle, uz nakon svakih nekoliko slanja poruke menjati svoj par privatnih i javnog ključa koji koristi, dali za obezbijivanje tajnosti ali optantikacije, znači nini bitno, u svakom slučaju on želi da prosto menja te svoje parove ključeva. Ili sa neke treće strane možda bi razlog korišćenja više svojih parova privatnih i javnih ključeva bio taj, što koristnik želi da komunicira sa različitim grupama ljudi, sa kojima ima svoju neku internu komunikaciju, tako da prosto jedna grupa ljudi zna za jednu verziu njegovih javnih ključeva, neka druga grupa ljudi zna za neku njegovu drugu verziu javnih ključeva, odnosno prosto ne želi da dozvali da prilikom slanja poruk je to jednoj grupi, eventualno ta druga grupa na primer može da tu poruku presretni pročite, zato što posiju do koristnikov odgovarajući javnih ključ. Tako da prosto to su nam neki razlozi zašto bi smo želili da obezgladimo koristniku da ima više parova privatnih i javnih ključeva. I naravno sad nam ovo donosi neke probleme koji se mogu pogledati sa neke dve variante, gde je prvi problem, nam praktično predstavlja kako mi sad da znamo prvo koji ključ je koristnik koristi od svih svojih parova privatnih javnih ključeva, da bi smo na strani prijama znali koji odgovarajući javnih ključ ili naš privatan ključ treba dopotrebimo, a sa druge strane moramo da znamo kako da identifikujemo te ključeve i kako prosto taj neki identifikator da prosledimo takođe na stranu prijama kako bi taj koristnik na strani prijama mohla da zna koji smo ključe upotrebedi. Drugi problem koji se tu javlja jeste da sada nekako kako je postoji gomila parova javnih i privatnih ključeva mi moramo dobezbedimo neki efika sa ni kompaktan način da prosto čuvamo sve te privatne javne ključeve, dakle što se nas tiče naše privatne ključeve, a i sve tuđe javne ključeve svih koristnika sa kojima komuniciramo, tako da prosto moramo dobezbedimo neku efikasmu strukturu koja će prosto čuvati sve te informacije i ključeve i te identifikatori, svaštvioš nešto što ćemo viditi. Tako da prvo što ćemo da spomenemo, dakle nekako ukratko jeste, kako se generišu ovi ključevi za simetrične algoritme koji se koriste za šifrovanje same poruke prilikomo bezbezvizivanja tajnosti, a onda ćemo nešto više pažnjno bespediti ovom drugom delu da vidimo kako sa jedne strane identifikujemo sada gomila u javnih i privatnih ključeva koja koristnik ima, kako se oni šalju kroz poruku, odnosno kako informacije
 o samom ključu koji smo iskoristili i da dostavimo na stranu prijama i sa treće strane da vidimo na kraju kako se sve to čuva kod svakog koristnika, koja je strukture podata kak koristimo. Tako da što se tiče generisanja ključeva sesije, dakle pošto se svaki ključ sesije koristi samo jednom i dakle šalje u sporuku na način koji ste već videli više puta, dakle i prošle nedalje i ove nedalje smo ponovili i onda nekako odvacuje i sledeći put, kad šaljimo poruku ponovog generišanog ključ, trebalo bi je bezbjediti naravno neki dobar algoritm za generisanju tih ključeva sesije. I suštini može tu da se opet koristi nekoliko različitih algoritama, ali recimo da se baziramo na K-128 algoritm, dakle bez nekoho umanjenju obštosti da vidimo prosto kako se pomoću njega koristi, tohce generišovi ključevi sesije. Dakle, ukoliko koristimo taj kast algoritam za šifrovanje same poruke, sam kast algoritam onda i generišete ključeve od 128 biti, odnosno on generiše neke slučine broje od 128 bita, kojo mi koristimo redom kao ključeve sesije. I sad sam ulaz u taj generator, dakle, ključeva predstavljaju osim samog ključa, dakle pošto je sam generator baš praktično taj kast algoritam, dakle, osim samog ključa imamo neka dva bloka podata ka P1 i P2, koji su veličine 64 bita. I koristimo cipher feedback mod funkcionisanja, da se sečete se da on nekako nam omogućava da za različite veličine tih delava poruke koristimo neki algoritm, kojem u opstom slučaju treba više ili manje podataka doprineti do algoritma. Tako da korišinjem cipher feedback moda funkcionisana, koji praktično od nekog inicijalnog dela dobija nešto što ksorojmo sa porukom i onda dobijemo cipher texta. Usećete pa onda prosto ta ideo ide dalje i tako dalj imamo neka šiftovanja, ako ne zna te poocetite se. Prosto stvara dva bloka, opet veličine 64 bita koje se konkateniraju i oni predstavljaju taj neki ključ sesije. Sami blokovi ulaza, dakle u algoritam, ti 64-obitni blokovi su dobijeni, tako što prosto korisnik na tastaturi pritiska tasteri, dakle neke proizvoljne tastere kako god želi kojem god brzinom hoće, na osnovu te brzine pritiska i samih karaktera koji se pritišču na tastaturi se formira neki 120-osmobitni slučajan broj, koji se deli u ta dva dela i praktično to nam predstavlja taj početni ulazni blok, odnosno ta dva bloka ulaza u generator i ta dva bloka ulaza u generator se kombinuju prvo sa predhodnim ključom sesije i na taj način dobijamo ulazni ključ samog generatora. I prosto ovo še ima je nekako dosta i efikastna koristi algoritm koji je tu već implementiran, al opet doprinosi nekako stvarnom generisonju tih slučajom ih nekih brojeva pa samim tim je efektivno nepradvidiva, ne može nekako na osnovu nekog naših predhodnog ključa da generiši nov ključ i ropšno slučaje on direktno zavisju tih tastaturi, dirkina tastaturi koja koristimo za generisonje sledačeg ključa. Dobro, to je to što se tiče simetričnih ključa, ja kažem sada ova druga tema koja se tiče javnih i privatnih ključeva i tu ćemo se više zadržati. Gde psa prostoposto postoji taj problem, kada smo u priču uveli više parova privatnih i javnih ključeva, kako identifikovati te ključeve? Jer bilo da pričamo o autentikaciji ili tajnosti, mi ćemo neki privatnih ili javnih ključ koristiti na strani slanja, a onda neki privatni ili javnih ključ koristiti na strani prijeva da ili deshifrujemo poruku pa koristimo privatnih ključ ili autentikuemo poruku, pa koristimo javnih ključ, to koristnika koji nam je poslava poruku, mi nekako moramo da znamo koji od svih tih ključeva koje poslava poruku posleduje iskoristiti da bi smo deshifruvali odnosno autentikovali samu poruku. Sad, prosto, ono što se predstavlja, to jest nam je čekao neko prvo rešenje jest da kao što smo sladi, o nej ključ ses i ovde šaljemo sam javnih ključ za šifrov koji korišće za šifrovanje zajedno sa porukom ili odgovarajući javnih ključ koji bi trebalo i skoristiti za autentikaciju koji je uparen sa privatnim ključem koji smo je skoristili opet nekako zajedno sa samom porukom. U plain textu s obzirom da je javnih ključ pa ne moramo prosto da brinemo o tome da će neko da presretne tu informaciju. Međutim, pošto, ovi asymmetričnih ključevi u opstom slučaju su dosta veliki. Dakle, rej sa javnih ključ pričali ste na predavanjima koliko bi samih cifara trebalo da posleduje, dakle u nekom brojnom vrednošću, da bi bio siguran da se sečete koliko je to nekako velika, velika količina podata, ka je bilo bi nekako neefika smo slati sam javnih ključ zajedno sa porukom, kao što to radimo za nekim mnogomanji simetričnih ključ sesiji. Tako da, što nam se naveće kao neku drugoj rešenje, jeste da prosto svakom paru javnog privatnog ključa dodelimo neki identifikator i možemo da tu priču prevedemo na priču da prosto ta identifikator, osim što je jedinstven, dakle, da ne mora da bude jedinstven nekako globalno, nego da bude jedinstvenan ivol koristnik, odnosno da nekako kombinacijom samog koristničkog imena, odnosno njegova nekoga ideja i idea tog ključa mi možemo da identifikojmo koji ključ treba iskoristiti. I onda prosto se priča svodi na to da ne šaljemo ceo ključ na stranu prijema, nego šaljemo prosto ta identifikator ključa na stranu prijema i onda ona i na stranu prijema nekako nosnogu identifikatora, znak koji je ključu potrebljen, iz te neke svoje lokalne strukture koje čuva ključeve i zabere baš o nekoj treba iskoristiti. Međutim, tu nam se stva javlja nov problem, a to je kako onda napraviti tu strukturu koja će prosto vezati ide i ključa sa samim javnim vjučom koji je upotrebljen, jer u suštini bi trebalo napraviti neku jako veliku tabelu mapiranja koji konkrata na ide, da kažem, veže u konkrata javni ključi. To je opet nekako nešto što ne bi možda bilo efikasno. Tako da rešenje koje se koristi u PGP-u koje je odabrano kao rešenje za ovaj problem, jeste da se ide i ključa bira, tako da on ima dosta veliki procena tšanse da stvarno bude jedinstven na nivou svih koristnika. Tako da praktično se od celog javnog ključa uzima poslednjih 64 bito, odnosno najmanje značenih 64 bito, odnosno nekako, pošto nama je javni ključ neka brojka, izračunam ostatek i videljenju sa 64. I praktično dobijemo te neke bite koje možemo da iskoristimo za prosto taj neki naš ID. Zašto kažem da ovo ne obezbeđuje prosto da su dva ključa različita, imaju različite ID-e, pa prosto može da se poklopi da njihojih poslednjih 64 bita identično, dosta je teško da će se to poklopiti, tako da ovo nešto što je prihvačeno u PGP-u i prosto se koristi za identifikaciju ključa u okviru, baš koristničkog ID-a, da klopiti na nivou koristnika. Dobro. I kažemo, ovo prosto se koristi u slučaju obezbeđivanja tajnosti, u slučaju obezbeđivanja autentikacijer, u jednom i u drugom slučaju nam je potrebno da znamo koje je ključ na strani slanja posla da bi smo mi odgovarajući privatni ili javni ključ na strani prijama i skoristili. Tako da sada kada smo videli kako možemo da identifikujemo same ključeve u PGP-u protokolu, možemo napokon da vidimo kako izgleda ta naša poruka nekako u detaljima, sama poruka koja šaljamo uz avisnosti od servisa koja smo odlučili da iskoristima. Dakle, sama poruka koja se šalje se u opstem slučaju koji li koristimo sve servise, sasto iz neka tri dela. Dakle, ovom prvom delu, mi imamo samo poruku koja ima svoje neko ime sam sadražaj poruke i neki time stamp koji predstavlja vreme kriranja same poruke. Ukoliko bezbeđujemo autentikaciju kao servis, naravno, na poruku se veže odnosno, kongatenira, one potpisk koji su dobija na već nadam se pozn...
 način koji se sastoji iz nekoliko delova. Dakle, prvi del koji smo do sada videli je svakako sam potpis. Dakle, to je ona potpisa na odnosno enkryptovanam hash vrednost same poruke pri čemu se hash vrednost same poruke im dobiha na osnovu samo poruke nego i na osnovu vreme na kreiranja potpisa. Zašto pa da bi se ne mogućili eventolni oni replay napadi u kojima ste sigurno pričali mnogo više na predavanju? Prosto na taj način osim same poruke nekako na potpis utiče i vreme nastanka potpisa pa prosto nekako se domogne poruke eventolno ne bi mogu da rekreira taj isti potpis u koliko z nasve ostali. Tako da prosto i taj time stem se šalje i učestvoje direktno u generisonju potpisa. Tako da prosto, to je nekad dodat na tu informaciji. Ono što nam je svakako sada potrebno, s obziram da smo mi potpis napravili našim privatnim ključem, jednim od naših privatnih ključeva, je ste da korisnik u nastrani prijema prosledimo informaciju koji naš javni ključ iskoristiti da bi se utentikovala poruka. I prosto rekli smo nećemo slati ceo ključ nego samo ID ključa i na predkonom slajdu smo videli da ID prosto poslednjih 64 bita tog ključa. Tako da se taj ID konkatenira u ovaj del potpisa same poruke i šalje na stranu prijema kao takav. I onda ćemo na neku naradnik slajdova videti kako se na osnovu tog ID bira baš odgovarajući javni ključ koji će sigurno i da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se da se samog korišćenja ključa ali sa druge strane i za proveru ispravnosti samog prenusa poruke. Dakle, da li je našto u prenosu eventuolo izmenjeno? E sad, treći deo poruke je vezan za sam deo koji ubezdeđuje tajnost. Dakle, tu smo videli već na predhodnim slajdovima Šta je sve od komponenti potrebno da šaljemo, dakle mi, enkryptovan, sesijski ključ, enkryptovan, javnim ključem primavca šaljemo upakovan zajedno sa porukom, ali ona što je dodatno sada kada znamo da može da postoje više parova javnih i prijatnih ključeva, potrebno poslati jeste informacija o javnom ključu koji je korišćen za prosto enkryptovanje samog sesijskog ključa. I taj ID tog javnog ključa koji smo izkuristili, ponovog onkateniramo na samu poruku ovom trećem delu i onda korisnik na strani prijema na osnovu toga ideja, opet vidjet ćemo kako, zna koji je javni ključ iskorišćen i onda u svojitoj neku istrukturih da čuva svoje ključeve, vidi koji je odgovarajući privatni ključ da iskoristi da bi prosto dekriptoval ova ideoporuke koji im se dohvata ključ sesije. Dodatno, ono što možemo ovde šemacki da videmo, jeste koji se delovi poruke zipuju, koji se delovi poruke šifruju i koji delovi poruke proleze kroz onu radiks konverziju i pošto smo više puta pričali u redosnoj do ovih operacija, znamo da se zipuje i zatim enkryptuje sesijskim ključem, deo koji je vezan za tajnost i sam deo koji je vezan, odnosno za fotpisi i sam deo koji je vezan za poruku, a onda nakon što se to enkrypto je sve zajedno, dakle sva tri dela poruke mogu da prođu kroz onu radiks, s 64 konverziju radi obezbeđivanja neke kompatibilnosti. Tako da ovaj nekako sad neki detaljni prikaz šta se ono i našaj poruci koje smo često vidjeli na predkonnim šemama, takšno nalazi od informacija i zašto koja informacija mora da se šalje u kom obliku. Dobro, da li imate ovdje neko pitanje s obzirom da je sada trenutak za pausu? Moš pitanje? Moš. Pa nimi ja sam zatvo sve ovaj radi x64 radi tek na kraju, ali su nimi ja sam svrha tog radi x64 obštrenu. I osato radi, zivno, osato radi da bi, u kogu nekam režno oprima stara pa ne može da u te fosam podrži, ja sam dobro razloba. Pa dakle radi se? Aha, čuvam se. Dakle radi se, to smo nismo ovdje nispominjali, to je Maja pričala, dakle zbog prostvog kompatibilnosti. Dakle sad ne znam da ste bili prisutni na ovom prom delu čase, da li može da Maja, može Polje da vam objastnije o ideju? Ja sam pričutan, nimi sam jasno. Vaš je pojenta da se radi nakon što se radi šifrovani, zato što se prosto očekuje jedan eksplicitan format onog nekoj proširenog ASI koda. Što nam može standardno samo da se pošeli ovečnalne poroka, zato mi se znašto se to rade? Zato što prosto postoje neki sistemi koji ne mogu da prepoznaju u bilo kom formatu poroka. Aha, znači zbog tova? Zato to je zbog specificno razvečitih sistema, od kojih neki prosto ne mogu da prepoznaju ove poroke u bilo korefor. I onda pošli se dokom šifrovanja, dakle to u principu može dobiti bilo kakav nijegih okteta, zbog toga se radi tako prevođenje, da bi se sigurno, dakle, poroka mogli interpretirati na bilo kakvom sistem. Ok, pala. Nemam te. Dobro, hvala. Le ima još neko pitanje. Dobro, ako ne imamo pitanja, idemo 15 minuta na pauzu, pa nastavljamo dalje da vidimo kako sad da čuvati ove privatne javne ključeve koje smo sad da naučili kako da identifikojmo. Eto, vidimo se sa 15 minuta. Pozdrav. Dobro. Ništa onda nastavljamo dalje. Dakle, videli smo kako se to generišo sesistki ključevi, videli smo kako se to identifikuju javni i privatni ključevi. Imamo poroku u četu. I videli smo kako sad da napokon izgleda nekako naša struktura poruke. I sad da ćemo da vidimo još dva konkretna problema koja postoje. Prvi problem kako čuvati sad sve ove ključeve. A drugi problem koji ćemo videti kasnije, jeste kako da uopšto bezbeđujemo razmenu tih ključeva kao jedan od najvećih problema generalno koji smo spominjali na ovom hursu, prosto ta razmena tih ključeva na sigura način. Dobro, što se tiče struktura u kojima se čuvaju sad ovisi naši skupovi privatnih i javnih ključeva. Prosto pošto se sada i u obezbeđivanju i tajnosti, autentikaciji koristi i u opštom slučaju više ključeva i u opštom slučaju videli ste da prosto kroz poruku te idejeve moramo da šaljemo. Prosto potrebna neka šema koja obezbeđuje da se ti ključevi nekako smestaju u neku strukturu i organizuje na neki sistematićan i efikasan način. Tako da prosto ovde i u PGP ideja, da mi vam o dve neke različite strukture. Jedna struktura koju nazivamo prsten privatnih ključeva u takvoj strukturi čuvamo i privatne i javne ključeve koje su vlasništvu baš nas kao koristnika. Dakle, vlasništvu tog nekog koristnika. Prsten privatnih ključeva je vezan za parove ključeva tog nekog konkretnog koristnika. Dakle, to je našto u nego omvičnom vlasništvu. Sa druge strane imamo i prsten javnih ključeva. To je jedna malo veća struktura, koja je prosto čuvamo sve parove, odnosno, samojavno, naravno ključeve, svih koristnika sa kojima smo nekada bili u komunikaciji i kojima želimo da komuniciramo, odnosno sve javne ključeve koje smo na neki način dobili od koristnika raznise, kojima želimo da komuniciramo, između ostalo g još neke.
 informacije. Pa, hajde prvo da malo prodiskutojmo da vidimo kako konkretno izgleda ova naša struktura prste na privotnih ključeva, kako izgleda struktura prste na javnih ključeva i kako se oni kombinuju uopšte u celoj onoj šemi koja nam obezbeđa autentikaciju i tajnost u sve one dodatne servise. Što se prste na privotnih ključeva tiče, dakle reklismo da je to prsten koju čuva naše ključeva koje smo mi generisali. Dakle, u paru javnih i privotnih ključeva. I od podatak, odnosno od bolje o toj strukturi, mi čuvamo, dakle sam javnih i privotnih ključ pri čemu se privotnih ključe enkryptojom videćemo zašto i kako. Naše koristničko ime pri čemu koristničko ime se ovdje dostavlja i ako prvo što pomyslimo, jeste da ovo bezpotrebno informacije privatnih ključeva, odnosno privatnih prsten ključeva je nešto što i direktno vezano za nasko koristnika. U opsem slučaju koristnički i i dije nekada, u glavnom email, samo koristnika i u glavnom se dešava da se ta email nekada prosto promeni i da mi za novo generisane privotnih njavnih ključeva želimo sad taj novim mail da koristimo ili imamo neki drugi razlog zašto koristimo više email adresu, dakle našu ličnu mail adresu, neko adresu na poslu i tako dalje, tako da taj uzera i dije prosto i za nas prosto može da ima različite vrednosti okviru tog polje. Sa druge strane imamo time stamp koji predstavlja prosto datom i vreme, odnosno kombinaciju datoma vreme nakada je taj par ključeva privotnih njavnih ključ generisani naravno ID samog ključa. Pričemo kada pričamo o ID-u, uvek pričemo o najmanje značenih 64 bita javnog ključa za taj neki ulas. Takli z nekog razloga nekada se dešava na kolokvijumima da prosto neko pomyslili da je ID u jednoj varianti, najmanjih 64 bita javnog ključa, drugo i varianti privadno ključa, ali uvek imajte u vidu da se taj ID šalje drugom koristniku na strani prijama, bez obzira da li on treba da autentipo je poruku ili da je dekriptuje, prosto na osnovu tog ID-a će onda nađe javnik ili privatni ključ koji treba da ih skoristim. Dakle, zašto bi smo mi u lovopšte slali ID nekog našeg privatnog ključa, dakle to opšte nema smisla. Sa druge strane, u koliko treba tom drugom koristniku da kažemo koji njegov privatni ključ treba da ih skoristi, prosto nemo način nikako da šaljemo ID, u koliko bi ID bio najmanjih 64 bita njegov privatnog ključa, jer prosto tu informaciju nikako neamo. Dakle, i da je ID uvek vezan za javnik ključ i predstavlja najmanje značenih 64 bita dog nekog ključa. Tako da ovako od prilik i izgleda neka struktura tog prste na privatnih ključeva sa svim informacijama koji se tu čuvaju. Sam ključ privatni iako je dakle ovaj cel prsten privatnih ključeva na našem računaru, naravno ima smisla enkriptova ti, da je to do radi predostrožnosti, dakle ako nekose domog na našeg računara, da ipak ne može iz ove kolekcija da izvadi naš privatnih ključ, tako da se on enkriptuje na neki odgovarajući način. I ono što treba još napomenemo, je s ove zvezdice ovdje koje stoje, dakle, zvezdice označavaju polja preko kojih možemo da indeksiramo jedan redu ovakvoj strukturi. Dakle, okoliko mi želimo dodohvatimo neki javnih ključ ili neki naš privatnih ključ, mi možemo te ključ da indeksiramo po njegovom id ili po user id za taj neki konkretan red. Što se tiče sami enkriptije privatnog ključa, dakle ona se obezbedžio koristićajom onog četvrtog ključa koji sam spomenuo na početku ovog dela sa ključu, ima to ona i Pats phrase ključ, odnosno ključ zastavano na nekoj lozinci, gde prosto ideje da mi sad zaštitimo dodatno taj naš ključ, ako ona našem računaru prosto tom nekom lozinku. Mi kako se to radi? Prosto korisnik unosi neku lozinku koju koristi kada generiša neki par privatnih i javnih ključeva i onda prosto ta lozinka se prosto provlači kroz SHA 1 algorita, mi zračunava se hashCode telozinke. Na osnovu hashCode telozinke sistem prosto šifruje sam naš privatan ključ koji želimo da čuvamo u našem prstannu privatnih ključeva, dakle ovdje graška treba da piša prstan privatnih ključeva i dalje, dakle prosto šifruje naš privatan ključ, koristeći hashCode kao ključ za cast algoritm, dakle prosto cast algoritm se koristi da šifruje naš privatan ključ, to nam je kao plain text koji šifrujamo, a za ključ samog cast algoritma se koristi hashCode od naše lozinke. Tako da svaki put kad mi želim da dohvatimo naš privatan ključ od korisnika se na računaru dodatno traži da unese tu lozinku, kada on unese uspešno, prosto, a uspešnost se nasličan način kao autentikacija ostvaru, odnosno ispituje, kada unesemo ispravnu lozinku i kada se poklope ti hashCodevi, onda prosto možemo da dekryptojemo taj naš ključ, dekryptojemo ga i prosto izlačimo taj ključ iz samog prstana privatnih ključeva. I ovaj jedna dosta onako efikastna še malo, njena sigurno se zasniva direktno, osim na algoritvima koji je su efikastni, direktno na samoj lozinci koji koristnik treba da unese i, naravno, ona treba da bude neprepoznatljiva, teška za pogadžanja, ali laka za pamćenje da korisnici ne bi prosto nekako zapisivali tu lozinku, na primer, pored računara, što onda totalno ruši celo ovo našu koncepciju. Dobro, e sada ovdje u naslu treba da piše prstenjavnih ključeva, to ćemo promeniti pa ćemo ažurirati prezentaciju. U suštini prstenjavnih ključeva je onako dosta malo veća struktura, pričemu se sad nećemo baviti svim, poljimo u samoj strukturi dok ne objasnimo kako sove strukture okšte koriste, pa ćemo posleda vidimo ova neka konkratna polja koju su vezana i neko poverenje u neki konkretan ključ. Sam ulaz u prstenjavnih ključeva je jedan certifikat javnog ključa koji osim svoj javnog ključa i njegovoj konkretnoj idea i vremena kada smo mi taj ključ primili od nekog korisnika, odnosno kada je taj ulaz u prstenjavnih ključeva jenerisan. Osim toga se vežu pošto o neki certifikat i podpisi na tom samom certifikatu. Okažem, ovaj ceo ovde deo, osim user id, koji opet nešto po čemu možemo da indeksiramo, u pitanju je prosto mail u glavnom ali može da bude i bilo kakav id vlasnika tog nekog javnog ključa. Pored toga imamo ova polja kojima ćemo se baviti kasnije. Ideja je ovde da mi nekako dobijemo javni ključ od korisnika s kojom želimo da komuniciramo i njega prosto unesemo u jednom red ovakve tabelo određenom trenutku i prosto čuvamo taj njegov javni ključ, čuvamo čiji je to ključ, dakle, odakle potekao i prosto koji je njegov id. Prosto kada korisnik autentikuje tu poruku da mi tačno znamo koji javni ključ iskoristiti da bi smo mi autentikuje tu poruku, odnosno on kada je potpise, ako prosto šifru je poruku opet nekako moramo da znamo koji ključ je on iskoristio pa po tome vucemo naš konkretan privatni ključ, isprste naprivatni ključ. Tako da i jedna i druga struktura se prosto, odnosno, dohvatamo informaciji strukture na sličan način, dakle li po juzera ideju ili po kija ideju vidjet ćemo še imama kad se koji tip indexiranja koristi, a prosto razlika je ta što se uprstveno privatnih ključova čuva informaciju našim parovima ključeva, uprstveno javnih ključeva su javnih ključevi, dakle, korisnika s kojima mi nekako komunicira. I sada kada znamo kako izgledaju te strukture, sada možemo ono celu kompleksmu šemu za autentikaciju i obezbeđivanje tajnosti na strani generisanja porukje i kastnima slečen slajdu na strani prijama porukje da vidimo kako se ti prstenovi uklapaju u šemu, kako se oni zapravo koriste. Ovej donji je deo već znamo, dakle sama poruka se na neki način podpisuje, prosto konkateniramo neke stvari, odnosno hešno poruku i to se sve šaljem. Međutim, sada pošto smo rekli da koristimo u ovom svom slučaju više paro o javnih i privatnih ključa, orekli smo da osim samog podpisa i same poruke mi moramo da prosledimo koristniku na strani prijama informaciju o tome koji smo mi privatni ključi skoristili. I taj ki ID treba da konkateniramo na samu poruku da bi...
 i po tom ki idiu, dakle naše javnog ključa koji je, da kažem uparen sa privetnim ključom koji smo skoristili, koristnik na strani prijema znao koji naš javni ključ da iskoristi. Međutim, kako se za početak uopšte sada generiše potpis? Dakle, pošto imamo više privetnih ključeva, potrebno je prvo nekako selektovat i koji ključ želimo da izgenerišemo po onom nekom idiu. Kada odaberemo koji ključ želimo da ne da izgenerišemo, da iskoristimo za potpisame poruke, onda nam je prosto PGB od nas traži da unesemo lozinku pod kojem se taj neki privatni ključ čuva. Tako da mi unosimo lozinku, lozinka se ponov, odnosno ponov prolaziu kroz hash funkciju, da bi prosto dobili ključ pod kojim je kryptovan naš privati ključ o nim kasta algoritmo. Mi sada koristimo dekriptio ni kasta algoritmo da sa tim ključem deshifrujemo ono što smo selektovali u ovom redu, a to je naš privatni ključ i kada da ga deshifremo, i onda imamo pristup našem privatnom ključu koji koristimo za prosto šifrovanje onog hasha i samim tim za podpisivanje naše poruke. Z druge strane, isto kada smo selektovali koji privatni ključ želimo da dohvatimo i skoristimo za potpis, odma iz tog reda izločimo i ID javnog ključa koji koristnik na strani prijema treba da iskoristi, a koji je vezan za naš privatni ključ da bi prosto autentikoval taj podpis. I taj ID kažem se nadovezo na poruku i sada se sečete prosto ona naša struktura poruke i onom nekom delu imala ID samog ključa pored podpisa i pored same podke. I tako podpisa na poruka se šifruje u koliku želimo da orazbeđemo i tajnos prosto nekim sesijskim ključom koji se generiše nekim generatorom slučenih brojela koji smo pisali kako funkcioniše i onda se tako enkriptovan potpisi poruka konkateniraju na enkriptovan sesijski ključ koji se enkripto je javnim ključem da ima oca, da bi samo primalac mogo da da ga deshifruje, a on se ponovog selektuje od svih mogućih javnih ključeva koje mi znamo za tog primalac. Odnosno prosto opet nekako po ID-u selektujemo jedan od javnih ključeva koji želimo da iskoristimo da bi ona i na strani prijema mogo da deshifuje poruku i taj ključ pošto ovo prsten javnih ključeva direktno izlačimo kao takav i koristimo za enkriptciju sesijskog ključa, a ono što na konkateniramo na poruku da bi na strani prijema se znalo koji odgovarajući privatni ključ treba da se iskoristi, jeste prosto ID tog nekog ključa koji smo iskoristi. I tako konkatenirana sad i poruka i sesijski ključ i ID sesijskog ključa, opet se sečete sa strukture da smo imali te dve dodatne stvari, prilikomo bezbeđivanja tajnosti u samoj poruci, šaljemo na nekim komunikacijunim kanalu na stranu prijema. Na strani prijema ponova se koriste prsten privatnih i prsten javnih ključeva gde sada ovo poruku prvo naravno moramo da deshifujemo. Kako je deshifujemo? Prosto sada smo prosledili ID ključa pod kojim se čuva privatni ključ koji je u paru sa javnim ključem koji smo mi iskoristili za šifrovanje samog sesijskog ključa s kojim smo dalje šifrovali poruku. Tako da bi smo deshifrovali sesijski ključ, mi izprste na privatnih ključeva moramo da izvucemo naš privatni ključ na strani prijema kojim ćemo da deshifruamo sesijski ključ. A da bi smo izvukli obšto taj privatnih ključ po ovom ID-u selektojmo prsten privatnih ključeva u kojem se nalazi i sad taj javnih ključ koji je obšto iskoristio, ali privatni ključ koji ćemo iskoristiti za dekrypciju. Naravno privatni ključ sam po sebi je šifrovan našom lozinkom, tako da opet kada primimo poruku da bi smo je otvorili od korisnika se traži da unese neku lozinku. Ta lozinka ponovoprolazi kroz hash da bi smo kreirali ključ za dekrypcijoni cast algoritam i onda se prosto ključ u kombinaciji sa enkryptovanim privatnim ključem provlači kroz cast algoritam i dobijamo dekryptovan privatni ključ koji koristimo da iz ovog drugog dela poruk je gde imamo enkryptovan sesijski ključ i izvucemo baš sesijski ključ. I kada smo izvukli sesijski ključ, ovaj treći del poruke napokon možemo da dekryptojemu i sada tu imamo samu poruku informacije o potpisu. Sad poruku možemo da čitamo, ali ukoliko nam je dodatno potrebna je autentikacija, potrebno je opet nekako ponešem je autentikovati poruku nosno u potpisa i sećete se da se to radi tako što se poruka ponovo provlači kroz hash i upoređu je sa dekryptovanim samim podpisom, odnosno samim dekryptovanim hash kodom. Tako da ukoliko su te dve vrednosti jednak je smatramo da smo ispravno autentikoli poruku, ali ono što se razliku ovoj šemi, odnosno, prethodne, jeste da sada opet pošto imamo mogućno zakorišćenje više ključeva za potpis poruke, imamo mogućno zakorišćenje više ključeva za dekryptovanje potpisa, tako da prosto moramo opet na osnovu ovog kija ideja koji smo prosledili, da izaberemo jedan od redova uprstenu javnih ključeva koje znamo za sve ostale koristnike i do odzvodatla izvučemo javnih ključ koji čije dakle par privatnog ključa koristnik izkoristio za potpis, da bi smo ovim sada njegovim javnim ključe mogli da deshifremo taj potpis i uporjedimo ga sa nologenerisanih hash kodom. Na taj način prosto se koriste na strani prijama privatnih i javni prstelnih ključeva. Dalje ovom trenutku imate pitanje, dakle ov je sad nekako kompletna napokon šema iz dva dela do duše, da je sad vidimo obezbeđivanje jednog i drugog servisa koji su naravno najvećeg značaja bez ulasku u detalje sa zipom i sa radiksom, jer prosto da istaj je stvar ovde, dakle ništo se dodatno ne menja, samo bi zip doša ovde i radik snegda na kraju. Tako da dalje imate neko pitanje ovom trenutku okolog? Dalje implementacija strukture prstenova specificira na PGP-om, u smislu niz, b, stablo i tako dalje, pa trebalo bi da jeste, nisam tačno sigur, a nao trebalo bi da jeste. Odnosno, mislim, specificirane opet verziom PGP, videćete, u stvari koji bude radi o projektu, na projektu će biti neka druga verzi, jedan open PGP, open PGP-verzi o PGP-a, gde se neke stvari možda nekako strugačije osmišljene, ali u suštinija mislim da bi u tom dokumentu trebalo da bude specificirano kako tačno izgledaju te strukture za svaku odgvarajuću verziu PGP. Sad nek nemaja isprav, jako nisam prav. Dakle, u pitanju je neka kolekcija i, dakle, kao što Aki reče, u pridzivu postoji format, kako me se, dakle, čuva u tom nekom, dakle, postoji format jasn prsten na ključeva i kako se, dakle, taj prsten eksportuje, odnosno, kako se čuva na svakom sistemu. Dakle, naravno, u skladu se tim, dakle, jasno, je definisena struktura pokoje se čuva zapravo, čuva je parovi ključeva, sertifikati, odnosno, ulazik koji generalno postoje uki stova. To je to dne. Pa hala. Dobro, još neko pitanjem. Dobro. E sad, kada smo videli, kako se konkretno čuvaju sami ključevi, postavlja se ponoposlednje i najteže pitanje, kako se uopšte obezbeđuje, da mi prosto čuvamo te informacije o ključevima na neki siguran način i kako prosto upravljati sa tom koleksijom ključeva, odnosno, kako obezberiti da smo u svakom trenutku sigurni, da ključeve javne od drugih korisnika koje imamo možemo da koristimo, da bi smo prosto šifrovali poruku ili nešto drugo radili s tim ključevima, odnosno, kako obezberđujemo da smo sigurni, da su to i dalje ključevi tih korisnika koji su, da je u svakom trenutku sigurni, da je u svakom trenutku sigurni, da je u svakom trenutku sigurni, da je u svakom trenutku sigurni,
 u tom konkretnom ulasu. Tako da prosto treba da razmatlimo sad a pitanje upravljanje tih javnih ključeva i PGP naravno pruža konkretnu strukturu za rešavanje ovih problema. Pri čemu nije definisana neka stroga šema, ali prosto definisani su neki pristupi za sigurnu razmenu ključeva gde naravno prvi pristup koji nam pada na pamet jeste da mi fizički preuzmemo ključ od korisnika B, u koliko želimo da mi kao korisnik A komuniciramo sa njim ili da verifikuemo taj njegov ključ putem telefona na primer da ga pitamo, da je to i dalje tvoj ključ, on njegov aj dije taj, taj, taj, taj, taj i korisnik B kaže, jeste to je moj. Mislim zašto bi smo to obšte radili? Pa zašto pa sečete semenin da middle napada da kde spominjalismo i na vežbama nešto ukratko, a svakako smo spominjali na predavanjima, odnosno ste spominjali, gde prosto mi u nekom trenutku ono što može da se desjeste da se između korisnika A i B nađe neki korisnik C, kojiće da nam podmetne nekako svoj ključ i mi ćemo pratično u našo istrukturu javnih ključeva čuvati ključ korisnika C pod imenom korisnik B i mi ćemo sve vreme misliti da je prosto to ključ korisnik B, tako da prosto sve što šifrojemo ćemo oči da vidi korisnik C, a z druge strane korisnik C ćemo oči da nekako forđuje odnosno podmetne poruke nama kao nekome ko komunicira sa korisnikom B, što će nama izgledati kao je došlo baš od korisnika B jer mi imamo prosto informaciju da je taj neki ključ vezan za korisnika B, a za korisnika C čak ni ne znamo. Tako da naravno ovo pitanje jako bitno i treba da se postavi i prosto PGP pužete neke pristupe za sigurnu razminu ključe, ali naravno poreda ova dva osnovna pristupa razmine ključeva koji nisu toliko tehnički uvijak izvodljiva, jeste da se prosto postoji ili neki uzajamno poverljiv korisnik D koji će nam služiti da nam prosledit ključeva koje želimo da koristimo ili one neki sertifikacijon i autoritet od poverenja koji od kog ćemo opet dobijati neke ključeve, ali ono našta se mislim zbog čega taj treći četvrti slučaj, ono s načemu se treći četvrti slučaj zasnivaju, jeste da prosto mi moramo i u jednom i drugom slučaju da imamo neko potpuno poverenja ili u tog treći koristnika D ili u taj sertifikacijoni autoritet. Tako da sama šema koji u PGP, da kažem, pruža za rešavanja ovog problema, je nešto što baš ličino ovaj treći četvrti slučaj da mi imamo nešto nekako poverenju nekog koristnika. Nemamo u suštini nekog postrednika izmađu nas, ali opet nekako svaki koristnik za sebe čuva jednu hierarchiju tih poverenja u svom prstenu javnih ključeva, tako da svakom trenutku tačno zna, da li da veruje nekom koristniku, da li da veruje da je neki ključ baš od tog koristnika i da li da veruje opšte u legitimitetu tog nekog ključa. Tako da slad se vraćemo na prsten javnih ključeva, da objasnimo ove dodatne komponente, odnosno, dodatna polja u samo istrukturi koju imamo. Čisto da bi smo schvatili kako sada prosto korišćenjem ovih poverjenja mi se obezbeđujemo da je ta razmena ključeva nekako legitimna sa naša strana gledašto. Ono što smo rekli, jeste da je svaki ulaz u prstenu prosto jedan certifikat od kojem mi čuvamo taj javnih ključi prilikom generisanja tog ulaza generalno u tom certifikatu može da bude proizvoljnjeno broj nekih potpisa koji su podpisali da je taj ključ, dakle, legitimat praktično. I u suštini tu postoji nekoliko sada ovih polja koji su vezana za tu neku, to neko obezbeđivanje poverje. Polje legitimitet ključa je polje koje direktno govori da je taj ključ legitiman ili nije, odnosno, govori, dakle, koji nivog poverjenja mi imamo da je ovaj ključ PUI u ovom redu baš ključ korisnika user i direktno na osnovu ovog polja legitimiteta ključa mi određujemo, da li ćemo opšte da šaljemo poruku koji ćemo iskoristiti ove javni ključi ili opšte nećemo to da radimo ili kada primemo poruku opet na osnovu tog legitimiteta možemo to da odlučimo. Dakle, prosto to polje nam jono od finalnog značaja, prosto, nosno u njega gledamo, da li verujemo da je taj ključ neči ili ne verujemo da je taj ključ neči i to polje se računa. Dakle, to polje ne biramo mi, nego PGP prosto izračunava to polje na neki odgovarajući način. A kako to polje se izračunila? Pa, pošto smo rekli da ovo certifikat idu u svakom jednom ulazu na taj javni ključ može da bude okačen proizvoljan broj certifikata. Za svaki taj certifikat je nakačen i nivopoverenja u tog koristnika koji nam je certifikoval ključ. Odnosno, podpisal ključ. I kada obijemo neki javni ključ, naprimer, ajde da nađemo neki primer. Naprimer u podpisima, evo, mi smo koristnik A, a u podpisima zove neki javni ključ za koristnika B se nalaze, na znam, CD i E. Podpis. Dakle, koristnici CD i E garantuju da ovo jeste ključ koristnik KB. Međutim, naravno, to što njih troje garantuna i da ih je milion da garantuju da ovo ključ baš koristnika B nama ništa ne znači, ukoliko mi ne znamo za te koristnika, odnosno, ukoliko ne verujemo baš tim koristnicima. Tako da uz sam potpis, se za svaki taj potpis nalazi neki nivopoverenja u tog podpisivaču, odnosno koliko mi i uopšte verujemo tom podpisivaču da sme uopšte da podpisuje drugi javni certifikat, odnosno koje je stepe našeg poverenja u to što oni kažu da ovo stvarno jeste ključ stvarno koristnika B. I ovo polje se takođe iz računava, dakle, malo jednostavnija, praktično ne računa se, nego se samo prepisuje, iz jednog drugog našeg polja u okviru prste na javnih ključeva, to je polje poverenja u nekog koristnika. To je ono, o čemu jedinom mi odlučujemo u celom ovom sistemu, neki PGP. Dakle, nama kad se pojavi neki nov ulaz ove prstenjavnih ključeva, dakle, to je neki nov ključ i neki nov koristnik, mi u tom trenutku određujemo koji je nivopoverenja u tog koristnika da podpisuje druge ključe. Dakle, mi možemo da verujemo nekom njegovom ključu, ali ne moramo da verujemo u to da on može da podpisuju druge ključeva, odmstno da verujemo u to što on kasnije kaže i obrano. Dakle, to je prosto nešto, što mi odlučujemo, dakle, taj neki nivopoverenja. I praktično za svakog koristnika u našeg prste na javnih ključeva mi određujemo taj nivopoverenja, osim za ključeva koji su direktno vezani za nas, a prosto taj nivopoverenja onda nekako ultimativan i prosto maksimalno moguć gde mi sami srebi sigurno verujemo. Okusmo mi reklji da ovo ključ stvarno jest od ovo koristnika, to je to, dakle, prosto zašto ne bi smo sebi verovali. Tako da za sve druge koristnike određujemo jedan od 3 stepena, odmstno, jedan od 2 stepena tog poverenja, ne, pardon, 3 stepena poverenja, gde možemo da kažemo da uopšte ne verujemo tom koristniku, da delimićno verujemo tom koristniku da podpisuje druge ključeve i da u potpunosti verujemo tom koristniku da podpisuje druge ključeve. Onda prosto kada najdžemo na ovako neki ulas B i vidimo da je on potpisan u strane koristnika C, D i E, prosto se u polja signature trust prepisuju polja owner trust iz ulaza za koristnike C, D i E. Dakle, ukoliko smo nekad komunicirali sa njima, za njih smo odredili koliko njima verujemo. Ukoliko takvi ulazi postoje, ta polja se prepisuju ovaj signature trust, a ukoliko ne postoje, recimo, sa koristnikom E nismo komunicirali, onda se prosto u signature trust piše undefined poverenje, koje označilo da prosto mi ninaznoma za pustanje to koristnika, tako da sigurnomo nećemo verovati, o koje možda on stvarno neki koristnik koji može u opštom sluči da se veru, ali prosto...
 tu to nećemo dula si. Tako da prosto svaki owner trust koji imamo za nekog koristnika postoju ovom skupu potpisanika, mi računamo njegov signočer trust, tako što prepisujemo owner trust za te koristnike i onda se nosnu u ovog signočer trusta prosto računa ovaj legitimitet ključa. Kako? Ukoliko smo mi jedan od podpisivača ovog ovde ključa. Naprimer mi smo fizički uzeli ključ od koristnika B, nači sigurni smo u njega, pa smo ga i podpisali, onda prosto odma ovaj legitimitet ključa je postavlja na vrednost ču. Dakle prosto verujemo tom ključu sigurno, dakle jer smo ga mi podpisali. Ukoliko nismo, onda se legitimitet ključa računa, tako što je prosto potrebno X koristnika kojima potpuno verujemo ili Y koristnika kojima delimićno verujemo da postoje u ovim povirenjima u potpisanicima, da bi prosto legitimitet ključa bio postavlja na ču. Odnosno za svakog koristnika kojem potpuno verujemo, imamo težinsku sumu od 1 kroz X, a za svakog koristnika kojem delimićno verujemo, imamo težinsku sumu od 1 kroz Y i za sve koristnike koje imamo ovde, osim za undy find, saberemo sve te sume, dakle prosto saberemo sve te težinske sume i ukoliko su te težinske sume veće ili jednak je od 1, dakle nekakva u kombinaciji dođemo do keca, onda se smatra da prosto mi u potpunosti verujemo legitimitet v tog ključa, dakle verujemo da to jeste ključ baš tog koristnika B, o kojem sve vreme pričamo. Ukoliko je ta izbir težinskih suma manji od 1, dakle ne manji jednak, nego manji od 1, onda se legitimitet ključa postavlja na vrednost false, odnosno mi ne verujemo da je prosto to ključ baš tog koristnika u tom ulazu, ker nemo možemo dovoljno potpisa kojima verujemo da bismo tako nešto rekli. I taj legitimite se kažem računa automatki u PGP-u. I onda ukoliko su x, y, neki parametri a jesu koje mi konfigurišemo, dakle u sistemu, recimo x je 2, y nije 3, to znači da su nam u suštini dovoljna dva koristnika kojima potpuno verujemo da bi mi prosto rekli da ovaj ključ legitiman jer 1 kroz 2 plus 1 kroz 2 je 1 ili 3 koristnika kojima delimićno verujemo da bi smo rekli da ključ legitiman ili neka kombinacija, naprim. 1 koristnik kojima potpuno verujemo i 2 koristnika kojima delimićno verujemo jer će zbiri težinskih suma za te koristnika biti 1,5 plus 2,3 da je što je sigurno već je od kjeca. Tako da prosto nosimo u toga računamo legitimitet ključa. I sad ova sve tu opisano na ovom slajdu. A ono kako sad napokon možemo to da prikažemo nekako šematke u vidu ovog nekog stabla podpisivanja, gde u vrhu stabla se nalazimo mi. U ostalim delovim, ostalim čvorima stabla se nalaze razni neki koristnici odnosno njihovi ključevi i svaki u tih čvorova ima neku svoju oznaku. Oznaka, da kažem skroz bjelog čvora, znači da mi praktično u opšte ne verujemo tom koristniku da podpisuju druge ključeve. Oznaka dakle polu popunjen kao a, b čvorovi, polu popunjen koristnik u ovaj kružić znači da mi praktično delimićno verujemo koristniku a ili koristniku b da dalje podpisuje druge ključeve, a potpuno, dakle potpunosti i polu popunjen kružić kao što su koristnici D, E, F i L, to znači da mi koristnicima verujemo da u potpunosti da mogu da podpisuju druge ključeve. I konačno mi ovde kao glavni koristnik, pošto maksimalno verujemo sebi, smo popunjeni, dakle ovom sivom bojemu potpunosti, imamo još jedan dodatni krugo kojna, što znači da prosto je to koristnik koji ima neko ultimativno povrenje u kojeg imamo ultimativno povrenje jer smo to baš mi. I sad na ovom konkretnom primjeru parametri X, Y su jedan odnosno dva, znači potreba nam je i dovoljno nam je jedan koristnik kojem potpuno verujemo da bi za ključ neki od rekli da je legitiman, odnosno dva delimićno poverljiva koristnika da bi smo rekli da ključ takođe legitiman. Sam legitimitet ključe se označava tačkom gde naš ključ sigurno je legitiman, a potpis samog ključa se označava ovom strelica gde strelica od jednog ključa ka drugom ključu, znači da je ovaj ključ, kod kojeg je strelica, podpisao one ključ od kojeg strelica započenja. Tako da na ovom primjeru vidimo nekoliko stvari. Mi smo podpisali kao koristnik ključeve A, B, C, D, E i F. I pošto smo ih mi podpisali, sam ona i vrednost podpisa, odnosno poverenje podpisa, sigurno je odma jedan jer mi sami se bi verujemo maksimalno, pa je legitimitet ključa postavljeno vrednošu što se označava o ovom ovdje tačkicom usredin. Dobro. E onda kada smo uneli te koristniki A, B, C, D, E i F u naš prstenjavnih ključeva, mi za njih biramo odnosno postavljamo koliko njima verujemo da dalje podpisuju drugi ključeve. I recimo da smo za koristniki D, E i F odlučili da im potpuno verujemo, dakle obojili smo te kružiće maksimalno, za koristnike A i B smo rekli pa delimčno im verujemo, a za koristnika C smo rekli da uopšte ne verujemo tom koristnika. Onda na dalje vidimo da kada nam u naš prstenjavnih ključeva, naprim. dođu nekih ključevi I, I, K, koji su podpisane od strane koristnika koji ima ključ kojeste legitiman za nas, ali ne verujemo njemu da smeda podpisuju druge ključeve. Vidimo da ove ključevi I, I, K neće biti legitimi za nas, dakle nema joj onu tačku odnosno mi nećemo znati, smatramo da ne znamo da ali je to baš njiho ključ ili se tu potkravu neki men in the middle. S odrugje skrane, naprim. u koliko u prstenu nesemo ključ L i u njegovim potpisima nađemo samo ključ D, odma znamo košto je D nešto, ko me potpuno verujemo da prosto je ključ L legitima, jer je prosto tako izabran parametr za X, dakle jedan kroz jedan je već jednakod jedan, tako da ključ L jeste legitiman i onda za njega kao legitimon ključ biramo ponovu da li njemu verujemo ili ne verujemo. I sad u praksije naravno da ovo poverenje, pošto mi direktno nismo popisali koristnik, kao ne bude baš ovde potpuno kao što smo ovde potpunili, ali ovo je prosto neki pokazni primvijed, da smo mi rekli, pa i koristniku L u potpunosti verujemo tako da ključevi P i Q koje on podpisav će takođe da budu legitimi. S druge strane ključevi M, N i O koji su potpisani u strane koristnika E kojem takođe potpuno verujemo, su takođe legitimni, a onda napr. ovaj neki ključevi, ovaj neki R koje potpisano strane ključe koje jeste legitima, ali mu ne verujemo, nije legitima. Dakle ključer nije legitima, ne vidite da on potpisano od strane još neka dva izvora, dva ključa koja mi opšte ne znamo koji su odnosno nemamo ih u našem prstenu ključeva, pa prosto njima dodeljemo onaj undefined signature trust, pa prosto sa time ne radimo nikak u težinsku sumu odnosno i gnorišemo takve ključeva pri likom računom. I poslini što možemo da vidimo, jestan napr. ovaj ključ H on je potpisano od strane dva ključa kojima delimićno verujemo, či su težinske sume jedna polovina po parametrimu koj smo goredi finisali, tako da ključ H jeste legitiman, s obzirom da je u zbiru težinska suma svih potpisanika veća ili jednaka od jedan, tako da ključ jest legitiman. Sa druge strane ključe K koje je potpisano od strane delimićno poverljivo ključa A, nije legitima njeri njegova težinska suma u zbiru jedna polovina, plus pa ovom ni ne znamo da verujemo i ne verujemo, pa je to plus nula, tako da ukupno jedna polovina, što nije dovojno da kažemo da ključ K je legitiman. Dobro. I poslenje, o čemu možemo da prodiskutom, ukratko, jeste povlačenje javnih ključeva, dakle, u koliku u bilo kom trenutku poželimo da promenimo svoj ključ, ili prosto mislimo da je ključ naš kompromitovan, pa želimo da zamenimo par javnih i privatnih ključeva koji mi koristimo, mi moramo, osim što generišemo nov par privatnog javnog ključa i prosledimo to svim koristnicima sa kojima komuniciramo, da povučemo taj naš javnih ključ. I u ropstvim slučaju, dakle, svi drugi koristnici moraju da znaju da je naš ključ možda kompromitovan jer su komunikaciji sa nama, tako da mi prosto moramo da pošaljemo jedan poseban sertifikat koji ima...
 ima i stu formu kao normalnih certifikat, ali ima jedan flag koji govori da je prostup namin o tog certifikata da se povuče nek jawni ključ i onda prosto taj vlasnik šalje taj certifikat na što više mesta, odnosno na sva mesta svih korisnika s kojima komunicira da bi oni ažurirali svoje prste na vej jawnih ključeva i rekli ja više ne verujem da je ovo ključ olog korisnika, prosto odmastavljam onei flag legitimiteta na false, zato što prostom je baš taj korisni krek, kao da je možda ključ kompromitovan ili želi da ga zameni u svakom slučaju povu ko ga je i uskora će mi poslati novi ključ koji ću ja tamo da obeležim u svom prstenu jawnih ključeva. Dobro, dali imate neko pitanje o ovom trenutku? Ovim bi smo praktično završili PGB prezentaciju pa ćemo sljedeveće ne da ljede raditi s-mime koji smo ispomenuli na početku PGB, dakle to je nešto još nešto što se koristi u zaštiti elektronski pošte, pa prosto na zanima dalje ovom trenutku imate pitanje što se ove elekcije tiče. Dobro, što se esi smera tiče, praktično ova prezentacija, odnosno PGB sam po sebi jeste tema i prošlo godišnjega, biće tema i ovog godišnjegu projekta, tako da ovo nešto što bi trebalo da razumete u potpunosti, projekto ćemo naravno pričati neki drugi put, dakle verotno ćemo organizovati poseba neki termin, samo za projekat, da vidite kako se on organizu, kako se radi, ali je to čisto da znate prosto da je tema PGB, pa prosto da znate da ovo treba da proučite malo više. Ako nema nikakvih pitanja onda bih ja ovde završio časa, ali imamo jedno pitanje. Šta može da se očeku na kolopu ima za logoritama RC4, Cha, Cha i Salsa? Dalje može da bude zadatak da se neki stream šifroje i vi samo teorijski da se crtaju še me pitanja u vezi toga. Pa mislim u suštini sve što smo pričali može dodoći. Pa isto kao što ste i na labovima imali šifrovanje u ZDES, ESDS i ASES, ASI što smo imali na labovima i tako može dodoći za dataki z ovih algoritama koje ste naveli. Dakle, i teorijski naravno i šemacki da nacrtate, odnosno da vas pitanje na što sa šeme ali da se nešto šifroje. Dakle da. Na naravno nekom pristenom količinom podata kako možete da uvradi u realnom remu. Naravno, naravno. Dakle, nika isto kao i za desnika nećemo dati DES da prođete ceo, dakle to će da bude onda ili neki desa, čisto da vidimo da se to razume li ili ona pojednoostavljena verzija, dakle isto i ovdje ili neki desa algoritma ili nešto da smislimo pojednoostavljeno, dakle prosto može u tom obliku dodoći. Nemam na čemu. Još neko pitanje? Dobro, ako nema nikakvih pitanja, to bi bilo to za dana, pa se vidimo nekom drugom prilikom. Pozdrav. Cao svima.
