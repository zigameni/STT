 Generisanje koda u compilerin. Ulaz u generator koda je među kod programa izlaz je mašinski kod za ciljno mašinu. Moguće variante izlaz za su absolutizovan i mašinski kod, zatim objektni kod, okome je više detalja data u predmetu sistemski software, asemblerski izvorni kod ako i izlaz potom ide u assembler. Za ovu lekciju ciljna mašina će nam biti Potskop X86 assemblera, radi su od dvoj adresne mašini, asemblerske naredve su oblika operacija i onda argumenti su odredište i izvorište. Takva naredva ima značenje da je rezultat ide u odredište, a izvorni operandi su prvi, je isto dat tim odredišnim operandom pa operacija pa izvorišnj operand. X86 ima to ogrančenje da istovneveno nemogu i izvori i odredište biti memorijske lokacije, jedna od te dva operanda mora biti u registru. Operacije će za naše potrebe biti neke osnovne aritmetičke sabilanje od uzljonja množenje deljenje i takođe kopiranje vrednosti izvorište u odredište. Množenje deljenje do neklesu specificne, zato što zahtevaju da se koristi par registrajo. Kod množenja, znači rezultat množenja ide baš u registre gorenji deo u DX, pošto biti nju 16 bitna mašina, znači rezultat je 3 zvobični, a izvorišni, znači prvi operand i uvek fixno AX, zama se zade drugi operand. Što se tiče deljenja, znači tu je deljeniku paru registra da je x AX, zade se delilac A, rezultat fixne ide u AX. Dok ostatak pri deljenju ide u registrat DX. X86 ovo koji mi razmatramo, ima 4 registra opšte namene AX, BX, CX, CDX i index na neke koji imaju neke specificne namene S, ID i BP. Adresiranje na nivog byte, to memorisko reće 2 byte, u našim primenu nasvi operandi rezultati operacija je će biti 16 bitni. Što se načina odresiranja tičova, tabela nam da je gratko pocećanje, imamo memorisko direktno odresiranje, to je stavlutno gde se adreso zade, kao neka memoriska lokacija, zatim registrskog D je operan zadat, znači registra koji se koristi, indexno to je vrednost registra plus minus, neka konstanta, se koristi kao pokazivač, u memoriju D smešten operan, zatim registrskog indirektnotu nema konstanta, nego samo vrednost registra je pokazivač. U memoriju i neposrednog deso zade, konstanta C. Kod registrskog indirektnog adresiranja mogu se koristiti samo registri, ovini navedeni BXSEDI kod indexnoj samo registri BXBPSEDI. E sad nešto opšte o funkcijama generatora koda, prva važna funkcija je izbor, na red bito je smapiranje među koda u mašinski kod, u ovj funkciji podrazumeva se fiksiranje na nomapiranjem promenjivih u memoriju i neogranićem broj registrata to se rešava, kao posebom problem, ovdje je fokus na izboru operacija i način adresiranja. Druga funkcija generatora koda je rasporedjivanje na red bito, odnosno instrakšnog scheduling, tu se radi promena red osreda na red bito da se smanje kašnjenje upotreba registrara i tome slično, podrazumeva se fiksirani program, to jest skup, instrukcija tu, igraju u logu i hardware-ski elementi kao što je pipeline i slično. Treća funkcija generatora koda je dodela registra, odnosno alokacija, što je odlučivanje o mapiranju promenjivih u memoriju i registre procesora. Znači tu je moguće privreno deljenje istoj lokaciji od strane više promenjivih, pošto su registri procesora, scarce, odnosno redak, resource. Ono što komplikuje problematiku, to je da ove tri funkcija ne mogu nezavisno da se rešavaju, nego su tessno povezane. Možemo sagledati samo neke probleme generatori, koda ako se to me pristupi su više naivno. Rećemo ako imamo dve naredba, jednako b plus c, d jednako a plus e, i ako odpunno nezavisno za ovu prvu naredbu, izgenerišemo to su ove prve tri naredbe, asembrarsko koda da u registra A x dovedemo b, da dodamo na to c i da onda u memorijskoj lokaciji a zapamtimo rezultati na sličan način, a ova druga naredba se rešava sa donje tri, odmah ćemo uočiti da u kompletno generisani sekvenci koda imamo, nepotrebno pamćenje, naravno pod predpostavkom da nam a, kasnije ne treba, nepotrebno se beleži a u memoriju i plus, naravno to je možda i potrebna instrukcija, ali naravno pošto vrednost a i dalju registra A x, ova druga instrukcija dovođenja, znači ponovog vrednosti A u A x je potrebno, puno nepotrebno u svim scenarijima, a ova prve nepotrebna ako nam a dalje ne treba. Drugi problem je problem izbora naredbi, recimo nekakav izraz ako program je napiša A1 kva plus 1, svakako može da se prevede recimo na x86 assembleru ili kao inkrementiranje vrednosti A, ili znatno komplikovanje sa tri naredbe, znači da se dovedao u A x, da se u potrebi sabiranje sa konstantom 1 i da se ponovog A, smešta o A x jasno je već intuitivno da je ova sekvenca manje efikastna od ove prve, za uzima i više memoria i potrebno je veće vrema izvršavanje. Sledaći primer je problem dodale registra promenivim, odnosno izbor skupa promenivih koja će biti u registrimu, dato i tački izvršavanje programa, što ima neposredan odraz na efikastno skoda, odnosno broj pristupa memoria jer je pristupanje registrima neuporedivo koca vremenih procesora efikastnije nego pristup memoria. Vrešavanje ovoga problema je eksponencijno zavis od broja promeniv, dokaze se problem mp kompletan i onda naravno se daju neki suboptivalni algoritmi koji mogu da efikastno urade alipu, znači vidi se da je to složen problem. I ćemo ilustrovat klasično generisanje koda, algoritmom iz knjige A, H, L, M, C, U, L, S, P, T, C, T, U, Z, poznatom D, B, koji je zadao jedan vrlo jednostavno algoritm generisanje koda koji radi na nivog i jednog u bazičnom blokom. U prvom koraku togo algoritma, nači kao predusov za primeno samog algoritma, određuju se informacije o životu i sredećem korišćenju za svaku pojav u promenivih u bazičnom bloku. Da definišemo te pojmove, promeniva X je živo u iskazu I, programa, ako postoji putanja od nekog iskaza J, po koje se X ne menja, a o iskazu J od promeniva X se koristi ka operant. Tada je iskazi od predstavlja sredeće korišćenje promeniva X, usuprotnom za promenivih se kaže da je mrt. Kako ćemo izračunati ove informacije o životu i sredećem korišćenju u promenivih? Ako se nevarši globalno analiza na kompletnom grafu toka kontrole, konzervarativna predpostavka je da su na izlazu iz bazičnom bloka sve koristničke promenive žive, a pri vremene promenive mrt. Izuzeneci su naravno ako je blok u petlji, a da je index petlji neka privrena promenive implicitan. Ali to je da kažem neke specijalni sluče. Ove informacije sačuvam u tabeli simbola za svaku promenivu to je jedna posebno abstruktura koja nam samo treba za izračunavanje ovih informacija. Zvaćemo je tabela simbola za što za svaku promenivu čuva tu informaciju. Konzervarativna predpostavka znači da naš hod će funcjalno sigurno biti ispravan, a može biti neoptimalan. U drugom koraku znači primenjujemo sam algoritam, izkazi u bazičnom bloku uvrađu se redose dom od poslednje ka prvom. Kada najdžemo na i tu, pošto je u pitanju, kod u obliku četvorki, na i tu četvorku x jednako y opc. Iz tabele simbola prvo treba pokupimo informacije o x y i c, i prikačimo i to je četvorkci. Zatim u tabeli simbola ažuriramo da je x mrtvo, jer to što stavljemo tabelu simbola, pošto idemo u nas adkroz kod, znači važi će preo ove na redb xa koja u x ima dodelu ovdje, više ta stara vrednost koja je došla do ovog trenutka, ovdje znači ova dodela x ubiatu staru vrednost. Tako da žuriramo da je x mrtvo i nema sljeće korišćenje, a za y ceta žuriramo da su živi i da imaju sljedeće korišćenje baš u i toj naredbe. I ilustrovaćemo algoritm na jednom konkretnom primjero, recimo da je u izvornom kodu zada tova koneka naredba dodela s neki kompleksnim izrazom. Danimo u medju koda moglibismo ove izraz predstaviti s ove četvorki, znači prvo izraču da imamo ovaj minus b, dodalimo nekoj privreno i promeljivo i t, zatim izračunamo ova minus c, dodalimo nekoj privreno i promeljivo i u ako uočemo da postoje zajednički pod izraz i ne moramo to 2 put računati nego saberemo, znači ova ideo dobijamo v i konačno kad saberemo taj medju rezultac o ovim prvim t dobijamo finalno znači ovo je koristica promeljiva d. I sada treba da izračunamo za ovu sekvencu medju koda informacije o životu s lećem korišćenju moramo uvesti tabelu simbola sa svim znači prve četvri su koristničke promeljive, ove druge tri su privrevene promeljive i početno stanju tabeli simbola odgovara tački izlaza iz ovog bazičnog bloka i rekli smo po konzervativne predpostvici sve koristničke promeljive su žive, nemo informacije o slećem korišćenju, to je negde u nastavku programa ali nama je fokusamo na ovom bazičnom bloku a privrevene promeljive su mrtve jer ih je kompajer uveo tako da znamo da sigurno van bloka neće više biti korišćene Kret ćemo od poslednje četvoreke kačimo ono što trenutno piše za svaku pojavu promeljive u četvrtoj četvorci, iz tabele simbola kupimo trenutnu informaciju, znači da je dživo, a u ive su mrtvi.
 taj podatak za 4 četvorku i potoma žuriramo tabelu simbola da je D mrtvo a V i uživi sa sredećim korišćenjem u 4 broj 4. Time smo završili s ovom poslednjom četvorkom, prelazimo na predpositiv. Z tabele simbola izvlačimo trenutne informacije o V, T i u. Da je V i u živo sa korišćenjem u 4 taj je još na inice informacije da je mrtvo. Sada žuriramo znači da je V mrtvo a T i u živi sa sredećim korišćenjem u 3. Prelazimo na drugu četvorku, izvlačimo informacije o U, da je živo u 3, A i C da su živi, ali ne znamo gde je sredeće korišćenje. A žuriramo tabelu simbola da je u mrtvo, a A i C živi sa sredećim korišćenjem u 2. I konacno prelazimo na prvu četvorku, i stabele simbola, kaj ćemo da je T živo sa sredećim korišćenjem u 3, da je A živo sa sredećim korišćenjem u 2, da je B živo, ali ne znamo gde je sredeće korišćenje. I sad žuriramo da je T mrtvo, a da su A i B živi sa sredećim korišćenjem u 1. I ovo je u jedno finalni rezultat, znači anotirali smo sve promenjive koje se pojavljaju u medju kodu, a ovo je finalni sadrža ove tabele simbola odgovara stanju na ulazu u bazični blok. Pre nego što pređemo na generisanje koda, da su poznamo sa strukturama podataka i samim algoritmom, generator koda koristi deskriptor registra za svaki registar i deskriptor adresa za svaku promenjivu deskriptor. Registra sadrži spisa ki mena promenjivih čije vrednosti se nalaze u pojedinim registrima i na početku bloka uvek podrezumimo da su registri prazni, znači za određan registra, ax tu mogu biti na primoru nekonternutku u vrednosti promenjivi hb, ic, zašto može više od jedne promenjive, pa jasno da su dopostojone naredbe do del x, jednako y njih, tako da jedna vrenos može da se odnosi na više promenjivih. Deskriptor adresa pokazu u kojim sve registri ima i memorijski lokacijama se nalazi vrenos neke promenjive. Na početku bloka sve korističke promenjive su memorijs, znači to je isto predpostavka između blokovada, i u nekoj memorijski lokacije ćemo oznacati imenom promenjive pa ova oznaka prim, da nam sugeriše koje promenjive ide rečo memorijski lokacije. Sam algoritm generisanja kod, formuli sanje za pojedinačne ove četvorke, znači recimo ita četvorke, znači u nekoj memorijski lokacije, znači u nekoj memorijski lokacije, sam algoritm generisanja kod, formuli sanje za pojedinačne ove četvorke, znači recimo ita četvorke, x jednako y opet set. Prvo postoji posebno delo algoritma odvenu ove podpruvan g-track i djegovu zadatak je da odredi lokaciju za destination, to je lokacija l, u koji će biti smešan rezultat x. Ta funcija g-track samo ime kaže preferentno vraća registrar, a ređe fizičku lokacija operativne memorije, vidjet ćemo kasnije detalje, pošto je taj destination u jedno i levi operant, ako levi operant y nije u l, onda se generiše priprem na mašinska instrukcija dovođenja u l, znači toga y, gde je y prim tekuća lokacija za y, ako možete izkoristiti registrar bolje registrar, ali ako nije registrar, onda može i memorija. U trećem koraku generiše se sama mašinska instrukcija, prema či ob kod odgovaru ovoj operaciji, gde je destination l, a izvorišnji operant je zadatak adresiranjem set-print, gde set-print tekuća lokacija za set-preferentno registrar. Posled samo generisanja ovih naredbi potrebna žurirati adresne i registarske destriptore, tako što se l dodao adresni deskriptor za x, da refrektuje činjenicu da se vrednost x atčuval l, također ako l registar treba x da se dodao registarski deskriptor za l. Ako y-nicet nisu živi u i toj četvorci, tu nam je potrebno ona informacije o životu, da se u daljiti ih iz deskriptora registara u kojima se trenutno nalaze. I posle obrade, ova i corak 6, znači, prvih pet coraka se obavlja za svaku četvorku, a corak 6 na kraju bazičnog bloka posa obrade svih četvorki, potrebno je sagledati, dali postoje promenjive na izlasku iz bazičnog bloka koje su žive, a nalaze se isključivo u registru, nisu još u memori, i potrebno je generisati za svakog takvih promenjivih dodatnu instrukciju, čuvanja, znači njen evrednosti iz registra u memori, u znači, ve primija memoriska lokacija za promenjive. Pod program GetRec na ulazu, znači, od uleznjima podata kak koristi tekuću četvorku za koju se generishe kod, dodatnu indikaciju, da li je neopkodan registar, da li mora da vrati registar ili može i memoriju, a na izlazu da je registar R ili memorisku lokaciju za ovaj levi operant Y. I algoritom je formulisan u četvi tačke, one ustvari idu po nekom prioritetu, odnosno tačka jedano označava najpovoljniju, najoptimalniju situaciju, a onda, znači, polako glizimo ako ne mogu da se ispune preduslovi za 1, idemo na 2, pa ako ne može ni 2 na 3, pa ako ne može 3, idemo na 4. Znači, najpovoljnija situacija je da je Y1, na promenjimu u nekom registru R, i da je Ymrtvu uposmatrono i četvorci. Znači, više nam neće biti ta vrednost potrebna, onda znači praktično možemo osloboditi R, odnosno praktično možemo ga vratiti, znači baš za Y i izbaciti značeri, zadevstno gdje je za Y, znači osloboditi ga za nared na korišnjenje i vratiti R. Znači, to je najpovoljnije da iskoristimo neki već zauzet registar koji može da se oslobodio dipsilon, a posljeto ga će da se koristi, naravno, za rezultat X. Međutim, ako tako nešto, tvoji preduslovi nisu ispunjeni, onda pokušavamo da nađemo i vratimo praza registara ko takavima, naravno, taj praza registar moraće na pripremnom naredbom da se napunisaj Y. Znači, ispunjeno, nekako ne može ni praza registar, a X ima sredneću upotrebu u tom bloku, ili ako je, nači, ovaj operator obavezna zahteva registar, mora da se pronađe neki zauzeti registar i onda sa jednom ili više ovih mugnaredbi potrebno je, znači, isprazniti, osloboditi registar o njih promenjivih koje su registara, nisu memori, znači, to ćemo vidjeti iz njegovog deskriptora i, nači, kad sve te promenjive sačuvam u memori, praktično ih izbacujemo iz tog registarskog deskriptora, oslobađemo, nači, registar i vrat ćemo taj onda, jer kao slobodan registar. I konačno, tačnaka četri, ako ne može ni tačka tri, onda se vrat će memoriska lokacija za X. I sada ćemo ilustrovat na onom našem primjeru sa četiri četvoreke, kako da primenimo ovaj jednostavan algoritm. Na početku vidimo da su registri prazni, a da su koristničke promenjive u memori. I fokusiramo se na prvu četvorku. Pozivom g-track potrebno je dobiti lokaciju za smešta i levog operanda A. Naravno, uvidom vidimo da je A u memori i da su svi registri prazni. Tačka 1 ne može da uspe, ne možemo sloboditi ni jedan registar, ali tačka 2 može da uspe. Inače, predpostavka, pod kojem ćemo primeniti sada algoritm, da ćemo koristiti samo dva reagistra AX i BX. I ovdje, ona informacija o životu promenjivih da ne bi se vraćali na ona i predkodni slajd. Podvuka 8, koje su mrtu, to su ovde T, ovdje V i u sve ove druge promeljive su žive. Tako da prva tačka g-track procedure ne uspevali, druga tačka g-track će nam vratiti slobodan registar, to je registar AX i potom moramo priprnom naredbom dovući vrednostav registar AX i obaviti operaciju konkretno od uzimanje. Za drugi operand moramo naći da se nalaze onje samo u memori, tako da koristimo memorisku lokaciju. U posla ove naredbe moramo žurirati deskriptore, znači AX će sadržati rezunta T i naravno za svak promenjivu moramo reći gde je koja, znači osim te koje AX ove druge su u memori. Zatim za sledeću naredbu, opetu nam je potrebno zlevi operand da odaberemo registar. Ne može biti ispunjen prvi slučaj algoritma da oslobodimo neki registar u kome se već nalazi A, pošto se A ne nalazi u registru, je sada drugi slučaj može da uspada, to je da vratimo slobodan registar, a to je registar BX koji još imamo na raspolaganju kao slobodan, znači moraći imati pripremno naredbu da dovučamo vrednost A u registar BX i potom da obavimo opet ovu glavnu operaciju, a to je od uzimanje znači od BX, ovog drugog operanda C se nalazi samo u memori i tako da moramo iskoristi memori skorivog lokaciju. Znači, izvašavanja naredba žuriramo deskritore, znači sad od rana imamo da je T u AX, ovo što je sad novo to je da je u rezultatu BX i znači ovdje za svaku promenji visto značujemo, znači dodajemo da je za promenji u, da se nalazi nja na vrednostu registru BX. Za treću...
 4 ruku među koda, moramo sa Getreg da dobijemo locaciju za levi operand. E sad levi operand kao što vidimo, prvo sadrži se, način alazi sa u registru, drugo mrtavje u ovoj tački. Znači ta vrenost više sad kada iskoristimo neće biti korišen i to je najpovojniji slučel algoritme, da možemo da iskoristimo registru u kome se, pošto se ništa drugo ne alazi osim t u tom registru, znači iskoristit ćemo registra AX i Getreg vraća registra AX, znači nije potrebna pošto se levi operand već nalazi u tom registru, nije potreba nikakva pripremina nareda, već samo ova osnovna operacija ADD AX, drugi operand U vidimo da se nalazi u registru, tako da ovaj i to je, znači povojno iskoristit ćemo registra BX i sada žuriramo deskritore, znači sada vidimo da, jer smo naravno izbacili vrednost T iz AX, A rezultat V, znači upisan U AX, naravno, ovo drugo se nije promenilo odranije, samo što naravno ovde znamo da je V U AX, T više nefiguriše jer je mrtvo, znači nevamo tu vrednost i konačno posrednja četvorka potreba nam je lokacija za levi operand V, vidimo da V je u registru i takođe da je V mrtvo, tako da opet možemo vratiti registar AX i osloboditi ga od V, znači ne treba nam pripran na naredbe, odmah izvašavamo sabiranje, drugi operand U sadrži su registru BX, i sada žuriramo deskritore, znači sad je rezultat D U AX, možemo izbaciti zato što je mrtvo poslove naredbe, znači više nam nije bitno ta vredno, da to ga nema više u BX, i evo vidimo znači praktično, pošto su kađemo se ove priprane promenive mrtve, njih više ne pominimo, nego ovde samo ove koristnečke promenive, znači da je u registru, ove druge su u memori, i sad dolazi ona tačka 6 algoritma, znači šta raditi na kraju bazično bloka, proveriti dali neka od tih promenivih koje je živana izlazko, a to je koristnečka promeniva D, nije još u memori, znači moramo da sačuvamo vrednost D iz AX u memori, tako da ugenerišemo još tu, da kažem naredbu pospremanja i poslažuriranja ovih deskritor, dobiamo stanje kao na samom početku da su svi registri prazni, A, A, B, C ide ove defali su u memori. Ove srajdi je više informativan u smislu da nismo, tako je zadatke davali na ispituali, moguće je naravno i za ove druge vrste naredbi među koda definisati, kako se generiše kod, znači za razna ova indexna, naredbu je tradisno koda koje se najčešće dobijaju pri prevođenju indexiranja, nizove i tako dalje, znači A jednako BI, ona će koristiti neke vrste indexnih adresiranja, znači i ovde su data opcije, uzavisnosti od toga da li je index I u registru, ili je index I u memori, ili je I lokalna promenjiva na steku sa pomeramD, znači za B se podrazumeva da je neka memoriska lokacija početna adresa, tog niza, je sad naravno najpovoljnih slučaj, ovde su data i neka kve cene, znači običu generatori koda kad biraju, znači to je već malo u našem jednostavnom algoritmu nije figurisala, izbor kad ima više mogućnosti, ali znači realni generator koda ako ima više mogućnosti da i zabere neku naredbu, svako je naredbu je dodeljena neka cena, koliko košta nije naprime, odnosno niža cena, znači da je naredba, je frikastnija da ima manje pristupa memori i manje procesorskih ciklu sa je za izvršavanje, tako da vidimo da naravno kad je i već u registru, onda možemo iskoristiti znači indexno adresiranje, znači da izraču nam ovo B plusi i naravno onda da potrebanje još jedna registrera prim za smešta i rezultat naravno ako i u memori, moramo pripremno prvod ovesti, znači i iz memori u registra, onda isto iskoristiti registr skoradresiranje, pri čemu ovde vidimo da može odmah i da se iskoristi ta isti registr, on je samo privremeno iskorišćen za dohvatanje ovog beodi i naravno ako i na steku, onda moramo preko basnog adresiranja da dohvatimo I naravno opet moramo da iskoristimo neki registr za to i onda opet ovaj ostav na naredba da upišemo u ovo A nači postoji varianta kad je obranu to a od i jednako B i slično se na kažem analizira za naravno u potrebu pokazivača, znači ako preko neko pokazivača P i nači da pričemo u a, onda naravno ćemo koristiti ako P već u nekom registru registrasku indirektno adresiranja ako P u memori, moramo naravno proda da dovedemo registr pa onda koristimo redistrasku indirektno ili ako je na steku moramo ga isto tako dovesti u registr pa onda koristiti registrasku indirektno adresiranja, ču ova druga dva sluča imamo i tu pripremnu naredba i e to, o toliko o temi generisanja kod kod klasičnih kompajlera koji direktno generišu kod za fizički proces. U ovom lekciju reći ćemo neke stvari o tome kako generisati kodu kompajleru za mikrojavu. Za podrešku generisanju koda postoji bibliotečka klasa kod koji ću implementaciju i dobijate i njena osnova je da se koristeći javne metode put, put 2 i put 4 generiše kodi smešta u jednu internu strukturu koja je u stvari niz baitova buffer buff i internu postoji jedan brojač program counter PC koga ne treba naravno mešati sa PC i virtual na mašine kada se bytecode izvršava znači ovo je prosto jedan interni brojač dok les se popunio buffer, buffer znači svaki put kad se imi to je put, put 1 ili više byte o byte koda smešta se od lokacija na koju kazove PC a potom se PC ažulira metodi put, put 2 i put 4 redom služe da u buffer buff ubace 1, 2 ili 4 byte sadržaja da bi se olakšalo kodiranje mikrojava naredbi postoji nizdefinisanih simbolički konstantu kod koje odgovareju operacijnim kodovima mikrojava naredbi, nakako kako su nedefinisanje u specifikaciji mikrojave, tako da ova jedan primer kako se recimo ova put jednobajtna naredba koristi, znači code tačka put sa argumentima code tačka load 0 plus 2 emituji u suštini load 2 gde je to jedna reč naredba do koju znamo da služi za dohvatanje drugi lokalne promenjive i smeštanje na vrh xp, xp, počet ćemo od obješnjenja kako generisati kod za mikrojava izraze za uzimanje vrednosti operana do izrazima ako krenemo od nekog izraza ili dela izraza koji predstavlja sabiranje dve vrednosti u mikrojavi potrebno izgenerisati kod koju učitava prvi operant na stek, zatim učitava drugi operant na xp, i onda se generisate naredba ed. Sad uzavisnosti od vrste operanda, menja se i kod koji treba da se generisate, nači ako je operant konstanta, onda treba mikrojava naredba konst sa vrednosti u konstante da se izgenerisate ako u pitanju lokalna promenjiva naredba treba da je load i adresa lokalna promenjiva, u pitanju globalna promenjiva potrebno je generisati get static, ako u pitanju polje objekta klasse treba generisati get field, ako u pitanju element niza treba naredba je a load, ako je vrednost veći na xp, i samo je treba iskoristi, onda ne treba generisati ništa vrednosti, nači veći ispunjenci da bude na xp. Da bi kompare vznavku u koju vrsti operanda i reč, on će gledati zapis objektu istabele simbola. Izbog toga postoji u klasi kod jedan pomoćni metod koji se zove load i koji prijima kao svoj stvarni parametar, znači taj objektni zapis na ulazu, a efekat pozivanja toga metoda je emitovanje odgovarajuće bytecode instrukcije za učitavanje vrednosti na e-stack. Ovaj metod dosta olakšava generisanje koda za pristup operandima izraza, samo ga treba na odgovarajuće mestu tokom semantičke obrade pozvati. Volvde je datso implementacija toga metoda, to je deote bibliotečke klasi kod, vi to nemorate da pišete, ali nije loše biti upoznat sa time kako funkcioniše ovaj metod. Na bazi vrste objekta imamo svić razgranatu strukturu i znači za svaku vrstu objekta imamo odgovarajuću case granu, gde možemo lepo onda videti kako dalje u metodu se koriste ove put naredbe da se emituju u buffer koda kako op kodowi, i tako i operandi odgovarajućih instrukcija. Kredam ovaj slučaj obo i otačka var, dodatno mora da se proveri level, da li je u pitanju globalna ili lokalna promenjiva, pa, na primera, vidimo...
 da se imituje opraceni kod get static, a da se u objektu pojadr koristi da se imituje adresate globalne konstante. I vidimo, to mora da se proverim u mikrojava specifikaciji, da je to na širini 2 byte. I tako da ljedećimo, vidimo, da u toj grani obojotačka varako nije, nači globalno nego lokalna konstanta, onda se dodatno proverava da nepristupamo nekoj od prve četri lokalne promenjive, pa se onda imituje ona i posebno efikasan operacijen kod, znači kada se piše load zajedno sa konstantom, da bi se izvršavalo brža ako, nači nije jedno od prve četri konstante, onda se imituje posebno loada, posebno, nači drugi da kažem spori i load i još se kao 1 byte imituje, nači adresa konstante i tako da. E sad, nači ključno je i ono što vas u stvari najviše zanima, gde smestiti poziv ovoga metoda code.load. Da bi smo razumeli kako tačno funkcioniše gramatika za mikrojava izraze, na žutom je dati jedan fragment mikrojava gramatike, koji se odnosi na izraze, znači dosta smena u mikrojava gramatici se odnosi na izraze, i te smene na neke način imaju hierarchiju, tako da negde na dnu te hierarchije je ova smena koji vidimo dole ident expression list. Nači te na deznice strane imamo terminal ident, koji znači to je token koji dolazi iz genera i koji u seben nosi id attribute ime identifika o to, na koju potrebujemo u izrazu, to može znači biti ako se iskoristi ova smena, to je u stvari nekakva lokalna ili globalna promenjiva. I ako gledamo od počeoviša ote done smene, nači tu treba na bazi imena pozvati metod fine tabele simbola, da bi se naša odgovaroviće ovaj objektni zapis, i ova varijanta odgovara slučaju da se semantička akcija ugradji o direktnu arseru gramatiku, ali može lako da se preradi i za varijantu kada se korista protstrakta syntax na stavla, za drugu varijantu pogledajte primer i nidomaćek koji je tajno razrađeno u vežbanoj prilog videovezen za laboratorije, ali ove zbog konciznih zapisa ja sam koristio ove varijante kada se odgovarajuće semitička akcija ugradji o direktnu gramatiku, ove vidimo da kad nađemo taj objekt preko ovoga result u suštini dodeljujemo ovom neterminalna identifier expression list taj objekt i u suštini taj objekt se dalje prenosi, nači vidimo u ovoj smeni izdatnji designator se menja sa identifier expression list i sa taj je identifier expression list ima attribute o koji se onda prosledžio petur result odnosno sa to postoji attribute designatora i gore u ovaj smenif factor se menja sa designator dolazi isto kao attribute taj referenci na taj nađeni objekt treba uočiti odnosno ja vam sad kažem, to je poslijicadeteljne upručavanja mikrojava grammatike, da ovaj neterminal designator je značan po tome što on učestvo i na levi strani izdraza dodeli i na desnoj, tako da u njegovim smenama ne znamo da li treba učitavati operand ili prosto da li se koristi u kontekstu odredišta kad bi onda ustvari treba da generišamo store mikrojava instrukcije, pa zato na nivou designatora ne generišamo nikakav kod, nego dolazimo do smene factor, factor je prvi od neterminala za izraze, a znači hierarkiški izdat njega su factor list term list xp, xp list, ali factor je prvi za koji znamo da se odnosi na izraze koji se pojavljuju samo na desnoj strani izka za dodele, tako da u smeni za factor smajemo da pozovemo load, tako da upravo u smeni za factor, znači sa prosleđenim objektrim i u tom trenutku se generiše mikrojava instrukcija koja dohvatla odgovarit će operand i sad se postavlja pitanja, vidimo ovde još dodato semanticko akcijalizat, i odako o tačka type, zašto je potrebno da dalje, ovo što smo komentili da su izdat faktora raznih neterminali, factor list termi tako dalje, počigledno i ti neterminali imaju neku semanticku vrednost neki atribut i to je u stvari tip promenjive, da ću smislu mikrojava tipa, zašto je potrebno da oni imaju, ako smo već izgenerisali kod zapristup vrednosti, pa potrebno je da radimo semanticka akcije prepoznavanja, da li je pravi lan tipu izrazima, jer sad kada se ovaj faktor u potrebnoj nekom služenim izraze, to osabiraju se dve vrednosti, znači, da komparer mora na nekom mesta imati proveru, da li se one poklapaju po tipu i da se sve osabirati i tako dalje, zbog toga, nači u više nivoje smena prosredživo tip objektu. Nači ako sad sagledamo, ono što sam pominjalo da ostoje više smene hierarchiski za mikrojava izraze, kao što su factor list term term list, to je fragment mikrojava, grammatike koje se drži s nijestih smena iznad faktora i recimo u smeni term list, to je samo jedna od smena, znači ja u ovim fragmentima pokazujem jedan deo, znači postoje i druge smene za određene neterminale, ali prosto kada ilustrojamo u semanitričku obrado ilustrojamo na određenom primjeru, recimo ovdje ilustrojamo za primer ovih ad op operacija sa viranje od uzivanja i onda na nivo u smene term list je term list ad op term, potrebno ugraditi znači semanitričku proveru kompatibilnosti tipova operana da t1 i t2, jer nam to dolazi kroz ove t1 i t2 atribute znači tipovi objekata, naču me sto ovoga komentara treba staviti pravi javakod, a zatim ide obrada pažgenerisanje koda za računanje vrennosti izraza, to je ovo code tačka put op, op je code ad konstanta ili code subtract konstanta u zavisnosti operacije, znači ovaj code put u suštini emituje mikrojava na redbu ad ili subtract koja nema svojih argumentata, tako da se tu vrši, recimo, nači generisanje koda za sabiranja, ako upotrebljena ova smena za sabiranje. I vidimo da sad dalje prosledžujemo, znači semantičke atribute ovog termlista, to je ovaj rezalt, preuzima vrednost od levoj operanda, znači i taj zbir, taj među rezultat, kad se dalje upotrebljava u složenim izrazima, načisto je podložam proveri tipa i on preuzima tip svoj glavog operanda, ako je ovde ispravno prošao semantičku proveru, onda u suštini, ovde operanda će imati isti tip taj 1 i taj 2, tako da je dozvoljeno proslediti tip levog operanda. Da sad vidimo neke specialne slučeve, opšte, ove priče koji smo već izpricali, a to je recimo, ako u izrazima upotrebimo objekte klas i njihova polja, znači ako je danad operana do izrazu o.f, onda praktično imamo opetno žutom prikazan fragment mikrojava grammatike koji se odnosi na, onaj najniži u hierarchiji delo izraza, kada prepoznajemo, znači samo operanda, znači ili ono skalarno promenivu, ili, znači dosas smo videli, ono smeno ident expression list se menja sa ident i taj tip je ta situacija odgovarala obično i skalarno i promenivaj, taj neterminal ident expression list ima i drugu smeno, a to je ova iznadnje, znači ident expression list se menja sa ident expression list dot ident, znači dot je naravno terminal koji odgovara upotrebi onog operatora tačke i još jedan ident koji ime polja, ako upotrebimo polja u izrazima onda ćemo jedan ili više puta, pošto ova druga smena rekursivna, znači to bi moglo da se zamisli a, b, c, više moguće napraviti više struku u potrebu togo operatora tačka za pristup poljiv. E sada vidimo znači kako ide semanticka obrada t situacije, vjede smo videli, kažemo, u osnovnu smeno ident i trešno list se menja sa ident, prana i i di koji nam dostalja token izator, to je string ime identificatora, se koristi da pozove method find dotabeli simola i da method find vrati objekat, e sada naravno ako je upitanje ovova izraz o.f, znači find za ovaj deo o vratiće objekat koji je značin stanca klase i pošto to prosledžujemo u result znači na niva identics pressure list, onda kada upotrebimo tačku, znači aktivira sa ova gornja smena i mi kroz ova i prvi neterminalna levoj strani i njegov attribute o dobijamo u stvari objekat koji je nađen s onim find metodom i sada ovdeg da piše komentar, ovdeg treba se proveri uslov dalje o instancaclas, znači tu mesto tog komentara treba naravno proveriti koja je vrsta, t.e. koji je tip objekta o, znači dalje je upitanju klasa, a zatim znači ide obrada generisanje koda za pristup objektu klase a obrada se stojio toga da se pozove code load koji će znači staviti na expression stack address, znači neće generisati puno na getfield ili putfield, nego će samo uraditi pripremu za adresu i sad je ključno ovo da mi sad moramo uraditi i pozvatiti poseban metod find field u tabelisi molasko, što je i nači isto bibliotečka klasa, znači to već postoji, sa ovojim imenom polja ide, nači tu ide iz ovog primera otačka f ide f na mesto ide i o tačka type je naravno tipo ovog, prvog tipota o u izrazu.
 u svoj otka F. Znači u suštini taj fine field ide kroz klasu i traži njena odgovarajuće polje. Tako da mi dobijamo u stvari kao rezultatog fine field ako je uspešan opet objektni čvor koji pokazuje na upravo polje odgovarajuće klase i vidimo da onda rezalta dobija upravo vrednost ovog objektu čora i dalje se znači prosledjuje taj rezalt. Tako da će se ponovno znači zvati na nekom mesto ona i što smo videli, onim na nim smenamo ko u tačka load i onda ćete load odraditi nače ako je pozvan tamo faktor smeni odradit će get field a vide ćemo ako je pozvan na nivou odredišta u naredbi dodelu u radit će put field. Takođe specijalna odbora slična ovo je predskodnji je pristup elementu niza u izrezu A od I. Ovoj prvi deo je deo specifikacije mikrojave konteksni uslovik koje treba ugraditi u sevantičke akcije. Znači mikrojava specifikacijt piše da tu postoje opet posebna smena za ovaj identifier expression list koji dosad nismo videli a to je znači da na desnoj strani ima opet identifier expression list pa u uglastim zagradama izras. I znači mora se proveriti dali je taj identifier expression list na desnoj strani tipa niza, i expression mora biti celobrojenog tipa. To su one proveri koje moraju da su ugradu sevantičke akcije koje se ja samo navjav koje komentar. Nizam pisao njihov kod. Kako izgledaju sevantičke akcije za generisanje koda. Znači rekli smo ovada posebna varijanta smene za identifier expression list. I na slič na način kao i ranije prvo ova osnovna smena za identifier expression list nalazi ona i osnovni objekata. Ovo a u izrazu a od i. I zatim se aktivira kada mi upotrebimo uglaste zagrade. Aktivira se ova gornja smena identifier expression list, semenja sa identifier expression list. L square je otvorena biti často zagrada. Onda ide prva sevantička obrada. Onda ide expression na desnoj strani smene. I r square odnosno zatvorena biti často zagrada. U ovaj smeni sevantička akcija nije na samom kraju smene, nego kad prođe otvorena biti často zagrada. I sevantička akcija se sastoji z toga da ispitamo dalje u ovom prosleđenom objektu koji dolazi kao atribut o. Ovoga identifier expression list na desnoj strani smene. Znači to je ovo što je tap find iz ove donje smene našao. Dali je tip toga objekta u stvari tip niza? To je onda u redu. I onda pozivamo code.load. A code.load će u slučaju kad je ova vrsta objekta postaviti. Znači to može se pogleda u onom kodu implementaciji load metoda. Znači postavi će početno adresu niza na expression stack. I posled toga znači ovo je zanimljiva situacija. Šta je semanticka vrednost sleve strane smene result? Pravimo, to je ovo je jedina situacija kada instanc u ovog objeknog čvora koji s inače koristir tabeli simbola i u glavnog interno generišu metodi tabele simbola instancu ovoga oboj. Međutim i ovdje eksplicitno pravimo instancu oboj. I stavljamo mu posebnu vrastu a to je oboj.elem. Znači to reprezentuje u stvari jedan element nekog niza. Nema ime, a njegov tip je tip elementa niza. Što vidimo na baziji ovoga objekta koji nam je došao koji je vrste niza. Zašto nam je potrebna? Znači ova posebna vrsta objekta koji se inače nema nigde u onim strukturama tabele sem goleni. Tismo pominjali vrstu oboj.elem. Znači ta vrsta objekta nam je potrebna isključivo u ovoj semanticko obrad izraza i to da je izraz vrste element nekog niza. Što pomaža kastijem drugom pozivu code.load metoda da izgeneriše pravilan kod. Znači da umesto loadu potrebio naj a load. Znači da ne generiše kod za običnu skalarno promenju, nego generiše kod za element niza. Znači upravo ta informacija se kroz ovu specialnu varijantu ovvjikto kčora pregasi. Naravno ELZ je ovova situacija kada je greška kad smo napisali A od I, a A nije nikakav niza. Znači X-pression koji se takođe pojavljio na desnoj strane ove smene je na X-pression steku ostavio u suštini svoju vrednost. Odnosno inicirove generisanje koda koja na X-pression steku ostavio vrednost za ovo I, ja to je stela element niza. Tako da u suštini kad izrađemo iz ovih semantickih akcije i krenemo na više hierarchiske nivoje smena za izraze. Ni na steku imamo početnu adresu niza i vrednost indexa i tovi elementani zupravo, ono što onim A, A, U, D, A, St, R instrukcijama je potrema. Takođe piša ovdje da provera indexa znači da li ovo i u granicama niza se radi u vreme izvršavanje od strane mikrojave virtual machine. Time smo obradili kako generišamo vrednost izraze, to je dsno stranu raznih o njih iskaza dodale. Iskas dodale kad napišete, promenjiva jednako izraz odnosno u graniciji. Imamo ismenut statement, vrsta iskaza, designator, pa ide jednako kod terminal pa izraz. U zavisnosti od toga šta je ovaj designator, ovdje je prikazano šta sve treba izgenerisa ti kao kod. Kod mora biti takav da se vrednost X-Pression ostavlja na X-Pression steku. Ako to dodeljujemo, ovaj designator po svom tipu predstavlja lokalno promenjivo, onda ustvari samo na kraju sekvence koda, znači ovo što je boldovan je ustvari, ona ideo koji je potreban da se izgeneriše u ovoj konkretno i gramatickoj speni. Ovo drugo što i talikom to je ustvari kod izgenerisam pri prepoznavanju X-Pression. Kada je u pitanju lokalna promenjiva, vidimo da boldovan i kod piše stor lokal variable, znači prakvisno jedna stor naredba, a ako u pitanju globalna skala na promenjiva, onda je to put static naredba. E sada nešto je složenija ako u pitanju dodela polju neke klasse, onda mi ustvari moramo plavim, tuk pripremu za dodelu objektu, moramo izgenerisati pre prepoznavanje X-Pression. U stvari, stavljanje na stack adrese objekta na hip, jer to mora ići pre ove vrednosti koja predstavlja desto strano tako dodale, a onda na kraju moramo još put field sa offsetom polja f izgenerisati. Svično tome i kod nizova, videli smo da se dodeljuje nekom elementu a od i neki izraz, neka vrenosnjaka u izraza, onda moramo dovesti na stack prvo početno adres u tog niza, zatim vrednost indexa i, zatim vrednost, znači elementa koji će biti, vrenos koje će biti dodena elementu i onda samo na kraju treba izgenerisati a stor na redbu bez argumentat. Međutim, nama ustvari tu na neki način malo pomažu, kao što ćemo sad videti onen obrade koje smo već radili na nivou onoga identifari X-Pressionist, međutim, je ovo da, način fokusiramo se konkretno na ovu smenu, u microjavi statement je designator i jednako X-Pression. I konteksni uslovi koji pišu u specifikaciji microjave da moraju, provere koje compiler mora da uradi, da bi to sve bilo semantički ispravno, je da, znači designator mora biti promenjive element nizaj ili polje objekta klasse, a tip izraza o X-Pression mora biti kompatibilan pri dodeli sa tipom designator. Znači kao što se sećemo iz onih lekcija o microjava tabeli simbola, postoji posebno metoda u tabeli simbola koja proverava tu kompatibilnost pri dodeli. Semantičko obrad ove smene svodi se samo na to da se pozove code store za objekat o, a objekat o se dobija kao semantički atribut ovog neterminala designator. Code.store metoda je u stvari u code klasi koji vi već dobijate goto implementirano i koja na bazi vrste prosledženog objekta, emitu je odgovara i uču upravo prema ovom predhodnom slajdu, znači emitu je, uzavisna ste toga šta je objekat, emitu joj ovu završnu boldovanu crnu microjava byte code naredu, dokove plave se emituji u stvari kao što sam reko, već pri prepoznavanju identifier X-Pression alisteri i kad se prepoznaje designator, prolazi se kroz te smene na najnižem nivou, tako da te pripremne plave naredbe su već emitovan, onda se emito je za izraze, nači kod koji treba da dovede vrednost na vrsteka i onda se tek prepoznaje ova konkretna smena koja onda emituje ove stvari naredbe, znači sve ide ispravni mredosled. Kako obrađujemo skokove u microjava byte code, reklj smo da bez uslovni skok postoji naredba jump i za uslovne skokove postoji niz naredbi sa razvečetim ovim relacijanim operatorima, provera jednakosti na jednakosti strogo manje, manje jednakost trogo veće ili veće do jednako i uslovni skok, nači kod za njega mora biti takav da se, nači dovede jedan operand vrednost na vrh steka, vrednost drugog operanda na vrh steka i onda se emituje kod uslovnog skok. Skokove su inacio implementaciji relativni u odnosu na tekući pis i pomeraj. Po ovde vidimo i razne konstante koje su u pod klasi definisani za razna ove uslove, tako da u suštini, ju ek plus kod nekogod ovih operatora vam da je pravilan byte code za pravilan relacijoni operator, to je ovaj primer dole, znači za uslovni skok dole desno, kod put, kod ju ek plus operatora vam da je tačno operacijani code.
 u operatoru potrebit gt, u suštini ćete dobiti kao vrednost tog zbira kod za je gt. I naravno offset je uvek dva baita, tako da i bez uslovnih skokovih zahtevaju da se emituje i dvo baitni offset. Odma se postavlja pitanje vrednosti tog u suštini odredišta skoka offseta. A ako su u pitanju skokovih unasa, realizamo petlje prelazna sredne citeracije. Onda je situacija čisto, odnosno, pošto smo početak petlji u tom trenutku već preveli, mi znamo i možemo zapamtiti početnu adresu. Međutim, skokovih unapredeluju ovako teži za realizaciju, zato što mi znamo da će adresa tek biti, recimo za realizaciju if, svišnih naredbi, znači mi znamo da će biti tek kad kompajler obradi, znači taj deo iskaza, onda ćemo znaći gde treba skočiti, ali u trenutku kada obrađujemo sam, kad emitujemo samo instrukciju za skok, nama odredišna adresa nije poznata. I ostavna ideja je da moramo naravno da izgenerišemo white code naredbu, znači da emitujemo i opcode i neku praznu vrednost nula znači za odredište skoka. Ali pamptim adresu te izgenerisane naredbe skoka, to je spreciznije to gnjenog dela sa operandima, ta dva baita gde se nalazi odredište skoka, da bi smo kasnije, kad znamo pravo adresu na kojoj treba skočiti, primeniti ovu tako zvanu backpatchim tehniku, odnosno da nakradno promenimo taj deo naredbe skoka. Za podršku ovom, ešto sam reka, u klasi kod, nači postoje metodi putjump zagenerisanje bez uslanog skoka na odgovarajuću adresu, znači zbog toga je u suštini lekcijo mikrojavirklje mašini primjeri su davani kao absolute adreser, ovaj pomoćni metod u stvari vrši tu konverziju, u suštini zadajete absolute adresu putjump metodu, a on interno preračuna u stvari koji offset treba da emituje. Znači ova argument stvarni putjump metode je absolute adres. Drugi metod je put false jump, on je za uslovne skokove i zbog toga što u suštini nam često mi znamo određeni uslov, ali treba neku njegovu negaciju da, na primer kada obrađuje tif naredbu i sad ako uslov uspe, u den deo ulazite bez nekoj posebno skoka samo sekvencijalno i za provere uslova, a ako treba izvšatela tijel s granu, u suštini u kodu treba preskočiti den granu i zbog toga je recimo logično da ako ifu imate neki uslovi, u kodu emitujete skok za negaciju tog uslora, to je uslora helper metod put false jump i znači njemu zadajete originalni kodu uslova, kao na konstanta kodu, i adresu tog uslonog skoka, a sam metod će u stvari košto se zove put false jump, znači on će izgenerisati skok za negaciju tog uslora, za to postoji pomećni inverse, znači za svaki uslov mapira njegu obranuti uslo i izgenerisa će znači petabsolutna adresu adara, on će u helper metod će izgenerisati, odgovarajuću relativnu adresu skoka. I rekli smo za ovu podrešku backpackingu, postoji ove metod fixup, ako zapantimo adresu za prepravku, a to je u stvari trenutni sadrežaj pisija, kada emitujemo put false jump, prenego što ga emitujemo, pisije za jedan manji, pošto put false jump ima 3 bytes, pre tog emitovanja, ako zapantimo pisij plus 7 treba za pisij plus 1, i onda ako je to ta peč adres, fixup treba pozvatio u trenutku, kad kompanor obrađuje upravo adresu na koju treba, taj skok da skoči, tako da fixup ne treba davati, taj drugi argument, znači gde se skacu, nego on podrezumevo uvek tekući pisija, kao odredište skoka, tako da jevo kao što vidite na ovaj slici, on će u onom kod bufferu, treba peč adresa da ukaze upravo i za nači koda skoka, i ako fixup pozavete kad je pisija na adresi 25, on će u suštini upisati znači za ovog i nv'e, šta go da je predkodno pisalo, on će to prebrisati, nego će izvršiti taj prorač u 25, manje 20 plus 1, i nači upisaće šesticu i za nj'e, što će o mogućiti, znači da taj uslovni skok, ako nije jednako skačena adresu 25, posle kad se bude zašavalo mikrojava virtuala mašini. Ako se generiše kod za neke naredbe toka u višem programska jeziku, nači u mikrojavi, ako u mikrojavi imamo vajal uslov, pa tevo vajal petlje reprezentojano sa statementu, grammatici, na ljubi često vidimo u stvari kostur ili šablon koda, koji treba izgenerisati da bi se implementirao vajal, nači moramo imati prvo jedno odredište skoka top za pamćenu je lokaciju, koja u stvari predstavlja odredište poslje onog skoka, kad idemo na novu iteraciju, zatim treba izgenerisati tako bytecode, koji će računati uslov, zatim moramo imati jedan skok za negaciju uslova, koji iskače znači iz petlje, zatim će biti generisan kod, nače obradom od strane parsera, statementa biti izgenerisano, znači tu potencelno može biti puno bytecode izgenerisano za implementaciju tela petlje, i na kraju tela petlje treba imati skoku nazad na ovu top lokaciju. U grammatici imamo ovu smenu statement, koja na desnoj strane ima token vile, njemu možemo dodeliti, toči token imamo dodeliti nekakve semantičke vrednosti, top, i u sluštini tu vrednost ćemo iskoristiti da pamptimo ovu lokaciju top, da je treba kasnije vršiti skok, zatim imamo otvore na zagrada, onda kondišan je poseban deo, način mikrojava grammatike opisuje ove uslovne izraze, znači nije expression, nego prosto oni relacijne operatori upačeni su, to je u stvari hierarskih, znači još iznad expression, neznam expression ili expression ili expression i expression i u stvari su ove smene za kondišan, tako da imamo taj kondišan i on ima to u svoju semantičku vrednost op, koja u stvari reprezentuje operator koji treba ugraditi, pošto mi znamo da je to u slovni izraz kondišan smene, prezentuje neznam neki izraz tipa x, op, y, povradan kondišan imaćemo na steku i x i y, a znači sam kondišan će nam kao semantičke tribut vraditi koji relacijne operatori upitanjujo op i to, kao što vidite odma poslij kondišan, znači treba emitovatio, pozvatio ovaj helper metod u klasiku od put fold jump, negacija tog operatora i kao što vidimo odredišta, skoka je nula jer mi u tom trenutku to je skoku napred, znači ne znamo gde skačamo, zatim ide desna zagrada i na to mesto vidite odnosno čim uradimo, pardon, znači delo ove semantičke akcije i za put fold jump je da zapamtimo ovo ader i jednako code pisim manje dva, pošto pisir u tom trenutku ukazujem neposredno, na prvi byte i za ova tri byte koja je realizuju skok, znači ako smanjimo pisir za dva upravo ćemo zapamtiti, znači, adresu ona dva byte koja odredišta skoka što će vam kasnije trebat izza fix up, znači ova adera promenjiva panti, upravo najpodatak potrebno za fix up, znači znači prolazi desna zagrada, značim prolazi statement koji generiše svoj znači kod i na samom kraju ove sve ne, znači kad prođe statement potrebno ovo je bezusom i skoku emitovat, znači kod u tačka put jump znači je uvedan u vrednost top i treba naravno emitovat u ovaj fix up, jer baš u tom trenutku, čim smo emitovali skoku nazad, mi u tom trenutku imamo adresu gde u stvari treba da i skočimo iz petlje, znači neposredno iz atok skoka tako da je to pravi trenutek da se pozava ova fix up metode i da se prosle i ona zapamće na adres, znači ovdje skroz dole desno imamo u stvari jedan konkretan primer ako je, znači mi kraja vi napisan ova ila a jednako, telopetlja a jednako a minus 2, tu će biti, vidite izgenerisan kod redom, ova i delo kondišn kad se bude prepoznalo, znači izgenerisa će dovođenje a, na vrhih x presnosteka to je low nula, zatim dovođenje b na vrhih x presnosteka to je low d1, zatim će biti aktivirano ova akcija put false jump, vidimo taj uslov strogoveće, a false jump će staviti negirani uslov odnosno manje do jedanako, u tom trenutku naravno adresa će biti nula, ona je kasnije ovdje ovo što je prikazano, to je kasnije prepravlja na adresa, posle tog skoka koji predstaje izgubis petlje ide prevođenje statement koje će u stvari izgenerisati kod za ovu dodelo a1 na kva minus 2, znači biti će u stvari dovo jedeno a salo od nula na vrhih x presnosteka, konstanta 2, sup nared bo od uzimanja i stor nula, znači upis u a, znači to je telopetlje i na kraju telopetlje imamo ovaj izbiti izgenerisano iz semantičke akcije smene, ona izskoku bezoslovnu nazad, nazapam će na ovu početnu adresu, u kodu su u stvari relativne adrese, znači biti ubačen operant minus 9, što sa PC je inače nekako od pravih procesora kad si izvršava jump, znači ne ukazuje na ovu prvu posle jumpa nego na sam jump, znači kad se izvršava jump, tako da PC 1-ko 19 operant minus 9 da je odredišno 10 što u stvari početa kove sequence koda. I konac biće pozvane kako
 Znači na lokaciji 13 prepraviti da bude skok na lokaciji 22 relatima. Ja to znači treba dodati plus 10 jer kad se bude vrši 8, znači PC je 12 plus 10 jednako 22. Sela stvaru u generaciju kode je pravi LAN timing da se na pravo mesto ubaci prava semantička akcija. Za iskaz if imamo varijantu bez L's i varijantu sa L's. Varianta bez L's imamo da se prvi zgeneriše tako kod pri prepoznavanju ovoga uslova, zati mora da se stavi jedan foldj jump koji u stvari preskače den del i f ako uslov nije ispunjen. To je skoku napre, znači mora će se koristi fix up i onda će statement izgenerisati svoj del koda. Dok u varijanti kada imamo i L's del, vrlo slično je ovom predkodnom, jedino što znači posled den granu imamo bez uslovan skoko i će preskočiti L's granu, ovaj foldj jump će u stvari skakati na početak L's grane, a bez uslovan skoko će skakati na kraj celog if. Dole, levo na žutom imamo gramaticku smenu koji opisuje i fove u mikrojava gramatici i to je ovdje je prikazan ovav varianta sa L's. Znači if leva zagrava condition ima svoj OP, relacijum operatoru tako koji trebu graditi uslovnu naredbu. Znači desna zagrada ide statement, to je den del ifa, onda ide L's token, del ifa, i tako onda ide statement koji opisuje L's del ifa. Prema ovom gore desno šablonu, prvo condition, kada se prepozne usmeli, on će izgenerisati svoj del koda, onda čim prođe ova desna zagrada zatvorena, znači posled condition, mi pozivamo ovaj put foldj jump i pamptimo adresu fix up'a, zatim prolazi statement, generisase ovaj kod za den del ifa, onda kada prođe L's, to je pravo mestvo za semanitričko akciju da izgenerisamo bezuslovan skok, moramo takođe da zapamtimo adresu za fix up'a i to je skoku napred, takođe na to mestu je ova labela, nepose do posledu bezuslovnog skoka i ustvari odredište ovog uslovnog skoka i tu je pravo mestvo da poznajimo prvi fix up, a kad prođe statement u L's delu i kad se izgenerisuje kompletam kod, tu je pravo mestvo na kraju sam je smena ova semanitrička akcija, poziva znači fix up' za bezuslovan skok i ovde imate istokonkretom primer za jedno konkretno if na redbu u mikrojava programu, kakav kodu stvari treba da se izgeneriša. Uvek treba voditi računa, znači da ifovi u programu mogu da su gneždavaju, a to je ovako kako smo napisa kod bezikakvi promena može da radi i za ugneždene ifove, treba samo voditi računa ovim zapamčenim, redsino fix up adresama i šta ja znam da svaki if ima svoju i al instancu, da ne bih slučeno prigneždavanju do unutršif ne prebriša neki podatak ispoljnog ifa, oprezno koristiti eventovne globalne strukture i tako dalje. Poziv metoda obradit ćemo ovaj poziv statičkih metoda, redsima ra nije videli kad smo pričali o mikrojava virtual masinida, za poziv metoda treba staviti stvarne parametre na stek, emitovatio ovu naradbu i tako kol i posle tog ako metod vraća neku uvrednost, pokupiti tu uvrednost sa expression stack. Koji deogramatike odgovara pozivu metoda, to je isto u suštini deogramatike za izraze, ku izrazi možete da upotrebite poziv metode i onda povrata u vrednost metoda koristiti izrazu kao i sve druge vrednosti, nači u suštini netremano faktorima posle mu smenu za pozivanje metoda, to je ovaj koja na desnoj strani ima designator na čime metoda koji se poziva, pa otvore na leva zagrada, pa stvarni parametre, znači listost vani parametra, pa zatvore na zagrada. Stvarni parametri su lista izraza i imamo posle mu smenu za listu izraza, znači koja je rekorzina. Postoji i druge smene koje imaju, poziv metoda, znači poziv metoda može biti iska sam za sebe, pričemo onda ako taj metod vraća neku uvrednost, ona su ustvariti za nemaru, je mora samo da se skina sa stacka. Da se vratimo na ove smene na žutom, znači šta u stvari treba sve onsematiske akcija, obraditi možemo da krenemo od dna od ove liste, znači izraza koje predstavljuje stvarni parametre, treba u tim smenama proveriti broj i tip stvarnih parametre, znači ja nisam sad dala o detalje koda, da ne oterećemo ovaj slide, moram na neki način zapamtiti koji smo metod pozvali, a to dobijemo preko ovog objekta u designator, je otako u ovoj smeni faktori, imamo designator na dešne strane pa njegovat ribut o, ustvari je objekat koji je vraće nista bile simboli, koji predstavlja ima metoda i preko polje locals za pamčenje formalnih parametra, a ako metoda je sad posle, kad proveravamo tipi broj stvarnih parametre, mi ustvari moramo pristupiti u suštini tim informacijama i onda sravniti, da je sve u redu isti broj parametre i parametre po parametre, da su tip formalno parametre isti sad tipom stvarno parametre. Na nivu ove smene za faktor, znači prvo treba naravno na bazi ovoga o atributa proveriti, da je o metode i da li ima povratni tip, jer je upotrebljenu izrazu, znači očekuje se da ima povratni tip, zatim moramo i kol metodu, slari upotrebljava relativna adresu, ovdje to vidimo iz ovog koda, znači izračunamo relativna adresu, tako što tekućeg pisija oduzmemo destination address, a destination address je isto, o.ada radobijamo iz o promenjive o, i onda samo znači imamo poziv metoda, i takođe na bazi o.tajf moramo vratiti semantičke atribu do ovog faktora za kasnije proveriti. Naravno metodi pored poziva ima i mestu kad se deklarišu metodi, ovdje o tako uokviru, glavnom programa ili uokviru klasa se definišu metodi klasa, ovo je su smene za glavni program što odgovoro ovim nižim nivoima projekta, ovdje o tako i b, znači imamo deklaracija metoda na dejsnoj strani povrčinje povratnim tipom, i ident, znači, return type ident je posebna smena koja daje i povratni tip i ime metoda, onda ide otvorena zagrada pa idu formalni parametri, znači lista formalni parametri isto posebno u smenom reprezent, to je pa onda ide zatvorena zagrada, pa onda idu znači lista lokalni promenjivi, pa otvorena vitičasto zagrada, pa statement list znači to je u zvištini izvošno teval metoda, pa zatvorena vitičasto zagrada, znači to je sama smena, ovo drugo su sve, znači upatčene semantičke akcije, znači što su se mantike tiče, čim prođe formalni parametri i lokalne promenjive, znači izgovan trenutak zlopacijan semantičke akcije, kad se direktno koristila ve semaničke akcije gramatikeci, bilo je čim se otvorena vitičasto zagrada, znači pre ovih statement list, praktično, evo vidimo šta su tu sve semantičke akcije, ako je metod, baš main metod, onda treba zapamtiti, znači to je isto jedno polje u klasiku, znači mi moramo postaviti to polje main psi na neku grednost, jer to će kasnije biti ugrađeno u ona i objektni file, znači klasak odima i neki helper za ispisivanje bafera u objektni file i on će zpisati vrednosti ovo polje od aklaj pose mi kreva, vyrtona šina treba da počna da izvrša obrok. Taj metod main ono mora biti tipa vojl, tako da postoji ta semantička provera, znači uvek morate pročitati delom i kreva specifikacije veza za semantiku i videti koje sve provere, tamo je o to odplike, bo smenama i napisano, znači šta sve treba gde proveravati. Vidimo dađa za neki metod praktično, ovo nam daje u stvari taj objektni čvor, znači tog metoda kako će biti zapamtil u tabeli simbola i onda postavljamo znači pošto su već prošli parametri, znači otačka level daje broj parametara, košto znavo da se poslil ono listu lokal će biti na kraju naredjani i parametri lokalne promenjive, pa uvo je ne nam govori koji deo liste, znači koliko na početku članova liste su u stvari parametri. A otačka adre je, znači to je u stvari sad početak tela metoda, mislim tek će sledeti generisanje koda, znači pravo vreme da se zapam ti početna adresa metoda iz naravno tekućek pisija u klasi kod i zatim znamo iz one priču microjavu virtual machine da tela svaku metoda standano odvočinje sa bytekodna redbom enter, koja ima ona dva parametre i vidimo kako se ono je ovde iz otačka level i iz toga koliko top scope, a to je trenutno otvoreni, znači obseg, to su u stvari to je obseg parametre i lokalni promenjiv i metoda, ali on još nije prikračen metodu, nepristupamo njemu kao otačka locals, nego još uvek del o toga top scope, o toberi simbola tek kad se zatvoril, tako kad prođe celo vasmena onda će otačka lokal za se definiš, znači zašto je to potrebno posleda s ovojnom frame, da je tako alocila dovoljno prostora za parametre i lokalne promenjive u zbiru i naravno još postoje jedna velika semantiška akcija na samom kraju kad se već izgeneriše kompletan kod metoda prođe zatvorena viti často zagrada, od semantiških provera treba proveriti, da li jo ovo bio metod koji nešto vraća i vidimo da ovo je postoje neka return exist logička promenjiva koja je delo isto parsersko kode i koja se postoja na nekom drugom mestu, u stvari kad obrađujemo u statement list ako najiđe znači return iskaz, onda to je neka globalna promenjiva return exist, znači biće prosto postavljena da je u ovom statement listu bila neka return narada, je sad ako ta promenjiva nije postavljena, a metod ima deklavisanje da vraća neku vrednost, onda je to greška, znači jer onda bi mora odab.
 s nekom povratnom rednošću. Sad tu tu globalnu promenju return x isponovo postavljano za folizdovi bila sprengna za obradu nekog sledećeger, tako te la metoda. Ovde imamo znače priču, koji smo pričali u tobelama simboljada treba zatvaranja ovog lokalnog obsega, znači zapamtiti ove lokalne promenjive i parametre u otakl lokalz. I ako metod znači je deklarisan sa void, onda naravno treba izgenerisati samo ona i završni kod koji se završavate svakom metoda exit i return bez parametara. Inače, to ne radimo znači za metode koji nešto vraće, jer onda je na programmeru odgovornost da svu da stavi explicit na return. Jedino koji je metoda koji su void, programmer ne mora nikakav return da stavi jer se podrezumeva da nakraju kad se zatvorite će to zagradati, to je veliki implicit i return. Tako da ovo je osgrani načekom metod nešto vraća neku vrednoza, ako je tako deklarisan, compiler neće explicitno generisati return na redbu nikakvu, međutim generisa će instrukciju softrskog preki da trap, tako da ako je slučeno programmer, zaboravi jo da stavili return explicitni, u runtime će se naleteti na ovaj trap i dati upravo odgovarajuća poruka. Videri smo da u ovoj deklaracijim metode jedna od povezanih smena su ovi formalni parametri i nekoliko smena znači koja je vezana sa deklaracijom tih formalnih parametra, pričemu znači jedan parametri je tip i ident, znači prosto deklariše se tipom imenom parametra, onda parametralist u stvari ponavlja, tako da možem imati više parametra razlojenih zarazima. Potrebno je formale parametru neti u tabelu simbola, kao nači promenivu lokalnom obsegu metoda i njihov ukupan broj treba da se ovoj prebroji i vidimo da ova smena na najviše mihovo u formalni parametru ima taj broj n, jer to kasnije nam ono treba za ono enter na redbu da bi znali koji u vrenu znači je prosledimo. Već sad znači vidimo na njive uve sa sindonje smene parametr, da prosto kad obijemo znači tip, to su posebe smene, ali vraćaju koji instancu strukčvora, t, a ident vraća string, to je iz kenera znači ime identificator, i onda pozivamo znači insert metoduta bele simbola, gde kažemo da je vrsta objekta promeniva, da je ime id i da je tip t. Ovo id left kao parametr je jedna implementacijon detađ koji dosad možda nismo pominjelim kričam od tabeli simbola, a to je u stvari id left je pozicija, znači broj linije u izvornom programu, znači token i još scanner znači kad prepoznaje token po token, vodi i stalno ažurira da kažem tu id left poziciji u izvornom filu, i to se kasnije prosledžuje parseru i parser za svaki svoj simbol, znači terminal i neterminal usmeni ima, znači možete dobiti u stvari, jer on to od scannera da kažem pampti te pozicije, i to ovde sad prosledžujemo ovo insert metodida, ako insert metoda treba da javi neku grešku, onda ona u okru teksta greške ispiše i tu poziciju, da bi programmer mogu lakše da se orientiše, znači gde je nastala greška. Sad vidimo da ovde postoji i smena za obradu situacije, kad je stvarni parametar neki niz, znači onda se zadaje tip, ime niza otvorena, zatvorena uglasta zagrada, i onda vidimo da se u tabeli insertuje objekat vrste promenjiva, ali njegov tip t je tip niza, čiji element t. Return iskaz kao vrsta iskaza, vidimo da se tu ojavljio na globalna promenjiva return exist, znači čim se naleti na neke return treba je postaviti na true, i sad treba ispitati, znači metod type je isto neka globalna promenjiva, koja pokazuje kad počne deklaracija metoda i taj metod type zapamtimo, i ona mohde na ovom mesto služi da prosto provarimo, ne znam, dali smo slučajno upotrebili return u metodu koji je deklarisan sa void, to je greška, ili ako metod nije deklarisan sa void, onda naravno i za return, pošto ovaj orient, return sa expression, onda moramo provariti, dali tip izra za odgovarati, u koji je deklarisan u deklaraciji metoda. I takođe znači runtime, kod koji se generiše za return je exit return, void kodove. I to bi, e to bilo ukratko znači neke karakteristične vrste izkaza smo pokreli, da bi smo objasnili principi generisanja koda u mikrojavakom pyleru za drugi detalje pogledaj. Mini domači, sve ovo treba da vam da dobro osnovu da samo stalno uradite projekt prema zahtevima koje dobijati. Klasu code možemo koristiti potpuno nezavisno od samo kompajlera i od rugi bibliotečkih klasa. I to je zgodno kada u toku razvoja kompajlera želimo da testiramo neke svoje predpostavke o tome koji kod treba generi sa tika kod do se ponašan. Evo, jedan konkretan primer, ovdje je dat, jedan kratki program na mikrojavi, koji, načima samo main metod i u telu main metoda vidimo neku kratku sekvencu koda sa ifom i print. Na redbom i fima neki složeni logički izraz kojina če u mikrojava gramatici opisuje se neterminalom kondišn. Interesantno je da po dobro i programerskoj praksi, opošto se o ovom izrazu meše u logičko ili i logičko i, bilo bi logično staviti zagrade, znači logičko i je veći prioritet, ali zbog dobro programerskej skvistila ovde i ovde bi trebalo da stoje dodate zagrade, međutim mikrojava gramatika to ne podržava, znači nije stavljena ta zagrada u ovaj deogramatike, tako da mora ovako da se napiše. I sad ovo što vidimo ovde na levoj strani je prevod, znači ako imate goto mikrojava compiler, compiler će on to izgenerisati ako ga ne mate, onda morate ručno da prevedete. Stvar znači enter se odnosi na rovno na početak tela main. Routine i tu se ovvi parametri parametri se odnosi na ovve 3 lokalne promenjive, koje smo ovde definisali, obrovno je x uopšto nekoristio, ali je zgodna da bi a dobilo offset 1, a b dobilo offset 2, tako da program postaje čitljivi, nego da je a na offsetu 0, a b na offsetu 1, to je jedin razruzašto vedeno x. Sad ova naredba jednako 3 se realizuje sa ovom konstantom, znači stavljanje konstante 3 na expression stack i stavljanju lokalnu promenju u 1. Ova dodela inicializacije p jednako minus 1, znači konstanta minus 1 stavlja se na expression stack i onda se upisuje u lokalnu promenju u 2. Sad ide prevod ovoga i fasovim složenim izrazom, znači ovo prvo poredjenje a manje do jednog koder je realizuje se tako što se stave a i b na expression stack i onda naredba jump less or equal, ovo je relativna a ovo je absolutna adres, znači ako ovo je relacijne operator uspe, onda se odmah ide na naredbu print pošto ovdje ilijel. Znači cvoj izraz je automatski uspeo, to je to tako zvanokratko spojeno računanje ovih logičkih izraza. Naravno ako skok nije uspio ide se na ovo drugo poredjenje b sa 0 i tu stavljamo constant, nadstavljamo b na expression stack, stavljamo constant u 0 i sad ako je negacija ovoga uslova, onda su suštini preskača ovoj print i ide se na direktona izlaz iz potprograma. I sad ako je prvo poredjenje uspilo, ako što je u pitanju logičko, jednog moramo ići na drugo poredjenje, to je znači ovo punjenje a punjenje constant na 0 i sad naravno ako less or equal, ako je manje dojada ko 0, odnosno ako drugi uslova uspeva, opet idemo na exit, sad ako i drugi uslova uspeo, konačno dolazimo do ove tačke 22, gde smo i način izvršili skoka kove prvi uslova uspeo. A to je realizacija ovoga izlaza, ona je ovdje stavlja se constant E1 na expression stack constant E4 i poziva print koji realizuje izlaz, jedanje vrednost koja se ispisuje o četiri formatna, koji širini koliko znakovaće se. Iskoristiti konačno standardni kraj svakog statičkog metoda exit i return. Kako možemo bez compilera izgenerisati microjava bytecode, ovaj ovde i pokrenuti naravno microjava virtual machine, moramo napisati jedan java program koji će direktno koristiti klasu code iz runtime, potrebna nama je ona jar biblioteka, mogu da pokađam na disku, miđe i runtime, 1.jar tu je microjava virtual machine, ali tu se nalazi unutra i klasa code. Tako da kad importujemo sve iz runtimea, ostajem nam dostupla i klasa code, ako nešto je što imamo da ispisujemo u našem ovoj programu, načinamo joj import I.O. Naravno moramo upakovati u neku klasu, košto ovo sad java program i sve će biti naravno realizovanu u ovome main. Šta je sve potrebno da bi smo iskoristili klasu code, generisali microjava objektni file, moramo postaviti za taj objektni file, da nećemo koristiti globalne podatke, oblast globalni podatak anjeva ličina je nula, moramo postaviti odakle program tras izršava, tu možemo da iskoristimo trenutnu vrednost pisi i sklase pošto nikakog drugog koda nemate u suštini adresa nula. I sad prosto treba ubaciti sve ove microjava bytecode naredbe, odgovarajućim pozivima put metoda klase kodi, koriste će one simboličke konstante za obkodove raznih naredbi, znači vidite, enter se sa svoja dva argumenta kodila, naravno potrebno je znati za svakaj argument na koje širini, dali da se znači.
 Ovo je običan put jednog baita, iput 2, iput 4 ovde uglavnom. Ovičan put od jednog baita nam je rešavao posao za sve ove naredbe. Vidimo, znači nijic pooziva raznih metoda klasekod. Kako znati? Kod metoda put follows jump to je onaj pomoćni metod kojim se generišu skokovi. On zahteva osim, znači kad je uslovni skok, osim da se iskodila uslov, što istos Konstanta definisena u klasi kod zahteva absolutno adresu. Moramo proročunati ili ručno, ovde je navedenu ulisting ovog programa tačne adrese na koji se nalazi svaka bait kod naredba, ili možemo se poslužiti malim trikom, to je da ako ne znamo, znači na kojoj adrese treba skočiti, tu za početak možemo staviti bilo štarec imo nulu, izgenerisati kod, disasemblierati, videti gdači, gde su realne adrese za svaku naredbu i onda u drugo iteraciji staviti smisle nevrednosti i ponovu prevesti. Napisali smo program na jave, što tu je zanimljivo, završetak je zanimljiv, znači kod rait je metod u klasi kod kojem su pravi na kraju prevođenja objektni file sa mikrojava kodom i njemu samo treba dostaviti file, output stream ideja da je naš java program, i ovo ćemo samo tu prosleniti. I naravno pretko treba samo ispitati, da li nije sučeno došlo do neke greške, kada kod ima interno, svoj ovo logičku promenju u koja vam kaže da je došlo do neke interne greške ako ste neke od ovih metoda možda pozvali s nekim lošim argumentima. Ako nije došlo do greške, upisujemo mikrojava objektni file i pošto ovoj poziv metoda rait može do patci zuzetak, moramo ga znači o staviti traj i kaj džuk block. Ako je slučeno došlo do greške pri krejiranju file, ako nije došlo do greške, naš program ispisuje ovu poruku da zamo da je uspešno završeno krejiranje file. I sad još samo da vidimo kako prevesti metod pokrenuti naš program dobiti mikrojava objektni file i onda kako iskoristiti koje su u mogućnosti za korišćenje tog filea u mikrojava virtualne mašini koje se nalazi u istoj jarn file koji sam već pominja. Znači, znači ćemo command prompt, predpostavljam da sam već instaliro i podesioj java jdk možemo se uveriti da postoji java compiler. I prva stvar je da ovu našu proba.java klasu u koji koristimo klasu kod prevedemo. Zatim priprevođenju u klas path sam zadao te kućih da mi se nalazi svi file ovih folder i ovaj jar da bi moglo da se pristupiti na da im portrealizuje je runtime. Vrlo osličanje sad i izvršavanje ove naše klase proba. Znači samo ovde je izostavljeno c. Klas path je isti. Ovde je sad ime naše klase proba i zadajemo način ime izlaznog filea proba.java oboje. Vidimo da je uspešan kraj i možemo se uveriti da postoji bolje da odemo folder. Evo je proba.java opoje sa trenutnim datumom i vremenom. Sad je napravljen. Vraćam se na command prompt. Sad možemo da disassembliramo ovoj runtime. Znači šta se se nalazi u ovoj jar file? Između ostavljog nalazi se klasa koja može da disassemblira ovaj objektni file koji smo napravili i u stvari pokaže šta će mikrojava virtualnošina zaista videti od mikrojava. Ono što mi mislimo da smo upisali, ne mora ovo povezan da se poklapa sa onim kako to mikrojava dobija ako smo narod naprovi neku grešku. Ovo je tkutji folder i runtime.jar. Sam disassembler nalazi se u nutar ovoga jara u ovom paketu sa jako dugačkim imenom. Ja uopšte nisam odgovorat za ovo manijakalno ime nego jedan od predhodnija sistemata na premedvetu. Ja svakako ne bi ovo liko foldera napisao do disasmu klase koja može da nam da u stvari tekstualni opis. Šta se nalazi u ovom file i sad pokrenem disasember. Evo šta dobijamo. Znači u sušti nisam poklapa sa onim što se vam pokazao kao mikrojava bytecode. Dodatno vidimo i ove podatke kolika je veričina koda u byte ovima veričina podataka i gde je main PC. Ovo je ono što će mikrojava virtualnošina. Kada sam pričao kako da saznate, na drese skoka, u slušti šti nivam disasember da je za svaku naredbu na kojoj i adresi. Osta je da pokrenemo ovaj program. Šta očekujemo da ćemo izpisati? Pa pošto a je 3b jednako minus 1. U služda a je manje do jednako b ne ispunjen, ali b je manje od nula, a da a je od nula je ispunjen, tako da očekujemo da će biti ispisana jedinica. Kako pokrećemo izvršavanje programa? Može na kraći ili duži način. U kodu da vam ja komandom ilustrujem duži način. Duži način je da se opet iskoristi java, klas pa fijistika oranije, isto jako veliko ime paketa, kde se nalazi file. Samo u mesto disasem je klasa ran sa velikim r i ime našeg objeknog file. Kako pokrećemo mikrojava, interpretar, virtojlne mašine, on ispisuje izlazni rezultat i ispisuje koliko je moje bilo potrebno za kompletno ovu pokretanje. Postoji i varijanta pokretanja ako zadate opciju crtica debug na komandno ili nije ovo interpretaru, onda će da vam izvršava program pri čemu će da, osve svake izvršene naredbe ispisivati, i sadržaja ekspresno steka što može biti jako korisno pri debagovalju mikrojava, ba it koda.
