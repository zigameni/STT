 ekskuzivno pravo. Vi želimo način to nekako da obezbedimo. A vrlo jednostavno se piše, način napišemo uslov u awaitu i kažemo ja čekam da se ovo ovde desi kad je to ispunjenu ja prelazivno narani koraka. Dobro, to je ok. Kada mi napuštamo ekskuzivno pravo, ako se zablokiramo i kažemo ja nema šta da radimo ovde uslovni. Nije za ispunjen ili ako ja završim korišćenje kritičnog regijona. Koji će imati pravo da pristupi kritičnom regijonu nakon mene, nema poima. Ove nema garantovanu. E, po FIF-u principu će se budi ili po nekom principu. Ovde nema nikakvog principa. Neko u trenutku kada mu bude ispunjenu uslov će proći dalje. Dalje je garantovan redosled? Nikako nije garantovan redosled. A ako mi želimo nešto da garantujemo, mi moramo to da stajemo u uslov koji ispitujemo. System ne garantuje ništa. Dobro. OK. Šta je panu? Šta sam rekao sada? Imamo uslov. Dok lego od uslov ne postane ispunjen, mi čekamo. U tom čekanju mi nemo ekskluzivno pravo. Mi smo prepustili pravo nekom drugom. Mi ćemo ekskluzivno proveriti naš uslov. Ali nije garantovanu da će taj uslov biti ispunjenu trenutku kada ga budemo proverao. Ustvari ja ne znami kako će se to realizovati. Dalje je to zaposlenu čekanje, dalje je to neko drugo čekanje. Taj da uopšte ne vam pojma kako će se realizovati. I to sada ve se zalisi od jezika do jezika. Dalje će jezik uspeti da napravi brzo eleganzno lepo rešenje ili neći? Ja sada vidim kako je to zamislino da se zapiše u regionu. Videli smo maločasko kors grain rešenje. Kažemo await na nekim bulom i mizrazom. Onda radi neko es. Kako se to ovde zapisuje? Kažemo region, taj naš zapis nad kojom se synchronizujemo res. Kada objemo ekskluzivnu pravo nad datim objektom, onda ulazimo u region. Imoj ekskluzivnu pravo. Dođemo na await, ako je uslov ispunjen, idemo dalje. Ako uslov nije ispunjen, idemo u etri tačkic. I čekamo dok je god uslov nepostane ispunjen napuštevići ekskluzivnu pravo. Ko će dobiti to ekskluzivnu pravo? Ne znamo. Kada će se dobiti to ekskluzivnu pravo? Tek kad na neko drugi napusti uslovni kritični region, mi možemo da proverimo. Ako smo proverili i ako je ispunjenu, mi ćemo nastaviti dalje, ne deljivo. Ok, šta sa to znači? Ako je uslov ispunjen za dva procesa, ne znamo koji će od njeg biti ispunjen. A jedan kad obije kontrolu, možda će da poništi to što je neko dobio pravo da nastavi dalje. Tako da taj možda kada sljedeći put, bude proverio to svoje pravo. A možda će možda svaki put da proveri prenego štući. Jest. Ovo ovde, ako je uslov ispunjen, idemo dalje. Ako uslov nije ispunjen, čekamo. A šta, ako je uslov ispunjen, a neko drugi može ekskuzivno pravo, pa u suštini mi nismo mogli da proverimo taj uslov, zato što je neko drugi imao ekskuzivno pravo. I moramo to, ne deljivo da proverimo. Znači, niko drugi ne koristi regionu u nekom trenutku. Jedan dođe proveri ako je ispunjen super. Ja imam, ja sam gazda. A ako nije ispunjen, nisam ja gazda, neko drugi će možda dobiti pravo i onda proveri drugi, treći, četvrti, kogu gode ih ima. E sad, ovo ovde se malo teže. Realizuju javi. Oni je tačno baš, da sam reko, lako se realizuju, ali možda bude mnogo spora. Ovo ovde u javi možda se realizuju na sledeći način. Ovo je ovde uslov. A možete implementirati kao while not uslov wait. Znači, while not uslov, ona referensa, ona je objekat, nad koji imamo ekskuzivno pravo, samo nad s tim objektom moramo da radimo wait. Aha, način, ovo ovde se relativno jednostavno implementira. A ako smo u ovde, ovde tri tačkice koje predhoda našem awaitu, imali bilo, šta, bilo kakak posao koje mogu da utiči na bilo koji blokiram i proces, onda moramo ovde imati reference.notify.all. Ači moramo sve probuditi i kažemo, ajde ti vidi, jelima nešto za tebe. Isto tako, ako smo u ovde tri tačkice radili, bilo šta, što bilo kome može da doprinese da se probudi, ona ćemo ovde, nadnu morati da imamo još jednom, reference.notify.all. Znači, ne može notify, probudi jednog. Ne, mora da se stavi notify.all. Svi se probudite pa vidite, ovo mašte dalje. Tako da vidite. Ovo ovde resenji koje mošemo napraviti u javi, implementaciju jednog regiona, nije baš optimalno. Ovo notify.all zovete u slučaju krajnje nužde. Ne bi trebalo da zovete to notify.all baš često, jer to ubija performanse u regionu i je to zamišljeno, a ovaj, tjera čekam dok legoce to nedasi. E sad bilo bi lepo da su ujavili u nekom drugom jeziku napravili, da to možete malo lepše da opišete, ali nisu možete neka napraviti. To je jedno ciljeva, što oni žele durati u javi. Da mogu ja da prosledim uslov, pa da se to atomski nekako proveri, pa ako je ispunjenu da ja nastajim, ali nisu napravili. Znači, za sada implementacije koji imate sa ključnom reču synchroniz, nam garantuje da imamo ekskuzivno pravo, a pristupa, dato i referenci. Još i jedan malim podsatnik sa programski jezik, ako ovo pozovete notify, notify all ili wait, to smete, duravite. Samo na doobjektima nad kojima imate ekskuzivno pravo, pristupa, stavili ste synchronizati. Ako nemate ekskuzivno pravo, pristupa, izleteće vam i legal monitor state exception. Da nemate ekskuzivno pravo, pristupa objektu i program ce pući. Ne smete da pozivete ove metode, ove 3 metode notify, notify all ili wait, ako ne držite synchroniz, da če ne držite ključ nad datim objektom. Šta to baš sada znači držeti ključ? Če te vidjeti na vešbama, na laboratorijski vešbama. Tamo će bukvalno biti naacratano. Ključ i pisac je 3, taj taj je zaključao taj i taj objekt. Jer svaki objekt, javo je tako napravljena od svoj verzi jedan. Svaki objekt je nešto što je u suštini monitor svak tip. I tamo za svaki objekt, a može stajati koja nit drži ključ, koja nit je zaključala dati objekt. Zamislnino od kada je napravljena, da postoji to kao koncept. Tako da taj ključ ćete vidjeti u okruženju, eklipsu ili šta godi ćete budete koristili. Pored vašeg objekta će biti nadbiti naacratan ključ i pisac je 3, taj taj taj koja nit je zaključala vaš objekt. A ako niko nije zaključao vaš objekt, ono neće biti naacratan ključ. I ovako da sada nikad niste videli taj ključ ili vrlo redko ste vidjeli taj ključ, možda vam nije upao oči, ali to je zaključavanje datog objekta. I to je sve što se regionatića. A ovde nije predvijedno ništa više u regionima, ovo je čisto mali prelaz kao jedan među korak za narednu oblast. Naradnu oblast, na prevljutu konkurentno i distribujiro na programiranje koji ću mi posvetiti znatno više vremena, je rad sa monitorima. Ovoj koncept monitora je koncept koji prati razvoj programskih jezika. A ako bi sema forim odgovarali ovoj prvim programskih jezicima gde smo imali samo neke promenjive, monitori regioni odgovarali programskih jezicima gde su se pojavili strukture, podataka u kojima smo nešto čuvali, monitori odgovaraju potpuno objeknu orientisanom pristupu. A monitori su objekti, oveči oni imaju metode i polja. Metode su stvari koje mi dozvoljamo ostatku sveta da rade sa tim objektom. Polja su sakrivena, nalaze se unutar datog objekta i služi u suštini zasynchronizaciju. Racamo monitorima odgovara ovo me što ste videli koji je objeknu orientisanih programskih jezika. Objeknu orientisanih programskih jezici treba da znatno-znatno olakšaju konkurentno i distribujereno programiranje. Sada kako to znatno olakšaju. Oni koji znaju do rade konkurentno i distribujereno programiranje, baviće se konkurentno i distribujereno programiranje. Oni koji ne znaju koristiće gotovu klasu koja treba da odradi neki posao. I na taj način je napravljena podela posla. Onaj što pravi synchronizaciju, on pravi obšte klase za synchronizaciju. Njega baš briga, na koji način medved jede ili filozof jede ili filozof pije ili ljudoš drjede. To lošte ne zanima.